
test_prog.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002a  00800100  00001c80  00001d14  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001c80  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000050  0080012a  0080012a  00001d3e  2**0
                  ALLOC
  3 .stab         00004230  00000000  00000000  00001d40  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001571  00000000  00000000  00005f70  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000074e1  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 dc 00 	jmp	0x1b8	; 0x1b8 <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 ba 09 	jmp	0x1374	; 0x1374 <__vector_10>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 a2 06 	jmp	0xd44	; 0xd44 <__vector_12>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__vector_16>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 e3 06 	jmp	0xdc6	; 0xdc6 <__vector_21>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      80:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      84:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      88:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      8c:	37 01       	movw	r6, r14
      8e:	3f 01       	movw	r6, r30
      90:	47 01       	movw	r8, r14
      92:	4f 01       	movw	r8, r30
      94:	57 01       	movw	r10, r14
      96:	60 01       	movw	r12, r0
      98:	69 01       	movw	r12, r18
      9a:	27 01       	movw	r4, r14
      9c:	2f 01       	movw	r4, r30
      9e:	bd 02       	muls	r27, r29
      a0:	b5 02       	muls	r27, r21
      a2:	b0 02       	muls	r27, r16
      a4:	da 02       	muls	r29, r26
      a6:	cd 02       	muls	r28, r29
      a8:	d5 02       	muls	r29, r21
      aa:	c5 02       	muls	r28, r21
      ac:	8e 02       	muls	r24, r30
      ae:	86 02       	muls	r24, r22
      b0:	81 02       	muls	r24, r17
      b2:	79 02       	muls	r23, r25
      b4:	e2 02       	muls	r30, r18
      b6:	96 02       	muls	r25, r22
      b8:	6c 02       	muls	r22, r28
      ba:	54 02       	muls	r21, r20
      bc:	02 03       	mulsu	r16, r18
      be:	ab 02       	muls	r26, r27
      c0:	a3 02       	muls	r26, r19
      c2:	9b 02       	muls	r25, r27
      c4:	22 03       	mulsu	r18, r18
      c6:	5c 02       	muls	r21, r28
      c8:	12 03       	mulsu	r17, r18
      ca:	64 02       	muls	r22, r20
      cc:	2f 03       	fmul	r18, r23
      ce:	fa 02       	muls	r31, r26
      d0:	1a 03       	fmul	r17, r18
      d2:	74 02       	muls	r23, r20
      d4:	f2 02       	muls	r31, r18
      d6:	ea 02       	muls	r30, r26
      d8:	0a 03       	fmul	r16, r18
      da:	4f 02       	muls	r20, r31
      dc:	1d 02       	muls	r17, r29
      de:	15 02       	muls	r17, r21
      e0:	25 02       	muls	r18, r21
      e2:	27 03       	mulsu	r18, r23
      e4:	08 02       	muls	r16, r24
      e6:	00 02       	muls	r16, r16
      e8:	2a 02       	muls	r18, r26
      ea:	e3 01       	movw	r28, r6
      ec:	47 02       	muls	r20, r23
      ee:	10 02       	muls	r17, r16
      f0:	f3 01       	movw	r30, r6
      f2:	eb 01       	movw	r28, r22
      f4:	37 02       	muls	r19, r23
      f6:	fb 01       	movw	r30, r22
      f8:	2f 02       	muls	r18, r31
      fa:	db 01       	movw	r26, r22
      fc:	c1 01       	movw	r24, r2
      fe:	3f 02       	muls	r19, r31
     100:	b1 01       	movw	r22, r2
     102:	a9 01       	movw	r20, r18
     104:	ce 01       	movw	r24, r28
     106:	c6 01       	movw	r24, r12
     108:	d3 01       	movw	r26, r6
     10a:	a4 01       	movw	r20, r8
     10c:	b9 01       	movw	r22, r18
     10e:	8c 01       	movw	r16, r24
     110:	9c 01       	movw	r18, r24
     112:	87 01       	movw	r16, r14
     114:	7f 01       	movw	r14, r30
     116:	77 01       	movw	r14, r14
     118:	72 01       	movw	r14, r4
     11a:	94 01       	movw	r18, r8
     11c:	39 04       	cpc	r3, r9
     11e:	57 04       	cpc	r5, r7
     120:	33 04       	cpc	r3, r3
     122:	45 04       	cpc	r4, r5
     124:	27 04       	cpc	r2, r7
     126:	2d 04       	cpc	r2, r13
     128:	27 04       	cpc	r2, r7
     12a:	2d 04       	cpc	r2, r13
     12c:	5d 04       	cpc	r5, r13
     12e:	39 04       	cpc	r3, r9
     130:	57 04       	cpc	r5, r7
     132:	33 04       	cpc	r3, r3
     134:	45 04       	cpc	r4, r5
     136:	3f 04       	cpc	r3, r15
     138:	21 04       	cpc	r2, r1
     13a:	3f 04       	cpc	r3, r15
     13c:	21 04       	cpc	r2, r1
     13e:	87 04       	cpc	r8, r7
     140:	c3 04       	cpc	r12, r3
     142:	7b 04       	cpc	r7, r11
     144:	f3 04       	cpc	r15, r3
     146:	7b 04       	cpc	r7, r11
     148:	b7 04       	cpc	r11, r7
     14a:	b1 04       	cpc	r11, r1
     14c:	21 04       	cpc	r2, r1
     14e:	8d 04       	cpc	r8, r13
     150:	21 04       	cpc	r2, r1
     152:	9f 04       	cpc	r9, r15
     154:	4b 04       	cpc	r4, r11
     156:	e1 04       	cpc	r14, r1
     158:	27 04       	cpc	r2, r7
     15a:	d5 04       	cpc	r13, r5
     15c:	63 04       	cpc	r6, r3
     15e:	db 04       	cpc	r13, r11
     160:	69 04       	cpc	r6, r9
     162:	e7 04       	cpc	r14, r7
     164:	ab 04       	cpc	r10, r11
     166:	51 04       	cpc	r5, r1
     168:	4b 04       	cpc	r4, r11
     16a:	93 04       	cpc	r9, r3
     16c:	6f 04       	cpc	r6, r15
     16e:	39 04       	cpc	r3, r9
     170:	57 04       	cpc	r5, r7
     172:	33 04       	cpc	r3, r3
     174:	45 04       	cpc	r4, r5
     176:	27 04       	cpc	r2, r7
     178:	2d 04       	cpc	r2, r13
     17a:	27 04       	cpc	r2, r7
     17c:	2d 04       	cpc	r2, r13
     17e:	5d 04       	cpc	r5, r13
     180:	39 04       	cpc	r3, r9
     182:	bd 04       	cpc	r11, r13
     184:	51 04       	cpc	r5, r1
     186:	33 04       	cpc	r3, r3
     188:	3f 04       	cpc	r3, r15
     18a:	21 04       	cpc	r2, r1
     18c:	3f 04       	cpc	r3, r15
     18e:	21 04       	cpc	r2, r1
     190:	87 04       	cpc	r8, r7
     192:	c9 04       	cpc	r12, r9
     194:	99 04       	cpc	r9, r9
     196:	5d 04       	cpc	r5, r13
     198:	cf 04       	cpc	r12, r15
     19a:	8d 04       	cpc	r8, r13
     19c:	63 04       	cpc	r6, r3
     19e:	69 04       	cpc	r6, r9
     1a0:	4b 04       	cpc	r4, r11
     1a2:	51 04       	cpc	r5, r1
     1a4:	ed 04       	cpc	r14, r13
     1a6:	6f 04       	cpc	r6, r15
     1a8:	09 08       	sbc	r0, r9
     1aa:	05 08       	sbc	r0, r5
     1ac:	0e 08       	sbc	r0, r14
     1ae:	32 08       	sbc	r3, r2
     1b0:	f5 07       	cpc	r31, r21
     1b2:	28 08       	sbc	r2, r8
     1b4:	17 08       	sbc	r1, r7
     1b6:	e9 07       	cpc	r30, r25

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d0 e1       	ldi	r29, 0x10	; 16
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61

000001c4 <__do_copy_data>:
     1c4:	11 e0       	ldi	r17, 0x01	; 1
     1c6:	a0 e0       	ldi	r26, 0x00	; 0
     1c8:	b1 e0       	ldi	r27, 0x01	; 1
     1ca:	e0 e8       	ldi	r30, 0x80	; 128
     1cc:	fc e1       	ldi	r31, 0x1C	; 28
     1ce:	00 e0       	ldi	r16, 0x00	; 0
     1d0:	0b bf       	out	0x3b, r16	; 59
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x14>
     1d4:	07 90       	elpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	aa 32       	cpi	r26, 0x2A	; 42
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0x10>

000001de <__do_clear_bss>:
     1de:	21 e0       	ldi	r18, 0x01	; 1
     1e0:	aa e2       	ldi	r26, 0x2A	; 42
     1e2:	b1 e0       	ldi	r27, 0x01	; 1
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	aa 37       	cpi	r26, 0x7A	; 122
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <main>
     1f2:	0c 94 3e 0e 	jmp	0x1c7c	; 0x1c7c <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <play_rest>:
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     1fa:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     1fc:	10 92 5f 01 	sts	0x015F, r1
     200:	10 92 5e 01 	sts	0x015E, r1
  max_beat = duration;
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	90 93 5d 01 	sts	0x015D, r25
     20a:	80 93 5c 01 	sts	0x015C, r24
     20e:	08 95       	ret

00000210 <play_note>:
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
     210:	cf 93       	push	r28
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
     212:	92 98       	cbi	0x12, 2	; 18
  beat = 0;             //reset the beat counter
     214:	10 92 5f 01 	sts	0x015F, r1
     218:	10 92 5e 01 	sts	0x015E, r1
  max_beat = duration;  //set the max beat
     21c:	30 e0       	ldi	r19, 0x00	; 0
     21e:	30 93 5d 01 	sts	0x015D, r19
     222:	20 93 5c 01 	sts	0x015C, r18
  switch (octave) {
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	49 30       	cpi	r20, 0x09	; 9
     22a:	51 05       	cpc	r21, r1
     22c:	20 f0       	brcs	.+8      	; 0x236 <play_note+0x26>
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
     22e:	1b bc       	out	0x2b, r1	; 43
     230:	1a bc       	out	0x2a, r1	; 42
  }
}
     232:	cf 91       	pop	r28
     234:	08 95       	ret
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     236:	4a 5b       	subi	r20, 0xBA	; 186
     238:	5f 4f       	sbci	r21, 0xFF	; 255
     23a:	fa 01       	movw	r30, r20
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     23c:	99 27       	eor	r25, r25
     23e:	87 fd       	sbrc	r24, 7
     240:	90 95       	com	r25
     242:	a9 2f       	mov	r26, r25
     244:	b9 2f       	mov	r27, r25
     246:	81 54       	subi	r24, 0x41	; 65
     248:	91 09       	sbc	r25, r1
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     24a:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
     24e:	87 30       	cpi	r24, 0x07	; 7
     250:	91 05       	cpc	r25, r1
     252:	78 f7       	brcc	.-34     	; 0x232 <play_note+0x22>
     254:	81 5b       	subi	r24, 0xB1	; 177
     256:	9f 4f       	sbci	r25, 0xFF	; 255
     258:	fc 01       	movw	r30, r24
     25a:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     25e:	87 30       	cpi	r24, 0x07	; 7
     260:	91 05       	cpc	r25, r1
     262:	38 f7       	brcc	.-50     	; 0x232 <play_note+0x22>
     264:	8a 5a       	subi	r24, 0xAA	; 170
     266:	9f 4f       	sbci	r25, 0xFF	; 255
     268:	fc 01       	movw	r30, r24
     26a:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
     26e:	87 30       	cpi	r24, 0x07	; 7
     270:	91 05       	cpc	r25, r1
     272:	f8 f6       	brcc	.-66     	; 0x232 <play_note+0x22>
     274:	83 5a       	subi	r24, 0xA3	; 163
     276:	9f 4f       	sbci	r25, 0xFF	; 255
     278:	fc 01       	movw	r30, r24
     27a:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
     27e:	87 30       	cpi	r24, 0x07	; 7
     280:	91 05       	cpc	r25, r1
     282:	b8 f6       	brcc	.-82     	; 0x232 <play_note+0x22>
     284:	8c 59       	subi	r24, 0x9C	; 156
     286:	9f 4f       	sbci	r25, 0xFF	; 255
     288:	fc 01       	movw	r30, r24
     28a:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
     28e:	87 30       	cpi	r24, 0x07	; 7
     290:	91 05       	cpc	r25, r1
     292:	78 f6       	brcc	.-98     	; 0x232 <play_note+0x22>
     294:	85 59       	subi	r24, 0x95	; 149
     296:	9f 4f       	sbci	r25, 0xFF	; 255
     298:	fc 01       	movw	r30, r24
     29a:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
     29e:	87 30       	cpi	r24, 0x07	; 7
     2a0:	91 05       	cpc	r25, r1
     2a2:	38 f6       	brcc	.-114    	; 0x232 <play_note+0x22>
     2a4:	8e 58       	subi	r24, 0x8E	; 142
     2a6:	9f 4f       	sbci	r25, 0xFF	; 255
     2a8:	fc 01       	movw	r30, r24
     2aa:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
     2ae:	87 30       	cpi	r24, 0x07	; 7
     2b0:	91 05       	cpc	r25, r1
     2b2:	08 f0       	brcs	.+2      	; 0x2b6 <play_note+0xa6>
     2b4:	be cf       	rjmp	.-132    	; 0x232 <play_note+0x22>
     2b6:	87 58       	subi	r24, 0x87	; 135
     2b8:	9f 4f       	sbci	r25, 0xFF	; 255
     2ba:	fc 01       	movw	r30, r24
     2bc:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
     2c0:	87 30       	cpi	r24, 0x07	; 7
     2c2:	91 05       	cpc	r25, r1
     2c4:	08 f0       	brcs	.+2      	; 0x2c8 <play_note+0xb8>
     2c6:	b5 cf       	rjmp	.-150    	; 0x232 <play_note+0x22>
     2c8:	80 58       	subi	r24, 0x80	; 128
     2ca:	9f 4f       	sbci	r25, 0xFF	; 255
     2cc:	fc 01       	movw	r30, r24
     2ce:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
     2d2:	87 30       	cpi	r24, 0x07	; 7
     2d4:	91 05       	cpc	r25, r1
     2d6:	08 f0       	brcs	.+2      	; 0x2da <play_note+0xca>
     2d8:	ac cf       	rjmp	.-168    	; 0x232 <play_note+0x22>
     2da:	89 57       	subi	r24, 0x79	; 121
     2dc:	9f 4f       	sbci	r25, 0xFF	; 255
     2de:	fc 01       	movw	r30, r24
     2e0:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
     2e4:	88 e5       	ldi	r24, 0x58	; 88
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	9b bd       	out	0x2b, r25	; 43
     2ea:	8a bd       	out	0x2a, r24	; 42
	break;
     2ec:	a2 cf       	rjmp	.-188    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
     2ee:	66 23       	and	r22, r22
     2f0:	09 f4       	brne	.+2      	; 0x2f4 <play_note+0xe4>
     2f2:	0f c2       	rjmp	.+1054   	; 0x712 <play_note+0x502>
     2f4:	83 e6       	ldi	r24, 0x63	; 99
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	9b bd       	out	0x2b, r25	; 43
     2fa:	8a bd       	out	0x2a, r24	; 42
     2fc:	9a cf       	rjmp	.-204    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
     2fe:	66 23       	and	r22, r22
     300:	09 f4       	brne	.+2      	; 0x304 <play_note+0xf4>
     302:	11 c2       	rjmp	.+1058   	; 0x726 <play_note+0x516>
     304:	8f e6       	ldi	r24, 0x6F	; 111
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	9b bd       	out	0x2b, r25	; 43
     30a:	8a bd       	out	0x2a, r24	; 42
     30c:	92 cf       	rjmp	.-220    	; 0x232 <play_note+0x22>
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
     30e:	86 e7       	ldi	r24, 0x76	; 118
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	9b bd       	out	0x2b, r25	; 43
     314:	8a bd       	out	0x2a, r24	; 42
	break;
     316:	8d cf       	rjmp	.-230    	; 0x232 <play_note+0x22>
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
     318:	66 23       	and	r22, r22
     31a:	09 f4       	brne	.+2      	; 0x31e <play_note+0x10e>
     31c:	ff c1       	rjmp	.+1022   	; 0x71c <play_note+0x50c>
     31e:	8a e4       	ldi	r24, 0x4A	; 74
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	9b bd       	out	0x2b, r25	; 43
     324:	8a bd       	out	0x2a, r24	; 42
     326:	85 cf       	rjmp	.-246    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
     328:	66 23       	and	r22, r22
     32a:	09 f4       	brne	.+2      	; 0x32e <play_note+0x11e>
     32c:	01 c2       	rjmp	.+1026   	; 0x730 <play_note+0x520>
     32e:	83 e5       	ldi	r24, 0x53	; 83
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	9b bd       	out	0x2b, r25	; 43
     334:	8a bd       	out	0x2a, r24	; 42
     336:	7d cf       	rjmp	.-262    	; 0x232 <play_note+0x22>
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
     338:	66 23       	and	r22, r22
     33a:	09 f4       	brne	.+2      	; 0x33e <play_note+0x12e>
     33c:	b8 c1       	rjmp	.+880    	; 0x6ae <play_note+0x49e>
     33e:	82 e4       	ldi	r24, 0x42	; 66
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	9b bd       	out	0x2b, r25	; 43
     344:	8a bd       	out	0x2a, r24	; 42
     346:	75 cf       	rjmp	.-278    	; 0x232 <play_note+0x22>
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
     348:	81 eb       	ldi	r24, 0xB1	; 177
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	9b bd       	out	0x2b, r25	; 43
     34e:	8a bd       	out	0x2a, r24	; 42
	break;
     350:	70 cf       	rjmp	.-288    	; 0x232 <play_note+0x22>
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
     352:	66 23       	and	r22, r22
     354:	09 f4       	brne	.+2      	; 0x358 <play_note+0x148>
     356:	d3 c1       	rjmp	.+934    	; 0x6fe <play_note+0x4ee>
     358:	85 e8       	ldi	r24, 0x85	; 133
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	9b bd       	out	0x2b, r25	; 43
     35e:	8a bd       	out	0x2a, r24	; 42
     360:	68 cf       	rjmp	.-304    	; 0x232 <play_note+0x22>
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
     362:	66 23       	and	r22, r22
     364:	09 f4       	brne	.+2      	; 0x368 <play_note+0x158>
     366:	c1 c1       	rjmp	.+898    	; 0x6ea <play_note+0x4da>
     368:	85 e9       	ldi	r24, 0x95	; 149
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	9b bd       	out	0x2b, r25	; 43
     36e:	8a bd       	out	0x2a, r24	; 42
     370:	60 cf       	rjmp	.-320    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
     372:	66 23       	and	r22, r22
     374:	09 f4       	brne	.+2      	; 0x378 <play_note+0x168>
     376:	be c1       	rjmp	.+892    	; 0x6f4 <play_note+0x4e4>
     378:	87 ea       	ldi	r24, 0xA7	; 167
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	9b bd       	out	0x2b, r25	; 43
     37e:	8a bd       	out	0x2a, r24	; 42
     380:	58 cf       	rjmp	.-336    	; 0x232 <play_note+0x22>
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
     382:	84 e6       	ldi	r24, 0x64	; 100
     384:	91 e0       	ldi	r25, 0x01	; 1
     386:	9b bd       	out	0x2b, r25	; 43
     388:	8a bd       	out	0x2a, r24	; 42
	break;
     38a:	53 cf       	rjmp	.-346    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
     38c:	66 23       	and	r22, r22
     38e:	09 f4       	brne	.+2      	; 0x392 <play_note+0x182>
     390:	bb c1       	rjmp	.+886    	; 0x708 <play_note+0x4f8>
     392:	80 ee       	ldi	r24, 0xE0	; 224
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	9b bd       	out	0x2b, r25	; 43
     398:	8a bd       	out	0x2a, r24	; 42
     39a:	4b cf       	rjmp	.-362    	; 0x232 <play_note+0x22>
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
     39c:	8d ee       	ldi	r24, 0xED	; 237
     39e:	90 e0       	ldi	r25, 0x00	; 0
     3a0:	9b bd       	out	0x2b, r25	; 43
     3a2:	8a bd       	out	0x2a, r24	; 42
	break;
     3a4:	46 cf       	rjmp	.-372    	; 0x232 <play_note+0x22>
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
     3a6:	66 23       	and	r22, r22
     3a8:	09 f4       	brne	.+2      	; 0x3ac <play_note+0x19c>
     3aa:	8b c1       	rjmp	.+790    	; 0x6c2 <play_note+0x4b2>
     3ac:	87 ec       	ldi	r24, 0xC7	; 199
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	9b bd       	out	0x2b, r25	; 43
     3b2:	8a bd       	out	0x2a, r24	; 42
     3b4:	3e cf       	rjmp	.-388    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
     3b6:	66 23       	and	r22, r22
     3b8:	09 f4       	brne	.+2      	; 0x3bc <play_note+0x1ac>
     3ba:	74 c1       	rjmp	.+744    	; 0x6a4 <play_note+0x494>
     3bc:	80 e9       	ldi	r24, 0x90	; 144
     3be:	91 e0       	ldi	r25, 0x01	; 1
     3c0:	9b bd       	out	0x2b, r25	; 43
     3c2:	8a bd       	out	0x2a, r24	; 42
     3c4:	36 cf       	rjmp	.-404    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
     3c6:	66 23       	and	r22, r22
     3c8:	09 f4       	brne	.+2      	; 0x3cc <play_note+0x1bc>
     3ca:	cb c1       	rjmp	.+918    	; 0x762 <play_note+0x552>
     3cc:	84 e8       	ldi	r24, 0x84	; 132
     3ce:	93 e0       	ldi	r25, 0x03	; 3
     3d0:	9b bd       	out	0x2b, r25	; 43
     3d2:	8a bd       	out	0x2a, r24	; 42
     3d4:	2e cf       	rjmp	.-420    	; 0x232 <play_note+0x22>
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
     3d6:	66 23       	and	r22, r22
     3d8:	09 f4       	brne	.+2      	; 0x3dc <play_note+0x1cc>
     3da:	af c1       	rjmp	.+862    	; 0x73a <play_note+0x52a>
     3dc:	8b e2       	ldi	r24, 0x2B	; 43
     3de:	91 e0       	ldi	r25, 0x01	; 1
     3e0:	9b bd       	out	0x2b, r25	; 43
     3e2:	8a bd       	out	0x2a, r24	; 42
     3e4:	26 cf       	rjmp	.-436    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
     3e6:	66 23       	and	r22, r22
     3e8:	09 f4       	brne	.+2      	; 0x3ec <play_note+0x1dc>
     3ea:	b1 c1       	rjmp	.+866    	; 0x74e <play_note+0x53e>
     3ec:	82 ea       	ldi	r24, 0xA2	; 162
     3ee:	92 e0       	ldi	r25, 0x02	; 2
     3f0:	9b bd       	out	0x2b, r25	; 43
     3f2:	8a bd       	out	0x2a, r24	; 42
     3f4:	1e cf       	rjmp	.-452    	; 0x232 <play_note+0x22>
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
     3f6:	8c ed       	ldi	r24, 0xDC	; 220
     3f8:	91 e0       	ldi	r25, 0x01	; 1
     3fa:	9b bd       	out	0x2b, r25	; 43
     3fc:	8a bd       	out	0x2a, r24	; 42
	break;
     3fe:	19 cf       	rjmp	.-462    	; 0x232 <play_note+0x22>
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
     400:	66 23       	and	r22, r22
     402:	09 f4       	brne	.+2      	; 0x406 <play_note+0x1f6>
     404:	59 c1       	rjmp	.+690    	; 0x6b8 <play_note+0x4a8>
     406:	87 e1       	ldi	r24, 0x17	; 23
     408:	92 e0       	ldi	r25, 0x02	; 2
     40a:	9b bd       	out	0x2b, r25	; 43
     40c:	8a bd       	out	0x2a, r24	; 42
     40e:	11 cf       	rjmp	.-478    	; 0x232 <play_note+0x22>
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
     410:	66 23       	and	r22, r22
     412:	09 f4       	brne	.+2      	; 0x416 <play_note+0x206>
     414:	b0 c1       	rjmp	.+864    	; 0x776 <play_note+0x566>
     416:	88 e5       	ldi	r24, 0x58	; 88
     418:	92 e0       	ldi	r25, 0x02	; 2
     41a:	9b bd       	out	0x2b, r25	; 43
     41c:	8a bd       	out	0x2a, r24	; 42
     41e:	09 cf       	rjmp	.-494    	; 0x232 <play_note+0x22>
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
     420:	8a ec       	ldi	r24, 0xCA	; 202
     422:	92 e0       	ldi	r25, 0x02	; 2
     424:	9b bd       	out	0x2b, r25	; 43
     426:	8a bd       	out	0x2a, r24	; 42
	break;
     428:	04 cf       	rjmp	.-504    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
     42a:	66 23       	and	r22, r22
     42c:	09 f4       	brne	.+2      	; 0x430 <play_note+0x220>
     42e:	35 c1       	rjmp	.+618    	; 0x69a <play_note+0x48a>
     430:	86 e4       	ldi	r24, 0x46	; 70
     432:	96 e0       	ldi	r25, 0x06	; 6
     434:	9b bd       	out	0x2b, r25	; 43
     436:	8a bd       	out	0x2a, r24	; 42
     438:	fc ce       	rjmp	.-520    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
     43a:	66 23       	and	r22, r22
     43c:	09 f4       	brne	.+2      	; 0x440 <play_note+0x230>
     43e:	82 c1       	rjmp	.+772    	; 0x744 <play_note+0x534>
     440:	8a e0       	ldi	r24, 0x0A	; 10
     442:	97 e0       	ldi	r25, 0x07	; 7
     444:	9b bd       	out	0x2b, r25	; 43
     446:	8a bd       	out	0x2a, r24	; 42
     448:	f4 ce       	rjmp	.-536    	; 0x232 <play_note+0x22>
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
     44a:	86 e9       	ldi	r24, 0x96	; 150
     44c:	95 e0       	ldi	r25, 0x05	; 5
     44e:	9b bd       	out	0x2b, r25	; 43
     450:	8a bd       	out	0x2a, r24	; 42
	break;
     452:	ef ce       	rjmp	.-546    	; 0x232 <play_note+0x22>
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
     454:	8a eb       	ldi	r24, 0xBA	; 186
     456:	93 e0       	ldi	r25, 0x03	; 3
     458:	9b bd       	out	0x2b, r25	; 43
     45a:	8a bd       	out	0x2a, r24	; 42
	break;
     45c:	ea ce       	rjmp	.-556    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
     45e:	66 23       	and	r22, r22
     460:	09 f4       	brne	.+2      	; 0x464 <play_note+0x254>
     462:	7a c1       	rjmp	.+756    	; 0x758 <play_note+0x548>
     464:	81 ec       	ldi	r24, 0xC1	; 193
     466:	91 e0       	ldi	r25, 0x01	; 1
     468:	9b bd       	out	0x2b, r25	; 43
     46a:	8a bd       	out	0x2a, r24	; 42
     46c:	e2 ce       	rjmp	.-572    	; 0x232 <play_note+0x22>
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
     46e:	66 23       	and	r22, r22
     470:	09 f4       	brne	.+2      	; 0x474 <play_note+0x264>
     472:	7c c1       	rjmp	.+760    	; 0x76c <play_note+0x55c>
     474:	8b e0       	ldi	r24, 0x0B	; 11
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	9b bd       	out	0x2b, r25	; 43
     47a:	8a bd       	out	0x2a, r24	; 42
     47c:	da ce       	rjmp	.-588    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
     47e:	66 23       	and	r22, r22
     480:	09 f4       	brne	.+2      	; 0x484 <play_note+0x274>
     482:	7e c1       	rjmp	.+764    	; 0x780 <play_note+0x570>
     484:	80 e5       	ldi	r24, 0x50	; 80
     486:	91 e0       	ldi	r25, 0x01	; 1
     488:	9b bd       	out	0x2b, r25	; 43
     48a:	8a bd       	out	0x2a, r24	; 42
     48c:	d2 ce       	rjmp	.-604    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
     48e:	66 23       	and	r22, r22
     490:	09 f4       	brne	.+2      	; 0x494 <play_note+0x284>
     492:	ad c1       	rjmp	.+858    	; 0x7ee <play_note+0x5de>
     494:	82 e2       	ldi	r24, 0x22	; 34
     496:	93 e0       	ldi	r25, 0x03	; 3
     498:	9b bd       	out	0x2b, r25	; 43
     49a:	8a bd       	out	0x2a, r24	; 42
     49c:	ca ce       	rjmp	.-620    	; 0x232 <play_note+0x22>
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
     49e:	86 e7       	ldi	r24, 0x76	; 118
     4a0:	97 e0       	ldi	r25, 0x07	; 7
     4a2:	9b bd       	out	0x2b, r25	; 43
     4a4:	8a bd       	out	0x2a, r24	; 42
	break;
     4a6:	c5 ce       	rjmp	.-630    	; 0x232 <play_note+0x22>
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
     4a8:	66 23       	and	r22, r22
     4aa:	09 f4       	brne	.+2      	; 0x4ae <play_note+0x29e>
     4ac:	0f c1       	rjmp	.+542    	; 0x6cc <play_note+0x4bc>
     4ae:	8e ec       	ldi	r24, 0xCE	; 206
     4b0:	92 e1       	ldi	r25, 0x12	; 18
     4b2:	9b bd       	out	0x2b, r25	; 43
     4b4:	8a bd       	out	0x2a, r24	; 42
     4b6:	bd ce       	rjmp	.-646    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
     4b8:	66 23       	and	r22, r22
     4ba:	09 f4       	brne	.+2      	; 0x4be <play_note+0x2ae>
     4bc:	7a c1       	rjmp	.+756    	; 0x7b2 <play_note+0x5a2>
     4be:	8d e1       	ldi	r24, 0x1D	; 29
     4c0:	95 e1       	ldi	r25, 0x15	; 21
     4c2:	9b bd       	out	0x2b, r25	; 43
     4c4:	8a bd       	out	0x2a, r24	; 42
     4c6:	b5 ce       	rjmp	.-662    	; 0x232 <play_note+0x22>
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
     4c8:	66 23       	and	r22, r22
     4ca:	09 f4       	brne	.+2      	; 0x4ce <play_note+0x2be>
     4cc:	dc c0       	rjmp	.+440    	; 0x686 <play_note+0x476>
     4ce:	80 e6       	ldi	r24, 0x60	; 96
     4d0:	98 e0       	ldi	r25, 0x08	; 8
     4d2:	9b bd       	out	0x2b, r25	; 43
     4d4:	8a bd       	out	0x2a, r24	; 42
     4d6:	ad ce       	rjmp	.-678    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
     4d8:	66 23       	and	r22, r22
     4da:	09 f4       	brne	.+2      	; 0x4de <play_note+0x2ce>
     4dc:	92 c1       	rjmp	.+804    	; 0x802 <play_note+0x5f2>
     4de:	80 e1       	ldi	r24, 0x10	; 16
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	9b bd       	out	0x2b, r25	; 43
     4e4:	8a bd       	out	0x2a, r24	; 42
     4e6:	a5 ce       	rjmp	.-694    	; 0x232 <play_note+0x22>
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
     4e8:	8e e2       	ldi	r24, 0x2E	; 46
     4ea:	9b e0       	ldi	r25, 0x0B	; 11
     4ec:	9b bd       	out	0x2b, r25	; 43
     4ee:	8a bd       	out	0x2a, r24	; 42
	break;
     4f0:	a0 ce       	rjmp	.-704    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
     4f2:	66 23       	and	r22, r22
     4f4:	09 f4       	brne	.+2      	; 0x4f8 <play_note+0x2e8>
     4f6:	49 c1       	rjmp	.+658    	; 0x78a <play_note+0x57a>
     4f8:	8b e1       	ldi	r24, 0x1B	; 27
     4fa:	90 e0       	ldi	r25, 0x00	; 0
     4fc:	9b bd       	out	0x2b, r25	; 43
     4fe:	8a bd       	out	0x2a, r24	; 42
     500:	98 ce       	rjmp	.-720    	; 0x232 <play_note+0x22>
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
     502:	8c e1       	ldi	r24, 0x1C	; 28
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	9b bd       	out	0x2b, r25	; 43
     508:	8a bd       	out	0x2a, r24	; 42
	break;
     50a:	93 ce       	rjmp	.-730    	; 0x232 <play_note+0x22>
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
     50c:	66 23       	and	r22, r22
     50e:	09 f4       	brne	.+2      	; 0x512 <play_note+0x302>
     510:	41 c1       	rjmp	.+642    	; 0x794 <play_note+0x584>
     512:	87 e0       	ldi	r24, 0x07	; 7
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	9b bd       	out	0x2b, r25	; 43
     518:	8a bd       	out	0x2a, r24	; 42
     51a:	8b ce       	rjmp	.-746    	; 0x232 <play_note+0x22>
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
     51c:	66 23       	and	r22, r22
     51e:	09 f4       	brne	.+2      	; 0x522 <play_note+0x312>
     520:	da c0       	rjmp	.+436    	; 0x6d6 <play_note+0x4c6>
     522:	8b e0       	ldi	r24, 0x0B	; 11
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	9b bd       	out	0x2b, r25	; 43
     528:	8a bd       	out	0x2a, r24	; 42
     52a:	83 ce       	rjmp	.-762    	; 0x232 <play_note+0x22>
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
     52c:	82 e1       	ldi	r24, 0x12	; 18
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	9b bd       	out	0x2b, r25	; 43
     532:	8a bd       	out	0x2a, r24	; 42
	break;
     534:	7e ce       	rjmp	.-772    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
     536:	66 23       	and	r22, r22
     538:	09 f4       	brne	.+2      	; 0x53c <play_note+0x32c>
     53a:	9b c0       	rjmp	.+310    	; 0x672 <play_note+0x462>
     53c:	89 e1       	ldi	r24, 0x19	; 25
     53e:	99 e1       	ldi	r25, 0x19	; 25
     540:	9b bd       	out	0x2b, r25	; 43
     542:	8a bd       	out	0x2a, r24	; 42
     544:	76 ce       	rjmp	.-788    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
     546:	66 23       	and	r22, r22
     548:	09 f4       	brne	.+2      	; 0x54c <play_note+0x33c>
     54a:	29 c1       	rjmp	.+594    	; 0x79e <play_note+0x58e>
     54c:	80 e3       	ldi	r24, 0x30	; 48
     54e:	9c e1       	ldi	r25, 0x1C	; 28
     550:	9b bd       	out	0x2b, r25	; 43
     552:	8a bd       	out	0x2a, r24	; 42
     554:	6e ce       	rjmp	.-804    	; 0x232 <play_note+0x22>
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
     556:	8c ed       	ldi	r24, 0xDC	; 220
     558:	9d e1       	ldi	r25, 0x1D	; 29
     55a:	9b bd       	out	0x2b, r25	; 43
     55c:	8a bd       	out	0x2a, r24	; 42
	break;
     55e:	69 ce       	rjmp	.-814    	; 0x232 <play_note+0x22>
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
     560:	8a e3       	ldi	r24, 0x3A	; 58
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	9b bd       	out	0x2b, r25	; 43
     566:	8a bd       	out	0x2a, r24	; 42
	break;
     568:	64 ce       	rjmp	.-824    	; 0x232 <play_note+0x22>
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
     56a:	66 23       	and	r22, r22
     56c:	09 f4       	brne	.+2      	; 0x570 <play_note+0x360>
     56e:	35 c1       	rjmp	.+618    	; 0x7da <play_note+0x5ca>
     570:	80 e2       	ldi	r24, 0x20	; 32
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	9b bd       	out	0x2b, r25	; 43
     576:	8a bd       	out	0x2a, r24	; 42
     578:	5c ce       	rjmp	.-840    	; 0x232 <play_note+0x22>
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
     57a:	66 23       	and	r22, r22
     57c:	09 f4       	brne	.+2      	; 0x580 <play_note+0x370>
     57e:	32 c1       	rjmp	.+612    	; 0x7e4 <play_note+0x5d4>
     580:	84 e2       	ldi	r24, 0x24	; 36
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	9b bd       	out	0x2b, r25	; 43
     586:	8a bd       	out	0x2a, r24	; 42
     588:	54 ce       	rjmp	.-856    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
     58a:	66 23       	and	r22, r22
     58c:	09 f4       	brne	.+2      	; 0x590 <play_note+0x380>
     58e:	76 c0       	rjmp	.+236    	; 0x67c <play_note+0x46c>
     590:	89 e2       	ldi	r24, 0x29	; 41
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	9b bd       	out	0x2b, r25	; 43
     596:	8a bd       	out	0x2a, r24	; 42
     598:	4c ce       	rjmp	.-872    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
     59a:	66 23       	and	r22, r22
     59c:	09 f4       	brne	.+2      	; 0x5a0 <play_note+0x390>
     59e:	78 c0       	rjmp	.+240    	; 0x690 <play_note+0x480>
     5a0:	81 e3       	ldi	r24, 0x31	; 49
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	9b bd       	out	0x2b, r25	; 43
     5a6:	8a bd       	out	0x2a, r24	; 42
     5a8:	44 ce       	rjmp	.-888    	; 0x232 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
     5aa:	8b e2       	ldi	r24, 0x2B	; 43
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	9b bd       	out	0x2b, r25	; 43
     5b0:	8a bd       	out	0x2a, r24	; 42
	break;
     5b2:	3f ce       	rjmp	.-898    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
     5b4:	66 23       	and	r22, r22
     5b6:	09 f4       	brne	.+2      	; 0x5ba <play_note+0x3aa>
     5b8:	93 c0       	rjmp	.+294    	; 0x6e0 <play_note+0x4d0>
     5ba:	87 e3       	ldi	r24, 0x37	; 55
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	9b bd       	out	0x2b, r25	; 43
     5c0:	8a bd       	out	0x2a, r24	; 42
     5c2:	37 ce       	rjmp	.-914    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
     5c4:	66 23       	and	r22, r22
     5c6:	09 f4       	brne	.+2      	; 0x5ca <play_note+0x3ba>
     5c8:	4f c0       	rjmp	.+158    	; 0x668 <play_note+0x458>
     5ca:	88 e1       	ldi	r24, 0x18	; 24
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	9b bd       	out	0x2b, r25	; 43
     5d0:	8a bd       	out	0x2a, r24	; 42
     5d2:	2f ce       	rjmp	.-930    	; 0x232 <play_note+0x22>
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
     5d4:	66 23       	and	r22, r22
     5d6:	09 f4       	brne	.+2      	; 0x5da <play_note+0x3ca>
     5d8:	f6 c0       	rjmp	.+492    	; 0x7c6 <play_note+0x5b6>
     5da:	82 eb       	ldi	r24, 0xB2	; 178
     5dc:	94 e0       	ldi	r25, 0x04	; 4
     5de:	9b bd       	out	0x2b, r25	; 43
     5e0:	8a bd       	out	0x2a, r24	; 42
     5e2:	27 ce       	rjmp	.-946    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
     5e4:	66 23       	and	r22, r22
     5e6:	09 f4       	brne	.+2      	; 0x5ea <play_note+0x3da>
     5e8:	16 c1       	rjmp	.+556    	; 0x816 <play_note+0x606>
     5ea:	8d e8       	ldi	r24, 0x8D	; 141
     5ec:	9a e0       	ldi	r25, 0x0A	; 10
     5ee:	9b bd       	out	0x2b, r25	; 43
     5f0:	8a bd       	out	0x2a, r24	; 42
     5f2:	1f ce       	rjmp	.-962    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
     5f4:	66 23       	and	r22, r22
     5f6:	09 f4       	brne	.+2      	; 0x5fa <play_note+0x3ea>
     5f8:	d7 c0       	rjmp	.+430    	; 0x7a8 <play_note+0x598>
     5fa:	86 e1       	ldi	r24, 0x16	; 22
     5fc:	9e e0       	ldi	r25, 0x0E	; 14
     5fe:	9b bd       	out	0x2b, r25	; 43
     600:	8a bd       	out	0x2a, r24	; 42
     602:	17 ce       	rjmp	.-978    	; 0x232 <play_note+0x22>
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
     604:	66 23       	and	r22, r22
     606:	09 f4       	brne	.+2      	; 0x60a <play_note+0x3fa>
     608:	f7 c0       	rjmp	.+494    	; 0x7f8 <play_note+0x5e8>
     60a:	80 ec       	ldi	r24, 0xC0	; 192
     60c:	90 e1       	ldi	r25, 0x10	; 16
     60e:	9b bd       	out	0x2b, r25	; 43
     610:	8a bd       	out	0x2a, r24	; 42
     612:	0f ce       	rjmp	.-994    	; 0x232 <play_note+0x22>
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
     614:	66 23       	and	r22, r22
     616:	09 f4       	brne	.+2      	; 0x61a <play_note+0x40a>
     618:	d1 c0       	rjmp	.+418    	; 0x7bc <play_note+0x5ac>
     61a:	8f e2       	ldi	r24, 0x2F	; 47
     61c:	94 e0       	ldi	r25, 0x04	; 4
     61e:	9b bd       	out	0x2b, r25	; 43
     620:	8a bd       	out	0x2a, r24	; 42
     622:	07 ce       	rjmp	.-1010   	; 0x232 <play_note+0x22>
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
     624:	66 23       	and	r22, r22
     626:	09 f4       	brne	.+2      	; 0x62a <play_note+0x41a>
     628:	f1 c0       	rjmp	.+482    	; 0x80c <play_note+0x5fc>
     62a:	87 e6       	ldi	r24, 0x67	; 103
     62c:	99 e0       	ldi	r25, 0x09	; 9
     62e:	9b bd       	out	0x2b, r25	; 43
     630:	8a bd       	out	0x2a, r24	; 42
     632:	ff cd       	rjmp	.-1026   	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
     634:	66 23       	and	r22, r22
     636:	09 f4       	brne	.+2      	; 0x63a <play_note+0x42a>
     638:	cb c0       	rjmp	.+406    	; 0x7d0 <play_note+0x5c0>
     63a:	8d e8       	ldi	r24, 0x8D	; 141
     63c:	9c e0       	ldi	r25, 0x0C	; 12
     63e:	9b bd       	out	0x2b, r25	; 43
     640:	8a bd       	out	0x2a, r24	; 42
     642:	f7 cd       	rjmp	.-1042   	; 0x232 <play_note+0x22>
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
     644:	8d e5       	ldi	r24, 0x5D	; 93
     646:	96 e1       	ldi	r25, 0x16	; 22
     648:	9b bd       	out	0x2b, r25	; 43
     64a:	8a bd       	out	0x2a, r24	; 42
	break;
     64c:	f2 cd       	rjmp	.-1052   	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
     64e:	66 23       	and	r22, r22
     650:	09 f4       	brne	.+2      	; 0x654 <play_note+0x444>
     652:	e6 c0       	rjmp	.+460    	; 0x820 <play_note+0x610>
     654:	86 e4       	ldi	r24, 0x46	; 70
     656:	95 e0       	ldi	r25, 0x05	; 5
     658:	9b bd       	out	0x2b, r25	; 43
     65a:	8a bd       	out	0x2a, r24	; 42
     65c:	ea cd       	rjmp	.-1068   	; 0x232 <play_note+0x22>
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
     65e:	8d ee       	ldi	r24, 0xED	; 237
     660:	9e e0       	ldi	r25, 0x0E	; 14
     662:	9b bd       	out	0x2b, r25	; 43
     664:	8a bd       	out	0x2a, r24	; 42
	break;
     666:	e5 cd       	rjmp	.-1078   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
     668:	85 e1       	ldi	r24, 0x15	; 21
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	9b bd       	out	0x2b, r25	; 43
     66e:	8a bd       	out	0x2a, r24	; 42
     670:	e0 cd       	rjmp	.-1088   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
     672:	82 eb       	ldi	r24, 0xB2	; 178
     674:	97 e1       	ldi	r25, 0x17	; 23
     676:	9b bd       	out	0x2b, r25	; 43
     678:	8a bd       	out	0x2a, r24	; 42
     67a:	db cd       	rjmp	.-1098   	; 0x232 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
     67c:	86 e2       	ldi	r24, 0x26	; 38
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	9b bd       	out	0x2b, r25	; 43
     682:	8a bd       	out	0x2a, r24	; 42
     684:	d6 cd       	rjmp	.-1108   	; 0x232 <play_note+0x22>
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
     686:	87 ee       	ldi	r24, 0xE7	; 231
     688:	97 e0       	ldi	r25, 0x07	; 7
     68a:	9b bd       	out	0x2b, r25	; 43
     68c:	8a bd       	out	0x2a, r24	; 42
     68e:	d1 cd       	rjmp	.-1118   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
     690:	8e e2       	ldi	r24, 0x2E	; 46
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	9b bd       	out	0x2b, r25	; 43
     696:	8a bd       	out	0x2a, r24	; 42
     698:	cc cd       	rjmp	.-1128   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
     69a:	8b ee       	ldi	r24, 0xEB	; 235
     69c:	95 e0       	ldi	r25, 0x05	; 5
     69e:	9b bd       	out	0x2b, r25	; 43
     6a0:	8a bd       	out	0x2a, r24	; 42
     6a2:	c7 cd       	rjmp	.-1138   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
     6a4:	8a e7       	ldi	r24, 0x7A	; 122
     6a6:	91 e0       	ldi	r25, 0x01	; 1
     6a8:	9b bd       	out	0x2b, r25	; 43
     6aa:	8a bd       	out	0x2a, r24	; 42
     6ac:	c2 cd       	rjmp	.-1148   	; 0x232 <play_note+0x22>
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
     6ae:	8e e3       	ldi	r24, 0x3E	; 62
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	9b bd       	out	0x2b, r25	; 43
     6b4:	8a bd       	out	0x2a, r24	; 42
     6b6:	bd cd       	rjmp	.-1158   	; 0x232 <play_note+0x22>
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
     6b8:	89 ef       	ldi	r24, 0xF9	; 249
     6ba:	91 e0       	ldi	r25, 0x01	; 1
     6bc:	9b bd       	out	0x2b, r25	; 43
     6be:	8a bd       	out	0x2a, r24	; 42
     6c0:	b8 cd       	rjmp	.-1168   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
     6c2:	8c eb       	ldi	r24, 0xBC	; 188
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	9b bd       	out	0x2b, r25	; 43
     6c8:	8a bd       	out	0x2a, r24	; 42
     6ca:	b3 cd       	rjmp	.-1178   	; 0x232 <play_note+0x22>
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
     6cc:	80 ec       	ldi	r24, 0xC0	; 192
     6ce:	91 e1       	ldi	r25, 0x11	; 17
     6d0:	9b bd       	out	0x2b, r25	; 43
     6d2:	8a bd       	out	0x2a, r24	; 42
     6d4:	ae cd       	rjmp	.-1188   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
     6d6:	89 e0       	ldi	r24, 0x09	; 9
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	9b bd       	out	0x2b, r25	; 43
     6dc:	8a bd       	out	0x2a, r24	; 42
     6de:	a9 cd       	rjmp	.-1198   	; 0x232 <play_note+0x22>
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
     6e0:	84 e3       	ldi	r24, 0x34	; 52
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	9b bd       	out	0x2b, r25	; 43
     6e6:	8a bd       	out	0x2a, r24	; 42
     6e8:	a4 cd       	rjmp	.-1208   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
     6ea:	8d e8       	ldi	r24, 0x8D	; 141
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	9b bd       	out	0x2b, r25	; 43
     6f0:	8a bd       	out	0x2a, r24	; 42
     6f2:	9f cd       	rjmp	.-1218   	; 0x232 <play_note+0x22>
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
     6f4:	8e e9       	ldi	r24, 0x9E	; 158
     6f6:	90 e0       	ldi	r25, 0x00	; 0
     6f8:	9b bd       	out	0x2b, r25	; 43
     6fa:	8a bd       	out	0x2a, r24	; 42
     6fc:	9a cd       	rjmp	.-1228   	; 0x232 <play_note+0x22>
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
     6fe:	8d e7       	ldi	r24, 0x7D	; 125
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	9b bd       	out	0x2b, r25	; 43
     704:	8a bd       	out	0x2a, r24	; 42
     706:	95 cd       	rjmp	.-1238   	; 0x232 <play_note+0x22>
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
     708:	83 ed       	ldi	r24, 0xD3	; 211
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	9b bd       	out	0x2b, r25	; 43
     70e:	8a bd       	out	0x2a, r24	; 42
     710:	90 cd       	rjmp	.-1248   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
     712:	8d e5       	ldi	r24, 0x5D	; 93
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	9b bd       	out	0x2b, r25	; 43
     718:	8a bd       	out	0x2a, r24	; 42
     71a:	8b cd       	rjmp	.-1258   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
     71c:	86 e4       	ldi	r24, 0x46	; 70
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	9b bd       	out	0x2b, r25	; 43
     722:	8a bd       	out	0x2a, r24	; 42
     724:	86 cd       	rjmp	.-1268   	; 0x232 <play_note+0x22>
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
     726:	89 e6       	ldi	r24, 0x69	; 105
     728:	90 e0       	ldi	r25, 0x00	; 0
     72a:	9b bd       	out	0x2b, r25	; 43
     72c:	8a bd       	out	0x2a, r24	; 42
     72e:	81 cd       	rjmp	.-1278   	; 0x232 <play_note+0x22>
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
     730:	8e e4       	ldi	r24, 0x4E	; 78
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9b bd       	out	0x2b, r25	; 43
     736:	8a bd       	out	0x2a, r24	; 42
     738:	7c cd       	rjmp	.-1288   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
     73a:	8b e1       	ldi	r24, 0x1B	; 27
     73c:	91 e0       	ldi	r25, 0x01	; 1
     73e:	9b bd       	out	0x2b, r25	; 43
     740:	8a bd       	out	0x2a, r24	; 42
     742:	77 cd       	rjmp	.-1298   	; 0x232 <play_note+0x22>
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
     744:	85 ea       	ldi	r24, 0xA5	; 165
     746:	96 e0       	ldi	r25, 0x06	; 6
     748:	9b bd       	out	0x2b, r25	; 43
     74a:	8a bd       	out	0x2a, r24	; 42
     74c:	72 cd       	rjmp	.-1308   	; 0x232 <play_note+0x22>
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
     74e:	8c e7       	ldi	r24, 0x7C	; 124
     750:	92 e0       	ldi	r25, 0x02	; 2
     752:	9b bd       	out	0x2b, r25	; 43
     754:	8a bd       	out	0x2a, r24	; 42
     756:	6d cd       	rjmp	.-1318   	; 0x232 <play_note+0x22>
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
     758:	88 ea       	ldi	r24, 0xA8	; 168
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	9b bd       	out	0x2b, r25	; 43
     75e:	8a bd       	out	0x2a, r24	; 42
     760:	68 cd       	rjmp	.-1328   	; 0x232 <play_note+0x22>
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
     762:	82 e5       	ldi	r24, 0x52	; 82
     764:	93 e0       	ldi	r25, 0x03	; 3
     766:	9b bd       	out	0x2b, r25	; 43
     768:	8a bd       	out	0x2a, r24	; 42
     76a:	63 cd       	rjmp	.-1338   	; 0x232 <play_note+0x22>
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
     76c:	8c ef       	ldi	r24, 0xFC	; 252
     76e:	90 e0       	ldi	r25, 0x00	; 0
     770:	9b bd       	out	0x2b, r25	; 43
     772:	8a bd       	out	0x2a, r24	; 42
     774:	5e cd       	rjmp	.-1348   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
     776:	87 e3       	ldi	r24, 0x37	; 55
     778:	92 e0       	ldi	r25, 0x02	; 2
     77a:	9b bd       	out	0x2b, r25	; 43
     77c:	8a bd       	out	0x2a, r24	; 42
     77e:	59 cd       	rjmp	.-1358   	; 0x232 <play_note+0x22>
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
     780:	8d e3       	ldi	r24, 0x3D	; 61
     782:	91 e0       	ldi	r25, 0x01	; 1
     784:	9b bd       	out	0x2b, r25	; 43
     786:	8a bd       	out	0x2a, r24	; 42
     788:	54 cd       	rjmp	.-1368   	; 0x232 <play_note+0x22>
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
     78a:	89 e1       	ldi	r24, 0x19	; 25
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	9b bd       	out	0x2b, r25	; 43
     790:	8a bd       	out	0x2a, r24	; 42
     792:	4f cd       	rjmp	.-1378   	; 0x232 <play_note+0x22>
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
     794:	85 e0       	ldi	r24, 0x05	; 5
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	9b bd       	out	0x2b, r25	; 43
     79a:	8a bd       	out	0x2a, r24	; 42
     79c:	4a cd       	rjmp	.-1388   	; 0x232 <play_note+0x22>
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
     79e:	8a e9       	ldi	r24, 0x9A	; 154
     7a0:	9a e1       	ldi	r25, 0x1A	; 26
     7a2:	9b bd       	out	0x2b, r25	; 43
     7a4:	8a bd       	out	0x2a, r24	; 42
     7a6:	45 cd       	rjmp	.-1398   	; 0x232 <play_note+0x22>
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
     7a8:	8c e4       	ldi	r24, 0x4C	; 76
     7aa:	9d e0       	ldi	r25, 0x0D	; 13
     7ac:	9b bd       	out	0x2b, r25	; 43
     7ae:	8a bd       	out	0x2a, r24	; 42
     7b0:	40 cd       	rjmp	.-1408   	; 0x232 <play_note+0x22>
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
     7b2:	8d ee       	ldi	r24, 0xED	; 237
     7b4:	93 e1       	ldi	r25, 0x13	; 19
     7b6:	9b bd       	out	0x2b, r25	; 43
     7b8:	8a bd       	out	0x2a, r24	; 42
     7ba:	3b cd       	rjmp	.-1418   	; 0x232 <play_note+0x22>
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
     7bc:	83 ef       	ldi	r24, 0xF3	; 243
     7be:	93 e0       	ldi	r25, 0x03	; 3
     7c0:	9b bd       	out	0x2b, r25	; 43
     7c2:	8a bd       	out	0x2a, r24	; 42
     7c4:	36 cd       	rjmp	.-1428   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
     7c6:	8f e6       	ldi	r24, 0x6F	; 111
     7c8:	94 e0       	ldi	r25, 0x04	; 4
     7ca:	9b bd       	out	0x2b, r25	; 43
     7cc:	8a bd       	out	0x2a, r24	; 42
     7ce:	31 cd       	rjmp	.-1438   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
     7d0:	88 ed       	ldi	r24, 0xD8	; 216
     7d2:	9b e0       	ldi	r25, 0x0B	; 11
     7d4:	9b bd       	out	0x2b, r25	; 43
     7d6:	8a bd       	out	0x2a, r24	; 42
     7d8:	2c cd       	rjmp	.-1448   	; 0x232 <play_note+0x22>
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
     7da:	8e e1       	ldi	r24, 0x1E	; 30
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	9b bd       	out	0x2b, r25	; 43
     7e0:	8a bd       	out	0x2a, r24	; 42
     7e2:	27 cd       	rjmp	.-1458   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
     7e4:	82 e2       	ldi	r24, 0x22	; 34
     7e6:	90 e0       	ldi	r25, 0x00	; 0
     7e8:	9b bd       	out	0x2b, r25	; 43
     7ea:	8a bd       	out	0x2a, r24	; 42
     7ec:	22 cd       	rjmp	.-1468   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
     7ee:	85 ef       	ldi	r24, 0xF5	; 245
     7f0:	92 e0       	ldi	r25, 0x02	; 2
     7f2:	9b bd       	out	0x2b, r25	; 43
     7f4:	8a bd       	out	0x2a, r24	; 42
     7f6:	1d cd       	rjmp	.-1478   	; 0x232 <play_note+0x22>
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
     7f8:	80 ed       	ldi	r24, 0xD0	; 208
     7fa:	9f e0       	ldi	r25, 0x0F	; 15
     7fc:	9b bd       	out	0x2b, r25	; 43
     7fe:	8a bd       	out	0x2a, r24	; 42
     800:	18 cd       	rjmp	.-1488   	; 0x232 <play_note+0x22>
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
     802:	8d e0       	ldi	r24, 0x0D	; 13
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	9b bd       	out	0x2b, r25	; 43
     808:	8a bd       	out	0x2a, r24	; 42
     80a:	13 cd       	rjmp	.-1498   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
     80c:	8f ed       	ldi	r24, 0xDF	; 223
     80e:	98 e0       	ldi	r25, 0x08	; 8
     810:	9b bd       	out	0x2b, r25	; 43
     812:	8a bd       	out	0x2a, r24	; 42
     814:	0e cd       	rjmp	.-1508   	; 0x232 <play_note+0x22>
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
     816:	86 ef       	ldi	r24, 0xF6	; 246
     818:	99 e0       	ldi	r25, 0x09	; 9
     81a:	9b bd       	out	0x2b, r25	; 43
     81c:	8a bd       	out	0x2a, r24	; 42
     81e:	09 cd       	rjmp	.-1518   	; 0x232 <play_note+0x22>
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
     820:	8a ef       	ldi	r24, 0xFA	; 250
     822:	94 e0       	ldi	r25, 0x04	; 4
     824:	9b bd       	out	0x2b, r25	; 43
     826:	8a bd       	out	0x2a, r24	; 42
     828:	04 cd       	rjmp	.-1528   	; 0x232 <play_note+0x22>

0000082a <song0>:
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     82a:	86 34       	cpi	r24, 0x46	; 70
     82c:	91 05       	cpc	r25, r1
     82e:	20 f0       	brcs	.+8      	; 0x838 <song0+0xe>
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
     830:	8f ef       	ldi	r24, 0xFF	; 255
     832:	80 93 4e 01 	sts	0x014E, r24
     836:	08 95       	ret
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     838:	fc 01       	movw	r30, r24
     83a:	e2 57       	subi	r30, 0x72	; 114
     83c:	ff 4f       	sbci	r31, 0xFF	; 255
     83e:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
     842:	22 e0       	ldi	r18, 0x02	; 2
     844:	44 e0       	ldi	r20, 0x04	; 4
     846:	60 e0       	ldi	r22, 0x00	; 0
     848:	81 e4       	ldi	r24, 0x41	; 65
     84a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
     84e:	26 e0       	ldi	r18, 0x06	; 6
     850:	44 e0       	ldi	r20, 0x04	; 4
     852:	60 e0       	ldi	r22, 0x00	; 0
     854:	81 e4       	ldi	r24, 0x41	; 65
     856:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
     85a:	22 e0       	ldi	r18, 0x02	; 2
     85c:	44 e0       	ldi	r20, 0x04	; 4
     85e:	61 e0       	ldi	r22, 0x01	; 1
     860:	81 e4       	ldi	r24, 0x41	; 65
     862:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
     866:	28 e0       	ldi	r18, 0x08	; 8
     868:	44 e0       	ldi	r20, 0x04	; 4
     86a:	60 e0       	ldi	r22, 0x00	; 0
     86c:	84 e4       	ldi	r24, 0x44	; 68
     86e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
     872:	28 e0       	ldi	r18, 0x08	; 8
     874:	44 e0       	ldi	r20, 0x04	; 4
     876:	60 e0       	ldi	r22, 0x00	; 0
     878:	86 e4       	ldi	r24, 0x46	; 70
     87a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
     87e:	26 e0       	ldi	r18, 0x06	; 6
     880:	44 e0       	ldi	r20, 0x04	; 4
     882:	61 e0       	ldi	r22, 0x01	; 1
     884:	82 e4       	ldi	r24, 0x42	; 66
     886:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
     88a:	28 e0       	ldi	r18, 0x08	; 8
     88c:	44 e0       	ldi	r20, 0x04	; 4
     88e:	60 e0       	ldi	r22, 0x00	; 0
     890:	83 e4       	ldi	r24, 0x43	; 67
     892:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
     896:	28 e0       	ldi	r18, 0x08	; 8
     898:	44 e0       	ldi	r20, 0x04	; 4
     89a:	60 e0       	ldi	r22, 0x00	; 0
     89c:	81 e4       	ldi	r24, 0x41	; 65
     89e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 67: play_note('G', 0, 4, 8);
     8a2:	28 e0       	ldi	r18, 0x08	; 8
     8a4:	44 e0       	ldi	r20, 0x04	; 4
     8a6:	60 e0       	ldi	r22, 0x00	; 0
     8a8:	87 e4       	ldi	r24, 0x47	; 71
     8aa:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
     8ae:	28 e0       	ldi	r18, 0x08	; 8
     8b0:	44 e0       	ldi	r20, 0x04	; 4
     8b2:	60 e0       	ldi	r22, 0x00	; 0
     8b4:	85 e4       	ldi	r24, 0x45	; 69
     8b6:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
     8ba:	20 e1       	ldi	r18, 0x10	; 16
     8bc:	44 e0       	ldi	r20, 0x04	; 4
     8be:	60 e0       	ldi	r22, 0x00	; 0
     8c0:	81 e4       	ldi	r24, 0x41	; 65
     8c2:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
     8c6:	24 e0       	ldi	r18, 0x04	; 4
     8c8:	45 e0       	ldi	r20, 0x05	; 5
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	83 e4       	ldi	r24, 0x43	; 67
     8ce:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 65: play_note('D', 0, 5, 4);
     8d2:	24 e0       	ldi	r18, 0x04	; 4
     8d4:	45 e0       	ldi	r20, 0x05	; 5
     8d6:	60 e0       	ldi	r22, 0x00	; 0
     8d8:	84 e4       	ldi	r24, 0x44	; 68
     8da:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     8de:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     8e0:	10 92 5f 01 	sts	0x015F, r1
     8e4:	10 92 5e 01 	sts	0x015E, r1
  max_beat = duration;
     8e8:	88 e0       	ldi	r24, 0x08	; 8
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	90 93 5d 01 	sts	0x015D, r25
     8f0:	80 93 5c 01 	sts	0x015C, r24
     8f4:	08 95       	ret
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     8f6:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     8f8:	10 92 5f 01 	sts	0x015F, r1
     8fc:	10 92 5e 01 	sts	0x015E, r1
  max_beat = duration;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	90 93 5d 01 	sts	0x015D, r25
     908:	80 93 5c 01 	sts	0x015C, r24
     90c:	08 95       	ret
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
     90e:	20 e1       	ldi	r18, 0x10	; 16
     910:	44 e0       	ldi	r20, 0x04	; 4
     912:	61 e0       	ldi	r22, 0x01	; 1
     914:	82 e4       	ldi	r24, 0x42	; 66
     916:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
     91a:	28 e0       	ldi	r18, 0x08	; 8
     91c:	44 e0       	ldi	r20, 0x04	; 4
     91e:	61 e0       	ldi	r22, 0x01	; 1
     920:	82 e4       	ldi	r24, 0x42	; 66
     922:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
     926:	28 e1       	ldi	r18, 0x18	; 24
     928:	44 e0       	ldi	r20, 0x04	; 4
     92a:	60 e0       	ldi	r22, 0x00	; 0
     92c:	87 e4       	ldi	r24, 0x47	; 71
     92e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
     932:	20 e1       	ldi	r18, 0x10	; 16
     934:	45 e0       	ldi	r20, 0x05	; 5
     936:	60 e0       	ldi	r22, 0x00	; 0
     938:	84 e4       	ldi	r24, 0x44	; 68
     93a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     93e:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     940:	10 92 5f 01 	sts	0x015F, r1
     944:	10 92 5e 01 	sts	0x015E, r1
  max_beat = duration;
     948:	82 e0       	ldi	r24, 0x02	; 2
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	90 93 5d 01 	sts	0x015D, r25
     950:	80 93 5c 01 	sts	0x015C, r24
     954:	08 95       	ret
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
     956:	24 e0       	ldi	r18, 0x04	; 4
     958:	44 e0       	ldi	r20, 0x04	; 4
     95a:	60 e0       	ldi	r22, 0x00	; 0
     95c:	81 e4       	ldi	r24, 0x41	; 65
     95e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
     962:	26 e0       	ldi	r18, 0x06	; 6
     964:	44 e0       	ldi	r20, 0x04	; 4
     966:	60 e0       	ldi	r22, 0x00	; 0
     968:	87 e4       	ldi	r24, 0x47	; 71
     96a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
     96e:	24 e0       	ldi	r18, 0x04	; 4
     970:	44 e0       	ldi	r20, 0x04	; 4
     972:	61 e0       	ldi	r22, 0x01	; 1
     974:	87 e4       	ldi	r24, 0x47	; 71
     976:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
     97a:	28 e0       	ldi	r18, 0x08	; 8
     97c:	44 e0       	ldi	r20, 0x04	; 4
     97e:	61 e0       	ldi	r22, 0x01	; 1
     980:	87 e4       	ldi	r24, 0x47	; 71
     982:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
     986:	23 e0       	ldi	r18, 0x03	; 3
     988:	44 e0       	ldi	r20, 0x04	; 4
     98a:	60 e0       	ldi	r22, 0x00	; 0
     98c:	87 e4       	ldi	r24, 0x47	; 71
     98e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
     992:	20 e1       	ldi	r18, 0x10	; 16
     994:	44 e0       	ldi	r20, 0x04	; 4
     996:	60 e0       	ldi	r22, 0x00	; 0
     998:	84 e4       	ldi	r24, 0x44	; 68
     99a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
     99e:	20 e1       	ldi	r18, 0x10	; 16
     9a0:	45 e0       	ldi	r20, 0x05	; 5
     9a2:	60 e0       	ldi	r22, 0x00	; 0
     9a4:	83 e4       	ldi	r24, 0x43	; 67
     9a6:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
     9aa:	22 e0       	ldi	r18, 0x02	; 2
     9ac:	44 e0       	ldi	r20, 0x04	; 4
     9ae:	61 e0       	ldi	r22, 0x01	; 1
     9b0:	82 e4       	ldi	r24, 0x42	; 66
     9b2:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
     9b6:	24 e0       	ldi	r18, 0x04	; 4
     9b8:	45 e0       	ldi	r20, 0x05	; 5
     9ba:	61 e0       	ldi	r22, 0x01	; 1
     9bc:	84 e4       	ldi	r24, 0x44	; 68
     9be:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
     9c2:	24 e0       	ldi	r18, 0x04	; 4
     9c4:	44 e0       	ldi	r20, 0x04	; 4
     9c6:	61 e0       	ldi	r22, 0x01	; 1
     9c8:	81 e4       	ldi	r24, 0x41	; 65
     9ca:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
     9ce:	28 e0       	ldi	r18, 0x08	; 8
     9d0:	44 e0       	ldi	r20, 0x04	; 4
     9d2:	60 e0       	ldi	r22, 0x00	; 0
     9d4:	82 e4       	ldi	r24, 0x42	; 66
     9d6:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
     9da:	28 e1       	ldi	r18, 0x18	; 24
     9dc:	44 e0       	ldi	r20, 0x04	; 4
     9de:	60 e0       	ldi	r22, 0x00	; 0
     9e0:	86 e4       	ldi	r24, 0x46	; 70
     9e2:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
     9e6:	27 e0       	ldi	r18, 0x07	; 7
     9e8:	44 e0       	ldi	r20, 0x04	; 4
     9ea:	60 e0       	ldi	r22, 0x00	; 0
     9ec:	87 e4       	ldi	r24, 0x47	; 71
     9ee:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>

000009f2 <play_song>:
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     9f2:	86 2f       	mov	r24, r22
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	0c 94 15 04 	jmp	0x82a	; 0x82a <song0>

000009fa <music_off>:
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     9fa:	10 92 4e 01 	sts	0x014E, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     9fe:	8e b5       	in	r24, 0x2e	; 46
     a00:	8c 7f       	andi	r24, 0xFC	; 252
     a02:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     a04:	92 9a       	sbi	0x12, 2	; 18
     a06:	08 95       	ret

00000a08 <music_on>:
}

void music_on(void) {
  //this starts the alarm timer running
  notes=0;
     a08:	10 92 4e 01 	sts	0x014E, r1
  TCCR1B |= (1<<CS11)|(1<<CS10);
     a0c:	8e b5       	in	r24, 0x2e	; 46
     a0e:	83 60       	ori	r24, 0x03	; 3
     a10:	8e bd       	out	0x2e, r24	; 46
  //unmutes the output
  PORTD &= unmute;
     a12:	92 98       	cbi	0x12, 2	; 18
  //and starts the selected song
  play_song(song, notes);
     a14:	80 91 4e 01 	lds	r24, 0x014E
     a18:	90 91 5b 01 	lds	r25, 0x015B
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     a1c:	90 e0       	ldi	r25, 0x00	; 0
     a1e:	0c 94 15 04 	jmp	0x82a	; 0x82a <song0>

00000a22 <music_init>:
  play_song(song, notes);
}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  DDRD |= (1<<PD7);
     a22:	8f 9a       	sbi	0x11, 7	; 17
  TIMSK |= (1<<OCIE1A) | (1<<TOIE0);  //enable timer interrupt 1 on compare
     a24:	87 b7       	in	r24, 0x37	; 55
     a26:	81 61       	ori	r24, 0x11	; 17
     a28:	87 bf       	out	0x37, r24	; 55
  TCCR1A = 0x00;         //TCNT1, normal port operation
     a2a:	1f bc       	out	0x2f, r1	; 47
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
     a2c:	8e b5       	in	r24, 0x2e	; 46
     a2e:	88 60       	ori	r24, 0x08	; 8
     a30:	8e bd       	out	0x2e, r24	; 46
  TCCR1C = 0x00;         //no forced compare
     a32:	10 92 7a 00 	sts	0x007A, r1
  OCR1A = 0x0033;        //(use to vary alarm frequency)
     a36:	83 e3       	ldi	r24, 0x33	; 51
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	9b bd       	out	0x2b, r25	; 43
     a3c:	8a bd       	out	0x2a, r24	; 42
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     a3e:	10 92 4e 01 	sts	0x014E, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     a42:	8e b5       	in	r24, 0x2e	; 46
     a44:	8c 7f       	andi	r24, 0xFC	; 252
     a46:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     a48:	92 9a       	sbi	0x12, 2	; 18
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0033;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
     a4a:	10 92 5f 01 	sts	0x015F, r1
     a4e:	10 92 5e 01 	sts	0x015E, r1
  max_beat = 0;
     a52:	10 92 5d 01 	sts	0x015D, r1
     a56:	10 92 5c 01 	sts	0x015C, r1
  notes = 0;
     a5a:	10 92 4e 01 	sts	0x014E, r1
  song = 0;              //beaver fight song
     a5e:	10 92 5b 01 	sts	0x015B, r1
     a62:	08 95       	ret

00000a64 <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     a64:	20 91 44 01 	lds	r18, 0x0144
     a68:	30 91 45 01 	lds	r19, 0x0145
     a6c:	22 0f       	add	r18, r18
     a6e:	33 1f       	adc	r19, r19
     a70:	49 b3       	in	r20, 0x19	; 25
     a72:	50 e0       	ldi	r21, 0x00	; 0
     a74:	02 c0       	rjmp	.+4      	; 0xa7a <chk_buttons+0x16>
     a76:	55 95       	asr	r21
     a78:	47 95       	ror	r20
     a7a:	8a 95       	dec	r24
     a7c:	e2 f7       	brpl	.-8      	; 0xa76 <chk_buttons+0x12>
     a7e:	40 fd       	sbrc	r20, 0
     a80:	0e c0       	rjmp	.+28     	; 0xa9e <chk_buttons+0x3a>
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	90 ee       	ldi	r25, 0xE0	; 224
     a86:	28 2b       	or	r18, r24
     a88:	39 2b       	or	r19, r25
     a8a:	30 93 45 01 	sts	0x0145, r19
     a8e:	20 93 44 01 	sts	0x0144, r18
    if (state == 0xF000){
     a92:	81 e0       	ldi	r24, 0x01	; 1
     a94:	21 15       	cp	r18, r1
     a96:	30 4f       	sbci	r19, 0xF0	; 240
     a98:	09 f0       	breq	.+2      	; 0xa9c <chk_buttons+0x38>
     a9a:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
    }
    return 0;
}
     a9c:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	90 ee       	ldi	r25, 0xE0	; 224
     aa2:	f1 cf       	rjmp	.-30     	; 0xa86 <chk_buttons+0x22>

00000aa4 <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
     aa4:	81 11       	cpse	r24, r1
     aa6:	02 c0       	rjmp	.+4      	; 0xaac <int2seg+0x8>
	return ZERO;
     aa8:	80 ec       	ldi	r24, 0xC0	; 192
     aaa:	08 95       	ret
    }
    else if(number == 1 ){
     aac:	81 30       	cpi	r24, 0x01	; 1
     aae:	91 f0       	breq	.+36     	; 0xad4 <int2seg+0x30>
	return ONE;
    }
    else if(number == 2 ){
     ab0:	82 30       	cpi	r24, 0x02	; 2
     ab2:	91 f0       	breq	.+36     	; 0xad8 <int2seg+0x34>
	return TWO;
    }
    else if(number == 3 ){
     ab4:	83 30       	cpi	r24, 0x03	; 3
     ab6:	a1 f0       	breq	.+40     	; 0xae0 <int2seg+0x3c>
	return THREE;
    }
    else if(number == 4 ){
     ab8:	84 30       	cpi	r24, 0x04	; 4
     aba:	81 f0       	breq	.+32     	; 0xadc <int2seg+0x38>
	return FOUR;
    }
    else if(number == 5 ){
     abc:	85 30       	cpi	r24, 0x05	; 5
     abe:	91 f0       	breq	.+36     	; 0xae4 <int2seg+0x40>
	return FIVE;
    }
    else if(number == 6 ){
     ac0:	86 30       	cpi	r24, 0x06	; 6
     ac2:	91 f0       	breq	.+36     	; 0xae8 <int2seg+0x44>
	return  SIX;
    }
    else if(number == 7 ){
     ac4:	87 30       	cpi	r24, 0x07	; 7
     ac6:	91 f0       	breq	.+36     	; 0xaec <int2seg+0x48>
	return SEVEN;
    }
    else if(number == 8 ){
     ac8:	88 30       	cpi	r24, 0x08	; 8
     aca:	91 f0       	breq	.+36     	; 0xaf0 <int2seg+0x4c>
	return EIGHT;
    }
    else if(number == 9 ){
     acc:	89 30       	cpi	r24, 0x09	; 9
     ace:	91 f0       	breq	.+36     	; 0xaf4 <int2seg+0x50>
	return NINE;
    }
    else{ 
	return 0;
     ad0:	80 e0       	ldi	r24, 0x00	; 0
     ad2:	08 95       	ret
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
	return ZERO;
    }
    else if(number == 1 ){
	return ONE;
     ad4:	89 ef       	ldi	r24, 0xF9	; 249
     ad6:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
     ad8:	84 ea       	ldi	r24, 0xA4	; 164
     ada:	08 95       	ret
    }
    else if(number == 3 ){
	return THREE;
    }
    else if(number == 4 ){
	return FOUR;
     adc:	89 e9       	ldi	r24, 0x99	; 153
     ade:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
    }
    else if(number == 3 ){
	return THREE;
     ae0:	80 eb       	ldi	r24, 0xB0	; 176
     ae2:	08 95       	ret
    }
    else if(number == 4 ){
	return FOUR;
    }
    else if(number == 5 ){
	return FIVE;
     ae4:	82 e9       	ldi	r24, 0x92	; 146
     ae6:	08 95       	ret
    }
    else if(number == 6 ){
	return  SIX;
     ae8:	82 e8       	ldi	r24, 0x82	; 130
     aea:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
     aec:	88 ef       	ldi	r24, 0xF8	; 248
	return NINE;
    }
    else{ 
	return 0;
    }
}
     aee:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
    }
    else if(number == 8 ){
	return EIGHT;
     af0:	80 e8       	ldi	r24, 0x80	; 128
     af2:	08 95       	ret
    }
    else if(number == 9 ){
	return NINE;
     af4:	80 e9       	ldi	r24, 0x90	; 144
     af6:	08 95       	ret

00000af8 <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
     af8:	ff 92       	push	r15
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	ec 01       	movw	r28, r24
    //determine how many digits there are 
    //int digit;
    // Break down the digits

    if(ticker%2 == 1){
     b04:	80 91 46 01 	lds	r24, 0x0146
     b08:	80 ff       	sbrs	r24, 0
     b0a:	82 c0       	rjmp	.+260    	; 0xc10 <segsum+0x118>
	segment_data[2] = 0xFC;
     b0c:	8c ef       	ldi	r24, 0xFC	; 252
     b0e:	80 93 67 01 	sts	0x0167, r24
	segment_data[2] = 0xFF;
    } 
    //When setting alarm is on)
    //break up decimal sum into 4 digit-segments

    segment_data[0] = int2seg(sum % 10); //ones
     b12:	9e 01       	movw	r18, r28
     b14:	ad ec       	ldi	r26, 0xCD	; 205
     b16:	bc ec       	ldi	r27, 0xCC	; 204
     b18:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <__umulhisi3>
     b1c:	96 95       	lsr	r25
     b1e:	87 95       	ror	r24
     b20:	96 95       	lsr	r25
     b22:	87 95       	ror	r24
     b24:	96 95       	lsr	r25
     b26:	87 95       	ror	r24
     b28:	3c 2f       	mov	r19, r28
     b2a:	2a e0       	ldi	r18, 0x0A	; 10
     b2c:	82 9f       	mul	r24, r18
     b2e:	30 19       	sub	r19, r0
     b30:	11 24       	eor	r1, r1
     b32:	83 2f       	mov	r24, r19
     b34:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     b38:	f8 2e       	mov	r15, r24
    segment_data[1] = int2seg((sum % 100)/10); //tens
     b3a:	9e 01       	movw	r18, r28
     b3c:	36 95       	lsr	r19
     b3e:	27 95       	ror	r18
     b40:	36 95       	lsr	r19
     b42:	27 95       	ror	r18
     b44:	ab e7       	ldi	r26, 0x7B	; 123
     b46:	b4 e1       	ldi	r27, 0x14	; 20
     b48:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <__umulhisi3>
     b4c:	96 95       	lsr	r25
     b4e:	87 95       	ror	r24
     b50:	44 e6       	ldi	r20, 0x64	; 100
     b52:	48 9f       	mul	r20, r24
     b54:	90 01       	movw	r18, r0
     b56:	49 9f       	mul	r20, r25
     b58:	30 0d       	add	r19, r0
     b5a:	11 24       	eor	r1, r1
     b5c:	ce 01       	movw	r24, r28
     b5e:	82 1b       	sub	r24, r18
     b60:	93 0b       	sbc	r25, r19
     b62:	9c 01       	movw	r18, r24
     b64:	ad ec       	ldi	r26, 0xCD	; 205
     b66:	bc ec       	ldi	r27, 0xCC	; 204
     b68:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <__umulhisi3>
     b6c:	96 95       	lsr	r25
     b6e:	87 95       	ror	r24
     b70:	96 95       	lsr	r25
     b72:	87 95       	ror	r24
     b74:	96 95       	lsr	r25
     b76:	87 95       	ror	r24
     b78:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     b7c:	80 93 66 01 	sts	0x0166, r24
    //segment_data[2] = 1; //decimal
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
     b80:	9e 01       	movw	r18, r28
     b82:	36 95       	lsr	r19
     b84:	27 95       	ror	r18
     b86:	36 95       	lsr	r19
     b88:	27 95       	ror	r18
     b8a:	36 95       	lsr	r19
     b8c:	27 95       	ror	r18
     b8e:	a5 ec       	ldi	r26, 0xC5	; 197
     b90:	b0 e2       	ldi	r27, 0x20	; 32
     b92:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <__umulhisi3>
     b96:	8c 01       	movw	r16, r24
     b98:	12 95       	swap	r17
     b9a:	02 95       	swap	r16
     b9c:	0f 70       	andi	r16, 0x0F	; 15
     b9e:	01 27       	eor	r16, r17
     ba0:	1f 70       	andi	r17, 0x0F	; 15
     ba2:	01 27       	eor	r16, r17
     ba4:	48 ee       	ldi	r20, 0xE8	; 232
     ba6:	53 e0       	ldi	r21, 0x03	; 3
     ba8:	04 9f       	mul	r16, r20
     baa:	90 01       	movw	r18, r0
     bac:	05 9f       	mul	r16, r21
     bae:	30 0d       	add	r19, r0
     bb0:	14 9f       	mul	r17, r20
     bb2:	30 0d       	add	r19, r0
     bb4:	11 24       	eor	r1, r1
     bb6:	ce 01       	movw	r24, r28
     bb8:	82 1b       	sub	r24, r18
     bba:	93 0b       	sbc	r25, r19
     bbc:	9c 01       	movw	r18, r24
     bbe:	36 95       	lsr	r19
     bc0:	27 95       	ror	r18
     bc2:	36 95       	lsr	r19
     bc4:	27 95       	ror	r18
     bc6:	ab e7       	ldi	r26, 0x7B	; 123
     bc8:	b4 e1       	ldi	r27, 0x14	; 20
     bca:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <__umulhisi3>
     bce:	96 95       	lsr	r25
     bd0:	87 95       	ror	r24
     bd2:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     bd6:	80 93 68 01 	sts	0x0168, r24
    segment_data[4] = int2seg(sum/1000); //thousands
     bda:	80 2f       	mov	r24, r16
     bdc:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     be0:	80 93 69 01 	sts	0x0169, r24
    //blank out leading zero digits 
    //now move data to right place for misplaced colon position
    if(am_pm && show_ampm){
     be4:	80 91 34 01 	lds	r24, 0x0134
     be8:	88 23       	and	r24, r24
     bea:	21 f0       	breq	.+8      	; 0xbf4 <segsum+0xfc>
     bec:	80 91 4d 01 	lds	r24, 0x014D
     bf0:	81 11       	cpse	r24, r1
     bf2:	12 c0       	rjmp	.+36     	; 0xc18 <segsum+0x120>
	segment_data[0] &= 0x7F;
    }
    else{
	segment_data[0] |= 0b10000000;
     bf4:	8f 2d       	mov	r24, r15
     bf6:	80 68       	ori	r24, 0x80	; 128
     bf8:	80 93 65 01 	sts	0x0165, r24
    }
    if(mode == 1 && blink){
     bfc:	80 91 4c 01 	lds	r24, 0x014C
     c00:	81 30       	cpi	r24, 0x01	; 1
     c02:	91 f0       	breq	.+36     	; 0xc28 <segsum+0x130>
	segment_data[4] = 0xFF;
	segment_data[3] = 0xFF;
	segment_data[1] = 0xFF;
	segment_data[0] = 0xFF;
    }
}//segment_sum
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	ff 90       	pop	r15
     c0e:	08 95       	ret

    if(ticker%2 == 1){
	segment_data[2] = 0xFC;
    }
    else{
	segment_data[2] = 0xFF;
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	80 93 67 01 	sts	0x0167, r24
     c16:	7d cf       	rjmp	.-262    	; 0xb12 <segsum+0x1a>
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
    segment_data[4] = int2seg(sum/1000); //thousands
    //blank out leading zero digits 
    //now move data to right place for misplaced colon position
    if(am_pm && show_ampm){
	segment_data[0] &= 0x7F;
     c18:	8f 2d       	mov	r24, r15
     c1a:	8f 77       	andi	r24, 0x7F	; 127
     c1c:	80 93 65 01 	sts	0x0165, r24
    }
    else{
	segment_data[0] |= 0b10000000;
    }
    if(mode == 1 && blink){
     c20:	80 91 4c 01 	lds	r24, 0x014C
     c24:	81 30       	cpi	r24, 0x01	; 1
     c26:	71 f7       	brne	.-36     	; 0xc04 <segsum+0x10c>
     c28:	80 91 2a 01 	lds	r24, 0x012A
     c2c:	88 23       	and	r24, r24
     c2e:	51 f3       	breq	.-44     	; 0xc04 <segsum+0x10c>
	segment_data[4] = 0xFF;
     c30:	8f ef       	ldi	r24, 0xFF	; 255
     c32:	80 93 69 01 	sts	0x0169, r24
	segment_data[3] = 0xFF;
     c36:	80 93 68 01 	sts	0x0168, r24
	segment_data[1] = 0xFF;
     c3a:	80 93 66 01 	sts	0x0166, r24
	segment_data[0] = 0xFF;
     c3e:	80 93 65 01 	sts	0x0165, r24
    }
}//segment_sum
     c42:	df 91       	pop	r29
     c44:	cf 91       	pop	r28
     c46:	1f 91       	pop	r17
     c48:	0f 91       	pop	r16
     c4a:	ff 90       	pop	r15
     c4c:	08 95       	ret

00000c4e <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
     c4e:	1f 92       	push	r1
     c50:	0f 92       	push	r0
     c52:	0f b6       	in	r0, 0x3f	; 63
     c54:	0f 92       	push	r0
     c56:	11 24       	eor	r1, r1
     c58:	0b b6       	in	r0, 0x3b	; 59
     c5a:	0f 92       	push	r0
     c5c:	2f 93       	push	r18
     c5e:	3f 93       	push	r19
     c60:	4f 93       	push	r20
     c62:	5f 93       	push	r21
     c64:	6f 93       	push	r22
     c66:	7f 93       	push	r23
     c68:	8f 93       	push	r24
     c6a:	9f 93       	push	r25
     c6c:	af 93       	push	r26
     c6e:	bf 93       	push	r27
     c70:	ef 93       	push	r30
     c72:	ff 93       	push	r31
    static uint8_t count = 0;
    count++;
     c74:	20 91 43 01 	lds	r18, 0x0143
     c78:	2f 5f       	subi	r18, 0xFF	; 255
     c7a:	20 93 43 01 	sts	0x0143, r18
    //update_time();
    if(count%8 == 0){
     c7e:	82 2f       	mov	r24, r18
     c80:	87 70       	andi	r24, 0x07	; 7
     c82:	81 f4       	brne	.+32     	; 0xca4 <__vector_16+0x56>
	beat++;
     c84:	80 91 5e 01 	lds	r24, 0x015E
     c88:	90 91 5f 01 	lds	r25, 0x015F
     c8c:	01 96       	adiw	r24, 0x01	; 1
     c8e:	90 93 5f 01 	sts	0x015F, r25
     c92:	80 93 5e 01 	sts	0x015E, r24
	blink = !blink;
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	90 91 2a 01 	lds	r25, 0x012A
     c9c:	91 11       	cpse	r25, r1
     c9e:	3b c0       	rjmp	.+118    	; 0xd16 <__vector_16+0xc8>
     ca0:	80 93 2a 01 	sts	0x012A, r24
    }
    if((count%128)==0){
     ca4:	2f 77       	andi	r18, 0x7F	; 127
     ca6:	21 f5       	brne	.+72     	; 0xcf0 <__vector_16+0xa2>
	ticker++;     
     ca8:	80 91 46 01 	lds	r24, 0x0146
     cac:	8f 5f       	subi	r24, 0xFF	; 255
     cae:	80 93 46 01 	sts	0x0146, r24
	second++;    
     cb2:	80 91 4b 01 	lds	r24, 0x014B
     cb6:	8f 5f       	subi	r24, 0xFF	; 255
     cb8:	80 93 4b 01 	sts	0x014B, r24
	if(alarm_on){
     cbc:	80 91 2d 01 	lds	r24, 0x012D
     cc0:	88 23       	and	r24, r24
     cc2:	b1 f0       	breq	.+44     	; 0xcf0 <__vector_16+0xa2>
	    if ((alarm_time == time) && !snooze_flag && !music_status){
     cc4:	20 91 37 01 	lds	r18, 0x0137
     cc8:	30 91 38 01 	lds	r19, 0x0138
     ccc:	80 91 39 01 	lds	r24, 0x0139
     cd0:	90 91 3a 01 	lds	r25, 0x013A
     cd4:	28 17       	cp	r18, r24
     cd6:	39 07       	cpc	r19, r25
     cd8:	39 f1       	breq	.+78     	; 0xd28 <__vector_16+0xda>
		//play music
		music_on();
		music_status = 1;
	    }
	    else if(snooze_flag){
     cda:	80 91 2e 01 	lds	r24, 0x012E
     cde:	88 23       	and	r24, r24
     ce0:	39 f0       	breq	.+14     	; 0xcf0 <__vector_16+0xa2>
		snooze_second++;
     ce2:	80 91 2f 01 	lds	r24, 0x012F
     ce6:	8f 5f       	subi	r24, 0xFF	; 255
     ce8:	80 93 2f 01 	sts	0x012F, r24
		if(snooze_second >= 10){
     cec:	8a 30       	cpi	r24, 0x0A	; 10
     cee:	a8 f4       	brcc	.+42     	; 0xd1a <__vector_16+0xcc>
		    snooze_second = 0;
		}	
	    }
	}
    }
}
     cf0:	ff 91       	pop	r31
     cf2:	ef 91       	pop	r30
     cf4:	bf 91       	pop	r27
     cf6:	af 91       	pop	r26
     cf8:	9f 91       	pop	r25
     cfa:	8f 91       	pop	r24
     cfc:	7f 91       	pop	r23
     cfe:	6f 91       	pop	r22
     d00:	5f 91       	pop	r21
     d02:	4f 91       	pop	r20
     d04:	3f 91       	pop	r19
     d06:	2f 91       	pop	r18
     d08:	0f 90       	pop	r0
     d0a:	0b be       	out	0x3b, r0	; 59
     d0c:	0f 90       	pop	r0
     d0e:	0f be       	out	0x3f, r0	; 63
     d10:	0f 90       	pop	r0
     d12:	1f 90       	pop	r1
     d14:	18 95       	reti
    static uint8_t count = 0;
    count++;
    //update_time();
    if(count%8 == 0){
	beat++;
	blink = !blink;
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	c3 cf       	rjmp	.-122    	; 0xca0 <__vector_16+0x52>
		music_status = 1;
	    }
	    else if(snooze_flag){
		snooze_second++;
		if(snooze_second >= 10){
		    snooze_flag = 0;
     d1a:	10 92 2e 01 	sts	0x012E, r1
		    music_on();
     d1e:	0e 94 04 05 	call	0xa08	; 0xa08 <music_on>
		    snooze_second = 0;
     d22:	10 92 2f 01 	sts	0x012F, r1
     d26:	e4 cf       	rjmp	.-56     	; 0xcf0 <__vector_16+0xa2>
    }
    if((count%128)==0){
	ticker++;     
	second++;    
	if(alarm_on){
	    if ((alarm_time == time) && !snooze_flag && !music_status){
     d28:	80 91 2e 01 	lds	r24, 0x012E
     d2c:	81 11       	cpse	r24, r1
     d2e:	d9 cf       	rjmp	.-78     	; 0xce2 <__vector_16+0x94>
     d30:	80 91 2c 01 	lds	r24, 0x012C
     d34:	81 11       	cpse	r24, r1
     d36:	dc cf       	rjmp	.-72     	; 0xcf0 <__vector_16+0xa2>
		//play music
		music_on();
     d38:	0e 94 04 05 	call	0xa08	; 0xa08 <music_on>
		music_status = 1;
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	80 93 2c 01 	sts	0x012C, r24
     d42:	d6 cf       	rjmp	.-84     	; 0xcf0 <__vector_16+0xa2>

00000d44 <__vector_12>:
	    }
	}
    }
}

ISR(TIMER1_COMPA_vect){
     d44:	1f 92       	push	r1
     d46:	0f 92       	push	r0
     d48:	0f b6       	in	r0, 0x3f	; 63
     d4a:	0f 92       	push	r0
     d4c:	11 24       	eor	r1, r1
     d4e:	0b b6       	in	r0, 0x3b	; 59
     d50:	0f 92       	push	r0
     d52:	2f 93       	push	r18
     d54:	3f 93       	push	r19
     d56:	4f 93       	push	r20
     d58:	5f 93       	push	r21
     d5a:	6f 93       	push	r22
     d5c:	7f 93       	push	r23
     d5e:	8f 93       	push	r24
     d60:	9f 93       	push	r25
     d62:	af 93       	push	r26
     d64:	bf 93       	push	r27
     d66:	ef 93       	push	r30
     d68:	ff 93       	push	r31
    PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
     d6a:	82 b3       	in	r24, 0x12	; 18
     d6c:	80 58       	subi	r24, 0x80	; 128
     d6e:	82 bb       	out	0x12, r24	; 18
    PORTB |= (1<<PB0);
     d70:	c0 9a       	sbi	0x18, 0	; 24
    if(beat >= max_beat) {   //if we've played the note long enough
     d72:	20 91 5e 01 	lds	r18, 0x015E
     d76:	30 91 5f 01 	lds	r19, 0x015F
     d7a:	80 91 5c 01 	lds	r24, 0x015C
     d7e:	90 91 5d 01 	lds	r25, 0x015D
     d82:	28 17       	cp	r18, r24
     d84:	39 07       	cpc	r19, r25
     d86:	60 f0       	brcs	.+24     	; 0xda0 <__vector_12+0x5c>
	notes++;               //move on to the next note
     d88:	80 91 4e 01 	lds	r24, 0x014E
     d8c:	8f 5f       	subi	r24, 0xFF	; 255
     d8e:	80 93 4e 01 	sts	0x014E, r24
	play_song(song, notes);//and play it
     d92:	80 91 4e 01 	lds	r24, 0x014E
     d96:	90 91 5b 01 	lds	r25, 0x015B
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	0e 94 15 04 	call	0x82a	; 0x82a <song0>
    }
}
     da0:	ff 91       	pop	r31
     da2:	ef 91       	pop	r30
     da4:	bf 91       	pop	r27
     da6:	af 91       	pop	r26
     da8:	9f 91       	pop	r25
     daa:	8f 91       	pop	r24
     dac:	7f 91       	pop	r23
     dae:	6f 91       	pop	r22
     db0:	5f 91       	pop	r21
     db2:	4f 91       	pop	r20
     db4:	3f 91       	pop	r19
     db6:	2f 91       	pop	r18
     db8:	0f 90       	pop	r0
     dba:	0b be       	out	0x3b, r0	; 59
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	0f 90       	pop	r0
     dc2:	1f 90       	pop	r1
     dc4:	18 95       	reti

00000dc6 <__vector_21>:
	default:
	    break;
    }    
} 

ISR(ADC_vect){
     dc6:	1f 92       	push	r1
     dc8:	0f 92       	push	r0
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	0f 92       	push	r0
     dce:	11 24       	eor	r1, r1
     dd0:	8f 93       	push	r24
     dd2:	9f 93       	push	r25

    if(ADCH < 100){
     dd4:	85 b1       	in	r24, 0x05	; 5
     dd6:	84 36       	cpi	r24, 0x64	; 100
     dd8:	48 f0       	brcs	.+18     	; 0xdec <__vector_21+0x26>
	OCR2 = 100-ADCH;
    }  
    else{
	OCR2 = 1;// brightness_level;
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	83 bd       	out	0x23, r24	; 35
    }
}
     dde:	9f 91       	pop	r25
     de0:	8f 91       	pop	r24
     de2:	0f 90       	pop	r0
     de4:	0f be       	out	0x3f, r0	; 63
     de6:	0f 90       	pop	r0
     de8:	1f 90       	pop	r1
     dea:	18 95       	reti
} 

ISR(ADC_vect){

    if(ADCH < 100){
	OCR2 = 100-ADCH;
     dec:	95 b1       	in	r25, 0x05	; 5
     dee:	84 e6       	ldi	r24, 0x64	; 100
     df0:	89 1b       	sub	r24, r25
     df2:	83 bd       	out	0x23, r24	; 35
    }  
    else{
	OCR2 = 1;// brightness_level;
    }
}
     df4:	9f 91       	pop	r25
     df6:	8f 91       	pop	r24
     df8:	0f 90       	pop	r0
     dfa:	0f be       	out	0x3f, r0	; 63
     dfc:	0f 90       	pop	r0
     dfe:	1f 90       	pop	r1
     e00:	18 95       	reti

00000e02 <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
   // static int minute_change = 0;
    if (second >= 60){
     e02:	80 91 4b 01 	lds	r24, 0x014B
	minute++;
     e06:	20 91 4a 01 	lds	r18, 0x014A
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
   // static int minute_change = 0;
    if (second >= 60){
     e0a:	8c 33       	cpi	r24, 0x3C	; 60
     e0c:	28 f0       	brcs	.+10     	; 0xe18 <update_time+0x16>
	minute++;
     e0e:	2f 5f       	subi	r18, 0xFF	; 255
     e10:	20 93 4a 01 	sts	0x014A, r18
	second = 0;
     e14:	10 92 4b 01 	sts	0x014B, r1
    }             
    if(minute >=60){
	hour++;
     e18:	e0 91 49 01 	lds	r30, 0x0149
   // static int minute_change = 0;
    if (second >= 60){
	minute++;
	second = 0;
    }             
    if(minute >=60){
     e1c:	2c 33       	cpi	r18, 0x3C	; 60
     e1e:	c0 f5       	brcc	.+112    	; 0xe90 <update_time+0x8e>
     e20:	30 e0       	ldi	r19, 0x00	; 0
	hour++;
	minute = 0;
    }
    if(hour >= 24){
     e22:	e8 31       	cpi	r30, 0x18	; 24
     e24:	f0 f5       	brcc	.+124    	; 0xea2 <update_time+0xa0>
     e26:	6e 2f       	mov	r22, r30
     e28:	70 e0       	ldi	r23, 0x00	; 0
     e2a:	84 e6       	ldi	r24, 0x64	; 100
     e2c:	e8 9f       	mul	r30, r24
     e2e:	a0 01       	movw	r20, r0
     e30:	11 24       	eor	r1, r1
	hour = 0;
    } 

    alarm_time = (alarm_hour * 100) + alarm_minute;
     e32:	f0 91 47 01 	lds	r31, 0x0147
     e36:	80 91 48 01 	lds	r24, 0x0148
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	a4 e6       	ldi	r26, 0x64	; 100
     e3e:	fa 9f       	mul	r31, r26
     e40:	80 0d       	add	r24, r0
     e42:	91 1d       	adc	r25, r1
     e44:	11 24       	eor	r1, r1
     e46:	90 93 38 01 	sts	0x0138, r25
     e4a:	80 93 37 01 	sts	0x0137, r24
    // if(minute_change){
    time = (hour * 100) + minute;
     e4e:	c9 01       	movw	r24, r18
     e50:	84 0f       	add	r24, r20
     e52:	95 1f       	adc	r25, r21
     e54:	90 93 3a 01 	sts	0x013A, r25
     e58:	80 93 39 01 	sts	0x0139, r24
    // minute_change = 0;

    if(show_ampm){
     e5c:	40 91 4d 01 	lds	r20, 0x014D
     e60:	44 23       	and	r20, r20
     e62:	39 f1       	breq	.+78     	; 0xeb2 <update_time+0xb0>
	if(hour>=12){
     e64:	ec 30       	cpi	r30, 0x0C	; 12
     e66:	50 f1       	brcs	.+84     	; 0xebc <update_time+0xba>
	    if(hour == 12){
     e68:	ec 30       	cpi	r30, 0x0C	; 12
     e6a:	d1 f1       	breq	.+116    	; 0xee0 <update_time+0xde>
		show_time = 1200 + minute;
	    }
	    else{
		show_time = (hour-12)*100 + minute;
     e6c:	6c 50       	subi	r22, 0x0C	; 12
     e6e:	71 09       	sbc	r23, r1
     e70:	44 e6       	ldi	r20, 0x64	; 100
     e72:	46 9f       	mul	r20, r22
     e74:	c0 01       	movw	r24, r0
     e76:	47 9f       	mul	r20, r23
     e78:	90 0d       	add	r25, r0
     e7a:	11 24       	eor	r1, r1
     e7c:	82 0f       	add	r24, r18
     e7e:	93 1f       	adc	r25, r19
     e80:	90 93 36 01 	sts	0x0136, r25
     e84:	80 93 35 01 	sts	0x0135, r24
		am_pm = 1;
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	80 93 34 01 	sts	0x0134, r24
     e8e:	08 95       	ret
    if (second >= 60){
	minute++;
	second = 0;
    }             
    if(minute >=60){
	hour++;
     e90:	ef 5f       	subi	r30, 0xFF	; 255
     e92:	e0 93 49 01 	sts	0x0149, r30
	minute = 0;
     e96:	10 92 4a 01 	sts	0x014A, r1
     e9a:	20 e0       	ldi	r18, 0x00	; 0
     e9c:	30 e0       	ldi	r19, 0x00	; 0
    }
    if(hour >= 24){
     e9e:	e8 31       	cpi	r30, 0x18	; 24
     ea0:	10 f2       	brcs	.-124    	; 0xe26 <update_time+0x24>
	hour = 0;
     ea2:	10 92 49 01 	sts	0x0149, r1
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	50 e0       	ldi	r21, 0x00	; 0
     eaa:	60 e0       	ldi	r22, 0x00	; 0
     eac:	70 e0       	ldi	r23, 0x00	; 0
     eae:	e0 e0       	ldi	r30, 0x00	; 0
     eb0:	c0 cf       	rjmp	.-128    	; 0xe32 <update_time+0x30>
	    }
	    am_pm = 0;
	}
    }
    else{
	show_time = (hour * 100) + minute;
     eb2:	90 93 36 01 	sts	0x0136, r25
     eb6:	80 93 35 01 	sts	0x0135, r24
     eba:	08 95       	ret
		show_time = (hour-12)*100 + minute;
		am_pm = 1;
	    }
	}
	else{           
	    if(hour == 0){
     ebc:	ee 23       	and	r30, r30
     ebe:	39 f0       	breq	.+14     	; 0xece <update_time+0xcc>
		show_time = 1200 + minute;
	    }
	    else{
		show_time = (hour)*100 + minute;
     ec0:	90 93 36 01 	sts	0x0136, r25
     ec4:	80 93 35 01 	sts	0x0135, r24
	    }
	    am_pm = 0;
     ec8:	10 92 34 01 	sts	0x0134, r1
     ecc:	08 95       	ret
		am_pm = 1;
	    }
	}
	else{           
	    if(hour == 0){
		show_time = 1200 + minute;
     ece:	20 55       	subi	r18, 0x50	; 80
     ed0:	3b 4f       	sbci	r19, 0xFB	; 251
     ed2:	30 93 36 01 	sts	0x0136, r19
     ed6:	20 93 35 01 	sts	0x0135, r18
	    }
	    else{
		show_time = (hour)*100 + minute;
	    }
	    am_pm = 0;
     eda:	10 92 34 01 	sts	0x0134, r1
     ede:	08 95       	ret
    // minute_change = 0;

    if(show_ampm){
	if(hour>=12){
	    if(hour == 12){
		show_time = 1200 + minute;
     ee0:	20 55       	subi	r18, 0x50	; 80
     ee2:	3b 4f       	sbci	r19, 0xFB	; 251
     ee4:	30 93 36 01 	sts	0x0136, r19
     ee8:	20 93 35 01 	sts	0x0135, r18
     eec:	08 95       	ret

00000eee <SPI_init>:
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR);
     eee:	80 e5       	ldi	r24, 0x50	; 80
     ef0:	8d b9       	out	0x0d, r24	; 13
     ef2:	08 95       	ret

00000ef4 <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
     ef4:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
     ef6:	77 9b       	sbis	0x0e, 7	; 14
     ef8:	fe cf       	rjmp	.-4      	; 0xef6 <SPI_Transmit+0x2>
}
     efa:	08 95       	ret

00000efc <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
    PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
     efc:	83 b1       	in	r24, 0x03	; 3
     efe:	13 b8       	out	0x03, r1	; 3
    __asm__ __volatile__ ("nop");
     f00:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f02:	00 00       	nop
    // Wait until 8 clock cycles are done 
    SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
     f04:	1f b8       	out	0x0f, r1	; 15
    PORTE |= (1 << PE6);  
     f06:	1e 9a       	sbi	0x03, 6	; 3
    __asm__ __volatile__ ("nop");
     f08:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f0a:	00 00       	nop
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
     f0c:	77 9b       	sbis	0x0e, 7	; 14
     f0e:	fe cf       	rjmp	.-4      	; 0xf0c <SPI_Receive+0x10>
    // Return incoming data from SPDR
    return(SPDR);  
     f10:	8f b1       	in	r24, 0x0f	; 15
}
     f12:	08 95       	ret

00000f14 <bar_graph>:
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    if(mode == 0){
     f14:	80 91 4c 01 	lds	r24, 0x014C
     f18:	88 23       	and	r24, r24
     f1a:	b9 f0       	breq	.+46     	; 0xf4a <bar_graph+0x36>
	write = 0x00;
    }
    else{
	write = 1<<(mode-1);
     f1c:	9f ef       	ldi	r25, 0xFF	; 255
     f1e:	98 0f       	add	r25, r24
     f20:	81 e0       	ldi	r24, 0x01	; 1
     f22:	01 c0       	rjmp	.+2      	; 0xf26 <bar_graph+0x12>
     f24:	88 0f       	add	r24, r24
     f26:	9a 95       	dec	r25
     f28:	ea f7       	brpl	.-6      	; 0xf24 <bar_graph+0x10>
    }

    if(alarm_on != 0){
     f2a:	90 91 2d 01 	lds	r25, 0x012D
     f2e:	91 11       	cpse	r25, r1
	write = 0xF0;
     f30:	80 ef       	ldi	r24, 0xF0	; 240

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
     f32:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
     f34:	77 9b       	sbis	0x0e, 7	; 14
     f36:	fe cf       	rjmp	.-4      	; 0xf34 <bar_graph+0x20>
	write = 0xF0;
    }
    //write &= 0xF7;
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
     f38:	84 e0       	ldi	r24, 0x04	; 4
     f3a:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop"); //Buffer
     f3c:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
     f3e:	00 00       	nop


    PORTD = (2 << PD2);  // Push data out of SPI
     f40:	88 e0       	ldi	r24, 0x08	; 8
     f42:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop");  //Buffer
     f44:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
     f46:	00 00       	nop
     f48:	08 95       	ret
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    if(mode == 0){
	write = 0x00;
     f4a:	80 e0       	ldi	r24, 0x00	; 0
     f4c:	ee cf       	rjmp	.-36     	; 0xf2a <bar_graph+0x16>

00000f4e <button_routine>:
	segment_data[1] = 0xFF;
	segment_data[0] = 0xFF;
    }
}//segment_sum
//***********************************************************************************
void button_routine(){
     f4e:	ff 92       	push	r15
     f50:	0f 93       	push	r16
     f52:	1f 93       	push	r17
     f54:	cf 93       	push	r28
     f56:	df 93       	push	r29
    // L -> R
    // 3 2 1 0 7 6 5 4
    uint8_t button = 0;
    static int previous_mode;   
    DDRA  = 0x00; // PORTA input mode
     f58:	1a ba       	out	0x1a, r1	; 26
    PORTA = 0xFF; //Pull ups
     f5a:	8f ef       	ldi	r24, 0xFF	; 255
     f5c:	8b bb       	out	0x1b, r24	; 27
    __asm__ __volatile__ ("nop");
     f5e:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f60:	00 00       	nop
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
     f62:	88 b3       	in	r24, 0x18	; 24
     f64:	80 67       	ori	r24, 0x70	; 112
     f66:	88 bb       	out	0x18, r24	; 24
    __asm__ __volatile__ ("nop");
     f68:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f6a:	00 00       	nop
     f6c:	c0 e0       	ldi	r28, 0x00	; 0
     f6e:	d0 e0       	ldi	r29, 0x00	; 0
		case 7:
		    if(alarm_on && music_status){
			music_off();
			music_status = 0;
		    }
		    alarm_on = !alarm_on;
     f70:	11 e0       	ldi	r17, 0x01	; 1
		case 3:
		    if(mode == 3){
			mode = 0;			
		    }
		    else{
			mode = 3;
     f72:	03 e0       	ldi	r16, 0x03	; 3
     f74:	f0 2e       	mov	r15, r16
		case 2:
		    if(mode == 2){
			mode = 0;	
		    }
		    else{
			mode = 2;
     f76:	02 e0       	ldi	r16, 0x02	; 2
     f78:	0f c0       	rjmp	.+30     	; 0xf98 <button_routine+0x4a>
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     f7a:	41 e0       	ldi	r20, 0x01	; 1
     f7c:	50 ee       	ldi	r21, 0xE0	; 224
     f7e:	24 2b       	or	r18, r20
     f80:	35 2b       	or	r19, r21
     f82:	30 93 45 01 	sts	0x0145, r19
     f86:	20 93 44 01 	sts	0x0144, r18
    if (state == 0xF000){
     f8a:	21 15       	cp	r18, r1
     f8c:	30 4f       	sbci	r19, 0xF0	; 240
     f8e:	c1 f0       	breq	.+48     	; 0xfc0 <button_routine+0x72>
     f90:	21 96       	adiw	r28, 0x01	; 1
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed

    for (button = 0 ; button < BUTTON_COUNT ; button++){
     f92:	c8 30       	cpi	r28, 0x08	; 8
     f94:	d1 05       	cpc	r29, r1
     f96:	79 f1       	breq	.+94     	; 0xff6 <button_routine+0xa8>
     f98:	8c 2f       	mov	r24, r28
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     f9a:	20 91 44 01 	lds	r18, 0x0144
     f9e:	30 91 45 01 	lds	r19, 0x0145
     fa2:	22 0f       	add	r18, r18
     fa4:	33 1f       	adc	r19, r19
     fa6:	49 b3       	in	r20, 0x19	; 25
     fa8:	50 e0       	ldi	r21, 0x00	; 0
     faa:	0c 2e       	mov	r0, r28
     fac:	02 c0       	rjmp	.+4      	; 0xfb2 <button_routine+0x64>
     fae:	55 95       	asr	r21
     fb0:	47 95       	ror	r20
     fb2:	0a 94       	dec	r0
     fb4:	e2 f7       	brpl	.-8      	; 0xfae <button_routine+0x60>
     fb6:	40 ff       	sbrs	r20, 0
     fb8:	e0 cf       	rjmp	.-64     	; 0xf7a <button_routine+0x2c>
     fba:	40 e0       	ldi	r20, 0x00	; 0
     fbc:	50 ee       	ldi	r21, 0xE0	; 224
     fbe:	df cf       	rjmp	.-66     	; 0xf7e <button_routine+0x30>
    //now check each button and increment the count as needed

    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    switch(button){
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	88 30       	cpi	r24, 0x08	; 8
     fc4:	91 05       	cpc	r25, r1
     fc6:	88 f4       	brcc	.+34     	; 0xfea <button_routine+0x9c>
     fc8:	fc 01       	movw	r30, r24
     fca:	ec 52       	subi	r30, 0x2C	; 44
     fcc:	ff 4f       	sbci	r31, 0xFF	; 255
     fce:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__tablejump2__>
			music_status = 0;
			music_off();
		    }
		    break;
		case 7:
		    if(alarm_on && music_status){
     fd2:	80 91 2d 01 	lds	r24, 0x012D
     fd6:	81 11       	cpse	r24, r1
     fd8:	57 c0       	rjmp	.+174    	; 0x1088 <button_routine+0x13a>
     fda:	90 e0       	ldi	r25, 0x00	; 0
			music_off();
			music_status = 0;
		    }
		    alarm_on = !alarm_on;
     fdc:	81 e0       	ldi	r24, 0x01	; 1
     fde:	91 11       	cpse	r25, r1
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	80 93 2d 01 	sts	0x012D, r24
		    update_LCD = 1;
     fe6:	10 93 3b 01 	sts	0x013B, r17
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
     fea:	0e 94 8a 07 	call	0xf14	; 0xf14 <bar_graph>
     fee:	21 96       	adiw	r28, 0x01	; 1
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed

    for (button = 0 ; button < BUTTON_COUNT ; button++){
     ff0:	c8 30       	cpi	r28, 0x08	; 8
     ff2:	d1 05       	cpc	r29, r1
     ff4:	89 f6       	brne	.-94     	; 0xf98 <button_routine+0x4a>
	       bar_graph();
	       previous_mode = button;
	     */
	}
    }
    DDRA = 0xFF;  //switch PORTA to output
     ff6:	8f ef       	ldi	r24, 0xFF	; 255
     ff8:	8a bb       	out	0x1a, r24	; 26
    __asm__ __volatile__ ("nop"); //Buffer
     ffa:	00 00       	nop
    __asm__ __volatile__ ("nop"); //Buffer 
     ffc:	00 00       	nop

}
     ffe:	df 91       	pop	r29
    1000:	cf 91       	pop	r28
    1002:	1f 91       	pop	r17
    1004:	0f 91       	pop	r16
    1006:	ff 90       	pop	r15
    1008:	08 95       	ret
	    switch(button){
		case 0:  
		    mode = 0;
		    break;
		case 1:
		    if(mode == 1){
    100a:	80 91 4c 01 	lds	r24, 0x014C
    100e:	81 30       	cpi	r24, 0x01	; 1
    1010:	91 f5       	brne	.+100    	; 0x1076 <button_routine+0x128>
			mode = 0;	
    1012:	10 92 4c 01 	sts	0x014C, r1
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    1016:	0e 94 8a 07 	call	0xf14	; 0xf14 <bar_graph>
    101a:	e9 cf       	rjmp	.-46     	; 0xfee <button_routine+0xa0>
		    else{
			mode = 1;
		    }
		    break;
		case 2:
		    if(mode == 2){
    101c:	80 91 4c 01 	lds	r24, 0x014C
    1020:	82 30       	cpi	r24, 0x02	; 2
    1022:	b9 f3       	breq	.-18     	; 0x1012 <button_routine+0xc4>
			mode = 0;	
		    }
		    else{
			mode = 2;
    1024:	00 93 4c 01 	sts	0x014C, r16
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    1028:	0e 94 8a 07 	call	0xf14	; 0xf14 <bar_graph>
    102c:	e0 cf       	rjmp	.-64     	; 0xfee <button_routine+0xa0>
		    break;
		case 5:
		    show_ampm = !show_ampm;
		    break;
		case 6:
		    if(music_status){
    102e:	80 91 2c 01 	lds	r24, 0x012C
    1032:	88 23       	and	r24, r24
    1034:	d1 f2       	breq	.-76     	; 0xfea <button_routine+0x9c>
			snooze_flag = 1;
    1036:	10 93 2e 01 	sts	0x012E, r17
			music_status = 0;
    103a:	10 92 2c 01 	sts	0x012C, r1
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
    103e:	10 92 4e 01 	sts	0x014E, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
    1042:	8e b5       	in	r24, 0x2e	; 46
    1044:	8c 7f       	andi	r24, 0xFC	; 252
    1046:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
    1048:	92 9a       	sbi	0x12, 2	; 18
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    104a:	0e 94 8a 07 	call	0xf14	; 0xf14 <bar_graph>
    104e:	cf cf       	rjmp	.-98     	; 0xfee <button_routine+0xa0>
		    }
		    break;
		case 4:
		    break;
		case 5:
		    show_ampm = !show_ampm;
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	90 91 4d 01 	lds	r25, 0x014D
    1056:	91 11       	cpse	r25, r1
    1058:	13 c0       	rjmp	.+38     	; 0x1080 <button_routine+0x132>
    105a:	80 93 4d 01 	sts	0x014D, r24
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    105e:	0e 94 8a 07 	call	0xf14	; 0xf14 <bar_graph>
    1062:	c5 cf       	rjmp	.-118    	; 0xfee <button_routine+0xa0>
		    else{
			mode = 2;
		    }
		    break;
		case 3:
		    if(mode == 3){
    1064:	80 91 4c 01 	lds	r24, 0x014C
    1068:	83 30       	cpi	r24, 0x03	; 3
    106a:	99 f2       	breq	.-90     	; 0x1012 <button_routine+0xc4>
			mode = 0;			
		    }
		    else{
			mode = 3;
    106c:	f0 92 4c 01 	sts	0x014C, r15
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    1070:	0e 94 8a 07 	call	0xf14	; 0xf14 <bar_graph>
    1074:	bc cf       	rjmp	.-136    	; 0xfee <button_routine+0xa0>
		case 1:
		    if(mode == 1){
			mode = 0;	
		    }
		    else{
			mode = 1;
    1076:	10 93 4c 01 	sts	0x014C, r17
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    107a:	0e 94 8a 07 	call	0xf14	; 0xf14 <bar_graph>
    107e:	b7 cf       	rjmp	.-146    	; 0xfee <button_routine+0xa0>
		    }
		    break;
		case 4:
		    break;
		case 5:
		    show_ampm = !show_ampm;
    1080:	80 e0       	ldi	r24, 0x00	; 0
    1082:	80 93 4d 01 	sts	0x014D, r24
    1086:	eb cf       	rjmp	.-42     	; 0x105e <button_routine+0x110>
			music_status = 0;
			music_off();
		    }
		    break;
		case 7:
		    if(alarm_on && music_status){
    1088:	90 91 2c 01 	lds	r25, 0x012C
    108c:	99 23       	and	r25, r25
    108e:	59 f0       	breq	.+22     	; 0x10a6 <button_routine+0x158>
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
    1090:	10 92 4e 01 	sts	0x014E, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
    1094:	8e b5       	in	r24, 0x2e	; 46
    1096:	8c 7f       	andi	r24, 0xFC	; 252
    1098:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
    109a:	92 9a       	sbi	0x12, 2	; 18
			music_off();
			music_status = 0;
    109c:	10 92 2c 01 	sts	0x012C, r1
    10a0:	90 91 2d 01 	lds	r25, 0x012D
    10a4:	9b cf       	rjmp	.-202    	; 0xfdc <button_routine+0x8e>
    10a6:	98 2f       	mov	r25, r24
    10a8:	99 cf       	rjmp	.-206    	; 0xfdc <button_routine+0x8e>

000010aa <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    uint8_t display_segment = 0;
    //static uint8_t rotate_7seg = 0;
    switch(mode){
    10aa:	80 91 4c 01 	lds	r24, 0x014C
    10ae:	83 30       	cpi	r24, 0x03	; 3
    10b0:	31 f1       	breq	.+76     	; 0x10fe <display_update+0x54>
    10b2:	84 30       	cpi	r24, 0x04	; 4
    10b4:	41 f0       	breq	.+16     	; 0x10c6 <display_update+0x1c>
    10b6:	82 30       	cpi	r24, 0x02	; 2
    10b8:	c9 f0       	breq	.+50     	; 0x10ec <display_update+0x42>
	    segment_data[2] = 0xFF; //decimal
	    break;
	case 4:
	    break;
	default:
	    segsum(show_time);
    10ba:	80 91 35 01 	lds	r24, 0x0135
    10be:	90 91 36 01 	lds	r25, 0x0136
    10c2:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <segsum>
    10c6:	e5 e6       	ldi	r30, 0x65	; 101
    10c8:	f1 e0       	ldi	r31, 0x01	; 1
    __asm__ __volatile__ ("nop");  //Buffer
}
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    10ca:	80 e0       	ldi	r24, 0x00	; 0

    for(display_segment = 0 ; display_segment < 5 ; display_segment++){
	PORTB = display_segment << 4;
	PORTA = segment_data[display_segment];
	_delay_us(40);
	PORTA = OFF;
    10cc:	2f ef       	ldi	r18, 0xFF	; 255
	    segsum(show_time);
	    break;
    }

    for(display_segment = 0 ; display_segment < 5 ; display_segment++){
	PORTB = display_segment << 4;
    10ce:	98 2f       	mov	r25, r24
    10d0:	92 95       	swap	r25
    10d2:	90 7f       	andi	r25, 0xF0	; 240
    10d4:	98 bb       	out	0x18, r25	; 24
	PORTA = segment_data[display_segment];
    10d6:	91 91       	ld	r25, Z+
    10d8:	9b bb       	out	0x1b, r25	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10da:	95 ed       	ldi	r25, 0xD5	; 213
    10dc:	9a 95       	dec	r25
    10de:	f1 f7       	brne	.-4      	; 0x10dc <display_update+0x32>
    10e0:	00 00       	nop
	_delay_us(40);
	PORTA = OFF;
    10e2:	2b bb       	out	0x1b, r18	; 27
	default:
	    segsum(show_time);
	    break;
    }

    for(display_segment = 0 ; display_segment < 5 ; display_segment++){
    10e4:	8f 5f       	subi	r24, 0xFF	; 255
    10e6:	85 30       	cpi	r24, 0x05	; 5
    10e8:	91 f7       	brne	.-28     	; 0x10ce <display_update+0x24>
       PORTB |= rotate_7seg << 4;
       PORTA = segment_data[rotate_7seg];	
       rotate_7seg++;
     */
    //_delay_us(40);
}
    10ea:	08 95       	ret
void display_update(){
    uint8_t display_segment = 0;
    //static uint8_t rotate_7seg = 0;
    switch(mode){
	case 2:
	    segsum(alarm_time);
    10ec:	80 91 37 01 	lds	r24, 0x0137
    10f0:	90 91 38 01 	lds	r25, 0x0138
    10f4:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <segsum>
	    segment_data[2] = 0x00;
    10f8:	10 92 67 01 	sts	0x0167, r1
	    break;
    10fc:	e4 cf       	rjmp	.-56     	; 0x10c6 <display_update+0x1c>
	case 3:
	    segsum(volume);
    10fe:	80 91 2b 01 	lds	r24, 0x012B
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <segsum>
	    segment_data[2] = 0xFF; //decimal
    1108:	8f ef       	ldi	r24, 0xFF	; 255
    110a:	80 93 67 01 	sts	0x0167, r24
	    break;
    110e:	db cf       	rjmp	.-74     	; 0x10c6 <display_update+0x1c>

00001110 <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
    switch(mode){
    1110:	80 91 4c 01 	lds	r24, 0x014C
    1114:	81 30       	cpi	r24, 0x01	; 1
    1116:	59 f0       	breq	.+22     	; 0x112e <right_inc+0x1e>
    1118:	82 30       	cpi	r24, 0x02	; 2
    111a:	41 f4       	brne	.+16     	; 0x112c <right_inc+0x1c>
		minute = 0;	    
	    }
	    second++;
	    break;
	case 2: 
	    alarm_minute++;
    111c:	80 91 48 01 	lds	r24, 0x0148
    1120:	8f 5f       	subi	r24, 0xFF	; 255
	    if(alarm_minute >= 60){
    1122:	8c 33       	cpi	r24, 0x3C	; 60
    1124:	88 f0       	brcs	.+34     	; 0x1148 <right_inc+0x38>
		alarm_minute = 0;	
    1126:	10 92 48 01 	sts	0x0148, r1
    112a:	08 95       	ret
    112c:	08 95       	ret
void right_inc(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute++;
    112e:	80 91 4a 01 	lds	r24, 0x014A
    1132:	8f 5f       	subi	r24, 0xFF	; 255
	    if(minute >= 60){
    1134:	8c 33       	cpi	r24, 0x3C	; 60
    1136:	58 f0       	brcs	.+22     	; 0x114e <right_inc+0x3e>
		minute = 0;	    
    1138:	10 92 4a 01 	sts	0x014A, r1
	    }
	    second++;
    113c:	80 91 4b 01 	lds	r24, 0x014B
    1140:	8f 5f       	subi	r24, 0xFF	; 255
    1142:	80 93 4b 01 	sts	0x014B, r24
	    break;
    1146:	08 95       	ret
	case 2: 
	    alarm_minute++;
    1148:	80 93 48 01 	sts	0x0148, r24
    114c:	08 95       	ret
void right_inc(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute++;
    114e:	80 93 4a 01 	sts	0x014A, r24
	    if(minute >= 60){
		minute = 0;	    
	    }
	    second++;
    1152:	80 91 4b 01 	lds	r24, 0x014B
    1156:	8f 5f       	subi	r24, 0xFF	; 255
    1158:	80 93 4b 01 	sts	0x014B, r24
	    break;
    115c:	08 95       	ret

0000115e <right_dec>:
	default:
	    break;             
    }
}
void right_dec(){
    switch(mode){
    115e:	80 91 4c 01 	lds	r24, 0x014C
    1162:	81 30       	cpi	r24, 0x01	; 1
    1164:	71 f0       	breq	.+28     	; 0x1182 <right_dec+0x24>
    1166:	82 30       	cpi	r24, 0x02	; 2
    1168:	59 f4       	brne	.+22     	; 0x1180 <right_dec+0x22>
	    if(minute >= 240){
		minute = 59;	    
	    }   
	    break;
	case 2: 
	    alarm_minute--;
    116a:	80 91 48 01 	lds	r24, 0x0148
    116e:	81 50       	subi	r24, 0x01	; 1
    1170:	80 93 48 01 	sts	0x0148, r24
	    if(alarm_minute >= 240){
    1174:	80 3f       	cpi	r24, 0xF0	; 240
    1176:	18 f0       	brcs	.+6      	; 0x117e <right_dec+0x20>
		alarm_minute = 59;	
    1178:	8b e3       	ldi	r24, 0x3B	; 59
    117a:	80 93 48 01 	sts	0x0148, r24
    117e:	08 95       	ret
    1180:	08 95       	ret
void right_dec(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute--;
    1182:	80 91 4a 01 	lds	r24, 0x014A
    1186:	81 50       	subi	r24, 0x01	; 1
    1188:	80 93 4a 01 	sts	0x014A, r24
	    if(minute >= 240){
    118c:	80 3f       	cpi	r24, 0xF0	; 240
    118e:	b8 f3       	brcs	.-18     	; 0x117e <right_dec+0x20>
		minute = 59;	    
    1190:	8b e3       	ldi	r24, 0x3B	; 59
    1192:	80 93 4a 01 	sts	0x014A, r24
    1196:	08 95       	ret

00001198 <decode_spi_right_knob>:
    previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
    1198:	cf 93       	push	r28
    119a:	df 93       	push	r29
    119c:	1f 92       	push	r1
    119e:	cd b7       	in	r28, 0x3d	; 61
    11a0:	de b7       	in	r29, 0x3e	; 62
    uint8_t sw_index = 0;
    static uint8_t acount2 = 0;
    static uint8_t previous_encoder2 = 0;
    uint8_t direction = 0;
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    11a2:	83 70       	andi	r24, 0x03	; 3
    sw_index = (previous_encoder2 << 2) | encoder2;
    11a4:	e0 91 3d 01 	lds	r30, 0x013D
    11a8:	ee 0f       	add	r30, r30
    11aa:	ee 0f       	add	r30, r30
    11ac:	e8 2b       	or	r30, r24
    direction = sw_table[sw_index];
    11ae:	f0 e0       	ldi	r31, 0x00	; 0
    11b0:	ee 5f       	subi	r30, 0xFE	; 254
    11b2:	fe 4f       	sbci	r31, 0xFE	; 254
    11b4:	90 81       	ld	r25, Z
    //value = modeA;
    if(direction == CW){
    11b6:	91 30       	cpi	r25, 0x01	; 1
    11b8:	09 f1       	breq	.+66     	; 0x11fc <decode_spi_right_knob+0x64>
	acount2++;
    }	
    if(direction == CCW){
    11ba:	92 30       	cpi	r25, 0x02	; 2
    11bc:	41 f0       	breq	.+16     	; 0x11ce <decode_spi_right_knob+0x36>
	acount2--;
    }
    if(encoder2 == 3){
    11be:	83 30       	cpi	r24, 0x03	; 3
    11c0:	69 f0       	breq	.+26     	; 0x11dc <decode_spi_right_knob+0x44>
	    right_dec();
	}
	//update_number();
	acount2 = 0;
    }
    previous_encoder2 = encoder2;
    11c2:	80 93 3d 01 	sts	0x013D, r24
}
    11c6:	0f 90       	pop	r0
    11c8:	df 91       	pop	r29
    11ca:	cf 91       	pop	r28
    11cc:	08 95       	ret
    //value = modeA;
    if(direction == CW){
	acount2++;
    }	
    if(direction == CCW){
	acount2--;
    11ce:	90 91 3c 01 	lds	r25, 0x013C
    11d2:	91 50       	subi	r25, 0x01	; 1
    11d4:	90 93 3c 01 	sts	0x013C, r25
    }
    if(encoder2 == 3){
    11d8:	83 30       	cpi	r24, 0x03	; 3
    11da:	99 f7       	brne	.-26     	; 0x11c2 <decode_spi_right_knob+0x2a>
	if((acount2 > 1) && (acount2 < 10)){
    11dc:	90 91 3c 01 	lds	r25, 0x013C
    11e0:	2e ef       	ldi	r18, 0xFE	; 254
    11e2:	29 0f       	add	r18, r25
    11e4:	28 30       	cpi	r18, 0x08	; 8
    11e6:	b8 f0       	brcs	.+46     	; 0x1216 <decode_spi_right_knob+0x7e>
	    right_inc();
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
    11e8:	91 3f       	cpi	r25, 0xF1	; 241
    11ea:	70 f4       	brcc	.+28     	; 0x1208 <decode_spi_right_knob+0x70>
	    right_dec();
	}
	//update_number();
	acount2 = 0;
    11ec:	10 92 3c 01 	sts	0x013C, r1
    }
    previous_encoder2 = encoder2;
    11f0:	80 93 3d 01 	sts	0x013D, r24
}
    11f4:	0f 90       	pop	r0
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	08 95       	ret
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    sw_index = (previous_encoder2 << 2) | encoder2;
    direction = sw_table[sw_index];
    //value = modeA;
    if(direction == CW){
	acount2++;
    11fc:	90 91 3c 01 	lds	r25, 0x013C
    1200:	9f 5f       	subi	r25, 0xFF	; 255
    1202:	90 93 3c 01 	sts	0x013C, r25
    1206:	db cf       	rjmp	.-74     	; 0x11be <decode_spi_right_knob+0x26>
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    right_inc();
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
	    right_dec();
    1208:	89 83       	std	Y+1, r24	; 0x01
    120a:	0e 94 af 08 	call	0x115e	; 0x115e <right_dec>
    120e:	89 81       	ldd	r24, Y+1	; 0x01
	}
	//update_number();
	acount2 = 0;
    1210:	10 92 3c 01 	sts	0x013C, r1
    1214:	ed cf       	rjmp	.-38     	; 0x11f0 <decode_spi_right_knob+0x58>
    if(direction == CCW){
	acount2--;
    }
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    right_inc();
    1216:	89 83       	std	Y+1, r24	; 0x01
    1218:	0e 94 88 08 	call	0x1110	; 0x1110 <right_inc>
    121c:	89 81       	ldd	r24, Y+1	; 0x01
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
	    right_dec();
	}
	//update_number();
	acount2 = 0;
    121e:	10 92 3c 01 	sts	0x013C, r1
    1222:	e6 cf       	rjmp	.-52     	; 0x11f0 <decode_spi_right_knob+0x58>

00001224 <left_inc>:
	    break;
    }

}
void left_inc(){
    switch(mode){
    1224:	80 91 4c 01 	lds	r24, 0x014C
    1228:	82 30       	cpi	r24, 0x02	; 2
    122a:	d1 f0       	breq	.+52     	; 0x1260 <left_inc+0x3c>
    122c:	83 30       	cpi	r24, 0x03	; 3
    122e:	69 f0       	breq	.+26     	; 0x124a <left_inc+0x26>
    1230:	81 30       	cpi	r24, 0x01	; 1
    1232:	09 f0       	breq	.+2      	; 0x1236 <left_inc+0x12>
    1234:	08 95       	ret
	case 0: 
	    break;
	case 1:
	    hour++;
    1236:	80 91 49 01 	lds	r24, 0x0149
    123a:	8f 5f       	subi	r24, 0xFF	; 255
    123c:	80 93 49 01 	sts	0x0149, r24
	    if(hour >= 24){
    1240:	88 31       	cpi	r24, 0x18	; 24
    1242:	c0 f3       	brcs	.-16     	; 0x1234 <left_inc+0x10>
		hour = 0;	    
    1244:	10 92 49 01 	sts	0x0149, r1
    1248:	08 95       	ret
	    if(alarm_hour >= 24){
		alarm_hour = 0;
	    }
	    break;
	case 3:
	    volume++;
    124a:	80 91 2b 01 	lds	r24, 0x012B
    124e:	8f 5f       	subi	r24, 0xFF	; 255
    1250:	80 93 2b 01 	sts	0x012B, r24
	    OCR3A = volume;
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	90 93 87 00 	sts	0x0087, r25
    125a:	80 93 86 00 	sts	0x0086, r24
    125e:	08 95       	ret
	    if(hour >= 24){
		hour = 0;	    
	    }   
	    break;
	case 2: 
	    alarm_hour++;
    1260:	80 91 47 01 	lds	r24, 0x0147
    1264:	8f 5f       	subi	r24, 0xFF	; 255
    1266:	80 93 47 01 	sts	0x0147, r24
	    if(alarm_hour >= 24){
    126a:	88 31       	cpi	r24, 0x18	; 24
    126c:	18 f3       	brcs	.-58     	; 0x1234 <left_inc+0x10>
		alarm_hour = 0;
    126e:	10 92 47 01 	sts	0x0147, r1
    1272:	08 95       	ret

00001274 <left_dec>:
	default:
	    break;
    }
}
void left_dec(){
    switch(mode){
    1274:	80 91 4c 01 	lds	r24, 0x014C
    1278:	82 30       	cpi	r24, 0x02	; 2
    127a:	d9 f0       	breq	.+54     	; 0x12b2 <left_dec+0x3e>
    127c:	83 30       	cpi	r24, 0x03	; 3
    127e:	71 f0       	breq	.+28     	; 0x129c <left_dec+0x28>
    1280:	81 30       	cpi	r24, 0x01	; 1
    1282:	09 f0       	breq	.+2      	; 0x1286 <left_dec+0x12>
    1284:	08 95       	ret
	case 0: 
	    break;
	case 1:
	    hour--;    
    1286:	80 91 49 01 	lds	r24, 0x0149
    128a:	81 50       	subi	r24, 0x01	; 1
    128c:	80 93 49 01 	sts	0x0149, r24
	    if(hour >= 240){
    1290:	80 3f       	cpi	r24, 0xF0	; 240
    1292:	c0 f3       	brcs	.-16     	; 0x1284 <left_dec+0x10>
		hour = 23;	    
    1294:	87 e1       	ldi	r24, 0x17	; 23
    1296:	80 93 49 01 	sts	0x0149, r24
    129a:	08 95       	ret
	    if(alarm_hour >= 240){
		alarm_hour = 23;
	    }
	    break;
	case 3:
	    volume--;
    129c:	80 91 2b 01 	lds	r24, 0x012B
    12a0:	81 50       	subi	r24, 0x01	; 1
    12a2:	80 93 2b 01 	sts	0x012B, r24
	    OCR3A = volume;
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	90 93 87 00 	sts	0x0087, r25
    12ac:	80 93 86 00 	sts	0x0086, r24
    12b0:	08 95       	ret
	    if(hour >= 240){
		hour = 23;	    
	    }   
	    break;
	case 2:
	    alarm_hour--;
    12b2:	80 91 47 01 	lds	r24, 0x0147
    12b6:	81 50       	subi	r24, 0x01	; 1
    12b8:	80 93 47 01 	sts	0x0147, r24
	    if(alarm_hour >= 240){
    12bc:	80 3f       	cpi	r24, 0xF0	; 240
    12be:	10 f3       	brcs	.-60     	; 0x1284 <left_dec+0x10>
		alarm_hour = 23;
    12c0:	87 e1       	ldi	r24, 0x17	; 23
    12c2:	80 93 47 01 	sts	0x0147, r24
    12c6:	08 95       	ret

000012c8 <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
    12c8:	cf 93       	push	r28
    12ca:	df 93       	push	r29
    uint8_t sw_index = 0;
    //Counter for preventing unneccessary reset    
    static uint8_t acount1 = 0;
    static uint8_t previous_encoder1 = 0; //Initialize previous    
    uint8_t direction = 0;                    //Direction variable
    encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
    12cc:	8c 70       	andi	r24, 0x0C	; 12
    12ce:	c8 2f       	mov	r28, r24
    12d0:	d0 e0       	ldi	r29, 0x00	; 0
    12d2:	d5 95       	asr	r29
    12d4:	c7 95       	ror	r28
    12d6:	d5 95       	asr	r29
    12d8:	c7 95       	ror	r28
    12da:	9c 2f       	mov	r25, r28
    sw_index = (previous_encoder1 << 2) | encoder1; 
    12dc:	e0 91 3f 01 	lds	r30, 0x013F
    12e0:	ee 0f       	add	r30, r30
    12e2:	ee 0f       	add	r30, r30
    12e4:	ec 2b       	or	r30, r28
    /*shift previous to the left use it as an index Since
      we know the pattern of the knob when it is turning
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
    12e6:	f0 e0       	ldi	r31, 0x00	; 0
    12e8:	ee 5f       	subi	r30, 0xFE	; 254
    12ea:	fe 4f       	sbci	r31, 0xFE	; 254
    12ec:	80 81       	ld	r24, Z
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
    12ee:	81 30       	cpi	r24, 0x01	; 1
    12f0:	f9 f0       	breq	.+62     	; 0x1330 <decode_spi_left_knob+0x68>
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
    12f2:	82 30       	cpi	r24, 0x02	; 2
    12f4:	39 f0       	breq	.+14     	; 0x1304 <decode_spi_left_knob+0x3c>
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    12f6:	93 30       	cpi	r25, 0x03	; 3
    12f8:	61 f0       	breq	.+24     	; 0x1312 <decode_spi_left_knob+0x4a>
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
    }
    previous_encoder1 = encoder1;
    12fa:	c0 93 3f 01 	sts	0x013F, r28
}
    12fe:	df 91       	pop	r29
    1300:	cf 91       	pop	r28
    1302:	08 95       	ret
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    1304:	80 91 3e 01 	lds	r24, 0x013E
    1308:	81 50       	subi	r24, 0x01	; 1
    130a:	80 93 3e 01 	sts	0x013E, r24
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    130e:	93 30       	cpi	r25, 0x03	; 3
    1310:	a1 f7       	brne	.-24     	; 0x12fa <decode_spi_left_knob+0x32>
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
    1312:	80 91 3e 01 	lds	r24, 0x013E
    1316:	9e ef       	ldi	r25, 0xFE	; 254
    1318:	98 0f       	add	r25, r24
    131a:	98 30       	cpi	r25, 0x08	; 8
    131c:	a0 f0       	brcs	.+40     	; 0x1346 <decode_spi_left_knob+0x7e>
	    left_inc();
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
    131e:	81 3f       	cpi	r24, 0xF1	; 241
    1320:	68 f4       	brcc	.+26     	; 0x133c <decode_spi_left_knob+0x74>
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
    1322:	10 92 3e 01 	sts	0x013E, r1
    }
    previous_encoder1 = encoder1;
    1326:	c0 93 3f 01 	sts	0x013F, r28
}
    132a:	df 91       	pop	r29
    132c:	cf 91       	pop	r28
    132e:	08 95       	ret
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
	acount1++;
    1330:	80 91 3e 01 	lds	r24, 0x013E
    1334:	8f 5f       	subi	r24, 0xFF	; 255
    1336:	80 93 3e 01 	sts	0x013E, r24
    133a:	dd cf       	rjmp	.-70     	; 0x12f6 <decode_spi_left_knob+0x2e>
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    left_inc();
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
    133c:	0e 94 3a 09 	call	0x1274	; 0x1274 <left_dec>
	}
	acount1 = 0;                     //Reset counter
    1340:	10 92 3e 01 	sts	0x013E, r1
    1344:	f0 cf       	rjmp	.-32     	; 0x1326 <decode_spi_left_knob+0x5e>
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    left_inc();
    1346:	0e 94 12 09 	call	0x1224	; 0x1224 <left_inc>
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
    134a:	10 92 3e 01 	sts	0x013E, r1
    134e:	eb cf       	rjmp	.-42     	; 0x1326 <decode_spi_left_knob+0x5e>

00001350 <check_knobs>:
    __asm__ __volatile__ ("nop");
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    // Return incoming data from SPDR
    return(SPDR);  
}
void check_knobs(void){
    1350:	cf 93       	push	r28
    static uint8_t cnt = 0;
    static uint8_t encoder;
    cnt++;
    1352:	c0 91 41 01 	lds	r28, 0x0141
    1356:	cf 5f       	subi	r28, 0xFF	; 255
    1358:	c0 93 41 01 	sts	0x0141, r28
    encoder = SPI_Receive();
    135c:	0e 94 7e 07 	call	0xefc	; 0xefc <SPI_Receive>
    1360:	80 93 40 01 	sts	0x0140, r24
    //TIFR |= (1<<TOV2);
    if(cnt%2==0){
    1364:	c0 ff       	sbrs	r28, 0
    1366:	03 c0       	rjmp	.+6      	; 0x136e <check_knobs+0x1e>
	decode_spi_left_knob(encoder);
    }
    else{
	decode_spi_right_knob(encoder);
    }
}
    1368:	cf 91       	pop	r28
    //TIFR |= (1<<TOV2);
    if(cnt%2==0){
	decode_spi_left_knob(encoder);
    }
    else{
	decode_spi_right_knob(encoder);
    136a:	0c 94 cc 08 	jmp	0x1198	; 0x1198 <decode_spi_right_knob>
    }
}
    136e:	cf 91       	pop	r28
    static uint8_t encoder;
    cnt++;
    encoder = SPI_Receive();
    //TIFR |= (1<<TOV2);
    if(cnt%2==0){
	decode_spi_left_knob(encoder);
    1370:	0c 94 64 09 	jmp	0x12c8	; 0x12c8 <decode_spi_left_knob>

00001374 <__vector_10>:
	notes++;               //move on to the next note
	play_song(song, notes);//and play it
    }
}

ISR(TIMER2_OVF_vect){
    1374:	1f 92       	push	r1
    1376:	0f 92       	push	r0
    1378:	0f b6       	in	r0, 0x3f	; 63
    137a:	0f 92       	push	r0
    137c:	11 24       	eor	r1, r1
    137e:	0b b6       	in	r0, 0x3b	; 59
    1380:	0f 92       	push	r0
    1382:	2f 93       	push	r18
    1384:	3f 93       	push	r19
    1386:	4f 93       	push	r20
    1388:	5f 93       	push	r21
    138a:	6f 93       	push	r22
    138c:	7f 93       	push	r23
    138e:	8f 93       	push	r24
    1390:	9f 93       	push	r25
    1392:	af 93       	push	r26
    1394:	bf 93       	push	r27
    1396:	cf 93       	push	r28
    1398:	ef 93       	push	r30
    139a:	ff 93       	push	r31
    static uint8_t count = 0;
    count++;
    139c:	c0 91 42 01 	lds	r28, 0x0142
    13a0:	cf 5f       	subi	r28, 0xFF	; 255
    13a2:	c0 93 42 01 	sts	0x0142, r28
    //display_update();
    if(count%64 == 0){
    13a6:	8c 2f       	mov	r24, r28
    13a8:	8f 73       	andi	r24, 0x3F	; 63
    13aa:	c1 f0       	breq	.+48     	; 0x13dc <__vector_10+0x68>
	button_routine();
    }
    if(count ==  255){
    }
    switch(count%8){
    13ac:	c7 70       	andi	r28, 0x07	; 7
    13ae:	11 f4       	brne	.+4      	; 0x13b4 <__vector_10+0x40>
	case 0:
	    check_knobs();
    13b0:	0e 94 a8 09 	call	0x1350	; 0x1350 <check_knobs>
	       }*/
	    break;
	default:
	    break;
    }    
} 
    13b4:	ff 91       	pop	r31
    13b6:	ef 91       	pop	r30
    13b8:	cf 91       	pop	r28
    13ba:	bf 91       	pop	r27
    13bc:	af 91       	pop	r26
    13be:	9f 91       	pop	r25
    13c0:	8f 91       	pop	r24
    13c2:	7f 91       	pop	r23
    13c4:	6f 91       	pop	r22
    13c6:	5f 91       	pop	r21
    13c8:	4f 91       	pop	r20
    13ca:	3f 91       	pop	r19
    13cc:	2f 91       	pop	r18
    13ce:	0f 90       	pop	r0
    13d0:	0b be       	out	0x3b, r0	; 59
    13d2:	0f 90       	pop	r0
    13d4:	0f be       	out	0x3f, r0	; 63
    13d6:	0f 90       	pop	r0
    13d8:	1f 90       	pop	r1
    13da:	18 95       	reti
ISR(TIMER2_OVF_vect){
    static uint8_t count = 0;
    count++;
    //display_update();
    if(count%64 == 0){
	button_routine();
    13dc:	0e 94 a7 07 	call	0xf4e	; 0xf4e <button_routine>
    13e0:	e5 cf       	rjmp	.-54     	; 0x13ac <__vector_10+0x38>

000013e2 <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
    TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    13e2:	83 b7       	in	r24, 0x33	; 51
    13e4:	81 60       	ori	r24, 0x01	; 1
    13e6:	83 bf       	out	0x33, r24	; 51
    ASSR  |= (1<<AS0);
    13e8:	80 b7       	in	r24, 0x30	; 48
    13ea:	88 60       	ori	r24, 0x08	; 8
    13ec:	80 bf       	out	0x30, r24	; 48
    TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    13ee:	85 b5       	in	r24, 0x25	; 37
    13f0:	8a 67       	ori	r24, 0x7A	; 122
    13f2:	85 bd       	out	0x25, r24	; 37
    TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    13f4:	87 b7       	in	r24, 0x37	; 55
    13f6:	81 64       	ori	r24, 0x41	; 65
    13f8:	87 bf       	out	0x37, r24	; 55
    13fa:	08 95       	ret

000013fc <ADC_init>:
}


void ADC_init(void){
    DDRF |= !(1<<PF0);
    13fc:	e1 e6       	ldi	r30, 0x61	; 97
    13fe:	f0 e0       	ldi	r31, 0x00	; 0
    1400:	80 81       	ld	r24, Z
    1402:	80 83       	st	Z, r24
    PORTF = 0x00;
    1404:	10 92 62 00 	sts	0x0062, r1
    ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1408:	87 b1       	in	r24, 0x07	; 7
    140a:	80 66       	ori	r24, 0x60	; 96
    140c:	87 b9       	out	0x07, r24	; 7
    ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    140e:	86 b1       	in	r24, 0x06	; 6
    1410:	8f 6e       	ori	r24, 0xEF	; 239
    1412:	86 b9       	out	0x06, r24	; 6
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    OCR2 = 0xFF;
    1414:	8f ef       	ldi	r24, 0xFF	; 255
    1416:	83 bd       	out	0x23, r24	; 35
    1418:	08 95       	ret

0000141a <volume_control_init>:
}

void volume_control_init(void){
    DDRE |= (1<<PE3);
    141a:	13 9a       	sbi	0x02, 3	; 2
    TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    141c:	81 e8       	ldi	r24, 0x81	; 129
    141e:	80 93 8b 00 	sts	0x008B, r24
    TCCR3B = (1<<WGM32) | (1<<CS30);
    1422:	89 e0       	ldi	r24, 0x09	; 9
    1424:	80 93 8a 00 	sts	0x008A, r24
    OCR3A = volume;
    1428:	80 91 2b 01 	lds	r24, 0x012B
    142c:	90 e0       	ldi	r25, 0x00	; 0
    142e:	90 93 87 00 	sts	0x0087, r25
    1432:	80 93 86 00 	sts	0x0086, r24
    1436:	08 95       	ret

00001438 <strobe_lcd>:
}


void strobe_lcd(void) {
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1438:	e2 e6       	ldi	r30, 0x62	; 98
    143a:	f0 e0       	ldi	r31, 0x00	; 0
    143c:	80 81       	ld	r24, Z
    143e:	88 60       	ori	r24, 0x08	; 8
    1440:	80 83       	st	Z, r24
	PORTF &= ~0x08;
    1442:	80 81       	ld	r24, Z
    1444:	87 7f       	andi	r24, 0xF7	; 247
    1446:	80 83       	st	Z, r24
    1448:	08 95       	ret

0000144a <LCD_Clr>:
}

void LCD_Clr(void) {
	LCD_CMD(0x01);
    144a:	1f b8       	out	0x0f, r1	; 15
    144c:	77 9b       	sbis	0x0e, 7	; 14
    144e:	fe cf       	rjmp	.-4      	; 0x144c <LCD_Clr+0x2>
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	8f b9       	out	0x0f, r24	; 15
    1454:	77 9b       	sbis	0x0e, 7	; 14
    1456:	fe cf       	rjmp	.-4      	; 0x1454 <LCD_Clr+0xa>
    1458:	80 91 62 00 	lds	r24, 0x0062
    145c:	88 60       	ori	r24, 0x08	; 8
    145e:	80 93 62 00 	sts	0x0062, r24
    1462:	80 91 62 00 	lds	r24, 0x0062
    1466:	87 7f       	andi	r24, 0xF7	; 247
    1468:	80 93 62 00 	sts	0x0062, r24
    146c:	8f e8       	ldi	r24, 0x8F	; 143
    146e:	91 e0       	ldi	r25, 0x01	; 1
    1470:	01 97       	sbiw	r24, 0x01	; 1
    1472:	f1 f7       	brne	.-4      	; 0x1470 <LCD_Clr+0x26>
    1474:	00 c0       	rjmp	.+0      	; 0x1476 <LCD_Clr+0x2c>
    1476:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1478:	8f e3       	ldi	r24, 0x3F	; 63
    147a:	9f e1       	ldi	r25, 0x1F	; 31
    147c:	01 97       	sbiw	r24, 0x01	; 1
    147e:	f1 f7       	brne	.-4      	; 0x147c <LCD_Clr+0x32>
    1480:	00 c0       	rjmp	.+0      	; 0x1482 <LCD_Clr+0x38>
    1482:	00 00       	nop
    1484:	08 95       	ret

00001486 <LCD_MovCursorLn1>:
	_delay_ms(2);   //obligatory waiting for slow LCD
}

void LCD_MovCursorLn1(void) {
	LCD_CMD(0x80);
    1486:	1f b8       	out	0x0f, r1	; 15
    1488:	77 9b       	sbis	0x0e, 7	; 14
    148a:	fe cf       	rjmp	.-4      	; 0x1488 <LCD_MovCursorLn1+0x2>
    148c:	80 e8       	ldi	r24, 0x80	; 128
    148e:	8f b9       	out	0x0f, r24	; 15
    1490:	77 9b       	sbis	0x0e, 7	; 14
    1492:	fe cf       	rjmp	.-4      	; 0x1490 <LCD_MovCursorLn1+0xa>
    1494:	80 91 62 00 	lds	r24, 0x0062
    1498:	88 60       	ori	r24, 0x08	; 8
    149a:	80 93 62 00 	sts	0x0062, r24
    149e:	80 91 62 00 	lds	r24, 0x0062
    14a2:	87 7f       	andi	r24, 0xF7	; 247
    14a4:	80 93 62 00 	sts	0x0062, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14a8:	8f e8       	ldi	r24, 0x8F	; 143
    14aa:	91 e0       	ldi	r25, 0x01	; 1
    14ac:	01 97       	sbiw	r24, 0x01	; 1
    14ae:	f1 f7       	brne	.-4      	; 0x14ac <LCD_MovCursorLn1+0x26>
    14b0:	00 c0       	rjmp	.+0      	; 0x14b2 <LCD_MovCursorLn1+0x2c>
    14b2:	00 00       	nop
    14b4:	08 95       	ret

000014b6 <LCD_MovCursorLn2>:
}

void LCD_MovCursorLn2(void) {
	LCD_CMD(0xC0);
    14b6:	1f b8       	out	0x0f, r1	; 15
    14b8:	77 9b       	sbis	0x0e, 7	; 14
    14ba:	fe cf       	rjmp	.-4      	; 0x14b8 <LCD_MovCursorLn2+0x2>
    14bc:	80 ec       	ldi	r24, 0xC0	; 192
    14be:	8f b9       	out	0x0f, r24	; 15
    14c0:	77 9b       	sbis	0x0e, 7	; 14
    14c2:	fe cf       	rjmp	.-4      	; 0x14c0 <LCD_MovCursorLn2+0xa>
    14c4:	80 91 62 00 	lds	r24, 0x0062
    14c8:	88 60       	ori	r24, 0x08	; 8
    14ca:	80 93 62 00 	sts	0x0062, r24
    14ce:	80 91 62 00 	lds	r24, 0x0062
    14d2:	87 7f       	andi	r24, 0xF7	; 247
    14d4:	80 93 62 00 	sts	0x0062, r24
    14d8:	8f e8       	ldi	r24, 0x8F	; 143
    14da:	91 e0       	ldi	r25, 0x01	; 1
    14dc:	01 97       	sbiw	r24, 0x01	; 1
    14de:	f1 f7       	brne	.-4      	; 0x14dc <LCD_MovCursorLn2+0x26>
    14e0:	00 c0       	rjmp	.+0      	; 0x14e2 <LCD_MovCursorLn2+0x2c>
    14e2:	00 00       	nop
    14e4:	08 95       	ret

000014e6 <LCD_CursorBlinkOn>:
}

void LCD_CursorBlinkOn(void) {
	LCD_CMD(0x0F);
    14e6:	1f b8       	out	0x0f, r1	; 15
    14e8:	77 9b       	sbis	0x0e, 7	; 14
    14ea:	fe cf       	rjmp	.-4      	; 0x14e8 <LCD_CursorBlinkOn+0x2>
    14ec:	8f e0       	ldi	r24, 0x0F	; 15
    14ee:	8f b9       	out	0x0f, r24	; 15
    14f0:	77 9b       	sbis	0x0e, 7	; 14
    14f2:	fe cf       	rjmp	.-4      	; 0x14f0 <LCD_CursorBlinkOn+0xa>
    14f4:	80 91 62 00 	lds	r24, 0x0062
    14f8:	88 60       	ori	r24, 0x08	; 8
    14fa:	80 93 62 00 	sts	0x0062, r24
    14fe:	80 91 62 00 	lds	r24, 0x0062
    1502:	87 7f       	andi	r24, 0xF7	; 247
    1504:	80 93 62 00 	sts	0x0062, r24
    1508:	8f e8       	ldi	r24, 0x8F	; 143
    150a:	91 e0       	ldi	r25, 0x01	; 1
    150c:	01 97       	sbiw	r24, 0x01	; 1
    150e:	f1 f7       	brne	.-4      	; 0x150c <LCD_CursorBlinkOn+0x26>
    1510:	00 c0       	rjmp	.+0      	; 0x1512 <LCD_CursorBlinkOn+0x2c>
    1512:	00 00       	nop
    1514:	08 95       	ret

00001516 <LCD_CursorBlinkOff>:
}

void LCD_CursorBlinkOff(void) {
	LCD_CMD(0x0C);
    1516:	1f b8       	out	0x0f, r1	; 15
    1518:	77 9b       	sbis	0x0e, 7	; 14
    151a:	fe cf       	rjmp	.-4      	; 0x1518 <LCD_CursorBlinkOff+0x2>
    151c:	8c e0       	ldi	r24, 0x0C	; 12
    151e:	8f b9       	out	0x0f, r24	; 15
    1520:	77 9b       	sbis	0x0e, 7	; 14
    1522:	fe cf       	rjmp	.-4      	; 0x1520 <LCD_CursorBlinkOff+0xa>
    1524:	80 91 62 00 	lds	r24, 0x0062
    1528:	88 60       	ori	r24, 0x08	; 8
    152a:	80 93 62 00 	sts	0x0062, r24
    152e:	80 91 62 00 	lds	r24, 0x0062
    1532:	87 7f       	andi	r24, 0xF7	; 247
    1534:	80 93 62 00 	sts	0x0062, r24
    1538:	8f e8       	ldi	r24, 0x8F	; 143
    153a:	91 e0       	ldi	r25, 0x01	; 1
    153c:	01 97       	sbiw	r24, 0x01	; 1
    153e:	f1 f7       	brne	.-4      	; 0x153c <LCD_CursorBlinkOff+0x26>
    1540:	00 c0       	rjmp	.+0      	; 0x1542 <LCD_CursorBlinkOff+0x2c>
    1542:	00 00       	nop
    1544:	08 95       	ret

00001546 <LCD_MovCursor>:
		
	The cursor will not be moved if an invalid location is provided
*/
void LCD_MovCursor(uint8_t line, uint8_t position) {
	uint8_t addr;
	if (position > 15)
    1546:	60 31       	cpi	r22, 0x10	; 16
    1548:	20 f4       	brcc	.+8      	; 0x1552 <LCD_MovCursor+0xc>
		return;
	if (line == 1) {
    154a:	81 30       	cpi	r24, 0x01	; 1
    154c:	19 f0       	breq	.+6      	; 0x1554 <LCD_MovCursor+0xe>
		addr = 0x80 + position;
	} else if (line == 2) {
    154e:	82 30       	cpi	r24, 0x02	; 2
    1550:	c9 f0       	breq	.+50     	; 0x1584 <LCD_MovCursor+0x3e>
    1552:	08 95       	ret
void LCD_MovCursor(uint8_t line, uint8_t position) {
	uint8_t addr;
	if (position > 15)
		return;
	if (line == 1) {
		addr = 0x80 + position;
    1554:	60 58       	subi	r22, 0x80	; 128
		addr = 0xC0 + position;
	} else {
		// invalid line number
		return;
	}
	LCD_CMD(addr);
    1556:	1f b8       	out	0x0f, r1	; 15
    1558:	77 9b       	sbis	0x0e, 7	; 14
    155a:	fe cf       	rjmp	.-4      	; 0x1558 <LCD_MovCursor+0x12>
    155c:	6f b9       	out	0x0f, r22	; 15
    155e:	77 9b       	sbis	0x0e, 7	; 14
    1560:	fe cf       	rjmp	.-4      	; 0x155e <LCD_MovCursor+0x18>
    1562:	80 91 62 00 	lds	r24, 0x0062
    1566:	88 60       	ori	r24, 0x08	; 8
    1568:	80 93 62 00 	sts	0x0062, r24
    156c:	80 91 62 00 	lds	r24, 0x0062
    1570:	87 7f       	andi	r24, 0xF7	; 247
    1572:	80 93 62 00 	sts	0x0062, r24
    1576:	8f e8       	ldi	r24, 0x8F	; 143
    1578:	91 e0       	ldi	r25, 0x01	; 1
    157a:	01 97       	sbiw	r24, 0x01	; 1
    157c:	f1 f7       	brne	.-4      	; 0x157a <LCD_MovCursor+0x34>
    157e:	00 c0       	rjmp	.+0      	; 0x1580 <LCD_MovCursor+0x3a>
    1580:	00 00       	nop
    1582:	08 95       	ret
	if (position > 15)
		return;
	if (line == 1) {
		addr = 0x80 + position;
	} else if (line == 2) {
		addr = 0xC0 + position;
    1584:	60 54       	subi	r22, 0x40	; 64
    1586:	e7 cf       	rjmp	.-50     	; 0x1556 <LCD_MovCursor+0x10>

00001588 <LCD_FillSpaces>:
		return;
	}
	LCD_CMD(addr);
}

void LCD_FillSpaces(void) {
    1588:	80 e1       	ldi	r24, 0x10	; 16
    158a:	90 e0       	ldi	r25, 0x00	; 0
	int count;
	for (count=0; count<=15; count++){
		LCD_DATA(' ');
    158c:	41 e0       	ldi	r20, 0x01	; 1
    158e:	30 e2       	ldi	r19, 0x20	; 32
    1590:	4f b9       	out	0x0f, r20	; 15
    1592:	77 9b       	sbis	0x0e, 7	; 14
    1594:	fe cf       	rjmp	.-4      	; 0x1592 <LCD_FillSpaces+0xa>
    1596:	3f b9       	out	0x0f, r19	; 15
    1598:	77 9b       	sbis	0x0e, 7	; 14
    159a:	fe cf       	rjmp	.-4      	; 0x1598 <LCD_FillSpaces+0x10>
    159c:	20 91 62 00 	lds	r18, 0x0062
    15a0:	28 60       	ori	r18, 0x08	; 8
    15a2:	20 93 62 00 	sts	0x0062, r18
    15a6:	20 91 62 00 	lds	r18, 0x0062
    15aa:	27 7f       	andi	r18, 0xF7	; 247
    15ac:	20 93 62 00 	sts	0x0062, r18
    15b0:	ef e8       	ldi	r30, 0x8F	; 143
    15b2:	f1 e0       	ldi	r31, 0x01	; 1
    15b4:	31 97       	sbiw	r30, 0x01	; 1
    15b6:	f1 f7       	brne	.-4      	; 0x15b4 <LCD_FillSpaces+0x2c>
    15b8:	00 c0       	rjmp	.+0      	; 0x15ba <LCD_FillSpaces+0x32>
    15ba:	00 00       	nop
    15bc:	01 97       	sbiw	r24, 0x01	; 1
	LCD_CMD(addr);
}

void LCD_FillSpaces(void) {
	int count;
	for (count=0; count<=15; count++){
    15be:	00 97       	sbiw	r24, 0x00	; 0
    15c0:	39 f7       	brne	.-50     	; 0x1590 <LCD_FillSpaces+0x8>
		LCD_DATA(' ');
	}
}
    15c2:	08 95       	ret

000015c4 <LCD_PutDec8>:
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 100) {
    15c4:	84 36       	cpi	r24, 0x64	; 100
    15c6:	08 f4       	brcc	.+2      	; 0x15ca <LCD_PutDec8+0x6>
    15c8:	5d c0       	rjmp	.+186    	; 0x1684 <LCD_PutDec8+0xc0>
		digit++;
		num -= 100;
    15ca:	9c e9       	ldi	r25, 0x9C	; 156
    15cc:	98 0f       	add	r25, r24
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 100) {
    15ce:	94 36       	cpi	r25, 0x64	; 100
    15d0:	08 f4       	brcc	.+2      	; 0x15d4 <LCD_PutDec8+0x10>
    15d2:	5c c0       	rjmp	.+184    	; 0x168c <LCD_PutDec8+0xc8>
		digit++;
		num -= 100;
    15d4:	88 5c       	subi	r24, 0xC8	; 200
    15d6:	22 e3       	ldi	r18, 0x32	; 50
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    15d8:	91 e0       	ldi	r25, 0x01	; 1
    15da:	9f b9       	out	0x0f, r25	; 15
    15dc:	77 9b       	sbis	0x0e, 7	; 14
    15de:	fe cf       	rjmp	.-4      	; 0x15dc <LCD_PutDec8+0x18>
    15e0:	2f b9       	out	0x0f, r18	; 15
    15e2:	77 9b       	sbis	0x0e, 7	; 14
    15e4:	fe cf       	rjmp	.-4      	; 0x15e2 <LCD_PutDec8+0x1e>
    15e6:	90 91 62 00 	lds	r25, 0x0062
    15ea:	98 60       	ori	r25, 0x08	; 8
    15ec:	90 93 62 00 	sts	0x0062, r25
    15f0:	90 91 62 00 	lds	r25, 0x0062
    15f4:	97 7f       	andi	r25, 0xF7	; 247
    15f6:	90 93 62 00 	sts	0x0062, r25
    15fa:	ef e8       	ldi	r30, 0x8F	; 143
    15fc:	f1 e0       	ldi	r31, 0x01	; 1
    15fe:	31 97       	sbiw	r30, 0x01	; 1
    1600:	f1 f7       	brne	.-4      	; 0x15fe <LCD_PutDec8+0x3a>
    1602:	00 c0       	rjmp	.+0      	; 0x1604 <LCD_PutDec8+0x40>
    1604:	00 00       	nop
		flag = 1;
    1606:	91 e0       	ldi	r25, 0x01	; 1
	}
	digit = 0;
	while (num >= 10) {
    1608:	8a 30       	cpi	r24, 0x0A	; 10
    160a:	c0 f1       	brcs	.+112    	; 0x167c <LCD_PutDec8+0xb8>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    160c:	90 e0       	ldi	r25, 0x00	; 0
	while (num >= 10) {
		digit++;
    160e:	9f 5f       	subi	r25, 0xFF	; 255
		num -= 10;
    1610:	8a 50       	subi	r24, 0x0A	; 10
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 10) {
    1612:	8a 30       	cpi	r24, 0x0A	; 10
    1614:	e0 f7       	brcc	.-8      	; 0x160e <LCD_PutDec8+0x4a>
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    1616:	21 e0       	ldi	r18, 0x01	; 1
    1618:	2f b9       	out	0x0f, r18	; 15
    161a:	77 9b       	sbis	0x0e, 7	; 14
    161c:	fe cf       	rjmp	.-4      	; 0x161a <LCD_PutDec8+0x56>
    161e:	90 5d       	subi	r25, 0xD0	; 208
    1620:	9f b9       	out	0x0f, r25	; 15
    1622:	77 9b       	sbis	0x0e, 7	; 14
    1624:	fe cf       	rjmp	.-4      	; 0x1622 <LCD_PutDec8+0x5e>
    1626:	90 91 62 00 	lds	r25, 0x0062
    162a:	98 60       	ori	r25, 0x08	; 8
    162c:	90 93 62 00 	sts	0x0062, r25
    1630:	90 91 62 00 	lds	r25, 0x0062
    1634:	97 7f       	andi	r25, 0xF7	; 247
    1636:	90 93 62 00 	sts	0x0062, r25
    163a:	ef e8       	ldi	r30, 0x8F	; 143
    163c:	f1 e0       	ldi	r31, 0x01	; 1
    163e:	31 97       	sbiw	r30, 0x01	; 1
    1640:	f1 f7       	brne	.-4      	; 0x163e <LCD_PutDec8+0x7a>
    1642:	00 c0       	rjmp	.+0      	; 0x1644 <LCD_PutDec8+0x80>
    1644:	00 00       	nop
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    1646:	88 23       	and	r24, r24
    1648:	f9 f0       	breq	.+62     	; 0x1688 <LCD_PutDec8+0xc4>
    164a:	80 5d       	subi	r24, 0xD0	; 208
		digit++;
		num -= 1;
	}
	LCD_DATA(digit + 48);
    164c:	91 e0       	ldi	r25, 0x01	; 1
    164e:	9f b9       	out	0x0f, r25	; 15
    1650:	77 9b       	sbis	0x0e, 7	; 14
    1652:	fe cf       	rjmp	.-4      	; 0x1650 <LCD_PutDec8+0x8c>
    1654:	8f b9       	out	0x0f, r24	; 15
    1656:	77 9b       	sbis	0x0e, 7	; 14
    1658:	fe cf       	rjmp	.-4      	; 0x1656 <LCD_PutDec8+0x92>
    165a:	80 91 62 00 	lds	r24, 0x0062
    165e:	88 60       	ori	r24, 0x08	; 8
    1660:	80 93 62 00 	sts	0x0062, r24
    1664:	80 91 62 00 	lds	r24, 0x0062
    1668:	87 7f       	andi	r24, 0xF7	; 247
    166a:	80 93 62 00 	sts	0x0062, r24
    166e:	8f e8       	ldi	r24, 0x8F	; 143
    1670:	91 e0       	ldi	r25, 0x01	; 1
    1672:	01 97       	sbiw	r24, 0x01	; 1
    1674:	f1 f7       	brne	.-4      	; 0x1672 <LCD_PutDec8+0xae>
    1676:	00 c0       	rjmp	.+0      	; 0x1678 <LCD_PutDec8+0xb4>
    1678:	00 00       	nop
    167a:	08 95       	ret
	digit = 0;
	while (num >= 10) {
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
    167c:	91 30       	cpi	r25, 0x01	; 1
    167e:	19 f7       	brne	.-58     	; 0x1646 <LCD_PutDec8+0x82>
    1680:	90 e0       	ldi	r25, 0x00	; 0
    1682:	c9 cf       	rjmp	.-110    	; 0x1616 <LCD_PutDec8+0x52>
	Convert an 8 bit unsigned number to ASCII
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	c0 cf       	rjmp	.-128    	; 0x1608 <LCD_PutDec8+0x44>
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    1688:	80 e3       	ldi	r24, 0x30	; 48
    168a:	e0 cf       	rjmp	.-64     	; 0x164c <LCD_PutDec8+0x88>
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 100) {
    168c:	89 2f       	mov	r24, r25
    168e:	21 e3       	ldi	r18, 0x31	; 49
    1690:	a3 cf       	rjmp	.-186    	; 0x15d8 <LCD_PutDec8+0x14>

00001692 <LCD_PutDec16>:
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 10000) {
    1692:	80 31       	cpi	r24, 0x10	; 16
    1694:	27 e2       	ldi	r18, 0x27	; 39
    1696:	92 07       	cpc	r25, r18
    1698:	08 f4       	brcc	.+2      	; 0x169c <LCD_PutDec16+0xa>
    169a:	bf c0       	rjmp	.+382    	; 0x181a <LCD_PutDec16+0x188>
/*
	Convert a 16 bit unsigned number to ASCII
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
    169c:	20 e0       	ldi	r18, 0x00	; 0
    169e:	01 c0       	rjmp	.+2      	; 0x16a2 <LCD_PutDec16+0x10>
	uint8_t flag = 0;
	while (num >= 10000) {
		digit++;
    16a0:	23 2f       	mov	r18, r19
    16a2:	31 e0       	ldi	r19, 0x01	; 1
    16a4:	32 0f       	add	r19, r18
		num -= 10000;
    16a6:	80 51       	subi	r24, 0x10	; 16
    16a8:	97 42       	sbci	r25, 0x27	; 39
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 10000) {
    16aa:	80 31       	cpi	r24, 0x10	; 16
    16ac:	47 e2       	ldi	r20, 0x27	; 39
    16ae:	94 07       	cpc	r25, r20
    16b0:	b8 f7       	brcc	.-18     	; 0x16a0 <LCD_PutDec16+0xe>
		digit++;
		num -= 10000;
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    16b2:	31 e0       	ldi	r19, 0x01	; 1
    16b4:	3f b9       	out	0x0f, r19	; 15
    16b6:	77 9b       	sbis	0x0e, 7	; 14
    16b8:	fe cf       	rjmp	.-4      	; 0x16b6 <LCD_PutDec16+0x24>
    16ba:	2f 5c       	subi	r18, 0xCF	; 207
    16bc:	2f b9       	out	0x0f, r18	; 15
    16be:	77 9b       	sbis	0x0e, 7	; 14
    16c0:	fe cf       	rjmp	.-4      	; 0x16be <LCD_PutDec16+0x2c>
    16c2:	20 91 62 00 	lds	r18, 0x0062
    16c6:	28 60       	ori	r18, 0x08	; 8
    16c8:	20 93 62 00 	sts	0x0062, r18
    16cc:	20 91 62 00 	lds	r18, 0x0062
    16d0:	27 7f       	andi	r18, 0xF7	; 247
    16d2:	20 93 62 00 	sts	0x0062, r18
    16d6:	ef e8       	ldi	r30, 0x8F	; 143
    16d8:	f1 e0       	ldi	r31, 0x01	; 1
    16da:	31 97       	sbiw	r30, 0x01	; 1
    16dc:	f1 f7       	brne	.-4      	; 0x16da <LCD_PutDec16+0x48>
    16de:	00 c0       	rjmp	.+0      	; 0x16e0 <LCD_PutDec16+0x4e>
    16e0:	00 00       	nop
		flag = 1;
    16e2:	21 e0       	ldi	r18, 0x01	; 1
	}
	digit = 0;
	while (num >= 1000) {
    16e4:	88 3e       	cpi	r24, 0xE8	; 232
    16e6:	f3 e0       	ldi	r31, 0x03	; 3
    16e8:	9f 07       	cpc	r25, r31
    16ea:	08 f4       	brcc	.+2      	; 0x16ee <LCD_PutDec16+0x5c>
    16ec:	8e c0       	rjmp	.+284    	; 0x180a <LCD_PutDec16+0x178>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    16ee:	20 e0       	ldi	r18, 0x00	; 0
	while (num >= 1000) {
		digit++;
    16f0:	2f 5f       	subi	r18, 0xFF	; 255
		num -= 1000;
    16f2:	88 5e       	subi	r24, 0xE8	; 232
    16f4:	93 40       	sbci	r25, 0x03	; 3
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 1000) {
    16f6:	88 3e       	cpi	r24, 0xE8	; 232
    16f8:	33 e0       	ldi	r19, 0x03	; 3
    16fa:	93 07       	cpc	r25, r19
    16fc:	c8 f7       	brcc	.-14     	; 0x16f0 <LCD_PutDec16+0x5e>
		digit++;
		num -= 1000;
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    16fe:	31 e0       	ldi	r19, 0x01	; 1
    1700:	3f b9       	out	0x0f, r19	; 15
    1702:	77 9b       	sbis	0x0e, 7	; 14
    1704:	fe cf       	rjmp	.-4      	; 0x1702 <LCD_PutDec16+0x70>
    1706:	20 5d       	subi	r18, 0xD0	; 208
    1708:	2f b9       	out	0x0f, r18	; 15
    170a:	77 9b       	sbis	0x0e, 7	; 14
    170c:	fe cf       	rjmp	.-4      	; 0x170a <LCD_PutDec16+0x78>
    170e:	20 91 62 00 	lds	r18, 0x0062
    1712:	28 60       	ori	r18, 0x08	; 8
    1714:	20 93 62 00 	sts	0x0062, r18
    1718:	20 91 62 00 	lds	r18, 0x0062
    171c:	27 7f       	andi	r18, 0xF7	; 247
    171e:	20 93 62 00 	sts	0x0062, r18
    1722:	ef e8       	ldi	r30, 0x8F	; 143
    1724:	f1 e0       	ldi	r31, 0x01	; 1
    1726:	31 97       	sbiw	r30, 0x01	; 1
    1728:	f1 f7       	brne	.-4      	; 0x1726 <LCD_PutDec16+0x94>
    172a:	00 c0       	rjmp	.+0      	; 0x172c <LCD_PutDec16+0x9a>
    172c:	00 00       	nop
		flag = 1;
    172e:	31 e0       	ldi	r19, 0x01	; 1
	}
	digit = 0;
	while (num >= 100) {
    1730:	84 36       	cpi	r24, 0x64	; 100
    1732:	91 05       	cpc	r25, r1
    1734:	08 f4       	brcc	.+2      	; 0x1738 <LCD_PutDec16+0xa6>
    1736:	65 c0       	rjmp	.+202    	; 0x1802 <LCD_PutDec16+0x170>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    1738:	20 e0       	ldi	r18, 0x00	; 0
	while (num >= 100) {
		digit++;
    173a:	2f 5f       	subi	r18, 0xFF	; 255
		num -= 100;
    173c:	84 56       	subi	r24, 0x64	; 100
    173e:	91 09       	sbc	r25, r1
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 100) {
    1740:	84 36       	cpi	r24, 0x64	; 100
    1742:	91 05       	cpc	r25, r1
    1744:	d0 f7       	brcc	.-12     	; 0x173a <LCD_PutDec16+0xa8>
		digit++;
		num -= 100;
	}
	if (digit > 0 || flag == 1) {
    1746:	22 23       	and	r18, r18
    1748:	09 f4       	brne	.+2      	; 0x174c <LCD_PutDec16+0xba>
    174a:	5b c0       	rjmp	.+182    	; 0x1802 <LCD_PutDec16+0x170>
		LCD_DATA(digit + 48);
    174c:	31 e0       	ldi	r19, 0x01	; 1
    174e:	3f b9       	out	0x0f, r19	; 15
    1750:	77 9b       	sbis	0x0e, 7	; 14
    1752:	fe cf       	rjmp	.-4      	; 0x1750 <LCD_PutDec16+0xbe>
    1754:	20 5d       	subi	r18, 0xD0	; 208
    1756:	2f b9       	out	0x0f, r18	; 15
    1758:	77 9b       	sbis	0x0e, 7	; 14
    175a:	fe cf       	rjmp	.-4      	; 0x1758 <LCD_PutDec16+0xc6>
    175c:	20 91 62 00 	lds	r18, 0x0062
    1760:	28 60       	ori	r18, 0x08	; 8
    1762:	20 93 62 00 	sts	0x0062, r18
    1766:	20 91 62 00 	lds	r18, 0x0062
    176a:	27 7f       	andi	r18, 0xF7	; 247
    176c:	20 93 62 00 	sts	0x0062, r18
    1770:	ef e8       	ldi	r30, 0x8F	; 143
    1772:	f1 e0       	ldi	r31, 0x01	; 1
    1774:	31 97       	sbiw	r30, 0x01	; 1
    1776:	f1 f7       	brne	.-4      	; 0x1774 <LCD_PutDec16+0xe2>
    1778:	00 c0       	rjmp	.+0      	; 0x177a <LCD_PutDec16+0xe8>
    177a:	00 00       	nop
		flag = 1;
    177c:	31 e0       	ldi	r19, 0x01	; 1
	}
	digit = 0;
	while (num >= 10) {
    177e:	8a 30       	cpi	r24, 0x0A	; 10
    1780:	91 05       	cpc	r25, r1
    1782:	d8 f1       	brcs	.+118    	; 0x17fa <LCD_PutDec16+0x168>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    1784:	20 e0       	ldi	r18, 0x00	; 0
	while (num >= 10) {
		digit++;
    1786:	2f 5f       	subi	r18, 0xFF	; 255
		num -= 10;
    1788:	0a 97       	sbiw	r24, 0x0a	; 10
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 10) {
    178a:	8a 30       	cpi	r24, 0x0A	; 10
    178c:	91 05       	cpc	r25, r1
    178e:	d8 f7       	brcc	.-10     	; 0x1786 <LCD_PutDec16+0xf4>
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
    1790:	22 23       	and	r18, r18
    1792:	99 f1       	breq	.+102    	; 0x17fa <LCD_PutDec16+0x168>
		LCD_DATA(digit + 48);
    1794:	31 e0       	ldi	r19, 0x01	; 1
    1796:	3f b9       	out	0x0f, r19	; 15
    1798:	77 9b       	sbis	0x0e, 7	; 14
    179a:	fe cf       	rjmp	.-4      	; 0x1798 <LCD_PutDec16+0x106>
    179c:	20 5d       	subi	r18, 0xD0	; 208
    179e:	2f b9       	out	0x0f, r18	; 15
    17a0:	77 9b       	sbis	0x0e, 7	; 14
    17a2:	fe cf       	rjmp	.-4      	; 0x17a0 <LCD_PutDec16+0x10e>
    17a4:	20 91 62 00 	lds	r18, 0x0062
    17a8:	28 60       	ori	r18, 0x08	; 8
    17aa:	20 93 62 00 	sts	0x0062, r18
    17ae:	20 91 62 00 	lds	r18, 0x0062
    17b2:	27 7f       	andi	r18, 0xF7	; 247
    17b4:	20 93 62 00 	sts	0x0062, r18
    17b8:	ef e8       	ldi	r30, 0x8F	; 143
    17ba:	f1 e0       	ldi	r31, 0x01	; 1
    17bc:	31 97       	sbiw	r30, 0x01	; 1
    17be:	f1 f7       	brne	.-4      	; 0x17bc <LCD_PutDec16+0x12a>
    17c0:	00 c0       	rjmp	.+0      	; 0x17c2 <LCD_PutDec16+0x130>
    17c2:	00 00       	nop
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    17c4:	00 97       	sbiw	r24, 0x00	; 0
    17c6:	59 f1       	breq	.+86     	; 0x181e <LCD_PutDec16+0x18c>
    17c8:	80 5d       	subi	r24, 0xD0	; 208
		digit++;
		num -= 1;
	}
	LCD_DATA(digit + 48);
    17ca:	91 e0       	ldi	r25, 0x01	; 1
    17cc:	9f b9       	out	0x0f, r25	; 15
    17ce:	77 9b       	sbis	0x0e, 7	; 14
    17d0:	fe cf       	rjmp	.-4      	; 0x17ce <LCD_PutDec16+0x13c>
    17d2:	8f b9       	out	0x0f, r24	; 15
    17d4:	77 9b       	sbis	0x0e, 7	; 14
    17d6:	fe cf       	rjmp	.-4      	; 0x17d4 <LCD_PutDec16+0x142>
    17d8:	80 91 62 00 	lds	r24, 0x0062
    17dc:	88 60       	ori	r24, 0x08	; 8
    17de:	80 93 62 00 	sts	0x0062, r24
    17e2:	80 91 62 00 	lds	r24, 0x0062
    17e6:	87 7f       	andi	r24, 0xF7	; 247
    17e8:	80 93 62 00 	sts	0x0062, r24
    17ec:	8f e8       	ldi	r24, 0x8F	; 143
    17ee:	91 e0       	ldi	r25, 0x01	; 1
    17f0:	01 97       	sbiw	r24, 0x01	; 1
    17f2:	f1 f7       	brne	.-4      	; 0x17f0 <LCD_PutDec16+0x15e>
    17f4:	00 c0       	rjmp	.+0      	; 0x17f6 <LCD_PutDec16+0x164>
    17f6:	00 00       	nop
    17f8:	08 95       	ret
	digit = 0;
	while (num >= 10) {
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
    17fa:	31 30       	cpi	r19, 0x01	; 1
    17fc:	19 f7       	brne	.-58     	; 0x17c4 <LCD_PutDec16+0x132>
    17fe:	20 e0       	ldi	r18, 0x00	; 0
    1800:	c9 cf       	rjmp	.-110    	; 0x1794 <LCD_PutDec16+0x102>
	digit = 0;
	while (num >= 100) {
		digit++;
		num -= 100;
	}
	if (digit > 0 || flag == 1) {
    1802:	31 30       	cpi	r19, 0x01	; 1
    1804:	41 f0       	breq	.+16     	; 0x1816 <LCD_PutDec16+0x184>
    1806:	30 e0       	ldi	r19, 0x00	; 0
    1808:	ba cf       	rjmp	.-140    	; 0x177e <LCD_PutDec16+0xec>
	digit = 0;
	while (num >= 1000) {
		digit++;
		num -= 1000;
	}
	if (digit > 0 || flag == 1) {
    180a:	21 30       	cpi	r18, 0x01	; 1
    180c:	11 f0       	breq	.+4      	; 0x1812 <LCD_PutDec16+0x180>
    180e:	30 e0       	ldi	r19, 0x00	; 0
    1810:	8f cf       	rjmp	.-226    	; 0x1730 <LCD_PutDec16+0x9e>
    1812:	20 e0       	ldi	r18, 0x00	; 0
    1814:	74 cf       	rjmp	.-280    	; 0x16fe <LCD_PutDec16+0x6c>
    1816:	20 e0       	ldi	r18, 0x00	; 0
    1818:	99 cf       	rjmp	.-206    	; 0x174c <LCD_PutDec16+0xba>
	Convert a 16 bit unsigned number to ASCII
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
    181a:	20 e0       	ldi	r18, 0x00	; 0
    181c:	63 cf       	rjmp	.-314    	; 0x16e4 <LCD_PutDec16+0x52>
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    181e:	80 e3       	ldi	r24, 0x30	; 48
    1820:	d4 cf       	rjmp	.-88     	; 0x17ca <LCD_PutDec16+0x138>

00001822 <LCD_PutChar>:
/*
	Send an ASCII character to the LCD
	usage: LCD_PutChar('H');
*/
void LCD_PutChar(char a_char) {
	LCD_DATA(a_char);
    1822:	91 e0       	ldi	r25, 0x01	; 1
    1824:	9f b9       	out	0x0f, r25	; 15
    1826:	77 9b       	sbis	0x0e, 7	; 14
    1828:	fe cf       	rjmp	.-4      	; 0x1826 <LCD_PutChar+0x4>
    182a:	8f b9       	out	0x0f, r24	; 15
    182c:	77 9b       	sbis	0x0e, 7	; 14
    182e:	fe cf       	rjmp	.-4      	; 0x182c <LCD_PutChar+0xa>
    1830:	80 91 62 00 	lds	r24, 0x0062
    1834:	88 60       	ori	r24, 0x08	; 8
    1836:	80 93 62 00 	sts	0x0062, r24
    183a:	80 91 62 00 	lds	r24, 0x0062
    183e:	87 7f       	andi	r24, 0xF7	; 247
    1840:	80 93 62 00 	sts	0x0062, r24
    1844:	8f e8       	ldi	r24, 0x8F	; 143
    1846:	91 e0       	ldi	r25, 0x01	; 1
    1848:	01 97       	sbiw	r24, 0x01	; 1
    184a:	f1 f7       	brne	.-4      	; 0x1848 <LCD_PutChar+0x26>
    184c:	00 c0       	rjmp	.+0      	; 0x184e <LCD_PutChar+0x2c>
    184e:	00 00       	nop
    1850:	08 95       	ret

00001852 <LCD_PutStr>:
}

/*
	Send an ASCII string to the LCD
*/
void LCD_PutStr(char *lcd_str) {
    1852:	dc 01       	movw	r26, r24
	uint8_t count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1854:	20 e0       	ldi	r18, 0x00	; 0
    1856:	30 e0       	ldi	r19, 0x00	; 0
    1858:	90 e0       	ldi	r25, 0x00	; 0
		LCD_DATA(lcd_str[count]);
    185a:	41 e0       	ldi	r20, 0x01	; 1
    185c:	4f b9       	out	0x0f, r20	; 15
    185e:	77 9b       	sbis	0x0e, 7	; 14
    1860:	fe cf       	rjmp	.-4      	; 0x185e <LCD_PutStr+0xc>
    1862:	fd 01       	movw	r30, r26
    1864:	e2 0f       	add	r30, r18
    1866:	f3 1f       	adc	r31, r19
    1868:	80 81       	ld	r24, Z
    186a:	8f b9       	out	0x0f, r24	; 15
    186c:	77 9b       	sbis	0x0e, 7	; 14
    186e:	fe cf       	rjmp	.-4      	; 0x186c <LCD_PutStr+0x1a>
    1870:	80 91 62 00 	lds	r24, 0x0062
    1874:	88 60       	ori	r24, 0x08	; 8
    1876:	80 93 62 00 	sts	0x0062, r24
    187a:	80 91 62 00 	lds	r24, 0x0062
    187e:	87 7f       	andi	r24, 0xF7	; 247
    1880:	80 93 62 00 	sts	0x0062, r24
    1884:	ef e8       	ldi	r30, 0x8F	; 143
    1886:	f1 e0       	ldi	r31, 0x01	; 1
    1888:	31 97       	sbiw	r30, 0x01	; 1
    188a:	f1 f7       	brne	.-4      	; 0x1888 <LCD_PutStr+0x36>
    188c:	00 c0       	rjmp	.+0      	; 0x188e <LCD_PutStr+0x3c>
    188e:	00 00       	nop
/*
	Send an ASCII string to the LCD
*/
void LCD_PutStr(char *lcd_str) {
	uint8_t count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1890:	9f 5f       	subi	r25, 0xFF	; 255
    1892:	29 2f       	mov	r18, r25
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	fd 01       	movw	r30, r26
    1898:	01 90       	ld	r0, Z+
    189a:	00 20       	and	r0, r0
    189c:	e9 f7       	brne	.-6      	; 0x1898 <LCD_PutStr+0x46>
    189e:	ea 1b       	sub	r30, r26
    18a0:	fb 0b       	sbc	r31, r27
    18a2:	32 97       	sbiw	r30, 0x02	; 2
    18a4:	e2 17       	cp	r30, r18
    18a6:	f3 07       	cpc	r31, r19
    18a8:	c8 f6       	brcc	.-78     	; 0x185c <LCD_PutStr+0xa>
		LCD_DATA(lcd_str[count]);
	}
}
    18aa:	08 95       	ret

000018ac <LCD_SPIInit>:

void LCD_SPIInit(void) {
	DDRF |= 0x08;  //port F bit 3 is enable for LCD
    18ac:	e1 e6       	ldi	r30, 0x61	; 97
    18ae:	f0 e0       	ldi	r31, 0x00	; 0
    18b0:	80 81       	ld	r24, Z
    18b2:	88 60       	ori	r24, 0x08	; 8
    18b4:	80 83       	st	Z, r24
	PORTB |= 0x00; //port B initialization for SPI
    18b6:	88 b3       	in	r24, 0x18	; 24
    18b8:	88 bb       	out	0x18, r24	; 24
	DDRB |= 0x07;  //Turn on SS, MOSI, SCLK
    18ba:	87 b3       	in	r24, 0x17	; 23
    18bc:	87 60       	ori	r24, 0x07	; 7
    18be:	87 bb       	out	0x17, r24	; 23
	//Master mode, Clock=clk/2, Cycle half phase, Low polarity, MSB first
	SPCR = 0x50;
    18c0:	80 e5       	ldi	r24, 0x50	; 80
    18c2:	8d b9       	out	0x0d, r24	; 13
    18c4:	08 95       	ret

000018c6 <LCD_Init>:
    18c6:	80 91 61 00 	lds	r24, 0x0061
    18ca:	88 60       	ori	r24, 0x08	; 8
    18cc:	80 93 61 00 	sts	0x0061, r24
    18d0:	88 b3       	in	r24, 0x18	; 24
    18d2:	88 bb       	out	0x18, r24	; 24
    18d4:	87 b3       	in	r24, 0x17	; 23
    18d6:	87 60       	ori	r24, 0x07	; 7
    18d8:	87 bb       	out	0x17, r24	; 23
    18da:	80 e5       	ldi	r24, 0x50	; 80
    18dc:	8d b9       	out	0x0d, r24	; 13
    18de:	80 91 61 00 	lds	r24, 0x0061
    18e2:	88 60       	ori	r24, 0x08	; 8
    18e4:	80 93 61 00 	sts	0x0061, r24
    18e8:	8f e5       	ldi	r24, 0x5F	; 95
    18ea:	9a ee       	ldi	r25, 0xEA	; 234
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	f1 f7       	brne	.-4      	; 0x18ec <LCD_Init+0x26>
    18f0:	00 c0       	rjmp	.+0      	; 0x18f2 <LCD_Init+0x2c>
    18f2:	00 00       	nop
    18f4:	1f b8       	out	0x0f, r1	; 15
    18f6:	77 9b       	sbis	0x0e, 7	; 14
    18f8:	fe cf       	rjmp	.-4      	; 0x18f6 <LCD_Init+0x30>
    18fa:	88 e3       	ldi	r24, 0x38	; 56
    18fc:	8f b9       	out	0x0f, r24	; 15
    18fe:	77 9b       	sbis	0x0e, 7	; 14
    1900:	fe cf       	rjmp	.-4      	; 0x18fe <LCD_Init+0x38>
    1902:	80 91 62 00 	lds	r24, 0x0062
    1906:	88 60       	ori	r24, 0x08	; 8
    1908:	80 93 62 00 	sts	0x0062, r24
    190c:	80 91 62 00 	lds	r24, 0x0062
    1910:	87 7f       	andi	r24, 0xF7	; 247
    1912:	80 93 62 00 	sts	0x0062, r24
    1916:	8f e8       	ldi	r24, 0x8F	; 143
    1918:	91 e0       	ldi	r25, 0x01	; 1
    191a:	01 97       	sbiw	r24, 0x01	; 1
    191c:	f1 f7       	brne	.-4      	; 0x191a <LCD_Init+0x54>
    191e:	00 c0       	rjmp	.+0      	; 0x1920 <LCD_Init+0x5a>
    1920:	00 00       	nop
    1922:	8f e1       	ldi	r24, 0x1F	; 31
    1924:	9e e4       	ldi	r25, 0x4E	; 78
    1926:	01 97       	sbiw	r24, 0x01	; 1
    1928:	f1 f7       	brne	.-4      	; 0x1926 <LCD_Init+0x60>
    192a:	00 c0       	rjmp	.+0      	; 0x192c <LCD_Init+0x66>
    192c:	00 00       	nop
    192e:	1f b8       	out	0x0f, r1	; 15
    1930:	77 9b       	sbis	0x0e, 7	; 14
    1932:	fe cf       	rjmp	.-4      	; 0x1930 <LCD_Init+0x6a>
    1934:	88 e0       	ldi	r24, 0x08	; 8
    1936:	8f b9       	out	0x0f, r24	; 15
    1938:	77 9b       	sbis	0x0e, 7	; 14
    193a:	fe cf       	rjmp	.-4      	; 0x1938 <LCD_Init+0x72>
    193c:	80 91 62 00 	lds	r24, 0x0062
    1940:	88 60       	ori	r24, 0x08	; 8
    1942:	80 93 62 00 	sts	0x0062, r24
    1946:	80 91 62 00 	lds	r24, 0x0062
    194a:	87 7f       	andi	r24, 0xF7	; 247
    194c:	80 93 62 00 	sts	0x0062, r24
    1950:	8f e8       	ldi	r24, 0x8F	; 143
    1952:	91 e0       	ldi	r25, 0x01	; 1
    1954:	01 97       	sbiw	r24, 0x01	; 1
    1956:	f1 f7       	brne	.-4      	; 0x1954 <LCD_Init+0x8e>
    1958:	00 c0       	rjmp	.+0      	; 0x195a <LCD_Init+0x94>
    195a:	00 00       	nop
    195c:	8f e3       	ldi	r24, 0x3F	; 63
    195e:	9f e1       	ldi	r25, 0x1F	; 31
    1960:	01 97       	sbiw	r24, 0x01	; 1
    1962:	f1 f7       	brne	.-4      	; 0x1960 <LCD_Init+0x9a>
    1964:	00 c0       	rjmp	.+0      	; 0x1966 <LCD_Init+0xa0>
    1966:	00 00       	nop
    1968:	1f b8       	out	0x0f, r1	; 15
    196a:	77 9b       	sbis	0x0e, 7	; 14
    196c:	fe cf       	rjmp	.-4      	; 0x196a <LCD_Init+0xa4>
    196e:	86 e0       	ldi	r24, 0x06	; 6
    1970:	8f b9       	out	0x0f, r24	; 15
    1972:	77 9b       	sbis	0x0e, 7	; 14
    1974:	fe cf       	rjmp	.-4      	; 0x1972 <LCD_Init+0xac>
    1976:	80 91 62 00 	lds	r24, 0x0062
    197a:	88 60       	ori	r24, 0x08	; 8
    197c:	80 93 62 00 	sts	0x0062, r24
    1980:	80 91 62 00 	lds	r24, 0x0062
    1984:	87 7f       	andi	r24, 0xF7	; 247
    1986:	80 93 62 00 	sts	0x0062, r24
    198a:	8f e8       	ldi	r24, 0x8F	; 143
    198c:	91 e0       	ldi	r25, 0x01	; 1
    198e:	01 97       	sbiw	r24, 0x01	; 1
    1990:	f1 f7       	brne	.-4      	; 0x198e <LCD_Init+0xc8>
    1992:	00 c0       	rjmp	.+0      	; 0x1994 <LCD_Init+0xce>
    1994:	00 00       	nop
    1996:	1f b8       	out	0x0f, r1	; 15
    1998:	77 9b       	sbis	0x0e, 7	; 14
    199a:	fe cf       	rjmp	.-4      	; 0x1998 <LCD_Init+0xd2>
    199c:	80 e4       	ldi	r24, 0x40	; 64
    199e:	8f b9       	out	0x0f, r24	; 15
    19a0:	77 9b       	sbis	0x0e, 7	; 14
    19a2:	fe cf       	rjmp	.-4      	; 0x19a0 <LCD_Init+0xda>
    19a4:	80 91 62 00 	lds	r24, 0x0062
    19a8:	88 60       	ori	r24, 0x08	; 8
    19aa:	80 93 62 00 	sts	0x0062, r24
    19ae:	80 91 62 00 	lds	r24, 0x0062
    19b2:	87 7f       	andi	r24, 0xF7	; 247
    19b4:	80 93 62 00 	sts	0x0062, r24
    19b8:	8f e8       	ldi	r24, 0x8F	; 143
    19ba:	91 e0       	ldi	r25, 0x01	; 1
    19bc:	01 97       	sbiw	r24, 0x01	; 1
    19be:	f1 f7       	brne	.-4      	; 0x19bc <LCD_Init+0xf6>
    19c0:	00 c0       	rjmp	.+0      	; 0x19c2 <LCD_Init+0xfc>
    19c2:	00 00       	nop
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	8f b9       	out	0x0f, r24	; 15
    19c8:	77 9b       	sbis	0x0e, 7	; 14
    19ca:	fe cf       	rjmp	.-4      	; 0x19c8 <LCD_Init+0x102>
    19cc:	8e e0       	ldi	r24, 0x0E	; 14
    19ce:	8f b9       	out	0x0f, r24	; 15
    19d0:	77 9b       	sbis	0x0e, 7	; 14
    19d2:	fe cf       	rjmp	.-4      	; 0x19d0 <LCD_Init+0x10a>
    19d4:	80 91 62 00 	lds	r24, 0x0062
    19d8:	88 60       	ori	r24, 0x08	; 8
    19da:	80 93 62 00 	sts	0x0062, r24
    19de:	80 91 62 00 	lds	r24, 0x0062
    19e2:	87 7f       	andi	r24, 0xF7	; 247
    19e4:	80 93 62 00 	sts	0x0062, r24
    19e8:	8f e8       	ldi	r24, 0x8F	; 143
    19ea:	91 e0       	ldi	r25, 0x01	; 1
    19ec:	01 97       	sbiw	r24, 0x01	; 1
    19ee:	f1 f7       	brne	.-4      	; 0x19ec <LCD_Init+0x126>
    19f0:	00 c0       	rjmp	.+0      	; 0x19f2 <LCD_Init+0x12c>
    19f2:	00 00       	nop
    19f4:	81 e0       	ldi	r24, 0x01	; 1
    19f6:	8f b9       	out	0x0f, r24	; 15
    19f8:	77 9b       	sbis	0x0e, 7	; 14
    19fa:	fe cf       	rjmp	.-4      	; 0x19f8 <LCD_Init+0x132>
    19fc:	8b e1       	ldi	r24, 0x1B	; 27
    19fe:	8f b9       	out	0x0f, r24	; 15
    1a00:	77 9b       	sbis	0x0e, 7	; 14
    1a02:	fe cf       	rjmp	.-4      	; 0x1a00 <LCD_Init+0x13a>
    1a04:	80 91 62 00 	lds	r24, 0x0062
    1a08:	88 60       	ori	r24, 0x08	; 8
    1a0a:	80 93 62 00 	sts	0x0062, r24
    1a0e:	80 91 62 00 	lds	r24, 0x0062
    1a12:	87 7f       	andi	r24, 0xF7	; 247
    1a14:	80 93 62 00 	sts	0x0062, r24
    1a18:	8f e8       	ldi	r24, 0x8F	; 143
    1a1a:	91 e0       	ldi	r25, 0x01	; 1
    1a1c:	01 97       	sbiw	r24, 0x01	; 1
    1a1e:	f1 f7       	brne	.-4      	; 0x1a1c <LCD_Init+0x156>
    1a20:	00 c0       	rjmp	.+0      	; 0x1a22 <LCD_Init+0x15c>
    1a22:	00 00       	nop
    1a24:	81 e0       	ldi	r24, 0x01	; 1
    1a26:	8f b9       	out	0x0f, r24	; 15
    1a28:	77 9b       	sbis	0x0e, 7	; 14
    1a2a:	fe cf       	rjmp	.-4      	; 0x1a28 <LCD_Init+0x162>
    1a2c:	81 e1       	ldi	r24, 0x11	; 17
    1a2e:	8f b9       	out	0x0f, r24	; 15
    1a30:	77 9b       	sbis	0x0e, 7	; 14
    1a32:	fe cf       	rjmp	.-4      	; 0x1a30 <LCD_Init+0x16a>
    1a34:	80 91 62 00 	lds	r24, 0x0062
    1a38:	88 60       	ori	r24, 0x08	; 8
    1a3a:	80 93 62 00 	sts	0x0062, r24
    1a3e:	80 91 62 00 	lds	r24, 0x0062
    1a42:	87 7f       	andi	r24, 0xF7	; 247
    1a44:	80 93 62 00 	sts	0x0062, r24
    1a48:	8f e8       	ldi	r24, 0x8F	; 143
    1a4a:	91 e0       	ldi	r25, 0x01	; 1
    1a4c:	01 97       	sbiw	r24, 0x01	; 1
    1a4e:	f1 f7       	brne	.-4      	; 0x1a4c <LCD_Init+0x186>
    1a50:	00 c0       	rjmp	.+0      	; 0x1a52 <LCD_Init+0x18c>
    1a52:	00 00       	nop
    1a54:	81 e0       	ldi	r24, 0x01	; 1
    1a56:	8f b9       	out	0x0f, r24	; 15
    1a58:	77 9b       	sbis	0x0e, 7	; 14
    1a5a:	fe cf       	rjmp	.-4      	; 0x1a58 <LCD_Init+0x192>
    1a5c:	81 e1       	ldi	r24, 0x11	; 17
    1a5e:	8f b9       	out	0x0f, r24	; 15
    1a60:	77 9b       	sbis	0x0e, 7	; 14
    1a62:	fe cf       	rjmp	.-4      	; 0x1a60 <LCD_Init+0x19a>
    1a64:	80 91 62 00 	lds	r24, 0x0062
    1a68:	88 60       	ori	r24, 0x08	; 8
    1a6a:	80 93 62 00 	sts	0x0062, r24
    1a6e:	80 91 62 00 	lds	r24, 0x0062
    1a72:	87 7f       	andi	r24, 0xF7	; 247
    1a74:	80 93 62 00 	sts	0x0062, r24
    1a78:	8f e8       	ldi	r24, 0x8F	; 143
    1a7a:	91 e0       	ldi	r25, 0x01	; 1
    1a7c:	01 97       	sbiw	r24, 0x01	; 1
    1a7e:	f1 f7       	brne	.-4      	; 0x1a7c <LCD_Init+0x1b6>
    1a80:	00 c0       	rjmp	.+0      	; 0x1a82 <LCD_Init+0x1bc>
    1a82:	00 00       	nop
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	8f b9       	out	0x0f, r24	; 15
    1a88:	77 9b       	sbis	0x0e, 7	; 14
    1a8a:	fe cf       	rjmp	.-4      	; 0x1a88 <LCD_Init+0x1c2>
    1a8c:	81 e1       	ldi	r24, 0x11	; 17
    1a8e:	8f b9       	out	0x0f, r24	; 15
    1a90:	77 9b       	sbis	0x0e, 7	; 14
    1a92:	fe cf       	rjmp	.-4      	; 0x1a90 <LCD_Init+0x1ca>
    1a94:	80 91 62 00 	lds	r24, 0x0062
    1a98:	88 60       	ori	r24, 0x08	; 8
    1a9a:	80 93 62 00 	sts	0x0062, r24
    1a9e:	80 91 62 00 	lds	r24, 0x0062
    1aa2:	87 7f       	andi	r24, 0xF7	; 247
    1aa4:	80 93 62 00 	sts	0x0062, r24
    1aa8:	8f e8       	ldi	r24, 0x8F	; 143
    1aaa:	91 e0       	ldi	r25, 0x01	; 1
    1aac:	01 97       	sbiw	r24, 0x01	; 1
    1aae:	f1 f7       	brne	.-4      	; 0x1aac <LCD_Init+0x1e6>
    1ab0:	00 c0       	rjmp	.+0      	; 0x1ab2 <LCD_Init+0x1ec>
    1ab2:	00 00       	nop
    1ab4:	81 e0       	ldi	r24, 0x01	; 1
    1ab6:	8f b9       	out	0x0f, r24	; 15
    1ab8:	77 9b       	sbis	0x0e, 7	; 14
    1aba:	fe cf       	rjmp	.-4      	; 0x1ab8 <LCD_Init+0x1f2>
    1abc:	81 e1       	ldi	r24, 0x11	; 17
    1abe:	8f b9       	out	0x0f, r24	; 15
    1ac0:	77 9b       	sbis	0x0e, 7	; 14
    1ac2:	fe cf       	rjmp	.-4      	; 0x1ac0 <LCD_Init+0x1fa>
    1ac4:	80 91 62 00 	lds	r24, 0x0062
    1ac8:	88 60       	ori	r24, 0x08	; 8
    1aca:	80 93 62 00 	sts	0x0062, r24
    1ace:	80 91 62 00 	lds	r24, 0x0062
    1ad2:	87 7f       	andi	r24, 0xF7	; 247
    1ad4:	80 93 62 00 	sts	0x0062, r24
    1ad8:	8f e8       	ldi	r24, 0x8F	; 143
    1ada:	91 e0       	ldi	r25, 0x01	; 1
    1adc:	01 97       	sbiw	r24, 0x01	; 1
    1ade:	f1 f7       	brne	.-4      	; 0x1adc <LCD_Init+0x216>
    1ae0:	00 c0       	rjmp	.+0      	; 0x1ae2 <LCD_Init+0x21c>
    1ae2:	00 00       	nop
    1ae4:	81 e0       	ldi	r24, 0x01	; 1
    1ae6:	8f b9       	out	0x0f, r24	; 15
    1ae8:	77 9b       	sbis	0x0e, 7	; 14
    1aea:	fe cf       	rjmp	.-4      	; 0x1ae8 <LCD_Init+0x222>
    1aec:	81 e1       	ldi	r24, 0x11	; 17
    1aee:	8f b9       	out	0x0f, r24	; 15
    1af0:	77 9b       	sbis	0x0e, 7	; 14
    1af2:	fe cf       	rjmp	.-4      	; 0x1af0 <LCD_Init+0x22a>
    1af4:	80 91 62 00 	lds	r24, 0x0062
    1af8:	88 60       	ori	r24, 0x08	; 8
    1afa:	80 93 62 00 	sts	0x0062, r24
    1afe:	80 91 62 00 	lds	r24, 0x0062
    1b02:	87 7f       	andi	r24, 0xF7	; 247
    1b04:	80 93 62 00 	sts	0x0062, r24
    1b08:	8f e8       	ldi	r24, 0x8F	; 143
    1b0a:	91 e0       	ldi	r25, 0x01	; 1
    1b0c:	01 97       	sbiw	r24, 0x01	; 1
    1b0e:	f1 f7       	brne	.-4      	; 0x1b0c <LCD_Init+0x246>
    1b10:	00 c0       	rjmp	.+0      	; 0x1b12 <LCD_Init+0x24c>
    1b12:	00 00       	nop
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	8f b9       	out	0x0f, r24	; 15
    1b18:	77 9b       	sbis	0x0e, 7	; 14
    1b1a:	fe cf       	rjmp	.-4      	; 0x1b18 <LCD_Init+0x252>
    1b1c:	8f e1       	ldi	r24, 0x1F	; 31
    1b1e:	8f b9       	out	0x0f, r24	; 15
    1b20:	77 9b       	sbis	0x0e, 7	; 14
    1b22:	fe cf       	rjmp	.-4      	; 0x1b20 <LCD_Init+0x25a>
    1b24:	80 91 62 00 	lds	r24, 0x0062
    1b28:	88 60       	ori	r24, 0x08	; 8
    1b2a:	80 93 62 00 	sts	0x0062, r24
    1b2e:	80 91 62 00 	lds	r24, 0x0062
    1b32:	87 7f       	andi	r24, 0xF7	; 247
    1b34:	80 93 62 00 	sts	0x0062, r24
    1b38:	8f e8       	ldi	r24, 0x8F	; 143
    1b3a:	91 e0       	ldi	r25, 0x01	; 1
    1b3c:	01 97       	sbiw	r24, 0x01	; 1
    1b3e:	f1 f7       	brne	.-4      	; 0x1b3c <LCD_Init+0x276>
    1b40:	00 c0       	rjmp	.+0      	; 0x1b42 <LCD_Init+0x27c>
    1b42:	00 00       	nop
    1b44:	1f b8       	out	0x0f, r1	; 15
    1b46:	77 9b       	sbis	0x0e, 7	; 14
    1b48:	fe cf       	rjmp	.-4      	; 0x1b46 <LCD_Init+0x280>
    1b4a:	81 e0       	ldi	r24, 0x01	; 1
    1b4c:	8f b9       	out	0x0f, r24	; 15
    1b4e:	77 9b       	sbis	0x0e, 7	; 14
    1b50:	fe cf       	rjmp	.-4      	; 0x1b4e <LCD_Init+0x288>
    1b52:	80 91 62 00 	lds	r24, 0x0062
    1b56:	88 60       	ori	r24, 0x08	; 8
    1b58:	80 93 62 00 	sts	0x0062, r24
    1b5c:	80 91 62 00 	lds	r24, 0x0062
    1b60:	87 7f       	andi	r24, 0xF7	; 247
    1b62:	80 93 62 00 	sts	0x0062, r24
    1b66:	8f e8       	ldi	r24, 0x8F	; 143
    1b68:	91 e0       	ldi	r25, 0x01	; 1
    1b6a:	01 97       	sbiw	r24, 0x01	; 1
    1b6c:	f1 f7       	brne	.-4      	; 0x1b6a <LCD_Init+0x2a4>
    1b6e:	00 c0       	rjmp	.+0      	; 0x1b70 <LCD_Init+0x2aa>
    1b70:	00 00       	nop
    1b72:	8f e1       	ldi	r24, 0x1F	; 31
    1b74:	9e e4       	ldi	r25, 0x4E	; 78
    1b76:	01 97       	sbiw	r24, 0x01	; 1
    1b78:	f1 f7       	brne	.-4      	; 0x1b76 <LCD_Init+0x2b0>
    1b7a:	00 c0       	rjmp	.+0      	; 0x1b7c <LCD_Init+0x2b6>
    1b7c:	00 00       	nop
    1b7e:	1f b8       	out	0x0f, r1	; 15
    1b80:	77 9b       	sbis	0x0e, 7	; 14
    1b82:	fe cf       	rjmp	.-4      	; 0x1b80 <LCD_Init+0x2ba>
    1b84:	8c e0       	ldi	r24, 0x0C	; 12
    1b86:	8f b9       	out	0x0f, r24	; 15
    1b88:	77 9b       	sbis	0x0e, 7	; 14
    1b8a:	fe cf       	rjmp	.-4      	; 0x1b88 <LCD_Init+0x2c2>
    1b8c:	80 91 62 00 	lds	r24, 0x0062
    1b90:	88 60       	ori	r24, 0x08	; 8
    1b92:	80 93 62 00 	sts	0x0062, r24
    1b96:	80 91 62 00 	lds	r24, 0x0062
    1b9a:	87 7f       	andi	r24, 0xF7	; 247
    1b9c:	80 93 62 00 	sts	0x0062, r24
    1ba0:	8f e8       	ldi	r24, 0x8F	; 143
    1ba2:	91 e0       	ldi	r25, 0x01	; 1
    1ba4:	01 97       	sbiw	r24, 0x01	; 1
    1ba6:	f1 f7       	brne	.-4      	; 0x1ba4 <LCD_Init+0x2de>
    1ba8:	00 c0       	rjmp	.+0      	; 0x1baa <LCD_Init+0x2e4>
    1baa:	00 00       	nop
    1bac:	08 95       	ret

00001bae <main>:

int main()
{
    //set port bits 4-7 B as outputs
    //uint8_t c = 0;
    DDRE = 0xc0;
    1bae:	80 ec       	ldi	r24, 0xC0	; 192
    1bb0:	82 b9       	out	0x02, r24	; 2
    PORTE &= 0x7F;
    1bb2:	1f 98       	cbi	0x03, 7	; 3
    DDRB = 0xF7;
    1bb4:	87 ef       	ldi	r24, 0xF7	; 247
    1bb6:	87 bb       	out	0x17, r24	; 23
    DDRD |= (1 << PB2);
    1bb8:	8a 9a       	sbi	0x11, 2	; 17

    volume = 100;
    1bba:	84 e6       	ldi	r24, 0x64	; 100
    1bbc:	80 93 2b 01 	sts	0x012B, r24
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
    TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1bc0:	83 b7       	in	r24, 0x33	; 51
    1bc2:	81 60       	ori	r24, 0x01	; 1
    1bc4:	83 bf       	out	0x33, r24	; 51
    ASSR  |= (1<<AS0);
    1bc6:	80 b7       	in	r24, 0x30	; 48
    1bc8:	88 60       	ori	r24, 0x08	; 8
    1bca:	80 bf       	out	0x30, r24	; 48
    TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1bcc:	85 b5       	in	r24, 0x25	; 37
    1bce:	8a 67       	ori	r24, 0x7A	; 122
    1bd0:	85 bd       	out	0x25, r24	; 37
    TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1bd2:	87 b7       	in	r24, 0x37	; 55
    1bd4:	81 64       	ori	r24, 0x41	; 65
    1bd6:	87 bf       	out	0x37, r24	; 55
}


void ADC_init(void){
    DDRF |= !(1<<PF0);
    1bd8:	80 91 61 00 	lds	r24, 0x0061
    1bdc:	80 93 61 00 	sts	0x0061, r24
    PORTF = 0x00;
    1be0:	10 92 62 00 	sts	0x0062, r1
    ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1be4:	87 b1       	in	r24, 0x07	; 7
    1be6:	80 66       	ori	r24, 0x60	; 96
    1be8:	87 b9       	out	0x07, r24	; 7
    ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1bea:	86 b1       	in	r24, 0x06	; 6
    1bec:	8f 6e       	ori	r24, 0xEF	; 239
    1bee:	86 b9       	out	0x06, r24	; 6
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    OCR2 = 0xFF;
    1bf0:	8f ef       	ldi	r24, 0xFF	; 255
    1bf2:	83 bd       	out	0x23, r24	; 35
    DDRD |= (1 << PB2);

    volume = 100;
    timer_init();
    ADC_init();
    music_init();   
    1bf4:	0e 94 11 05 	call	0xa22	; 0xa22 <music_init>
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR);
    1bf8:	80 e5       	ldi	r24, 0x50	; 80
    1bfa:	8d b9       	out	0x0d, r24	; 13
    timer_init();
    ADC_init();
    music_init();   
    SPI_init();
    //LCD_SPIInit();
    LCD_Init();
    1bfc:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <LCD_Init>
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    OCR2 = 0xFF;
}

void volume_control_init(void){
    DDRE |= (1<<PE3);
    1c00:	13 9a       	sbi	0x02, 3	; 2
    TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1c02:	81 e8       	ldi	r24, 0x81	; 129
    1c04:	80 93 8b 00 	sts	0x008B, r24
    TCCR3B = (1<<WGM32) | (1<<CS30);
    1c08:	89 e0       	ldi	r24, 0x09	; 9
    1c0a:	80 93 8a 00 	sts	0x008A, r24
    OCR3A = volume;
    1c0e:	80 91 2b 01 	lds	r24, 0x012B
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	90 93 87 00 	sts	0x0087, r25
    1c18:	80 93 86 00 	sts	0x0086, r24
    LCD_Init();
    volume_control_init();
    // lcd_init();
    // clear_display();
    // string2lcd("hello");
    sei();
    1c1c:	78 94       	sei
    while(1){
	display_update();
    1c1e:	0e 94 55 08 	call	0x10aa	; 0x10aa <display_update>
	update_time();
    1c22:	0e 94 01 07 	call	0xe02	; 0xe02 <update_time>
        if(update_LCD){
    1c26:	80 91 3b 01 	lds	r24, 0x013B
    1c2a:	88 23       	and	r24, r24
    1c2c:	c1 f3       	breq	.-16     	; 0x1c1e <main+0x70>
	    LCD_Clr();
    1c2e:	0e 94 25 0a 	call	0x144a	; 0x144a <LCD_Clr>
	    if(alarm_on){
    1c32:	80 91 2d 01 	lds	r24, 0x012D
    1c36:	88 23       	and	r24, r24
    1c38:	39 f0       	breq	.+14     	; 0x1c48 <main+0x9a>
		LCD_PutStr("ALARM ON!!");
    1c3a:	82 e1       	ldi	r24, 0x12	; 18
    1c3c:	91 e0       	ldi	r25, 0x01	; 1
    1c3e:	0e 94 29 0c 	call	0x1852	; 0x1852 <LCD_PutStr>
	    }
	    else{
		LCD_PutStr("ALARM OFF!!");
	    }
	    update_LCD = 0;
    1c42:	10 92 3b 01 	sts	0x013B, r1
    1c46:	eb cf       	rjmp	.-42     	; 0x1c1e <main+0x70>
	    LCD_Clr();
	    if(alarm_on){
		LCD_PutStr("ALARM ON!!");
	    }
	    else{
		LCD_PutStr("ALARM OFF!!");
    1c48:	8d e1       	ldi	r24, 0x1D	; 29
    1c4a:	91 e0       	ldi	r25, 0x01	; 1
    1c4c:	0e 94 29 0c 	call	0x1852	; 0x1852 <LCD_PutStr>
    1c50:	f8 cf       	rjmp	.-16     	; 0x1c42 <main+0x94>

00001c52 <__tablejump2__>:
    1c52:	ee 0f       	add	r30, r30
    1c54:	ff 1f       	adc	r31, r31

00001c56 <__tablejump__>:
    1c56:	05 90       	lpm	r0, Z+
    1c58:	f4 91       	lpm	r31, Z
    1c5a:	e0 2d       	mov	r30, r0
    1c5c:	09 94       	ijmp

00001c5e <__umulhisi3>:
    1c5e:	a2 9f       	mul	r26, r18
    1c60:	b0 01       	movw	r22, r0
    1c62:	b3 9f       	mul	r27, r19
    1c64:	c0 01       	movw	r24, r0
    1c66:	a3 9f       	mul	r26, r19
    1c68:	70 0d       	add	r23, r0
    1c6a:	81 1d       	adc	r24, r1
    1c6c:	11 24       	eor	r1, r1
    1c6e:	91 1d       	adc	r25, r1
    1c70:	b2 9f       	mul	r27, r18
    1c72:	70 0d       	add	r23, r0
    1c74:	81 1d       	adc	r24, r1
    1c76:	11 24       	eor	r1, r1
    1c78:	91 1d       	adc	r25, r1
    1c7a:	08 95       	ret

00001c7c <_exit>:
    1c7c:	f8 94       	cli

00001c7e <__stop_program>:
    1c7e:	ff cf       	rjmp	.-2      	; 0x1c7e <__stop_program>
