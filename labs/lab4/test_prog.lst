
test_prog.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002a  00800100  00001c98  00001d2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001c98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000052  0080012a  0080012a  00001d56  2**0
                  ALLOC
  3 .stab         00004284  00000000  00000000  00001d58  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001586  00000000  00000000  00005fdc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00007562  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 dc 00 	jmp	0x1b8	; 0x1b8 <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 c0 09 	jmp	0x1380	; 0x1380 <__vector_10>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 a2 06 	jmp	0xd44	; 0xd44 <__vector_12>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__vector_16>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 e3 06 	jmp	0xdc6	; 0xdc6 <__vector_21>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      80:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      84:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      88:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      8c:	37 01       	movw	r6, r14
      8e:	3f 01       	movw	r6, r30
      90:	47 01       	movw	r8, r14
      92:	4f 01       	movw	r8, r30
      94:	57 01       	movw	r10, r14
      96:	60 01       	movw	r12, r0
      98:	69 01       	movw	r12, r18
      9a:	27 01       	movw	r4, r14
      9c:	2f 01       	movw	r4, r30
      9e:	bd 02       	muls	r27, r29
      a0:	b5 02       	muls	r27, r21
      a2:	b0 02       	muls	r27, r16
      a4:	da 02       	muls	r29, r26
      a6:	cd 02       	muls	r28, r29
      a8:	d5 02       	muls	r29, r21
      aa:	c5 02       	muls	r28, r21
      ac:	8e 02       	muls	r24, r30
      ae:	86 02       	muls	r24, r22
      b0:	81 02       	muls	r24, r17
      b2:	79 02       	muls	r23, r25
      b4:	e2 02       	muls	r30, r18
      b6:	96 02       	muls	r25, r22
      b8:	6c 02       	muls	r22, r28
      ba:	54 02       	muls	r21, r20
      bc:	02 03       	mulsu	r16, r18
      be:	ab 02       	muls	r26, r27
      c0:	a3 02       	muls	r26, r19
      c2:	9b 02       	muls	r25, r27
      c4:	22 03       	mulsu	r18, r18
      c6:	5c 02       	muls	r21, r28
      c8:	12 03       	mulsu	r17, r18
      ca:	64 02       	muls	r22, r20
      cc:	2f 03       	fmul	r18, r23
      ce:	fa 02       	muls	r31, r26
      d0:	1a 03       	fmul	r17, r18
      d2:	74 02       	muls	r23, r20
      d4:	f2 02       	muls	r31, r18
      d6:	ea 02       	muls	r30, r26
      d8:	0a 03       	fmul	r16, r18
      da:	4f 02       	muls	r20, r31
      dc:	1d 02       	muls	r17, r29
      de:	15 02       	muls	r17, r21
      e0:	25 02       	muls	r18, r21
      e2:	27 03       	mulsu	r18, r23
      e4:	08 02       	muls	r16, r24
      e6:	00 02       	muls	r16, r16
      e8:	2a 02       	muls	r18, r26
      ea:	e3 01       	movw	r28, r6
      ec:	47 02       	muls	r20, r23
      ee:	10 02       	muls	r17, r16
      f0:	f3 01       	movw	r30, r6
      f2:	eb 01       	movw	r28, r22
      f4:	37 02       	muls	r19, r23
      f6:	fb 01       	movw	r30, r22
      f8:	2f 02       	muls	r18, r31
      fa:	db 01       	movw	r26, r22
      fc:	c1 01       	movw	r24, r2
      fe:	3f 02       	muls	r19, r31
     100:	b1 01       	movw	r22, r2
     102:	a9 01       	movw	r20, r18
     104:	ce 01       	movw	r24, r28
     106:	c6 01       	movw	r24, r12
     108:	d3 01       	movw	r26, r6
     10a:	a4 01       	movw	r20, r8
     10c:	b9 01       	movw	r22, r18
     10e:	8c 01       	movw	r16, r24
     110:	9c 01       	movw	r18, r24
     112:	87 01       	movw	r16, r14
     114:	7f 01       	movw	r14, r30
     116:	77 01       	movw	r14, r14
     118:	72 01       	movw	r14, r4
     11a:	94 01       	movw	r18, r8
     11c:	39 04       	cpc	r3, r9
     11e:	57 04       	cpc	r5, r7
     120:	33 04       	cpc	r3, r3
     122:	45 04       	cpc	r4, r5
     124:	27 04       	cpc	r2, r7
     126:	2d 04       	cpc	r2, r13
     128:	27 04       	cpc	r2, r7
     12a:	2d 04       	cpc	r2, r13
     12c:	5d 04       	cpc	r5, r13
     12e:	39 04       	cpc	r3, r9
     130:	57 04       	cpc	r5, r7
     132:	33 04       	cpc	r3, r3
     134:	45 04       	cpc	r4, r5
     136:	3f 04       	cpc	r3, r15
     138:	21 04       	cpc	r2, r1
     13a:	3f 04       	cpc	r3, r15
     13c:	21 04       	cpc	r2, r1
     13e:	87 04       	cpc	r8, r7
     140:	c3 04       	cpc	r12, r3
     142:	7b 04       	cpc	r7, r11
     144:	f3 04       	cpc	r15, r3
     146:	7b 04       	cpc	r7, r11
     148:	b7 04       	cpc	r11, r7
     14a:	b1 04       	cpc	r11, r1
     14c:	21 04       	cpc	r2, r1
     14e:	8d 04       	cpc	r8, r13
     150:	21 04       	cpc	r2, r1
     152:	9f 04       	cpc	r9, r15
     154:	4b 04       	cpc	r4, r11
     156:	e1 04       	cpc	r14, r1
     158:	27 04       	cpc	r2, r7
     15a:	d5 04       	cpc	r13, r5
     15c:	63 04       	cpc	r6, r3
     15e:	db 04       	cpc	r13, r11
     160:	69 04       	cpc	r6, r9
     162:	e7 04       	cpc	r14, r7
     164:	ab 04       	cpc	r10, r11
     166:	51 04       	cpc	r5, r1
     168:	4b 04       	cpc	r4, r11
     16a:	93 04       	cpc	r9, r3
     16c:	6f 04       	cpc	r6, r15
     16e:	39 04       	cpc	r3, r9
     170:	57 04       	cpc	r5, r7
     172:	33 04       	cpc	r3, r3
     174:	45 04       	cpc	r4, r5
     176:	27 04       	cpc	r2, r7
     178:	2d 04       	cpc	r2, r13
     17a:	27 04       	cpc	r2, r7
     17c:	2d 04       	cpc	r2, r13
     17e:	5d 04       	cpc	r5, r13
     180:	39 04       	cpc	r3, r9
     182:	bd 04       	cpc	r11, r13
     184:	51 04       	cpc	r5, r1
     186:	33 04       	cpc	r3, r3
     188:	3f 04       	cpc	r3, r15
     18a:	21 04       	cpc	r2, r1
     18c:	3f 04       	cpc	r3, r15
     18e:	21 04       	cpc	r2, r1
     190:	87 04       	cpc	r8, r7
     192:	c9 04       	cpc	r12, r9
     194:	99 04       	cpc	r9, r9
     196:	5d 04       	cpc	r5, r13
     198:	cf 04       	cpc	r12, r15
     19a:	8d 04       	cpc	r8, r13
     19c:	63 04       	cpc	r6, r3
     19e:	69 04       	cpc	r6, r9
     1a0:	4b 04       	cpc	r4, r11
     1a2:	51 04       	cpc	r5, r1
     1a4:	ed 04       	cpc	r14, r13
     1a6:	6f 04       	cpc	r6, r15
     1a8:	0f 08       	sbc	r0, r15
     1aa:	0b 08       	sbc	r0, r11
     1ac:	14 08       	sbc	r1, r4
     1ae:	38 08       	sbc	r3, r8
     1b0:	fb 07       	cpc	r31, r27
     1b2:	2e 08       	sbc	r2, r14
     1b4:	1d 08       	sbc	r1, r13
     1b6:	ef 07       	cpc	r30, r31

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d0 e1       	ldi	r29, 0x10	; 16
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61

000001c4 <__do_copy_data>:
     1c4:	11 e0       	ldi	r17, 0x01	; 1
     1c6:	a0 e0       	ldi	r26, 0x00	; 0
     1c8:	b1 e0       	ldi	r27, 0x01	; 1
     1ca:	e8 e9       	ldi	r30, 0x98	; 152
     1cc:	fc e1       	ldi	r31, 0x1C	; 28
     1ce:	00 e0       	ldi	r16, 0x00	; 0
     1d0:	0b bf       	out	0x3b, r16	; 59
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x14>
     1d4:	07 90       	elpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	aa 32       	cpi	r26, 0x2A	; 42
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0x10>

000001de <__do_clear_bss>:
     1de:	21 e0       	ldi	r18, 0x01	; 1
     1e0:	aa e2       	ldi	r26, 0x2A	; 42
     1e2:	b1 e0       	ldi	r27, 0x01	; 1
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	ac 37       	cpi	r26, 0x7C	; 124
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <main>
     1f2:	0c 94 4a 0e 	jmp	0x1c94	; 0x1c94 <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <play_rest>:
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     1fa:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     1fc:	10 92 61 01 	sts	0x0161, r1
     200:	10 92 60 01 	sts	0x0160, r1
  max_beat = duration;
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	90 93 5f 01 	sts	0x015F, r25
     20a:	80 93 5e 01 	sts	0x015E, r24
     20e:	08 95       	ret

00000210 <play_note>:
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
     210:	cf 93       	push	r28
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
     212:	92 98       	cbi	0x12, 2	; 18
  beat = 0;             //reset the beat counter
     214:	10 92 61 01 	sts	0x0161, r1
     218:	10 92 60 01 	sts	0x0160, r1
  max_beat = duration;  //set the max beat
     21c:	30 e0       	ldi	r19, 0x00	; 0
     21e:	30 93 5f 01 	sts	0x015F, r19
     222:	20 93 5e 01 	sts	0x015E, r18
  switch (octave) {
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	49 30       	cpi	r20, 0x09	; 9
     22a:	51 05       	cpc	r21, r1
     22c:	20 f0       	brcs	.+8      	; 0x236 <play_note+0x26>
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
     22e:	1b bc       	out	0x2b, r1	; 43
     230:	1a bc       	out	0x2a, r1	; 42
  }
}
     232:	cf 91       	pop	r28
     234:	08 95       	ret
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     236:	4a 5b       	subi	r20, 0xBA	; 186
     238:	5f 4f       	sbci	r21, 0xFF	; 255
     23a:	fa 01       	movw	r30, r20
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     23c:	99 27       	eor	r25, r25
     23e:	87 fd       	sbrc	r24, 7
     240:	90 95       	com	r25
     242:	a9 2f       	mov	r26, r25
     244:	b9 2f       	mov	r27, r25
     246:	81 54       	subi	r24, 0x41	; 65
     248:	91 09       	sbc	r25, r1
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     24a:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
     24e:	87 30       	cpi	r24, 0x07	; 7
     250:	91 05       	cpc	r25, r1
     252:	78 f7       	brcc	.-34     	; 0x232 <play_note+0x22>
     254:	81 5b       	subi	r24, 0xB1	; 177
     256:	9f 4f       	sbci	r25, 0xFF	; 255
     258:	fc 01       	movw	r30, r24
     25a:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     25e:	87 30       	cpi	r24, 0x07	; 7
     260:	91 05       	cpc	r25, r1
     262:	38 f7       	brcc	.-50     	; 0x232 <play_note+0x22>
     264:	8a 5a       	subi	r24, 0xAA	; 170
     266:	9f 4f       	sbci	r25, 0xFF	; 255
     268:	fc 01       	movw	r30, r24
     26a:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
     26e:	87 30       	cpi	r24, 0x07	; 7
     270:	91 05       	cpc	r25, r1
     272:	f8 f6       	brcc	.-66     	; 0x232 <play_note+0x22>
     274:	83 5a       	subi	r24, 0xA3	; 163
     276:	9f 4f       	sbci	r25, 0xFF	; 255
     278:	fc 01       	movw	r30, r24
     27a:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
     27e:	87 30       	cpi	r24, 0x07	; 7
     280:	91 05       	cpc	r25, r1
     282:	b8 f6       	brcc	.-82     	; 0x232 <play_note+0x22>
     284:	8c 59       	subi	r24, 0x9C	; 156
     286:	9f 4f       	sbci	r25, 0xFF	; 255
     288:	fc 01       	movw	r30, r24
     28a:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
     28e:	87 30       	cpi	r24, 0x07	; 7
     290:	91 05       	cpc	r25, r1
     292:	78 f6       	brcc	.-98     	; 0x232 <play_note+0x22>
     294:	85 59       	subi	r24, 0x95	; 149
     296:	9f 4f       	sbci	r25, 0xFF	; 255
     298:	fc 01       	movw	r30, r24
     29a:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
     29e:	87 30       	cpi	r24, 0x07	; 7
     2a0:	91 05       	cpc	r25, r1
     2a2:	38 f6       	brcc	.-114    	; 0x232 <play_note+0x22>
     2a4:	8e 58       	subi	r24, 0x8E	; 142
     2a6:	9f 4f       	sbci	r25, 0xFF	; 255
     2a8:	fc 01       	movw	r30, r24
     2aa:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
     2ae:	87 30       	cpi	r24, 0x07	; 7
     2b0:	91 05       	cpc	r25, r1
     2b2:	08 f0       	brcs	.+2      	; 0x2b6 <play_note+0xa6>
     2b4:	be cf       	rjmp	.-132    	; 0x232 <play_note+0x22>
     2b6:	87 58       	subi	r24, 0x87	; 135
     2b8:	9f 4f       	sbci	r25, 0xFF	; 255
     2ba:	fc 01       	movw	r30, r24
     2bc:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
     2c0:	87 30       	cpi	r24, 0x07	; 7
     2c2:	91 05       	cpc	r25, r1
     2c4:	08 f0       	brcs	.+2      	; 0x2c8 <play_note+0xb8>
     2c6:	b5 cf       	rjmp	.-150    	; 0x232 <play_note+0x22>
     2c8:	80 58       	subi	r24, 0x80	; 128
     2ca:	9f 4f       	sbci	r25, 0xFF	; 255
     2cc:	fc 01       	movw	r30, r24
     2ce:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
     2d2:	87 30       	cpi	r24, 0x07	; 7
     2d4:	91 05       	cpc	r25, r1
     2d6:	08 f0       	brcs	.+2      	; 0x2da <play_note+0xca>
     2d8:	ac cf       	rjmp	.-168    	; 0x232 <play_note+0x22>
     2da:	89 57       	subi	r24, 0x79	; 121
     2dc:	9f 4f       	sbci	r25, 0xFF	; 255
     2de:	fc 01       	movw	r30, r24
     2e0:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
     2e4:	88 e5       	ldi	r24, 0x58	; 88
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	9b bd       	out	0x2b, r25	; 43
     2ea:	8a bd       	out	0x2a, r24	; 42
	break;
     2ec:	a2 cf       	rjmp	.-188    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
     2ee:	66 23       	and	r22, r22
     2f0:	09 f4       	brne	.+2      	; 0x2f4 <play_note+0xe4>
     2f2:	0f c2       	rjmp	.+1054   	; 0x712 <play_note+0x502>
     2f4:	83 e6       	ldi	r24, 0x63	; 99
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	9b bd       	out	0x2b, r25	; 43
     2fa:	8a bd       	out	0x2a, r24	; 42
     2fc:	9a cf       	rjmp	.-204    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
     2fe:	66 23       	and	r22, r22
     300:	09 f4       	brne	.+2      	; 0x304 <play_note+0xf4>
     302:	11 c2       	rjmp	.+1058   	; 0x726 <play_note+0x516>
     304:	8f e6       	ldi	r24, 0x6F	; 111
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	9b bd       	out	0x2b, r25	; 43
     30a:	8a bd       	out	0x2a, r24	; 42
     30c:	92 cf       	rjmp	.-220    	; 0x232 <play_note+0x22>
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
     30e:	86 e7       	ldi	r24, 0x76	; 118
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	9b bd       	out	0x2b, r25	; 43
     314:	8a bd       	out	0x2a, r24	; 42
	break;
     316:	8d cf       	rjmp	.-230    	; 0x232 <play_note+0x22>
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
     318:	66 23       	and	r22, r22
     31a:	09 f4       	brne	.+2      	; 0x31e <play_note+0x10e>
     31c:	ff c1       	rjmp	.+1022   	; 0x71c <play_note+0x50c>
     31e:	8a e4       	ldi	r24, 0x4A	; 74
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	9b bd       	out	0x2b, r25	; 43
     324:	8a bd       	out	0x2a, r24	; 42
     326:	85 cf       	rjmp	.-246    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
     328:	66 23       	and	r22, r22
     32a:	09 f4       	brne	.+2      	; 0x32e <play_note+0x11e>
     32c:	01 c2       	rjmp	.+1026   	; 0x730 <play_note+0x520>
     32e:	83 e5       	ldi	r24, 0x53	; 83
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	9b bd       	out	0x2b, r25	; 43
     334:	8a bd       	out	0x2a, r24	; 42
     336:	7d cf       	rjmp	.-262    	; 0x232 <play_note+0x22>
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
     338:	66 23       	and	r22, r22
     33a:	09 f4       	brne	.+2      	; 0x33e <play_note+0x12e>
     33c:	b8 c1       	rjmp	.+880    	; 0x6ae <play_note+0x49e>
     33e:	82 e4       	ldi	r24, 0x42	; 66
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	9b bd       	out	0x2b, r25	; 43
     344:	8a bd       	out	0x2a, r24	; 42
     346:	75 cf       	rjmp	.-278    	; 0x232 <play_note+0x22>
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
     348:	81 eb       	ldi	r24, 0xB1	; 177
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	9b bd       	out	0x2b, r25	; 43
     34e:	8a bd       	out	0x2a, r24	; 42
	break;
     350:	70 cf       	rjmp	.-288    	; 0x232 <play_note+0x22>
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
     352:	66 23       	and	r22, r22
     354:	09 f4       	brne	.+2      	; 0x358 <play_note+0x148>
     356:	d3 c1       	rjmp	.+934    	; 0x6fe <play_note+0x4ee>
     358:	85 e8       	ldi	r24, 0x85	; 133
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	9b bd       	out	0x2b, r25	; 43
     35e:	8a bd       	out	0x2a, r24	; 42
     360:	68 cf       	rjmp	.-304    	; 0x232 <play_note+0x22>
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
     362:	66 23       	and	r22, r22
     364:	09 f4       	brne	.+2      	; 0x368 <play_note+0x158>
     366:	c1 c1       	rjmp	.+898    	; 0x6ea <play_note+0x4da>
     368:	85 e9       	ldi	r24, 0x95	; 149
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	9b bd       	out	0x2b, r25	; 43
     36e:	8a bd       	out	0x2a, r24	; 42
     370:	60 cf       	rjmp	.-320    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
     372:	66 23       	and	r22, r22
     374:	09 f4       	brne	.+2      	; 0x378 <play_note+0x168>
     376:	be c1       	rjmp	.+892    	; 0x6f4 <play_note+0x4e4>
     378:	87 ea       	ldi	r24, 0xA7	; 167
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	9b bd       	out	0x2b, r25	; 43
     37e:	8a bd       	out	0x2a, r24	; 42
     380:	58 cf       	rjmp	.-336    	; 0x232 <play_note+0x22>
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
     382:	84 e6       	ldi	r24, 0x64	; 100
     384:	91 e0       	ldi	r25, 0x01	; 1
     386:	9b bd       	out	0x2b, r25	; 43
     388:	8a bd       	out	0x2a, r24	; 42
	break;
     38a:	53 cf       	rjmp	.-346    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
     38c:	66 23       	and	r22, r22
     38e:	09 f4       	brne	.+2      	; 0x392 <play_note+0x182>
     390:	bb c1       	rjmp	.+886    	; 0x708 <play_note+0x4f8>
     392:	80 ee       	ldi	r24, 0xE0	; 224
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	9b bd       	out	0x2b, r25	; 43
     398:	8a bd       	out	0x2a, r24	; 42
     39a:	4b cf       	rjmp	.-362    	; 0x232 <play_note+0x22>
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
     39c:	8d ee       	ldi	r24, 0xED	; 237
     39e:	90 e0       	ldi	r25, 0x00	; 0
     3a0:	9b bd       	out	0x2b, r25	; 43
     3a2:	8a bd       	out	0x2a, r24	; 42
	break;
     3a4:	46 cf       	rjmp	.-372    	; 0x232 <play_note+0x22>
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
     3a6:	66 23       	and	r22, r22
     3a8:	09 f4       	brne	.+2      	; 0x3ac <play_note+0x19c>
     3aa:	8b c1       	rjmp	.+790    	; 0x6c2 <play_note+0x4b2>
     3ac:	87 ec       	ldi	r24, 0xC7	; 199
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	9b bd       	out	0x2b, r25	; 43
     3b2:	8a bd       	out	0x2a, r24	; 42
     3b4:	3e cf       	rjmp	.-388    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
     3b6:	66 23       	and	r22, r22
     3b8:	09 f4       	brne	.+2      	; 0x3bc <play_note+0x1ac>
     3ba:	74 c1       	rjmp	.+744    	; 0x6a4 <play_note+0x494>
     3bc:	80 e9       	ldi	r24, 0x90	; 144
     3be:	91 e0       	ldi	r25, 0x01	; 1
     3c0:	9b bd       	out	0x2b, r25	; 43
     3c2:	8a bd       	out	0x2a, r24	; 42
     3c4:	36 cf       	rjmp	.-404    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
     3c6:	66 23       	and	r22, r22
     3c8:	09 f4       	brne	.+2      	; 0x3cc <play_note+0x1bc>
     3ca:	cb c1       	rjmp	.+918    	; 0x762 <play_note+0x552>
     3cc:	84 e8       	ldi	r24, 0x84	; 132
     3ce:	93 e0       	ldi	r25, 0x03	; 3
     3d0:	9b bd       	out	0x2b, r25	; 43
     3d2:	8a bd       	out	0x2a, r24	; 42
     3d4:	2e cf       	rjmp	.-420    	; 0x232 <play_note+0x22>
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
     3d6:	66 23       	and	r22, r22
     3d8:	09 f4       	brne	.+2      	; 0x3dc <play_note+0x1cc>
     3da:	af c1       	rjmp	.+862    	; 0x73a <play_note+0x52a>
     3dc:	8b e2       	ldi	r24, 0x2B	; 43
     3de:	91 e0       	ldi	r25, 0x01	; 1
     3e0:	9b bd       	out	0x2b, r25	; 43
     3e2:	8a bd       	out	0x2a, r24	; 42
     3e4:	26 cf       	rjmp	.-436    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
     3e6:	66 23       	and	r22, r22
     3e8:	09 f4       	brne	.+2      	; 0x3ec <play_note+0x1dc>
     3ea:	b1 c1       	rjmp	.+866    	; 0x74e <play_note+0x53e>
     3ec:	82 ea       	ldi	r24, 0xA2	; 162
     3ee:	92 e0       	ldi	r25, 0x02	; 2
     3f0:	9b bd       	out	0x2b, r25	; 43
     3f2:	8a bd       	out	0x2a, r24	; 42
     3f4:	1e cf       	rjmp	.-452    	; 0x232 <play_note+0x22>
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
     3f6:	8c ed       	ldi	r24, 0xDC	; 220
     3f8:	91 e0       	ldi	r25, 0x01	; 1
     3fa:	9b bd       	out	0x2b, r25	; 43
     3fc:	8a bd       	out	0x2a, r24	; 42
	break;
     3fe:	19 cf       	rjmp	.-462    	; 0x232 <play_note+0x22>
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
     400:	66 23       	and	r22, r22
     402:	09 f4       	brne	.+2      	; 0x406 <play_note+0x1f6>
     404:	59 c1       	rjmp	.+690    	; 0x6b8 <play_note+0x4a8>
     406:	87 e1       	ldi	r24, 0x17	; 23
     408:	92 e0       	ldi	r25, 0x02	; 2
     40a:	9b bd       	out	0x2b, r25	; 43
     40c:	8a bd       	out	0x2a, r24	; 42
     40e:	11 cf       	rjmp	.-478    	; 0x232 <play_note+0x22>
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
     410:	66 23       	and	r22, r22
     412:	09 f4       	brne	.+2      	; 0x416 <play_note+0x206>
     414:	b0 c1       	rjmp	.+864    	; 0x776 <play_note+0x566>
     416:	88 e5       	ldi	r24, 0x58	; 88
     418:	92 e0       	ldi	r25, 0x02	; 2
     41a:	9b bd       	out	0x2b, r25	; 43
     41c:	8a bd       	out	0x2a, r24	; 42
     41e:	09 cf       	rjmp	.-494    	; 0x232 <play_note+0x22>
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
     420:	8a ec       	ldi	r24, 0xCA	; 202
     422:	92 e0       	ldi	r25, 0x02	; 2
     424:	9b bd       	out	0x2b, r25	; 43
     426:	8a bd       	out	0x2a, r24	; 42
	break;
     428:	04 cf       	rjmp	.-504    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
     42a:	66 23       	and	r22, r22
     42c:	09 f4       	brne	.+2      	; 0x430 <play_note+0x220>
     42e:	35 c1       	rjmp	.+618    	; 0x69a <play_note+0x48a>
     430:	86 e4       	ldi	r24, 0x46	; 70
     432:	96 e0       	ldi	r25, 0x06	; 6
     434:	9b bd       	out	0x2b, r25	; 43
     436:	8a bd       	out	0x2a, r24	; 42
     438:	fc ce       	rjmp	.-520    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
     43a:	66 23       	and	r22, r22
     43c:	09 f4       	brne	.+2      	; 0x440 <play_note+0x230>
     43e:	82 c1       	rjmp	.+772    	; 0x744 <play_note+0x534>
     440:	8a e0       	ldi	r24, 0x0A	; 10
     442:	97 e0       	ldi	r25, 0x07	; 7
     444:	9b bd       	out	0x2b, r25	; 43
     446:	8a bd       	out	0x2a, r24	; 42
     448:	f4 ce       	rjmp	.-536    	; 0x232 <play_note+0x22>
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
     44a:	86 e9       	ldi	r24, 0x96	; 150
     44c:	95 e0       	ldi	r25, 0x05	; 5
     44e:	9b bd       	out	0x2b, r25	; 43
     450:	8a bd       	out	0x2a, r24	; 42
	break;
     452:	ef ce       	rjmp	.-546    	; 0x232 <play_note+0x22>
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
     454:	8a eb       	ldi	r24, 0xBA	; 186
     456:	93 e0       	ldi	r25, 0x03	; 3
     458:	9b bd       	out	0x2b, r25	; 43
     45a:	8a bd       	out	0x2a, r24	; 42
	break;
     45c:	ea ce       	rjmp	.-556    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
     45e:	66 23       	and	r22, r22
     460:	09 f4       	brne	.+2      	; 0x464 <play_note+0x254>
     462:	7a c1       	rjmp	.+756    	; 0x758 <play_note+0x548>
     464:	81 ec       	ldi	r24, 0xC1	; 193
     466:	91 e0       	ldi	r25, 0x01	; 1
     468:	9b bd       	out	0x2b, r25	; 43
     46a:	8a bd       	out	0x2a, r24	; 42
     46c:	e2 ce       	rjmp	.-572    	; 0x232 <play_note+0x22>
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
     46e:	66 23       	and	r22, r22
     470:	09 f4       	brne	.+2      	; 0x474 <play_note+0x264>
     472:	7c c1       	rjmp	.+760    	; 0x76c <play_note+0x55c>
     474:	8b e0       	ldi	r24, 0x0B	; 11
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	9b bd       	out	0x2b, r25	; 43
     47a:	8a bd       	out	0x2a, r24	; 42
     47c:	da ce       	rjmp	.-588    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
     47e:	66 23       	and	r22, r22
     480:	09 f4       	brne	.+2      	; 0x484 <play_note+0x274>
     482:	7e c1       	rjmp	.+764    	; 0x780 <play_note+0x570>
     484:	80 e5       	ldi	r24, 0x50	; 80
     486:	91 e0       	ldi	r25, 0x01	; 1
     488:	9b bd       	out	0x2b, r25	; 43
     48a:	8a bd       	out	0x2a, r24	; 42
     48c:	d2 ce       	rjmp	.-604    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
     48e:	66 23       	and	r22, r22
     490:	09 f4       	brne	.+2      	; 0x494 <play_note+0x284>
     492:	ad c1       	rjmp	.+858    	; 0x7ee <play_note+0x5de>
     494:	82 e2       	ldi	r24, 0x22	; 34
     496:	93 e0       	ldi	r25, 0x03	; 3
     498:	9b bd       	out	0x2b, r25	; 43
     49a:	8a bd       	out	0x2a, r24	; 42
     49c:	ca ce       	rjmp	.-620    	; 0x232 <play_note+0x22>
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
     49e:	86 e7       	ldi	r24, 0x76	; 118
     4a0:	97 e0       	ldi	r25, 0x07	; 7
     4a2:	9b bd       	out	0x2b, r25	; 43
     4a4:	8a bd       	out	0x2a, r24	; 42
	break;
     4a6:	c5 ce       	rjmp	.-630    	; 0x232 <play_note+0x22>
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
     4a8:	66 23       	and	r22, r22
     4aa:	09 f4       	brne	.+2      	; 0x4ae <play_note+0x29e>
     4ac:	0f c1       	rjmp	.+542    	; 0x6cc <play_note+0x4bc>
     4ae:	8e ec       	ldi	r24, 0xCE	; 206
     4b0:	92 e1       	ldi	r25, 0x12	; 18
     4b2:	9b bd       	out	0x2b, r25	; 43
     4b4:	8a bd       	out	0x2a, r24	; 42
     4b6:	bd ce       	rjmp	.-646    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
     4b8:	66 23       	and	r22, r22
     4ba:	09 f4       	brne	.+2      	; 0x4be <play_note+0x2ae>
     4bc:	7a c1       	rjmp	.+756    	; 0x7b2 <play_note+0x5a2>
     4be:	8d e1       	ldi	r24, 0x1D	; 29
     4c0:	95 e1       	ldi	r25, 0x15	; 21
     4c2:	9b bd       	out	0x2b, r25	; 43
     4c4:	8a bd       	out	0x2a, r24	; 42
     4c6:	b5 ce       	rjmp	.-662    	; 0x232 <play_note+0x22>
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
     4c8:	66 23       	and	r22, r22
     4ca:	09 f4       	brne	.+2      	; 0x4ce <play_note+0x2be>
     4cc:	dc c0       	rjmp	.+440    	; 0x686 <play_note+0x476>
     4ce:	80 e6       	ldi	r24, 0x60	; 96
     4d0:	98 e0       	ldi	r25, 0x08	; 8
     4d2:	9b bd       	out	0x2b, r25	; 43
     4d4:	8a bd       	out	0x2a, r24	; 42
     4d6:	ad ce       	rjmp	.-678    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
     4d8:	66 23       	and	r22, r22
     4da:	09 f4       	brne	.+2      	; 0x4de <play_note+0x2ce>
     4dc:	92 c1       	rjmp	.+804    	; 0x802 <play_note+0x5f2>
     4de:	80 e1       	ldi	r24, 0x10	; 16
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	9b bd       	out	0x2b, r25	; 43
     4e4:	8a bd       	out	0x2a, r24	; 42
     4e6:	a5 ce       	rjmp	.-694    	; 0x232 <play_note+0x22>
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
     4e8:	8e e2       	ldi	r24, 0x2E	; 46
     4ea:	9b e0       	ldi	r25, 0x0B	; 11
     4ec:	9b bd       	out	0x2b, r25	; 43
     4ee:	8a bd       	out	0x2a, r24	; 42
	break;
     4f0:	a0 ce       	rjmp	.-704    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
     4f2:	66 23       	and	r22, r22
     4f4:	09 f4       	brne	.+2      	; 0x4f8 <play_note+0x2e8>
     4f6:	49 c1       	rjmp	.+658    	; 0x78a <play_note+0x57a>
     4f8:	8b e1       	ldi	r24, 0x1B	; 27
     4fa:	90 e0       	ldi	r25, 0x00	; 0
     4fc:	9b bd       	out	0x2b, r25	; 43
     4fe:	8a bd       	out	0x2a, r24	; 42
     500:	98 ce       	rjmp	.-720    	; 0x232 <play_note+0x22>
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
     502:	8c e1       	ldi	r24, 0x1C	; 28
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	9b bd       	out	0x2b, r25	; 43
     508:	8a bd       	out	0x2a, r24	; 42
	break;
     50a:	93 ce       	rjmp	.-730    	; 0x232 <play_note+0x22>
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
     50c:	66 23       	and	r22, r22
     50e:	09 f4       	brne	.+2      	; 0x512 <play_note+0x302>
     510:	41 c1       	rjmp	.+642    	; 0x794 <play_note+0x584>
     512:	87 e0       	ldi	r24, 0x07	; 7
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	9b bd       	out	0x2b, r25	; 43
     518:	8a bd       	out	0x2a, r24	; 42
     51a:	8b ce       	rjmp	.-746    	; 0x232 <play_note+0x22>
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
     51c:	66 23       	and	r22, r22
     51e:	09 f4       	brne	.+2      	; 0x522 <play_note+0x312>
     520:	da c0       	rjmp	.+436    	; 0x6d6 <play_note+0x4c6>
     522:	8b e0       	ldi	r24, 0x0B	; 11
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	9b bd       	out	0x2b, r25	; 43
     528:	8a bd       	out	0x2a, r24	; 42
     52a:	83 ce       	rjmp	.-762    	; 0x232 <play_note+0x22>
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
     52c:	82 e1       	ldi	r24, 0x12	; 18
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	9b bd       	out	0x2b, r25	; 43
     532:	8a bd       	out	0x2a, r24	; 42
	break;
     534:	7e ce       	rjmp	.-772    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
     536:	66 23       	and	r22, r22
     538:	09 f4       	brne	.+2      	; 0x53c <play_note+0x32c>
     53a:	9b c0       	rjmp	.+310    	; 0x672 <play_note+0x462>
     53c:	89 e1       	ldi	r24, 0x19	; 25
     53e:	99 e1       	ldi	r25, 0x19	; 25
     540:	9b bd       	out	0x2b, r25	; 43
     542:	8a bd       	out	0x2a, r24	; 42
     544:	76 ce       	rjmp	.-788    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
     546:	66 23       	and	r22, r22
     548:	09 f4       	brne	.+2      	; 0x54c <play_note+0x33c>
     54a:	29 c1       	rjmp	.+594    	; 0x79e <play_note+0x58e>
     54c:	80 e3       	ldi	r24, 0x30	; 48
     54e:	9c e1       	ldi	r25, 0x1C	; 28
     550:	9b bd       	out	0x2b, r25	; 43
     552:	8a bd       	out	0x2a, r24	; 42
     554:	6e ce       	rjmp	.-804    	; 0x232 <play_note+0x22>
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
     556:	8c ed       	ldi	r24, 0xDC	; 220
     558:	9d e1       	ldi	r25, 0x1D	; 29
     55a:	9b bd       	out	0x2b, r25	; 43
     55c:	8a bd       	out	0x2a, r24	; 42
	break;
     55e:	69 ce       	rjmp	.-814    	; 0x232 <play_note+0x22>
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
     560:	8a e3       	ldi	r24, 0x3A	; 58
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	9b bd       	out	0x2b, r25	; 43
     566:	8a bd       	out	0x2a, r24	; 42
	break;
     568:	64 ce       	rjmp	.-824    	; 0x232 <play_note+0x22>
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
     56a:	66 23       	and	r22, r22
     56c:	09 f4       	brne	.+2      	; 0x570 <play_note+0x360>
     56e:	35 c1       	rjmp	.+618    	; 0x7da <play_note+0x5ca>
     570:	80 e2       	ldi	r24, 0x20	; 32
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	9b bd       	out	0x2b, r25	; 43
     576:	8a bd       	out	0x2a, r24	; 42
     578:	5c ce       	rjmp	.-840    	; 0x232 <play_note+0x22>
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
     57a:	66 23       	and	r22, r22
     57c:	09 f4       	brne	.+2      	; 0x580 <play_note+0x370>
     57e:	32 c1       	rjmp	.+612    	; 0x7e4 <play_note+0x5d4>
     580:	84 e2       	ldi	r24, 0x24	; 36
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	9b bd       	out	0x2b, r25	; 43
     586:	8a bd       	out	0x2a, r24	; 42
     588:	54 ce       	rjmp	.-856    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
     58a:	66 23       	and	r22, r22
     58c:	09 f4       	brne	.+2      	; 0x590 <play_note+0x380>
     58e:	76 c0       	rjmp	.+236    	; 0x67c <play_note+0x46c>
     590:	89 e2       	ldi	r24, 0x29	; 41
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	9b bd       	out	0x2b, r25	; 43
     596:	8a bd       	out	0x2a, r24	; 42
     598:	4c ce       	rjmp	.-872    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
     59a:	66 23       	and	r22, r22
     59c:	09 f4       	brne	.+2      	; 0x5a0 <play_note+0x390>
     59e:	78 c0       	rjmp	.+240    	; 0x690 <play_note+0x480>
     5a0:	81 e3       	ldi	r24, 0x31	; 49
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	9b bd       	out	0x2b, r25	; 43
     5a6:	8a bd       	out	0x2a, r24	; 42
     5a8:	44 ce       	rjmp	.-888    	; 0x232 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
     5aa:	8b e2       	ldi	r24, 0x2B	; 43
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	9b bd       	out	0x2b, r25	; 43
     5b0:	8a bd       	out	0x2a, r24	; 42
	break;
     5b2:	3f ce       	rjmp	.-898    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
     5b4:	66 23       	and	r22, r22
     5b6:	09 f4       	brne	.+2      	; 0x5ba <play_note+0x3aa>
     5b8:	93 c0       	rjmp	.+294    	; 0x6e0 <play_note+0x4d0>
     5ba:	87 e3       	ldi	r24, 0x37	; 55
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	9b bd       	out	0x2b, r25	; 43
     5c0:	8a bd       	out	0x2a, r24	; 42
     5c2:	37 ce       	rjmp	.-914    	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
     5c4:	66 23       	and	r22, r22
     5c6:	09 f4       	brne	.+2      	; 0x5ca <play_note+0x3ba>
     5c8:	4f c0       	rjmp	.+158    	; 0x668 <play_note+0x458>
     5ca:	88 e1       	ldi	r24, 0x18	; 24
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	9b bd       	out	0x2b, r25	; 43
     5d0:	8a bd       	out	0x2a, r24	; 42
     5d2:	2f ce       	rjmp	.-930    	; 0x232 <play_note+0x22>
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
     5d4:	66 23       	and	r22, r22
     5d6:	09 f4       	brne	.+2      	; 0x5da <play_note+0x3ca>
     5d8:	f6 c0       	rjmp	.+492    	; 0x7c6 <play_note+0x5b6>
     5da:	82 eb       	ldi	r24, 0xB2	; 178
     5dc:	94 e0       	ldi	r25, 0x04	; 4
     5de:	9b bd       	out	0x2b, r25	; 43
     5e0:	8a bd       	out	0x2a, r24	; 42
     5e2:	27 ce       	rjmp	.-946    	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
     5e4:	66 23       	and	r22, r22
     5e6:	09 f4       	brne	.+2      	; 0x5ea <play_note+0x3da>
     5e8:	16 c1       	rjmp	.+556    	; 0x816 <play_note+0x606>
     5ea:	8d e8       	ldi	r24, 0x8D	; 141
     5ec:	9a e0       	ldi	r25, 0x0A	; 10
     5ee:	9b bd       	out	0x2b, r25	; 43
     5f0:	8a bd       	out	0x2a, r24	; 42
     5f2:	1f ce       	rjmp	.-962    	; 0x232 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
     5f4:	66 23       	and	r22, r22
     5f6:	09 f4       	brne	.+2      	; 0x5fa <play_note+0x3ea>
     5f8:	d7 c0       	rjmp	.+430    	; 0x7a8 <play_note+0x598>
     5fa:	86 e1       	ldi	r24, 0x16	; 22
     5fc:	9e e0       	ldi	r25, 0x0E	; 14
     5fe:	9b bd       	out	0x2b, r25	; 43
     600:	8a bd       	out	0x2a, r24	; 42
     602:	17 ce       	rjmp	.-978    	; 0x232 <play_note+0x22>
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
     604:	66 23       	and	r22, r22
     606:	09 f4       	brne	.+2      	; 0x60a <play_note+0x3fa>
     608:	f7 c0       	rjmp	.+494    	; 0x7f8 <play_note+0x5e8>
     60a:	80 ec       	ldi	r24, 0xC0	; 192
     60c:	90 e1       	ldi	r25, 0x10	; 16
     60e:	9b bd       	out	0x2b, r25	; 43
     610:	8a bd       	out	0x2a, r24	; 42
     612:	0f ce       	rjmp	.-994    	; 0x232 <play_note+0x22>
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
     614:	66 23       	and	r22, r22
     616:	09 f4       	brne	.+2      	; 0x61a <play_note+0x40a>
     618:	d1 c0       	rjmp	.+418    	; 0x7bc <play_note+0x5ac>
     61a:	8f e2       	ldi	r24, 0x2F	; 47
     61c:	94 e0       	ldi	r25, 0x04	; 4
     61e:	9b bd       	out	0x2b, r25	; 43
     620:	8a bd       	out	0x2a, r24	; 42
     622:	07 ce       	rjmp	.-1010   	; 0x232 <play_note+0x22>
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
     624:	66 23       	and	r22, r22
     626:	09 f4       	brne	.+2      	; 0x62a <play_note+0x41a>
     628:	f1 c0       	rjmp	.+482    	; 0x80c <play_note+0x5fc>
     62a:	87 e6       	ldi	r24, 0x67	; 103
     62c:	99 e0       	ldi	r25, 0x09	; 9
     62e:	9b bd       	out	0x2b, r25	; 43
     630:	8a bd       	out	0x2a, r24	; 42
     632:	ff cd       	rjmp	.-1026   	; 0x232 <play_note+0x22>
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
     634:	66 23       	and	r22, r22
     636:	09 f4       	brne	.+2      	; 0x63a <play_note+0x42a>
     638:	cb c0       	rjmp	.+406    	; 0x7d0 <play_note+0x5c0>
     63a:	8d e8       	ldi	r24, 0x8D	; 141
     63c:	9c e0       	ldi	r25, 0x0C	; 12
     63e:	9b bd       	out	0x2b, r25	; 43
     640:	8a bd       	out	0x2a, r24	; 42
     642:	f7 cd       	rjmp	.-1042   	; 0x232 <play_note+0x22>
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
     644:	8d e5       	ldi	r24, 0x5D	; 93
     646:	96 e1       	ldi	r25, 0x16	; 22
     648:	9b bd       	out	0x2b, r25	; 43
     64a:	8a bd       	out	0x2a, r24	; 42
	break;
     64c:	f2 cd       	rjmp	.-1052   	; 0x232 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
     64e:	66 23       	and	r22, r22
     650:	09 f4       	brne	.+2      	; 0x654 <play_note+0x444>
     652:	e6 c0       	rjmp	.+460    	; 0x820 <play_note+0x610>
     654:	86 e4       	ldi	r24, 0x46	; 70
     656:	95 e0       	ldi	r25, 0x05	; 5
     658:	9b bd       	out	0x2b, r25	; 43
     65a:	8a bd       	out	0x2a, r24	; 42
     65c:	ea cd       	rjmp	.-1068   	; 0x232 <play_note+0x22>
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
     65e:	8d ee       	ldi	r24, 0xED	; 237
     660:	9e e0       	ldi	r25, 0x0E	; 14
     662:	9b bd       	out	0x2b, r25	; 43
     664:	8a bd       	out	0x2a, r24	; 42
	break;
     666:	e5 cd       	rjmp	.-1078   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
     668:	85 e1       	ldi	r24, 0x15	; 21
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	9b bd       	out	0x2b, r25	; 43
     66e:	8a bd       	out	0x2a, r24	; 42
     670:	e0 cd       	rjmp	.-1088   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
     672:	82 eb       	ldi	r24, 0xB2	; 178
     674:	97 e1       	ldi	r25, 0x17	; 23
     676:	9b bd       	out	0x2b, r25	; 43
     678:	8a bd       	out	0x2a, r24	; 42
     67a:	db cd       	rjmp	.-1098   	; 0x232 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
     67c:	86 e2       	ldi	r24, 0x26	; 38
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	9b bd       	out	0x2b, r25	; 43
     682:	8a bd       	out	0x2a, r24	; 42
     684:	d6 cd       	rjmp	.-1108   	; 0x232 <play_note+0x22>
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
     686:	87 ee       	ldi	r24, 0xE7	; 231
     688:	97 e0       	ldi	r25, 0x07	; 7
     68a:	9b bd       	out	0x2b, r25	; 43
     68c:	8a bd       	out	0x2a, r24	; 42
     68e:	d1 cd       	rjmp	.-1118   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
     690:	8e e2       	ldi	r24, 0x2E	; 46
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	9b bd       	out	0x2b, r25	; 43
     696:	8a bd       	out	0x2a, r24	; 42
     698:	cc cd       	rjmp	.-1128   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
     69a:	8b ee       	ldi	r24, 0xEB	; 235
     69c:	95 e0       	ldi	r25, 0x05	; 5
     69e:	9b bd       	out	0x2b, r25	; 43
     6a0:	8a bd       	out	0x2a, r24	; 42
     6a2:	c7 cd       	rjmp	.-1138   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
     6a4:	8a e7       	ldi	r24, 0x7A	; 122
     6a6:	91 e0       	ldi	r25, 0x01	; 1
     6a8:	9b bd       	out	0x2b, r25	; 43
     6aa:	8a bd       	out	0x2a, r24	; 42
     6ac:	c2 cd       	rjmp	.-1148   	; 0x232 <play_note+0x22>
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
     6ae:	8e e3       	ldi	r24, 0x3E	; 62
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	9b bd       	out	0x2b, r25	; 43
     6b4:	8a bd       	out	0x2a, r24	; 42
     6b6:	bd cd       	rjmp	.-1158   	; 0x232 <play_note+0x22>
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
     6b8:	89 ef       	ldi	r24, 0xF9	; 249
     6ba:	91 e0       	ldi	r25, 0x01	; 1
     6bc:	9b bd       	out	0x2b, r25	; 43
     6be:	8a bd       	out	0x2a, r24	; 42
     6c0:	b8 cd       	rjmp	.-1168   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
     6c2:	8c eb       	ldi	r24, 0xBC	; 188
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	9b bd       	out	0x2b, r25	; 43
     6c8:	8a bd       	out	0x2a, r24	; 42
     6ca:	b3 cd       	rjmp	.-1178   	; 0x232 <play_note+0x22>
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
     6cc:	80 ec       	ldi	r24, 0xC0	; 192
     6ce:	91 e1       	ldi	r25, 0x11	; 17
     6d0:	9b bd       	out	0x2b, r25	; 43
     6d2:	8a bd       	out	0x2a, r24	; 42
     6d4:	ae cd       	rjmp	.-1188   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
     6d6:	89 e0       	ldi	r24, 0x09	; 9
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	9b bd       	out	0x2b, r25	; 43
     6dc:	8a bd       	out	0x2a, r24	; 42
     6de:	a9 cd       	rjmp	.-1198   	; 0x232 <play_note+0x22>
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
     6e0:	84 e3       	ldi	r24, 0x34	; 52
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	9b bd       	out	0x2b, r25	; 43
     6e6:	8a bd       	out	0x2a, r24	; 42
     6e8:	a4 cd       	rjmp	.-1208   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
     6ea:	8d e8       	ldi	r24, 0x8D	; 141
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	9b bd       	out	0x2b, r25	; 43
     6f0:	8a bd       	out	0x2a, r24	; 42
     6f2:	9f cd       	rjmp	.-1218   	; 0x232 <play_note+0x22>
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
     6f4:	8e e9       	ldi	r24, 0x9E	; 158
     6f6:	90 e0       	ldi	r25, 0x00	; 0
     6f8:	9b bd       	out	0x2b, r25	; 43
     6fa:	8a bd       	out	0x2a, r24	; 42
     6fc:	9a cd       	rjmp	.-1228   	; 0x232 <play_note+0x22>
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
     6fe:	8d e7       	ldi	r24, 0x7D	; 125
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	9b bd       	out	0x2b, r25	; 43
     704:	8a bd       	out	0x2a, r24	; 42
     706:	95 cd       	rjmp	.-1238   	; 0x232 <play_note+0x22>
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
     708:	83 ed       	ldi	r24, 0xD3	; 211
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	9b bd       	out	0x2b, r25	; 43
     70e:	8a bd       	out	0x2a, r24	; 42
     710:	90 cd       	rjmp	.-1248   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
     712:	8d e5       	ldi	r24, 0x5D	; 93
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	9b bd       	out	0x2b, r25	; 43
     718:	8a bd       	out	0x2a, r24	; 42
     71a:	8b cd       	rjmp	.-1258   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
     71c:	86 e4       	ldi	r24, 0x46	; 70
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	9b bd       	out	0x2b, r25	; 43
     722:	8a bd       	out	0x2a, r24	; 42
     724:	86 cd       	rjmp	.-1268   	; 0x232 <play_note+0x22>
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
     726:	89 e6       	ldi	r24, 0x69	; 105
     728:	90 e0       	ldi	r25, 0x00	; 0
     72a:	9b bd       	out	0x2b, r25	; 43
     72c:	8a bd       	out	0x2a, r24	; 42
     72e:	81 cd       	rjmp	.-1278   	; 0x232 <play_note+0x22>
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
     730:	8e e4       	ldi	r24, 0x4E	; 78
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9b bd       	out	0x2b, r25	; 43
     736:	8a bd       	out	0x2a, r24	; 42
     738:	7c cd       	rjmp	.-1288   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
     73a:	8b e1       	ldi	r24, 0x1B	; 27
     73c:	91 e0       	ldi	r25, 0x01	; 1
     73e:	9b bd       	out	0x2b, r25	; 43
     740:	8a bd       	out	0x2a, r24	; 42
     742:	77 cd       	rjmp	.-1298   	; 0x232 <play_note+0x22>
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
     744:	85 ea       	ldi	r24, 0xA5	; 165
     746:	96 e0       	ldi	r25, 0x06	; 6
     748:	9b bd       	out	0x2b, r25	; 43
     74a:	8a bd       	out	0x2a, r24	; 42
     74c:	72 cd       	rjmp	.-1308   	; 0x232 <play_note+0x22>
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
     74e:	8c e7       	ldi	r24, 0x7C	; 124
     750:	92 e0       	ldi	r25, 0x02	; 2
     752:	9b bd       	out	0x2b, r25	; 43
     754:	8a bd       	out	0x2a, r24	; 42
     756:	6d cd       	rjmp	.-1318   	; 0x232 <play_note+0x22>
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
     758:	88 ea       	ldi	r24, 0xA8	; 168
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	9b bd       	out	0x2b, r25	; 43
     75e:	8a bd       	out	0x2a, r24	; 42
     760:	68 cd       	rjmp	.-1328   	; 0x232 <play_note+0x22>
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
     762:	82 e5       	ldi	r24, 0x52	; 82
     764:	93 e0       	ldi	r25, 0x03	; 3
     766:	9b bd       	out	0x2b, r25	; 43
     768:	8a bd       	out	0x2a, r24	; 42
     76a:	63 cd       	rjmp	.-1338   	; 0x232 <play_note+0x22>
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
     76c:	8c ef       	ldi	r24, 0xFC	; 252
     76e:	90 e0       	ldi	r25, 0x00	; 0
     770:	9b bd       	out	0x2b, r25	; 43
     772:	8a bd       	out	0x2a, r24	; 42
     774:	5e cd       	rjmp	.-1348   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
     776:	87 e3       	ldi	r24, 0x37	; 55
     778:	92 e0       	ldi	r25, 0x02	; 2
     77a:	9b bd       	out	0x2b, r25	; 43
     77c:	8a bd       	out	0x2a, r24	; 42
     77e:	59 cd       	rjmp	.-1358   	; 0x232 <play_note+0x22>
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
     780:	8d e3       	ldi	r24, 0x3D	; 61
     782:	91 e0       	ldi	r25, 0x01	; 1
     784:	9b bd       	out	0x2b, r25	; 43
     786:	8a bd       	out	0x2a, r24	; 42
     788:	54 cd       	rjmp	.-1368   	; 0x232 <play_note+0x22>
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
     78a:	89 e1       	ldi	r24, 0x19	; 25
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	9b bd       	out	0x2b, r25	; 43
     790:	8a bd       	out	0x2a, r24	; 42
     792:	4f cd       	rjmp	.-1378   	; 0x232 <play_note+0x22>
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
     794:	85 e0       	ldi	r24, 0x05	; 5
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	9b bd       	out	0x2b, r25	; 43
     79a:	8a bd       	out	0x2a, r24	; 42
     79c:	4a cd       	rjmp	.-1388   	; 0x232 <play_note+0x22>
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
     79e:	8a e9       	ldi	r24, 0x9A	; 154
     7a0:	9a e1       	ldi	r25, 0x1A	; 26
     7a2:	9b bd       	out	0x2b, r25	; 43
     7a4:	8a bd       	out	0x2a, r24	; 42
     7a6:	45 cd       	rjmp	.-1398   	; 0x232 <play_note+0x22>
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
     7a8:	8c e4       	ldi	r24, 0x4C	; 76
     7aa:	9d e0       	ldi	r25, 0x0D	; 13
     7ac:	9b bd       	out	0x2b, r25	; 43
     7ae:	8a bd       	out	0x2a, r24	; 42
     7b0:	40 cd       	rjmp	.-1408   	; 0x232 <play_note+0x22>
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
     7b2:	8d ee       	ldi	r24, 0xED	; 237
     7b4:	93 e1       	ldi	r25, 0x13	; 19
     7b6:	9b bd       	out	0x2b, r25	; 43
     7b8:	8a bd       	out	0x2a, r24	; 42
     7ba:	3b cd       	rjmp	.-1418   	; 0x232 <play_note+0x22>
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
     7bc:	83 ef       	ldi	r24, 0xF3	; 243
     7be:	93 e0       	ldi	r25, 0x03	; 3
     7c0:	9b bd       	out	0x2b, r25	; 43
     7c2:	8a bd       	out	0x2a, r24	; 42
     7c4:	36 cd       	rjmp	.-1428   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
     7c6:	8f e6       	ldi	r24, 0x6F	; 111
     7c8:	94 e0       	ldi	r25, 0x04	; 4
     7ca:	9b bd       	out	0x2b, r25	; 43
     7cc:	8a bd       	out	0x2a, r24	; 42
     7ce:	31 cd       	rjmp	.-1438   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
     7d0:	88 ed       	ldi	r24, 0xD8	; 216
     7d2:	9b e0       	ldi	r25, 0x0B	; 11
     7d4:	9b bd       	out	0x2b, r25	; 43
     7d6:	8a bd       	out	0x2a, r24	; 42
     7d8:	2c cd       	rjmp	.-1448   	; 0x232 <play_note+0x22>
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
     7da:	8e e1       	ldi	r24, 0x1E	; 30
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	9b bd       	out	0x2b, r25	; 43
     7e0:	8a bd       	out	0x2a, r24	; 42
     7e2:	27 cd       	rjmp	.-1458   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
     7e4:	82 e2       	ldi	r24, 0x22	; 34
     7e6:	90 e0       	ldi	r25, 0x00	; 0
     7e8:	9b bd       	out	0x2b, r25	; 43
     7ea:	8a bd       	out	0x2a, r24	; 42
     7ec:	22 cd       	rjmp	.-1468   	; 0x232 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
     7ee:	85 ef       	ldi	r24, 0xF5	; 245
     7f0:	92 e0       	ldi	r25, 0x02	; 2
     7f2:	9b bd       	out	0x2b, r25	; 43
     7f4:	8a bd       	out	0x2a, r24	; 42
     7f6:	1d cd       	rjmp	.-1478   	; 0x232 <play_note+0x22>
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
     7f8:	80 ed       	ldi	r24, 0xD0	; 208
     7fa:	9f e0       	ldi	r25, 0x0F	; 15
     7fc:	9b bd       	out	0x2b, r25	; 43
     7fe:	8a bd       	out	0x2a, r24	; 42
     800:	18 cd       	rjmp	.-1488   	; 0x232 <play_note+0x22>
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
     802:	8d e0       	ldi	r24, 0x0D	; 13
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	9b bd       	out	0x2b, r25	; 43
     808:	8a bd       	out	0x2a, r24	; 42
     80a:	13 cd       	rjmp	.-1498   	; 0x232 <play_note+0x22>
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
     80c:	8f ed       	ldi	r24, 0xDF	; 223
     80e:	98 e0       	ldi	r25, 0x08	; 8
     810:	9b bd       	out	0x2b, r25	; 43
     812:	8a bd       	out	0x2a, r24	; 42
     814:	0e cd       	rjmp	.-1508   	; 0x232 <play_note+0x22>
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
     816:	86 ef       	ldi	r24, 0xF6	; 246
     818:	99 e0       	ldi	r25, 0x09	; 9
     81a:	9b bd       	out	0x2b, r25	; 43
     81c:	8a bd       	out	0x2a, r24	; 42
     81e:	09 cd       	rjmp	.-1518   	; 0x232 <play_note+0x22>
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
     820:	8a ef       	ldi	r24, 0xFA	; 250
     822:	94 e0       	ldi	r25, 0x04	; 4
     824:	9b bd       	out	0x2b, r25	; 43
     826:	8a bd       	out	0x2a, r24	; 42
     828:	04 cd       	rjmp	.-1528   	; 0x232 <play_note+0x22>

0000082a <song0>:
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     82a:	86 34       	cpi	r24, 0x46	; 70
     82c:	91 05       	cpc	r25, r1
     82e:	20 f0       	brcs	.+8      	; 0x838 <song0+0xe>
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
     830:	8f ef       	ldi	r24, 0xFF	; 255
     832:	80 93 50 01 	sts	0x0150, r24
     836:	08 95       	ret
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     838:	fc 01       	movw	r30, r24
     83a:	e2 57       	subi	r30, 0x72	; 114
     83c:	ff 4f       	sbci	r31, 0xFF	; 255
     83e:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
     842:	22 e0       	ldi	r18, 0x02	; 2
     844:	44 e0       	ldi	r20, 0x04	; 4
     846:	60 e0       	ldi	r22, 0x00	; 0
     848:	81 e4       	ldi	r24, 0x41	; 65
     84a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
     84e:	26 e0       	ldi	r18, 0x06	; 6
     850:	44 e0       	ldi	r20, 0x04	; 4
     852:	60 e0       	ldi	r22, 0x00	; 0
     854:	81 e4       	ldi	r24, 0x41	; 65
     856:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
     85a:	22 e0       	ldi	r18, 0x02	; 2
     85c:	44 e0       	ldi	r20, 0x04	; 4
     85e:	61 e0       	ldi	r22, 0x01	; 1
     860:	81 e4       	ldi	r24, 0x41	; 65
     862:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
     866:	28 e0       	ldi	r18, 0x08	; 8
     868:	44 e0       	ldi	r20, 0x04	; 4
     86a:	60 e0       	ldi	r22, 0x00	; 0
     86c:	84 e4       	ldi	r24, 0x44	; 68
     86e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
     872:	28 e0       	ldi	r18, 0x08	; 8
     874:	44 e0       	ldi	r20, 0x04	; 4
     876:	60 e0       	ldi	r22, 0x00	; 0
     878:	86 e4       	ldi	r24, 0x46	; 70
     87a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
     87e:	26 e0       	ldi	r18, 0x06	; 6
     880:	44 e0       	ldi	r20, 0x04	; 4
     882:	61 e0       	ldi	r22, 0x01	; 1
     884:	82 e4       	ldi	r24, 0x42	; 66
     886:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
     88a:	28 e0       	ldi	r18, 0x08	; 8
     88c:	44 e0       	ldi	r20, 0x04	; 4
     88e:	60 e0       	ldi	r22, 0x00	; 0
     890:	83 e4       	ldi	r24, 0x43	; 67
     892:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
     896:	28 e0       	ldi	r18, 0x08	; 8
     898:	44 e0       	ldi	r20, 0x04	; 4
     89a:	60 e0       	ldi	r22, 0x00	; 0
     89c:	81 e4       	ldi	r24, 0x41	; 65
     89e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 67: play_note('G', 0, 4, 8);
     8a2:	28 e0       	ldi	r18, 0x08	; 8
     8a4:	44 e0       	ldi	r20, 0x04	; 4
     8a6:	60 e0       	ldi	r22, 0x00	; 0
     8a8:	87 e4       	ldi	r24, 0x47	; 71
     8aa:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
     8ae:	28 e0       	ldi	r18, 0x08	; 8
     8b0:	44 e0       	ldi	r20, 0x04	; 4
     8b2:	60 e0       	ldi	r22, 0x00	; 0
     8b4:	85 e4       	ldi	r24, 0x45	; 69
     8b6:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
     8ba:	20 e1       	ldi	r18, 0x10	; 16
     8bc:	44 e0       	ldi	r20, 0x04	; 4
     8be:	60 e0       	ldi	r22, 0x00	; 0
     8c0:	81 e4       	ldi	r24, 0x41	; 65
     8c2:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
     8c6:	24 e0       	ldi	r18, 0x04	; 4
     8c8:	45 e0       	ldi	r20, 0x05	; 5
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	83 e4       	ldi	r24, 0x43	; 67
     8ce:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 65: play_note('D', 0, 5, 4);
     8d2:	24 e0       	ldi	r18, 0x04	; 4
     8d4:	45 e0       	ldi	r20, 0x05	; 5
     8d6:	60 e0       	ldi	r22, 0x00	; 0
     8d8:	84 e4       	ldi	r24, 0x44	; 68
     8da:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     8de:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     8e0:	10 92 61 01 	sts	0x0161, r1
     8e4:	10 92 60 01 	sts	0x0160, r1
  max_beat = duration;
     8e8:	88 e0       	ldi	r24, 0x08	; 8
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	90 93 5f 01 	sts	0x015F, r25
     8f0:	80 93 5e 01 	sts	0x015E, r24
     8f4:	08 95       	ret
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     8f6:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     8f8:	10 92 61 01 	sts	0x0161, r1
     8fc:	10 92 60 01 	sts	0x0160, r1
  max_beat = duration;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	90 93 5f 01 	sts	0x015F, r25
     908:	80 93 5e 01 	sts	0x015E, r24
     90c:	08 95       	ret
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
     90e:	20 e1       	ldi	r18, 0x10	; 16
     910:	44 e0       	ldi	r20, 0x04	; 4
     912:	61 e0       	ldi	r22, 0x01	; 1
     914:	82 e4       	ldi	r24, 0x42	; 66
     916:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
     91a:	28 e0       	ldi	r18, 0x08	; 8
     91c:	44 e0       	ldi	r20, 0x04	; 4
     91e:	61 e0       	ldi	r22, 0x01	; 1
     920:	82 e4       	ldi	r24, 0x42	; 66
     922:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
     926:	28 e1       	ldi	r18, 0x18	; 24
     928:	44 e0       	ldi	r20, 0x04	; 4
     92a:	60 e0       	ldi	r22, 0x00	; 0
     92c:	87 e4       	ldi	r24, 0x47	; 71
     92e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
     932:	20 e1       	ldi	r18, 0x10	; 16
     934:	45 e0       	ldi	r20, 0x05	; 5
     936:	60 e0       	ldi	r22, 0x00	; 0
     938:	84 e4       	ldi	r24, 0x44	; 68
     93a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     93e:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     940:	10 92 61 01 	sts	0x0161, r1
     944:	10 92 60 01 	sts	0x0160, r1
  max_beat = duration;
     948:	82 e0       	ldi	r24, 0x02	; 2
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	90 93 5f 01 	sts	0x015F, r25
     950:	80 93 5e 01 	sts	0x015E, r24
     954:	08 95       	ret
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
     956:	24 e0       	ldi	r18, 0x04	; 4
     958:	44 e0       	ldi	r20, 0x04	; 4
     95a:	60 e0       	ldi	r22, 0x00	; 0
     95c:	81 e4       	ldi	r24, 0x41	; 65
     95e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
     962:	26 e0       	ldi	r18, 0x06	; 6
     964:	44 e0       	ldi	r20, 0x04	; 4
     966:	60 e0       	ldi	r22, 0x00	; 0
     968:	87 e4       	ldi	r24, 0x47	; 71
     96a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
     96e:	24 e0       	ldi	r18, 0x04	; 4
     970:	44 e0       	ldi	r20, 0x04	; 4
     972:	61 e0       	ldi	r22, 0x01	; 1
     974:	87 e4       	ldi	r24, 0x47	; 71
     976:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
     97a:	28 e0       	ldi	r18, 0x08	; 8
     97c:	44 e0       	ldi	r20, 0x04	; 4
     97e:	61 e0       	ldi	r22, 0x01	; 1
     980:	87 e4       	ldi	r24, 0x47	; 71
     982:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
     986:	23 e0       	ldi	r18, 0x03	; 3
     988:	44 e0       	ldi	r20, 0x04	; 4
     98a:	60 e0       	ldi	r22, 0x00	; 0
     98c:	87 e4       	ldi	r24, 0x47	; 71
     98e:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
     992:	20 e1       	ldi	r18, 0x10	; 16
     994:	44 e0       	ldi	r20, 0x04	; 4
     996:	60 e0       	ldi	r22, 0x00	; 0
     998:	84 e4       	ldi	r24, 0x44	; 68
     99a:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
     99e:	20 e1       	ldi	r18, 0x10	; 16
     9a0:	45 e0       	ldi	r20, 0x05	; 5
     9a2:	60 e0       	ldi	r22, 0x00	; 0
     9a4:	83 e4       	ldi	r24, 0x43	; 67
     9a6:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
     9aa:	22 e0       	ldi	r18, 0x02	; 2
     9ac:	44 e0       	ldi	r20, 0x04	; 4
     9ae:	61 e0       	ldi	r22, 0x01	; 1
     9b0:	82 e4       	ldi	r24, 0x42	; 66
     9b2:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
     9b6:	24 e0       	ldi	r18, 0x04	; 4
     9b8:	45 e0       	ldi	r20, 0x05	; 5
     9ba:	61 e0       	ldi	r22, 0x01	; 1
     9bc:	84 e4       	ldi	r24, 0x44	; 68
     9be:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
     9c2:	24 e0       	ldi	r18, 0x04	; 4
     9c4:	44 e0       	ldi	r20, 0x04	; 4
     9c6:	61 e0       	ldi	r22, 0x01	; 1
     9c8:	81 e4       	ldi	r24, 0x41	; 65
     9ca:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
     9ce:	28 e0       	ldi	r18, 0x08	; 8
     9d0:	44 e0       	ldi	r20, 0x04	; 4
     9d2:	60 e0       	ldi	r22, 0x00	; 0
     9d4:	82 e4       	ldi	r24, 0x42	; 66
     9d6:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
     9da:	28 e1       	ldi	r18, 0x18	; 24
     9dc:	44 e0       	ldi	r20, 0x04	; 4
     9de:	60 e0       	ldi	r22, 0x00	; 0
     9e0:	86 e4       	ldi	r24, 0x46	; 70
     9e2:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
     9e6:	27 e0       	ldi	r18, 0x07	; 7
     9e8:	44 e0       	ldi	r20, 0x04	; 4
     9ea:	60 e0       	ldi	r22, 0x00	; 0
     9ec:	87 e4       	ldi	r24, 0x47	; 71
     9ee:	0c 94 08 01 	jmp	0x210	; 0x210 <play_note>

000009f2 <play_song>:
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     9f2:	86 2f       	mov	r24, r22
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	0c 94 15 04 	jmp	0x82a	; 0x82a <song0>

000009fa <music_off>:
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     9fa:	10 92 50 01 	sts	0x0150, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     9fe:	8e b5       	in	r24, 0x2e	; 46
     a00:	8c 7f       	andi	r24, 0xFC	; 252
     a02:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     a04:	92 9a       	sbi	0x12, 2	; 18
     a06:	08 95       	ret

00000a08 <music_on>:
}

void music_on(void) {
  //this starts the alarm timer running
  notes=0;
     a08:	10 92 50 01 	sts	0x0150, r1
  TCCR1B |= (1<<CS11)|(1<<CS10);
     a0c:	8e b5       	in	r24, 0x2e	; 46
     a0e:	83 60       	ori	r24, 0x03	; 3
     a10:	8e bd       	out	0x2e, r24	; 46
  //unmutes the output
  PORTD &= unmute;
     a12:	92 98       	cbi	0x12, 2	; 18
  //and starts the selected song
  play_song(song, notes);
     a14:	80 91 50 01 	lds	r24, 0x0150
     a18:	90 91 5d 01 	lds	r25, 0x015D
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     a1c:	90 e0       	ldi	r25, 0x00	; 0
     a1e:	0c 94 15 04 	jmp	0x82a	; 0x82a <song0>

00000a22 <music_init>:
  play_song(song, notes);
}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  DDRD |= (1<<PD7);
     a22:	8f 9a       	sbi	0x11, 7	; 17
  TIMSK |= (1<<OCIE1A) | (1<<TOIE0);  //enable timer interrupt 1 on compare
     a24:	87 b7       	in	r24, 0x37	; 55
     a26:	81 61       	ori	r24, 0x11	; 17
     a28:	87 bf       	out	0x37, r24	; 55
  TCCR1A = 0x00;         //TCNT1, normal port operation
     a2a:	1f bc       	out	0x2f, r1	; 47
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
     a2c:	8e b5       	in	r24, 0x2e	; 46
     a2e:	88 60       	ori	r24, 0x08	; 8
     a30:	8e bd       	out	0x2e, r24	; 46
  TCCR1C = 0x00;         //no forced compare
     a32:	10 92 7a 00 	sts	0x007A, r1
  OCR1A = 0x0033;        //(use to vary alarm frequency)
     a36:	83 e3       	ldi	r24, 0x33	; 51
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	9b bd       	out	0x2b, r25	; 43
     a3c:	8a bd       	out	0x2a, r24	; 42
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     a3e:	10 92 50 01 	sts	0x0150, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     a42:	8e b5       	in	r24, 0x2e	; 46
     a44:	8c 7f       	andi	r24, 0xFC	; 252
     a46:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     a48:	92 9a       	sbi	0x12, 2	; 18
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0033;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
     a4a:	10 92 61 01 	sts	0x0161, r1
     a4e:	10 92 60 01 	sts	0x0160, r1
  max_beat = 0;
     a52:	10 92 5f 01 	sts	0x015F, r1
     a56:	10 92 5e 01 	sts	0x015E, r1
  notes = 0;
     a5a:	10 92 50 01 	sts	0x0150, r1
  song = 0;              //beaver fight song
     a5e:	10 92 5d 01 	sts	0x015D, r1
     a62:	08 95       	ret

00000a64 <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     a64:	20 91 46 01 	lds	r18, 0x0146
     a68:	30 91 47 01 	lds	r19, 0x0147
     a6c:	22 0f       	add	r18, r18
     a6e:	33 1f       	adc	r19, r19
     a70:	49 b3       	in	r20, 0x19	; 25
     a72:	50 e0       	ldi	r21, 0x00	; 0
     a74:	02 c0       	rjmp	.+4      	; 0xa7a <chk_buttons+0x16>
     a76:	55 95       	asr	r21
     a78:	47 95       	ror	r20
     a7a:	8a 95       	dec	r24
     a7c:	e2 f7       	brpl	.-8      	; 0xa76 <chk_buttons+0x12>
     a7e:	40 fd       	sbrc	r20, 0
     a80:	0e c0       	rjmp	.+28     	; 0xa9e <chk_buttons+0x3a>
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	90 ee       	ldi	r25, 0xE0	; 224
     a86:	28 2b       	or	r18, r24
     a88:	39 2b       	or	r19, r25
     a8a:	30 93 47 01 	sts	0x0147, r19
     a8e:	20 93 46 01 	sts	0x0146, r18
    if (state == 0xF000){
     a92:	81 e0       	ldi	r24, 0x01	; 1
     a94:	21 15       	cp	r18, r1
     a96:	30 4f       	sbci	r19, 0xF0	; 240
     a98:	09 f0       	breq	.+2      	; 0xa9c <chk_buttons+0x38>
     a9a:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
    }
    return 0;
}
     a9c:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	90 ee       	ldi	r25, 0xE0	; 224
     aa2:	f1 cf       	rjmp	.-30     	; 0xa86 <chk_buttons+0x22>

00000aa4 <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
     aa4:	81 11       	cpse	r24, r1
     aa6:	02 c0       	rjmp	.+4      	; 0xaac <int2seg+0x8>
	return ZERO;
     aa8:	80 ec       	ldi	r24, 0xC0	; 192
     aaa:	08 95       	ret
    }
    else if(number == 1 ){
     aac:	81 30       	cpi	r24, 0x01	; 1
     aae:	91 f0       	breq	.+36     	; 0xad4 <int2seg+0x30>
	return ONE;
    }
    else if(number == 2 ){
     ab0:	82 30       	cpi	r24, 0x02	; 2
     ab2:	91 f0       	breq	.+36     	; 0xad8 <int2seg+0x34>
	return TWO;
    }
    else if(number == 3 ){
     ab4:	83 30       	cpi	r24, 0x03	; 3
     ab6:	a1 f0       	breq	.+40     	; 0xae0 <int2seg+0x3c>
	return THREE;
    }
    else if(number == 4 ){
     ab8:	84 30       	cpi	r24, 0x04	; 4
     aba:	81 f0       	breq	.+32     	; 0xadc <int2seg+0x38>
	return FOUR;
    }
    else if(number == 5 ){
     abc:	85 30       	cpi	r24, 0x05	; 5
     abe:	91 f0       	breq	.+36     	; 0xae4 <int2seg+0x40>
	return FIVE;
    }
    else if(number == 6 ){
     ac0:	86 30       	cpi	r24, 0x06	; 6
     ac2:	91 f0       	breq	.+36     	; 0xae8 <int2seg+0x44>
	return  SIX;
    }
    else if(number == 7 ){
     ac4:	87 30       	cpi	r24, 0x07	; 7
     ac6:	91 f0       	breq	.+36     	; 0xaec <int2seg+0x48>
	return SEVEN;
    }
    else if(number == 8 ){
     ac8:	88 30       	cpi	r24, 0x08	; 8
     aca:	91 f0       	breq	.+36     	; 0xaf0 <int2seg+0x4c>
	return EIGHT;
    }
    else if(number == 9 ){
     acc:	89 30       	cpi	r24, 0x09	; 9
     ace:	91 f0       	breq	.+36     	; 0xaf4 <int2seg+0x50>
	return NINE;
    }
    else{ 
	return 0;
     ad0:	80 e0       	ldi	r24, 0x00	; 0
     ad2:	08 95       	ret
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
	return ZERO;
    }
    else if(number == 1 ){
	return ONE;
     ad4:	89 ef       	ldi	r24, 0xF9	; 249
     ad6:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
     ad8:	84 ea       	ldi	r24, 0xA4	; 164
     ada:	08 95       	ret
    }
    else if(number == 3 ){
	return THREE;
    }
    else if(number == 4 ){
	return FOUR;
     adc:	89 e9       	ldi	r24, 0x99	; 153
     ade:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
    }
    else if(number == 3 ){
	return THREE;
     ae0:	80 eb       	ldi	r24, 0xB0	; 176
     ae2:	08 95       	ret
    }
    else if(number == 4 ){
	return FOUR;
    }
    else if(number == 5 ){
	return FIVE;
     ae4:	82 e9       	ldi	r24, 0x92	; 146
     ae6:	08 95       	ret
    }
    else if(number == 6 ){
	return  SIX;
     ae8:	82 e8       	ldi	r24, 0x82	; 130
     aea:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
     aec:	88 ef       	ldi	r24, 0xF8	; 248
	return NINE;
    }
    else{ 
	return 0;
    }
}
     aee:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
    }
    else if(number == 8 ){
	return EIGHT;
     af0:	80 e8       	ldi	r24, 0x80	; 128
     af2:	08 95       	ret
    }
    else if(number == 9 ){
	return NINE;
     af4:	80 e9       	ldi	r24, 0x90	; 144
     af6:	08 95       	ret

00000af8 <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
     af8:	ff 92       	push	r15
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	ec 01       	movw	r28, r24
    //determine how many digits there are 
    //int digit;
    // Break down the digits

    if(ticker%2 == 1){
     b04:	80 91 48 01 	lds	r24, 0x0148
     b08:	80 ff       	sbrs	r24, 0
     b0a:	82 c0       	rjmp	.+260    	; 0xc10 <segsum+0x118>
	segment_data[2] = 0xFC;
     b0c:	8c ef       	ldi	r24, 0xFC	; 252
     b0e:	80 93 69 01 	sts	0x0169, r24
	segment_data[2] = 0xFF;
    } 
    //When setting alarm is on)
    //break up decimal sum into 4 digit-segments

    segment_data[0] = int2seg(sum % 10); //ones
     b12:	9e 01       	movw	r18, r28
     b14:	ad ec       	ldi	r26, 0xCD	; 205
     b16:	bc ec       	ldi	r27, 0xCC	; 204
     b18:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__umulhisi3>
     b1c:	96 95       	lsr	r25
     b1e:	87 95       	ror	r24
     b20:	96 95       	lsr	r25
     b22:	87 95       	ror	r24
     b24:	96 95       	lsr	r25
     b26:	87 95       	ror	r24
     b28:	3c 2f       	mov	r19, r28
     b2a:	2a e0       	ldi	r18, 0x0A	; 10
     b2c:	82 9f       	mul	r24, r18
     b2e:	30 19       	sub	r19, r0
     b30:	11 24       	eor	r1, r1
     b32:	83 2f       	mov	r24, r19
     b34:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     b38:	f8 2e       	mov	r15, r24
    segment_data[1] = int2seg((sum % 100)/10); //tens
     b3a:	9e 01       	movw	r18, r28
     b3c:	36 95       	lsr	r19
     b3e:	27 95       	ror	r18
     b40:	36 95       	lsr	r19
     b42:	27 95       	ror	r18
     b44:	ab e7       	ldi	r26, 0x7B	; 123
     b46:	b4 e1       	ldi	r27, 0x14	; 20
     b48:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__umulhisi3>
     b4c:	96 95       	lsr	r25
     b4e:	87 95       	ror	r24
     b50:	44 e6       	ldi	r20, 0x64	; 100
     b52:	48 9f       	mul	r20, r24
     b54:	90 01       	movw	r18, r0
     b56:	49 9f       	mul	r20, r25
     b58:	30 0d       	add	r19, r0
     b5a:	11 24       	eor	r1, r1
     b5c:	ce 01       	movw	r24, r28
     b5e:	82 1b       	sub	r24, r18
     b60:	93 0b       	sbc	r25, r19
     b62:	9c 01       	movw	r18, r24
     b64:	ad ec       	ldi	r26, 0xCD	; 205
     b66:	bc ec       	ldi	r27, 0xCC	; 204
     b68:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__umulhisi3>
     b6c:	96 95       	lsr	r25
     b6e:	87 95       	ror	r24
     b70:	96 95       	lsr	r25
     b72:	87 95       	ror	r24
     b74:	96 95       	lsr	r25
     b76:	87 95       	ror	r24
     b78:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     b7c:	80 93 68 01 	sts	0x0168, r24
    //segment_data[2] = 1; //decimal
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
     b80:	9e 01       	movw	r18, r28
     b82:	36 95       	lsr	r19
     b84:	27 95       	ror	r18
     b86:	36 95       	lsr	r19
     b88:	27 95       	ror	r18
     b8a:	36 95       	lsr	r19
     b8c:	27 95       	ror	r18
     b8e:	a5 ec       	ldi	r26, 0xC5	; 197
     b90:	b0 e2       	ldi	r27, 0x20	; 32
     b92:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__umulhisi3>
     b96:	8c 01       	movw	r16, r24
     b98:	12 95       	swap	r17
     b9a:	02 95       	swap	r16
     b9c:	0f 70       	andi	r16, 0x0F	; 15
     b9e:	01 27       	eor	r16, r17
     ba0:	1f 70       	andi	r17, 0x0F	; 15
     ba2:	01 27       	eor	r16, r17
     ba4:	48 ee       	ldi	r20, 0xE8	; 232
     ba6:	53 e0       	ldi	r21, 0x03	; 3
     ba8:	04 9f       	mul	r16, r20
     baa:	90 01       	movw	r18, r0
     bac:	05 9f       	mul	r16, r21
     bae:	30 0d       	add	r19, r0
     bb0:	14 9f       	mul	r17, r20
     bb2:	30 0d       	add	r19, r0
     bb4:	11 24       	eor	r1, r1
     bb6:	ce 01       	movw	r24, r28
     bb8:	82 1b       	sub	r24, r18
     bba:	93 0b       	sbc	r25, r19
     bbc:	9c 01       	movw	r18, r24
     bbe:	36 95       	lsr	r19
     bc0:	27 95       	ror	r18
     bc2:	36 95       	lsr	r19
     bc4:	27 95       	ror	r18
     bc6:	ab e7       	ldi	r26, 0x7B	; 123
     bc8:	b4 e1       	ldi	r27, 0x14	; 20
     bca:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__umulhisi3>
     bce:	96 95       	lsr	r25
     bd0:	87 95       	ror	r24
     bd2:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     bd6:	80 93 6a 01 	sts	0x016A, r24
    segment_data[4] = int2seg(sum/1000); //thousands
     bda:	80 2f       	mov	r24, r16
     bdc:	0e 94 52 05 	call	0xaa4	; 0xaa4 <int2seg>
     be0:	80 93 6b 01 	sts	0x016B, r24
    //blank out leading zero digits 
    //now move data to right place for misplaced colon position
    if(am_pm && show_ampm){
     be4:	80 91 34 01 	lds	r24, 0x0134
     be8:	88 23       	and	r24, r24
     bea:	21 f0       	breq	.+8      	; 0xbf4 <segsum+0xfc>
     bec:	80 91 4f 01 	lds	r24, 0x014F
     bf0:	81 11       	cpse	r24, r1
     bf2:	12 c0       	rjmp	.+36     	; 0xc18 <segsum+0x120>
	segment_data[0] &= 0x7F;
    }
    else{
	segment_data[0] |= 0b10000000;
     bf4:	8f 2d       	mov	r24, r15
     bf6:	80 68       	ori	r24, 0x80	; 128
     bf8:	80 93 67 01 	sts	0x0167, r24
    }
    if(mode == 1 && blink){
     bfc:	80 91 4e 01 	lds	r24, 0x014E
     c00:	81 30       	cpi	r24, 0x01	; 1
     c02:	91 f0       	breq	.+36     	; 0xc28 <segsum+0x130>
	segment_data[4] = 0xFF;
	segment_data[3] = 0xFF;
	segment_data[1] = 0xFF;
	segment_data[0] = 0xFF;
    }
}//segment_sum
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	ff 90       	pop	r15
     c0e:	08 95       	ret

    if(ticker%2 == 1){
	segment_data[2] = 0xFC;
    }
    else{
	segment_data[2] = 0xFF;
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	80 93 69 01 	sts	0x0169, r24
     c16:	7d cf       	rjmp	.-262    	; 0xb12 <segsum+0x1a>
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
    segment_data[4] = int2seg(sum/1000); //thousands
    //blank out leading zero digits 
    //now move data to right place for misplaced colon position
    if(am_pm && show_ampm){
	segment_data[0] &= 0x7F;
     c18:	8f 2d       	mov	r24, r15
     c1a:	8f 77       	andi	r24, 0x7F	; 127
     c1c:	80 93 67 01 	sts	0x0167, r24
    }
    else{
	segment_data[0] |= 0b10000000;
    }
    if(mode == 1 && blink){
     c20:	80 91 4e 01 	lds	r24, 0x014E
     c24:	81 30       	cpi	r24, 0x01	; 1
     c26:	71 f7       	brne	.-36     	; 0xc04 <segsum+0x10c>
     c28:	80 91 2a 01 	lds	r24, 0x012A
     c2c:	88 23       	and	r24, r24
     c2e:	51 f3       	breq	.-44     	; 0xc04 <segsum+0x10c>
	segment_data[4] = 0xFF;
     c30:	8f ef       	ldi	r24, 0xFF	; 255
     c32:	80 93 6b 01 	sts	0x016B, r24
	segment_data[3] = 0xFF;
     c36:	80 93 6a 01 	sts	0x016A, r24
	segment_data[1] = 0xFF;
     c3a:	80 93 68 01 	sts	0x0168, r24
	segment_data[0] = 0xFF;
     c3e:	80 93 67 01 	sts	0x0167, r24
    }
}//segment_sum
     c42:	df 91       	pop	r29
     c44:	cf 91       	pop	r28
     c46:	1f 91       	pop	r17
     c48:	0f 91       	pop	r16
     c4a:	ff 90       	pop	r15
     c4c:	08 95       	ret

00000c4e <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
     c4e:	1f 92       	push	r1
     c50:	0f 92       	push	r0
     c52:	0f b6       	in	r0, 0x3f	; 63
     c54:	0f 92       	push	r0
     c56:	11 24       	eor	r1, r1
     c58:	0b b6       	in	r0, 0x3b	; 59
     c5a:	0f 92       	push	r0
     c5c:	2f 93       	push	r18
     c5e:	3f 93       	push	r19
     c60:	4f 93       	push	r20
     c62:	5f 93       	push	r21
     c64:	6f 93       	push	r22
     c66:	7f 93       	push	r23
     c68:	8f 93       	push	r24
     c6a:	9f 93       	push	r25
     c6c:	af 93       	push	r26
     c6e:	bf 93       	push	r27
     c70:	ef 93       	push	r30
     c72:	ff 93       	push	r31
    static uint8_t count = 0;
    count++;
     c74:	20 91 45 01 	lds	r18, 0x0145
     c78:	2f 5f       	subi	r18, 0xFF	; 255
     c7a:	20 93 45 01 	sts	0x0145, r18
    //update_time();
    if(count%8 == 0){
     c7e:	82 2f       	mov	r24, r18
     c80:	87 70       	andi	r24, 0x07	; 7
     c82:	81 f4       	brne	.+32     	; 0xca4 <__vector_16+0x56>
	beat++;
     c84:	80 91 60 01 	lds	r24, 0x0160
     c88:	90 91 61 01 	lds	r25, 0x0161
     c8c:	01 96       	adiw	r24, 0x01	; 1
     c8e:	90 93 61 01 	sts	0x0161, r25
     c92:	80 93 60 01 	sts	0x0160, r24
	blink = !blink;
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	90 91 2a 01 	lds	r25, 0x012A
     c9c:	91 11       	cpse	r25, r1
     c9e:	3b c0       	rjmp	.+118    	; 0xd16 <__vector_16+0xc8>
     ca0:	80 93 2a 01 	sts	0x012A, r24
    }
    if((count%128)==0){
     ca4:	2f 77       	andi	r18, 0x7F	; 127
     ca6:	21 f5       	brne	.+72     	; 0xcf0 <__vector_16+0xa2>
	ticker++;     
     ca8:	80 91 48 01 	lds	r24, 0x0148
     cac:	8f 5f       	subi	r24, 0xFF	; 255
     cae:	80 93 48 01 	sts	0x0148, r24
	second++;    
     cb2:	80 91 4d 01 	lds	r24, 0x014D
     cb6:	8f 5f       	subi	r24, 0xFF	; 255
     cb8:	80 93 4d 01 	sts	0x014D, r24
	if(alarm_on){
     cbc:	80 91 2d 01 	lds	r24, 0x012D
     cc0:	88 23       	and	r24, r24
     cc2:	b1 f0       	breq	.+44     	; 0xcf0 <__vector_16+0xa2>
	    if ((alarm_time == time) && !snooze_flag && !music_status){
     cc4:	20 91 37 01 	lds	r18, 0x0137
     cc8:	30 91 38 01 	lds	r19, 0x0138
     ccc:	80 91 39 01 	lds	r24, 0x0139
     cd0:	90 91 3a 01 	lds	r25, 0x013A
     cd4:	28 17       	cp	r18, r24
     cd6:	39 07       	cpc	r19, r25
     cd8:	39 f1       	breq	.+78     	; 0xd28 <__vector_16+0xda>
		//play music
		music_on();
		music_status = 1;
	    }
	    else if(snooze_flag){
     cda:	80 91 2e 01 	lds	r24, 0x012E
     cde:	88 23       	and	r24, r24
     ce0:	39 f0       	breq	.+14     	; 0xcf0 <__vector_16+0xa2>
		snooze_second++;
     ce2:	80 91 2f 01 	lds	r24, 0x012F
     ce6:	8f 5f       	subi	r24, 0xFF	; 255
     ce8:	80 93 2f 01 	sts	0x012F, r24
		if(snooze_second >= 10){
     cec:	8a 30       	cpi	r24, 0x0A	; 10
     cee:	a8 f4       	brcc	.+42     	; 0xd1a <__vector_16+0xcc>
		    snooze_second = 0;
		}	
	    }
	}
    }
}
     cf0:	ff 91       	pop	r31
     cf2:	ef 91       	pop	r30
     cf4:	bf 91       	pop	r27
     cf6:	af 91       	pop	r26
     cf8:	9f 91       	pop	r25
     cfa:	8f 91       	pop	r24
     cfc:	7f 91       	pop	r23
     cfe:	6f 91       	pop	r22
     d00:	5f 91       	pop	r21
     d02:	4f 91       	pop	r20
     d04:	3f 91       	pop	r19
     d06:	2f 91       	pop	r18
     d08:	0f 90       	pop	r0
     d0a:	0b be       	out	0x3b, r0	; 59
     d0c:	0f 90       	pop	r0
     d0e:	0f be       	out	0x3f, r0	; 63
     d10:	0f 90       	pop	r0
     d12:	1f 90       	pop	r1
     d14:	18 95       	reti
    static uint8_t count = 0;
    count++;
    //update_time();
    if(count%8 == 0){
	beat++;
	blink = !blink;
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	c3 cf       	rjmp	.-122    	; 0xca0 <__vector_16+0x52>
		music_status = 1;
	    }
	    else if(snooze_flag){
		snooze_second++;
		if(snooze_second >= 10){
		    snooze_flag = 0;
     d1a:	10 92 2e 01 	sts	0x012E, r1
		    music_on();
     d1e:	0e 94 04 05 	call	0xa08	; 0xa08 <music_on>
		    snooze_second = 0;
     d22:	10 92 2f 01 	sts	0x012F, r1
     d26:	e4 cf       	rjmp	.-56     	; 0xcf0 <__vector_16+0xa2>
    }
    if((count%128)==0){
	ticker++;     
	second++;    
	if(alarm_on){
	    if ((alarm_time == time) && !snooze_flag && !music_status){
     d28:	80 91 2e 01 	lds	r24, 0x012E
     d2c:	81 11       	cpse	r24, r1
     d2e:	d9 cf       	rjmp	.-78     	; 0xce2 <__vector_16+0x94>
     d30:	80 91 2c 01 	lds	r24, 0x012C
     d34:	81 11       	cpse	r24, r1
     d36:	dc cf       	rjmp	.-72     	; 0xcf0 <__vector_16+0xa2>
		//play music
		music_on();
     d38:	0e 94 04 05 	call	0xa08	; 0xa08 <music_on>
		music_status = 1;
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	80 93 2c 01 	sts	0x012C, r24
     d42:	d6 cf       	rjmp	.-84     	; 0xcf0 <__vector_16+0xa2>

00000d44 <__vector_12>:
	    }
	}
    }
}

ISR(TIMER1_COMPA_vect){
     d44:	1f 92       	push	r1
     d46:	0f 92       	push	r0
     d48:	0f b6       	in	r0, 0x3f	; 63
     d4a:	0f 92       	push	r0
     d4c:	11 24       	eor	r1, r1
     d4e:	0b b6       	in	r0, 0x3b	; 59
     d50:	0f 92       	push	r0
     d52:	2f 93       	push	r18
     d54:	3f 93       	push	r19
     d56:	4f 93       	push	r20
     d58:	5f 93       	push	r21
     d5a:	6f 93       	push	r22
     d5c:	7f 93       	push	r23
     d5e:	8f 93       	push	r24
     d60:	9f 93       	push	r25
     d62:	af 93       	push	r26
     d64:	bf 93       	push	r27
     d66:	ef 93       	push	r30
     d68:	ff 93       	push	r31
    PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
     d6a:	82 b3       	in	r24, 0x12	; 18
     d6c:	80 58       	subi	r24, 0x80	; 128
     d6e:	82 bb       	out	0x12, r24	; 18
    PORTB |= (1<<PB0);
     d70:	c0 9a       	sbi	0x18, 0	; 24
    if(beat >= max_beat) {   //if we've played the note long enough
     d72:	20 91 60 01 	lds	r18, 0x0160
     d76:	30 91 61 01 	lds	r19, 0x0161
     d7a:	80 91 5e 01 	lds	r24, 0x015E
     d7e:	90 91 5f 01 	lds	r25, 0x015F
     d82:	28 17       	cp	r18, r24
     d84:	39 07       	cpc	r19, r25
     d86:	60 f0       	brcs	.+24     	; 0xda0 <__vector_12+0x5c>
	notes++;               //move on to the next note
     d88:	80 91 50 01 	lds	r24, 0x0150
     d8c:	8f 5f       	subi	r24, 0xFF	; 255
     d8e:	80 93 50 01 	sts	0x0150, r24
	play_song(song, notes);//and play it
     d92:	80 91 50 01 	lds	r24, 0x0150
     d96:	90 91 5d 01 	lds	r25, 0x015D
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	0e 94 15 04 	call	0x82a	; 0x82a <song0>
    }
}
     da0:	ff 91       	pop	r31
     da2:	ef 91       	pop	r30
     da4:	bf 91       	pop	r27
     da6:	af 91       	pop	r26
     da8:	9f 91       	pop	r25
     daa:	8f 91       	pop	r24
     dac:	7f 91       	pop	r23
     dae:	6f 91       	pop	r22
     db0:	5f 91       	pop	r21
     db2:	4f 91       	pop	r20
     db4:	3f 91       	pop	r19
     db6:	2f 91       	pop	r18
     db8:	0f 90       	pop	r0
     dba:	0b be       	out	0x3b, r0	; 59
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	0f 90       	pop	r0
     dc2:	1f 90       	pop	r1
     dc4:	18 95       	reti

00000dc6 <__vector_21>:
	default:
	    break;
    }    
} 

ISR(ADC_vect){
     dc6:	1f 92       	push	r1
     dc8:	0f 92       	push	r0
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	0f 92       	push	r0
     dce:	11 24       	eor	r1, r1
     dd0:	8f 93       	push	r24
     dd2:	9f 93       	push	r25

    if(ADCH < 100){
     dd4:	85 b1       	in	r24, 0x05	; 5
     dd6:	84 36       	cpi	r24, 0x64	; 100
     dd8:	48 f0       	brcs	.+18     	; 0xdec <__vector_21+0x26>
	OCR2 = 100-ADCH;
    }  
    else{
	OCR2 = 1;// brightness_level;
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	83 bd       	out	0x23, r24	; 35
    }
}
     dde:	9f 91       	pop	r25
     de0:	8f 91       	pop	r24
     de2:	0f 90       	pop	r0
     de4:	0f be       	out	0x3f, r0	; 63
     de6:	0f 90       	pop	r0
     de8:	1f 90       	pop	r1
     dea:	18 95       	reti
} 

ISR(ADC_vect){

    if(ADCH < 100){
	OCR2 = 100-ADCH;
     dec:	95 b1       	in	r25, 0x05	; 5
     dee:	84 e6       	ldi	r24, 0x64	; 100
     df0:	89 1b       	sub	r24, r25
     df2:	83 bd       	out	0x23, r24	; 35
    }  
    else{
	OCR2 = 1;// brightness_level;
    }
}
     df4:	9f 91       	pop	r25
     df6:	8f 91       	pop	r24
     df8:	0f 90       	pop	r0
     dfa:	0f be       	out	0x3f, r0	; 63
     dfc:	0f 90       	pop	r0
     dfe:	1f 90       	pop	r1
     e00:	18 95       	reti

00000e02 <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
    static int minute_change = 0;
    if (second >= 60){
     e02:	80 91 4d 01 	lds	r24, 0x014D
	minute++;
     e06:	20 91 4c 01 	lds	r18, 0x014C
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
    static int minute_change = 0;
    if (second >= 60){
     e0a:	8c 33       	cpi	r24, 0x3C	; 60
     e0c:	28 f0       	brcs	.+10     	; 0xe18 <update_time+0x16>
	minute++;
     e0e:	2f 5f       	subi	r18, 0xFF	; 255
     e10:	20 93 4c 01 	sts	0x014C, r18
	second = 0;
     e14:	10 92 4d 01 	sts	0x014D, r1
    }             
    if(minute >=60){
	hour++;
     e18:	e0 91 4b 01 	lds	r30, 0x014B
    static int minute_change = 0;
    if (second >= 60){
	minute++;
	second = 0;
    }             
    if(minute >=60){
     e1c:	2c 33       	cpi	r18, 0x3C	; 60
     e1e:	e8 f5       	brcc	.+122    	; 0xe9a <update_time+0x98>
     e20:	30 e0       	ldi	r19, 0x00	; 0
	hour++;
	minute = 0;
    }
    if(hour >= 24){
     e22:	e8 31       	cpi	r30, 0x18	; 24
     e24:	08 f0       	brcs	.+2      	; 0xe28 <update_time+0x26>
     e26:	43 c0       	rjmp	.+134    	; 0xeae <update_time+0xac>
     e28:	6e 2f       	mov	r22, r30
     e2a:	70 e0       	ldi	r23, 0x00	; 0
     e2c:	84 e6       	ldi	r24, 0x64	; 100
     e2e:	e8 9f       	mul	r30, r24
     e30:	a0 01       	movw	r20, r0
     e32:	11 24       	eor	r1, r1
	hour = 0;
    } 
    minute_change = 1;

    alarm_time = (alarm_hour * 100) + alarm_minute;
     e34:	f0 91 49 01 	lds	r31, 0x0149
     e38:	80 91 4a 01 	lds	r24, 0x014A
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	a4 e6       	ldi	r26, 0x64	; 100
     e40:	fa 9f       	mul	r31, r26
     e42:	80 0d       	add	r24, r0
     e44:	91 1d       	adc	r25, r1
     e46:	11 24       	eor	r1, r1
     e48:	90 93 38 01 	sts	0x0138, r25
     e4c:	80 93 37 01 	sts	0x0137, r24
    if(minute_change){
	time = (hour * 100) + minute;
     e50:	c9 01       	movw	r24, r18
     e52:	84 0f       	add	r24, r20
     e54:	95 1f       	adc	r25, r21
     e56:	90 93 3a 01 	sts	0x013A, r25
     e5a:	80 93 39 01 	sts	0x0139, r24
	minute_change = 0;
     e5e:	10 92 43 01 	sts	0x0143, r1
     e62:	10 92 42 01 	sts	0x0142, r1

	if(show_ampm){
     e66:	40 91 4f 01 	lds	r20, 0x014F
     e6a:	44 23       	and	r20, r20
     e6c:	41 f1       	breq	.+80     	; 0xebe <update_time+0xbc>
	    if(hour>=12){
     e6e:	ec 30       	cpi	r30, 0x0C	; 12
     e70:	58 f1       	brcs	.+86     	; 0xec8 <update_time+0xc6>
		if(hour == 12){
     e72:	ec 30       	cpi	r30, 0x0C	; 12
     e74:	d9 f1       	breq	.+118    	; 0xeec <update_time+0xea>
		    show_time = 1200 + minute;
		}
		else{
		    show_time = (hour-12)*100 + minute;
     e76:	6c 50       	subi	r22, 0x0C	; 12
     e78:	71 09       	sbc	r23, r1
     e7a:	44 e6       	ldi	r20, 0x64	; 100
     e7c:	46 9f       	mul	r20, r22
     e7e:	c0 01       	movw	r24, r0
     e80:	47 9f       	mul	r20, r23
     e82:	90 0d       	add	r25, r0
     e84:	11 24       	eor	r1, r1
     e86:	82 0f       	add	r24, r18
     e88:	93 1f       	adc	r25, r19
     e8a:	90 93 36 01 	sts	0x0136, r25
     e8e:	80 93 35 01 	sts	0x0135, r24
		    am_pm = 1;
     e92:	81 e0       	ldi	r24, 0x01	; 1
     e94:	80 93 34 01 	sts	0x0134, r24
     e98:	08 95       	ret
    if (second >= 60){
	minute++;
	second = 0;
    }             
    if(minute >=60){
	hour++;
     e9a:	ef 5f       	subi	r30, 0xFF	; 255
     e9c:	e0 93 4b 01 	sts	0x014B, r30
	minute = 0;
     ea0:	10 92 4c 01 	sts	0x014C, r1
     ea4:	20 e0       	ldi	r18, 0x00	; 0
     ea6:	30 e0       	ldi	r19, 0x00	; 0
    }
    if(hour >= 24){
     ea8:	e8 31       	cpi	r30, 0x18	; 24
     eaa:	08 f4       	brcc	.+2      	; 0xeae <update_time+0xac>
     eac:	bd cf       	rjmp	.-134    	; 0xe28 <update_time+0x26>
	hour = 0;
     eae:	10 92 4b 01 	sts	0x014B, r1
     eb2:	40 e0       	ldi	r20, 0x00	; 0
     eb4:	50 e0       	ldi	r21, 0x00	; 0
     eb6:	60 e0       	ldi	r22, 0x00	; 0
     eb8:	70 e0       	ldi	r23, 0x00	; 0
     eba:	e0 e0       	ldi	r30, 0x00	; 0
     ebc:	bb cf       	rjmp	.-138    	; 0xe34 <update_time+0x32>
		}
		am_pm = 0;
	    }
	}
	else{
	    show_time = (hour * 100) + minute;
     ebe:	90 93 36 01 	sts	0x0136, r25
     ec2:	80 93 35 01 	sts	0x0135, r24
     ec6:	08 95       	ret
		    show_time = (hour-12)*100 + minute;
		    am_pm = 1;
		}
	    }
	    else{           
		if(hour == 0){
     ec8:	ee 23       	and	r30, r30
     eca:	39 f0       	breq	.+14     	; 0xeda <update_time+0xd8>
		    show_time = 1200 + minute;
		}
		else{
		    show_time = (hour)*100 + minute;
     ecc:	90 93 36 01 	sts	0x0136, r25
     ed0:	80 93 35 01 	sts	0x0135, r24
		}
		am_pm = 0;
     ed4:	10 92 34 01 	sts	0x0134, r1
     ed8:	08 95       	ret
		    am_pm = 1;
		}
	    }
	    else{           
		if(hour == 0){
		    show_time = 1200 + minute;
     eda:	20 55       	subi	r18, 0x50	; 80
     edc:	3b 4f       	sbci	r19, 0xFB	; 251
     ede:	30 93 36 01 	sts	0x0136, r19
     ee2:	20 93 35 01 	sts	0x0135, r18
		}
		else{
		    show_time = (hour)*100 + minute;
		}
		am_pm = 0;
     ee6:	10 92 34 01 	sts	0x0134, r1
     eea:	08 95       	ret
	minute_change = 0;

	if(show_ampm){
	    if(hour>=12){
		if(hour == 12){
		    show_time = 1200 + minute;
     eec:	20 55       	subi	r18, 0x50	; 80
     eee:	3b 4f       	sbci	r19, 0xFB	; 251
     ef0:	30 93 36 01 	sts	0x0136, r19
     ef4:	20 93 35 01 	sts	0x0135, r18
     ef8:	08 95       	ret

00000efa <SPI_init>:
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     efa:	81 e5       	ldi	r24, 0x51	; 81
     efc:	8d b9       	out	0x0d, r24	; 13
     efe:	08 95       	ret

00000f00 <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
     f00:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
     f02:	77 9b       	sbis	0x0e, 7	; 14
     f04:	fe cf       	rjmp	.-4      	; 0xf02 <SPI_Transmit+0x2>
}
     f06:	08 95       	ret

00000f08 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
    PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
     f08:	83 b1       	in	r24, 0x03	; 3
     f0a:	13 b8       	out	0x03, r1	; 3
    __asm__ __volatile__ ("nop");
     f0c:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f0e:	00 00       	nop
    // Wait until 8 clock cycles are done 
    SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
     f10:	1f b8       	out	0x0f, r1	; 15
    PORTE |= (1 << PE6);  
     f12:	1e 9a       	sbi	0x03, 6	; 3
    __asm__ __volatile__ ("nop");
     f14:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f16:	00 00       	nop
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
     f18:	77 9b       	sbis	0x0e, 7	; 14
     f1a:	fe cf       	rjmp	.-4      	; 0xf18 <SPI_Receive+0x10>
    // Return incoming data from SPDR
    return(SPDR);  
     f1c:	8f b1       	in	r24, 0x0f	; 15
}
     f1e:	08 95       	ret

00000f20 <bar_graph>:
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    if(mode == 0){
     f20:	80 91 4e 01 	lds	r24, 0x014E
     f24:	88 23       	and	r24, r24
     f26:	b9 f0       	breq	.+46     	; 0xf56 <bar_graph+0x36>
	write = 0x00;
    }
    else{
	write = 1<<(mode-1);
     f28:	9f ef       	ldi	r25, 0xFF	; 255
     f2a:	98 0f       	add	r25, r24
     f2c:	81 e0       	ldi	r24, 0x01	; 1
     f2e:	01 c0       	rjmp	.+2      	; 0xf32 <bar_graph+0x12>
     f30:	88 0f       	add	r24, r24
     f32:	9a 95       	dec	r25
     f34:	ea f7       	brpl	.-6      	; 0xf30 <bar_graph+0x10>
    }

    if(alarm_on != 0){
     f36:	90 91 2d 01 	lds	r25, 0x012D
     f3a:	91 11       	cpse	r25, r1
	write = 0xF0;
     f3c:	80 ef       	ldi	r24, 0xF0	; 240

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
     f3e:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
     f40:	77 9b       	sbis	0x0e, 7	; 14
     f42:	fe cf       	rjmp	.-4      	; 0xf40 <bar_graph+0x20>
	write = 0xF0;
    }
    //write &= 0xF7;
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
     f44:	84 e0       	ldi	r24, 0x04	; 4
     f46:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop"); //Buffer
     f48:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
     f4a:	00 00       	nop


    PORTD = (2 << PD2);  // Push data out of SPI
     f4c:	88 e0       	ldi	r24, 0x08	; 8
     f4e:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop");  //Buffer
     f50:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
     f52:	00 00       	nop
     f54:	08 95       	ret
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    if(mode == 0){
	write = 0x00;
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	ee cf       	rjmp	.-36     	; 0xf36 <bar_graph+0x16>

00000f5a <button_routine>:
	segment_data[1] = 0xFF;
	segment_data[0] = 0xFF;
    }
}//segment_sum
//***********************************************************************************
void button_routine(){
     f5a:	ff 92       	push	r15
     f5c:	0f 93       	push	r16
     f5e:	1f 93       	push	r17
     f60:	cf 93       	push	r28
     f62:	df 93       	push	r29
    // L -> R
    // 3 2 1 0 7 6 5 4
    uint8_t button = 0;
    static int previous_mode;   
    DDRA  = 0x00; // PORTA input mode
     f64:	1a ba       	out	0x1a, r1	; 26
    PORTA = 0xFF; //Pull ups
     f66:	8f ef       	ldi	r24, 0xFF	; 255
     f68:	8b bb       	out	0x1b, r24	; 27
    __asm__ __volatile__ ("nop");
     f6a:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f6c:	00 00       	nop
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
     f6e:	88 b3       	in	r24, 0x18	; 24
     f70:	80 67       	ori	r24, 0x70	; 112
     f72:	88 bb       	out	0x18, r24	; 24
    __asm__ __volatile__ ("nop");
     f74:	00 00       	nop
    __asm__ __volatile__ ("nop");
     f76:	00 00       	nop
     f78:	c0 e0       	ldi	r28, 0x00	; 0
     f7a:	d0 e0       	ldi	r29, 0x00	; 0
		case 7:
		    if(alarm_on && music_status){
			music_off();
			music_status = 0;
		    }
		    alarm_on = !alarm_on;
     f7c:	11 e0       	ldi	r17, 0x01	; 1
		case 3:
		    if(mode == 3){
			mode = 0;			
		    }
		    else{
			mode = 3;
     f7e:	03 e0       	ldi	r16, 0x03	; 3
     f80:	f0 2e       	mov	r15, r16
		case 2:
		    if(mode == 2){
			mode = 0;	
		    }
		    else{
			mode = 2;
     f82:	02 e0       	ldi	r16, 0x02	; 2
     f84:	0f c0       	rjmp	.+30     	; 0xfa4 <button_routine+0x4a>
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     f86:	41 e0       	ldi	r20, 0x01	; 1
     f88:	50 ee       	ldi	r21, 0xE0	; 224
     f8a:	24 2b       	or	r18, r20
     f8c:	35 2b       	or	r19, r21
     f8e:	30 93 47 01 	sts	0x0147, r19
     f92:	20 93 46 01 	sts	0x0146, r18
    if (state == 0xF000){
     f96:	21 15       	cp	r18, r1
     f98:	30 4f       	sbci	r19, 0xF0	; 240
     f9a:	c1 f0       	breq	.+48     	; 0xfcc <button_routine+0x72>
     f9c:	21 96       	adiw	r28, 0x01	; 1
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed

    for (button = 0 ; button < BUTTON_COUNT ; button++){
     f9e:	c8 30       	cpi	r28, 0x08	; 8
     fa0:	d1 05       	cpc	r29, r1
     fa2:	79 f1       	breq	.+94     	; 0x1002 <button_routine+0xa8>
     fa4:	8c 2f       	mov	r24, r28
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     fa6:	20 91 46 01 	lds	r18, 0x0146
     faa:	30 91 47 01 	lds	r19, 0x0147
     fae:	22 0f       	add	r18, r18
     fb0:	33 1f       	adc	r19, r19
     fb2:	49 b3       	in	r20, 0x19	; 25
     fb4:	50 e0       	ldi	r21, 0x00	; 0
     fb6:	0c 2e       	mov	r0, r28
     fb8:	02 c0       	rjmp	.+4      	; 0xfbe <button_routine+0x64>
     fba:	55 95       	asr	r21
     fbc:	47 95       	ror	r20
     fbe:	0a 94       	dec	r0
     fc0:	e2 f7       	brpl	.-8      	; 0xfba <button_routine+0x60>
     fc2:	40 ff       	sbrs	r20, 0
     fc4:	e0 cf       	rjmp	.-64     	; 0xf86 <button_routine+0x2c>
     fc6:	40 e0       	ldi	r20, 0x00	; 0
     fc8:	50 ee       	ldi	r21, 0xE0	; 224
     fca:	df cf       	rjmp	.-66     	; 0xf8a <button_routine+0x30>
    //now check each button and increment the count as needed

    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    switch(button){
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	88 30       	cpi	r24, 0x08	; 8
     fd0:	91 05       	cpc	r25, r1
     fd2:	88 f4       	brcc	.+34     	; 0xff6 <button_routine+0x9c>
     fd4:	fc 01       	movw	r30, r24
     fd6:	ec 52       	subi	r30, 0x2C	; 44
     fd8:	ff 4f       	sbci	r31, 0xFF	; 255
     fda:	0c 94 35 0e 	jmp	0x1c6a	; 0x1c6a <__tablejump2__>
			music_status = 0;
			music_off();
		    }
		    break;
		case 7:
		    if(alarm_on && music_status){
     fde:	80 91 2d 01 	lds	r24, 0x012D
     fe2:	81 11       	cpse	r24, r1
     fe4:	57 c0       	rjmp	.+174    	; 0x1094 <button_routine+0x13a>
     fe6:	90 e0       	ldi	r25, 0x00	; 0
			music_off();
			music_status = 0;
		    }
		    alarm_on = !alarm_on;
     fe8:	81 e0       	ldi	r24, 0x01	; 1
     fea:	91 11       	cpse	r25, r1
     fec:	80 e0       	ldi	r24, 0x00	; 0
     fee:	80 93 2d 01 	sts	0x012D, r24
		    update_LCD = 1;
     ff2:	10 93 3b 01 	sts	0x013B, r17
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
     ff6:	0e 94 90 07 	call	0xf20	; 0xf20 <bar_graph>
     ffa:	21 96       	adiw	r28, 0x01	; 1
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed

    for (button = 0 ; button < BUTTON_COUNT ; button++){
     ffc:	c8 30       	cpi	r28, 0x08	; 8
     ffe:	d1 05       	cpc	r29, r1
    1000:	89 f6       	brne	.-94     	; 0xfa4 <button_routine+0x4a>
	       bar_graph();
	       previous_mode = button;
	     */
	}
    }
    DDRA = 0xFF;  //switch PORTA to output
    1002:	8f ef       	ldi	r24, 0xFF	; 255
    1004:	8a bb       	out	0x1a, r24	; 26
    __asm__ __volatile__ ("nop"); //Buffer
    1006:	00 00       	nop
    __asm__ __volatile__ ("nop"); //Buffer 
    1008:	00 00       	nop

}
    100a:	df 91       	pop	r29
    100c:	cf 91       	pop	r28
    100e:	1f 91       	pop	r17
    1010:	0f 91       	pop	r16
    1012:	ff 90       	pop	r15
    1014:	08 95       	ret
	    switch(button){
		case 0:  
		    mode = 0;
		    break;
		case 1:
		    if(mode == 1){
    1016:	80 91 4e 01 	lds	r24, 0x014E
    101a:	81 30       	cpi	r24, 0x01	; 1
    101c:	91 f5       	brne	.+100    	; 0x1082 <button_routine+0x128>
			mode = 0;	
    101e:	10 92 4e 01 	sts	0x014E, r1
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    1022:	0e 94 90 07 	call	0xf20	; 0xf20 <bar_graph>
    1026:	e9 cf       	rjmp	.-46     	; 0xffa <button_routine+0xa0>
		    else{
			mode = 1;
		    }
		    break;
		case 2:
		    if(mode == 2){
    1028:	80 91 4e 01 	lds	r24, 0x014E
    102c:	82 30       	cpi	r24, 0x02	; 2
    102e:	b9 f3       	breq	.-18     	; 0x101e <button_routine+0xc4>
			mode = 0;	
		    }
		    else{
			mode = 2;
    1030:	00 93 4e 01 	sts	0x014E, r16
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    1034:	0e 94 90 07 	call	0xf20	; 0xf20 <bar_graph>
    1038:	e0 cf       	rjmp	.-64     	; 0xffa <button_routine+0xa0>
		    break;
		case 5:
		    show_ampm = !show_ampm;
		    break;
		case 6:
		    if(music_status){
    103a:	80 91 2c 01 	lds	r24, 0x012C
    103e:	88 23       	and	r24, r24
    1040:	d1 f2       	breq	.-76     	; 0xff6 <button_routine+0x9c>
			snooze_flag = 1;
    1042:	10 93 2e 01 	sts	0x012E, r17
			music_status = 0;
    1046:	10 92 2c 01 	sts	0x012C, r1
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
    104a:	10 92 50 01 	sts	0x0150, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
    104e:	8e b5       	in	r24, 0x2e	; 46
    1050:	8c 7f       	andi	r24, 0xFC	; 252
    1052:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
    1054:	92 9a       	sbi	0x12, 2	; 18
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    1056:	0e 94 90 07 	call	0xf20	; 0xf20 <bar_graph>
    105a:	cf cf       	rjmp	.-98     	; 0xffa <button_routine+0xa0>
		    }
		    break;
		case 4:
		    break;
		case 5:
		    show_ampm = !show_ampm;
    105c:	81 e0       	ldi	r24, 0x01	; 1
    105e:	90 91 4f 01 	lds	r25, 0x014F
    1062:	91 11       	cpse	r25, r1
    1064:	13 c0       	rjmp	.+38     	; 0x108c <button_routine+0x132>
    1066:	80 93 4f 01 	sts	0x014F, r24
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    106a:	0e 94 90 07 	call	0xf20	; 0xf20 <bar_graph>
    106e:	c5 cf       	rjmp	.-118    	; 0xffa <button_routine+0xa0>
		    else{
			mode = 2;
		    }
		    break;
		case 3:
		    if(mode == 3){
    1070:	80 91 4e 01 	lds	r24, 0x014E
    1074:	83 30       	cpi	r24, 0x03	; 3
    1076:	99 f2       	breq	.-90     	; 0x101e <button_routine+0xc4>
			mode = 0;			
		    }
		    else{
			mode = 3;
    1078:	f0 92 4e 01 	sts	0x014E, r15
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    107c:	0e 94 90 07 	call	0xf20	; 0xf20 <bar_graph>
    1080:	bc cf       	rjmp	.-136    	; 0xffa <button_routine+0xa0>
		case 1:
		    if(mode == 1){
			mode = 0;	
		    }
		    else{
			mode = 1;
    1082:	10 93 4e 01 	sts	0x014E, r17
		    //alarm_change = 1; 
		    break;
		default:
		    break;
	    }
	    bar_graph();
    1086:	0e 94 90 07 	call	0xf20	; 0xf20 <bar_graph>
    108a:	b7 cf       	rjmp	.-146    	; 0xffa <button_routine+0xa0>
		    }
		    break;
		case 4:
		    break;
		case 5:
		    show_ampm = !show_ampm;
    108c:	80 e0       	ldi	r24, 0x00	; 0
    108e:	80 93 4f 01 	sts	0x014F, r24
    1092:	eb cf       	rjmp	.-42     	; 0x106a <button_routine+0x110>
			music_status = 0;
			music_off();
		    }
		    break;
		case 7:
		    if(alarm_on && music_status){
    1094:	90 91 2c 01 	lds	r25, 0x012C
    1098:	99 23       	and	r25, r25
    109a:	59 f0       	breq	.+22     	; 0x10b2 <button_routine+0x158>
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
    109c:	10 92 50 01 	sts	0x0150, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
    10a0:	8e b5       	in	r24, 0x2e	; 46
    10a2:	8c 7f       	andi	r24, 0xFC	; 252
    10a4:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
    10a6:	92 9a       	sbi	0x12, 2	; 18
			music_off();
			music_status = 0;
    10a8:	10 92 2c 01 	sts	0x012C, r1
    10ac:	90 91 2d 01 	lds	r25, 0x012D
    10b0:	9b cf       	rjmp	.-202    	; 0xfe8 <button_routine+0x8e>
    10b2:	98 2f       	mov	r25, r24
    10b4:	99 cf       	rjmp	.-206    	; 0xfe8 <button_routine+0x8e>

000010b6 <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    uint8_t display_segment = 0;
    //static uint8_t rotate_7seg = 0;
    switch(mode){
    10b6:	80 91 4e 01 	lds	r24, 0x014E
    10ba:	83 30       	cpi	r24, 0x03	; 3
    10bc:	31 f1       	breq	.+76     	; 0x110a <__stack+0xb>
    10be:	84 30       	cpi	r24, 0x04	; 4
    10c0:	41 f0       	breq	.+16     	; 0x10d2 <display_update+0x1c>
    10c2:	82 30       	cpi	r24, 0x02	; 2
    10c4:	c9 f0       	breq	.+50     	; 0x10f8 <display_update+0x42>
	    segment_data[2] = 0xFF; //decimal
	    break;
	case 4:
	    break;
	default:
	    segsum(show_time);
    10c6:	80 91 35 01 	lds	r24, 0x0135
    10ca:	90 91 36 01 	lds	r25, 0x0136
    10ce:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <segsum>
    10d2:	e7 e6       	ldi	r30, 0x67	; 103
    10d4:	f1 e0       	ldi	r31, 0x01	; 1
    __asm__ __volatile__ ("nop");  //Buffer
}
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    10d6:	80 e0       	ldi	r24, 0x00	; 0

    for(display_segment = 0 ; display_segment < 5 ; display_segment++){
	PORTB = display_segment << 4;
	PORTA = segment_data[display_segment];
	_delay_us(40);
	PORTA = OFF;
    10d8:	2f ef       	ldi	r18, 0xFF	; 255
	    segsum(show_time);
	    break;
    }

    for(display_segment = 0 ; display_segment < 5 ; display_segment++){
	PORTB = display_segment << 4;
    10da:	98 2f       	mov	r25, r24
    10dc:	92 95       	swap	r25
    10de:	90 7f       	andi	r25, 0xF0	; 240
    10e0:	98 bb       	out	0x18, r25	; 24
	PORTA = segment_data[display_segment];
    10e2:	91 91       	ld	r25, Z+
    10e4:	9b bb       	out	0x1b, r25	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10e6:	95 ed       	ldi	r25, 0xD5	; 213
    10e8:	9a 95       	dec	r25
    10ea:	f1 f7       	brne	.-4      	; 0x10e8 <display_update+0x32>
    10ec:	00 00       	nop
	_delay_us(40);
	PORTA = OFF;
    10ee:	2b bb       	out	0x1b, r18	; 27
	default:
	    segsum(show_time);
	    break;
    }

    for(display_segment = 0 ; display_segment < 5 ; display_segment++){
    10f0:	8f 5f       	subi	r24, 0xFF	; 255
    10f2:	85 30       	cpi	r24, 0x05	; 5
    10f4:	91 f7       	brne	.-28     	; 0x10da <display_update+0x24>
       PORTB |= rotate_7seg << 4;
       PORTA = segment_data[rotate_7seg];	
       rotate_7seg++;
     */
    //_delay_us(40);
}
    10f6:	08 95       	ret
void display_update(){
    uint8_t display_segment = 0;
    //static uint8_t rotate_7seg = 0;
    switch(mode){
	case 2:
	    segsum(alarm_time);
    10f8:	80 91 37 01 	lds	r24, 0x0137
    10fc:	90 91 38 01 	lds	r25, 0x0138
    1100:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <segsum>
	    segment_data[2] = 0x00;
    1104:	10 92 69 01 	sts	0x0169, r1
	    break;
    1108:	e4 cf       	rjmp	.-56     	; 0x10d2 <display_update+0x1c>
	case 3:
	    segsum(volume);
    110a:	80 91 2b 01 	lds	r24, 0x012B
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <segsum>
	    segment_data[2] = 0xFF; //decimal
    1114:	8f ef       	ldi	r24, 0xFF	; 255
    1116:	80 93 69 01 	sts	0x0169, r24
	    break;
    111a:	db cf       	rjmp	.-74     	; 0x10d2 <display_update+0x1c>

0000111c <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
    switch(mode){
    111c:	80 91 4e 01 	lds	r24, 0x014E
    1120:	81 30       	cpi	r24, 0x01	; 1
    1122:	59 f0       	breq	.+22     	; 0x113a <right_inc+0x1e>
    1124:	82 30       	cpi	r24, 0x02	; 2
    1126:	41 f4       	brne	.+16     	; 0x1138 <right_inc+0x1c>
		minute = 0;	    
	    }
	    second++;
	    break;
	case 2: 
	    alarm_minute++;
    1128:	80 91 4a 01 	lds	r24, 0x014A
    112c:	8f 5f       	subi	r24, 0xFF	; 255
	    if(alarm_minute >= 60){
    112e:	8c 33       	cpi	r24, 0x3C	; 60
    1130:	88 f0       	brcs	.+34     	; 0x1154 <right_inc+0x38>
		alarm_minute = 0;	
    1132:	10 92 4a 01 	sts	0x014A, r1
    1136:	08 95       	ret
    1138:	08 95       	ret
void right_inc(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute++;
    113a:	80 91 4c 01 	lds	r24, 0x014C
    113e:	8f 5f       	subi	r24, 0xFF	; 255
	    if(minute >= 60){
    1140:	8c 33       	cpi	r24, 0x3C	; 60
    1142:	58 f0       	brcs	.+22     	; 0x115a <right_inc+0x3e>
		minute = 0;	    
    1144:	10 92 4c 01 	sts	0x014C, r1
	    }
	    second++;
    1148:	80 91 4d 01 	lds	r24, 0x014D
    114c:	8f 5f       	subi	r24, 0xFF	; 255
    114e:	80 93 4d 01 	sts	0x014D, r24
	    break;
    1152:	08 95       	ret
	case 2: 
	    alarm_minute++;
    1154:	80 93 4a 01 	sts	0x014A, r24
    1158:	08 95       	ret
void right_inc(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute++;
    115a:	80 93 4c 01 	sts	0x014C, r24
	    if(minute >= 60){
		minute = 0;	    
	    }
	    second++;
    115e:	80 91 4d 01 	lds	r24, 0x014D
    1162:	8f 5f       	subi	r24, 0xFF	; 255
    1164:	80 93 4d 01 	sts	0x014D, r24
	    break;
    1168:	08 95       	ret

0000116a <right_dec>:
	default:
	    break;             
    }
}
void right_dec(){
    switch(mode){
    116a:	80 91 4e 01 	lds	r24, 0x014E
    116e:	81 30       	cpi	r24, 0x01	; 1
    1170:	71 f0       	breq	.+28     	; 0x118e <right_dec+0x24>
    1172:	82 30       	cpi	r24, 0x02	; 2
    1174:	59 f4       	brne	.+22     	; 0x118c <right_dec+0x22>
	    if(minute >= 240){
		minute = 59;	    
	    }   
	    break;
	case 2: 
	    alarm_minute--;
    1176:	80 91 4a 01 	lds	r24, 0x014A
    117a:	81 50       	subi	r24, 0x01	; 1
    117c:	80 93 4a 01 	sts	0x014A, r24
	    if(alarm_minute >= 240){
    1180:	80 3f       	cpi	r24, 0xF0	; 240
    1182:	18 f0       	brcs	.+6      	; 0x118a <right_dec+0x20>
		alarm_minute = 59;	
    1184:	8b e3       	ldi	r24, 0x3B	; 59
    1186:	80 93 4a 01 	sts	0x014A, r24
    118a:	08 95       	ret
    118c:	08 95       	ret
void right_dec(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute--;
    118e:	80 91 4c 01 	lds	r24, 0x014C
    1192:	81 50       	subi	r24, 0x01	; 1
    1194:	80 93 4c 01 	sts	0x014C, r24
	    if(minute >= 240){
    1198:	80 3f       	cpi	r24, 0xF0	; 240
    119a:	b8 f3       	brcs	.-18     	; 0x118a <right_dec+0x20>
		minute = 59;	    
    119c:	8b e3       	ldi	r24, 0x3B	; 59
    119e:	80 93 4c 01 	sts	0x014C, r24
    11a2:	08 95       	ret

000011a4 <decode_spi_right_knob>:
    previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
    11a4:	cf 93       	push	r28
    11a6:	df 93       	push	r29
    11a8:	1f 92       	push	r1
    11aa:	cd b7       	in	r28, 0x3d	; 61
    11ac:	de b7       	in	r29, 0x3e	; 62
    uint8_t sw_index = 0;
    static uint8_t acount2 = 0;
    static uint8_t previous_encoder2 = 0;
    uint8_t direction = 0;
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    11ae:	83 70       	andi	r24, 0x03	; 3
    sw_index = (previous_encoder2 << 2) | encoder2;
    11b0:	e0 91 3d 01 	lds	r30, 0x013D
    11b4:	ee 0f       	add	r30, r30
    11b6:	ee 0f       	add	r30, r30
    11b8:	e8 2b       	or	r30, r24
    direction = sw_table[sw_index];
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	ee 5f       	subi	r30, 0xFE	; 254
    11be:	fe 4f       	sbci	r31, 0xFE	; 254
    11c0:	90 81       	ld	r25, Z
    //value = modeA;
    if(direction == CW){
    11c2:	91 30       	cpi	r25, 0x01	; 1
    11c4:	09 f1       	breq	.+66     	; 0x1208 <decode_spi_right_knob+0x64>
	acount2++;
    }	
    if(direction == CCW){
    11c6:	92 30       	cpi	r25, 0x02	; 2
    11c8:	41 f0       	breq	.+16     	; 0x11da <decode_spi_right_knob+0x36>
	acount2--;
    }
    if(encoder2 == 3){
    11ca:	83 30       	cpi	r24, 0x03	; 3
    11cc:	69 f0       	breq	.+26     	; 0x11e8 <decode_spi_right_knob+0x44>
	    right_dec();
	}
	//update_number();
	acount2 = 0;
    }
    previous_encoder2 = encoder2;
    11ce:	80 93 3d 01 	sts	0x013D, r24
}
    11d2:	0f 90       	pop	r0
    11d4:	df 91       	pop	r29
    11d6:	cf 91       	pop	r28
    11d8:	08 95       	ret
    //value = modeA;
    if(direction == CW){
	acount2++;
    }	
    if(direction == CCW){
	acount2--;
    11da:	90 91 3c 01 	lds	r25, 0x013C
    11de:	91 50       	subi	r25, 0x01	; 1
    11e0:	90 93 3c 01 	sts	0x013C, r25
    }
    if(encoder2 == 3){
    11e4:	83 30       	cpi	r24, 0x03	; 3
    11e6:	99 f7       	brne	.-26     	; 0x11ce <decode_spi_right_knob+0x2a>
	if((acount2 > 1) && (acount2 < 10)){
    11e8:	90 91 3c 01 	lds	r25, 0x013C
    11ec:	2e ef       	ldi	r18, 0xFE	; 254
    11ee:	29 0f       	add	r18, r25
    11f0:	28 30       	cpi	r18, 0x08	; 8
    11f2:	b8 f0       	brcs	.+46     	; 0x1222 <decode_spi_right_knob+0x7e>
	    right_inc();
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
    11f4:	91 3f       	cpi	r25, 0xF1	; 241
    11f6:	70 f4       	brcc	.+28     	; 0x1214 <decode_spi_right_knob+0x70>
	    right_dec();
	}
	//update_number();
	acount2 = 0;
    11f8:	10 92 3c 01 	sts	0x013C, r1
    }
    previous_encoder2 = encoder2;
    11fc:	80 93 3d 01 	sts	0x013D, r24
}
    1200:	0f 90       	pop	r0
    1202:	df 91       	pop	r29
    1204:	cf 91       	pop	r28
    1206:	08 95       	ret
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    sw_index = (previous_encoder2 << 2) | encoder2;
    direction = sw_table[sw_index];
    //value = modeA;
    if(direction == CW){
	acount2++;
    1208:	90 91 3c 01 	lds	r25, 0x013C
    120c:	9f 5f       	subi	r25, 0xFF	; 255
    120e:	90 93 3c 01 	sts	0x013C, r25
    1212:	db cf       	rjmp	.-74     	; 0x11ca <decode_spi_right_knob+0x26>
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    right_inc();
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
	    right_dec();
    1214:	89 83       	std	Y+1, r24	; 0x01
    1216:	0e 94 b5 08 	call	0x116a	; 0x116a <right_dec>
    121a:	89 81       	ldd	r24, Y+1	; 0x01
	}
	//update_number();
	acount2 = 0;
    121c:	10 92 3c 01 	sts	0x013C, r1
    1220:	ed cf       	rjmp	.-38     	; 0x11fc <decode_spi_right_knob+0x58>
    if(direction == CCW){
	acount2--;
    }
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    right_inc();
    1222:	89 83       	std	Y+1, r24	; 0x01
    1224:	0e 94 8e 08 	call	0x111c	; 0x111c <right_inc>
    1228:	89 81       	ldd	r24, Y+1	; 0x01
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
	    right_dec();
	}
	//update_number();
	acount2 = 0;
    122a:	10 92 3c 01 	sts	0x013C, r1
    122e:	e6 cf       	rjmp	.-52     	; 0x11fc <decode_spi_right_knob+0x58>

00001230 <left_inc>:
	    break;
    }

}
void left_inc(){
    switch(mode){
    1230:	80 91 4e 01 	lds	r24, 0x014E
    1234:	82 30       	cpi	r24, 0x02	; 2
    1236:	d1 f0       	breq	.+52     	; 0x126c <left_inc+0x3c>
    1238:	83 30       	cpi	r24, 0x03	; 3
    123a:	69 f0       	breq	.+26     	; 0x1256 <left_inc+0x26>
    123c:	81 30       	cpi	r24, 0x01	; 1
    123e:	09 f0       	breq	.+2      	; 0x1242 <left_inc+0x12>
    1240:	08 95       	ret
	case 0: 
	    break;
	case 1:
	    hour++;
    1242:	80 91 4b 01 	lds	r24, 0x014B
    1246:	8f 5f       	subi	r24, 0xFF	; 255
    1248:	80 93 4b 01 	sts	0x014B, r24
	    if(hour >= 24){
    124c:	88 31       	cpi	r24, 0x18	; 24
    124e:	c0 f3       	brcs	.-16     	; 0x1240 <left_inc+0x10>
		hour = 0;	    
    1250:	10 92 4b 01 	sts	0x014B, r1
    1254:	08 95       	ret
	    if(alarm_hour >= 24){
		alarm_hour = 0;
	    }
	    break;
	case 3:
	    volume++;
    1256:	80 91 2b 01 	lds	r24, 0x012B
    125a:	8f 5f       	subi	r24, 0xFF	; 255
    125c:	80 93 2b 01 	sts	0x012B, r24
	    OCR3A = volume;
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	90 93 87 00 	sts	0x0087, r25
    1266:	80 93 86 00 	sts	0x0086, r24
    126a:	08 95       	ret
	    if(hour >= 24){
		hour = 0;	    
	    }   
	    break;
	case 2: 
	    alarm_hour++;
    126c:	80 91 49 01 	lds	r24, 0x0149
    1270:	8f 5f       	subi	r24, 0xFF	; 255
    1272:	80 93 49 01 	sts	0x0149, r24
	    if(alarm_hour >= 24){
    1276:	88 31       	cpi	r24, 0x18	; 24
    1278:	18 f3       	brcs	.-58     	; 0x1240 <left_inc+0x10>
		alarm_hour = 0;
    127a:	10 92 49 01 	sts	0x0149, r1
    127e:	08 95       	ret

00001280 <left_dec>:
	default:
	    break;
    }
}
void left_dec(){
    switch(mode){
    1280:	80 91 4e 01 	lds	r24, 0x014E
    1284:	82 30       	cpi	r24, 0x02	; 2
    1286:	d9 f0       	breq	.+54     	; 0x12be <left_dec+0x3e>
    1288:	83 30       	cpi	r24, 0x03	; 3
    128a:	71 f0       	breq	.+28     	; 0x12a8 <left_dec+0x28>
    128c:	81 30       	cpi	r24, 0x01	; 1
    128e:	09 f0       	breq	.+2      	; 0x1292 <left_dec+0x12>
    1290:	08 95       	ret
	case 0: 
	    break;
	case 1:
	    hour--;    
    1292:	80 91 4b 01 	lds	r24, 0x014B
    1296:	81 50       	subi	r24, 0x01	; 1
    1298:	80 93 4b 01 	sts	0x014B, r24
	    if(hour >= 240){
    129c:	80 3f       	cpi	r24, 0xF0	; 240
    129e:	c0 f3       	brcs	.-16     	; 0x1290 <left_dec+0x10>
		hour = 23;	    
    12a0:	87 e1       	ldi	r24, 0x17	; 23
    12a2:	80 93 4b 01 	sts	0x014B, r24
    12a6:	08 95       	ret
	    if(alarm_hour >= 240){
		alarm_hour = 23;
	    }
	    break;
	case 3:
	    volume--;
    12a8:	80 91 2b 01 	lds	r24, 0x012B
    12ac:	81 50       	subi	r24, 0x01	; 1
    12ae:	80 93 2b 01 	sts	0x012B, r24
	    OCR3A = volume;
    12b2:	90 e0       	ldi	r25, 0x00	; 0
    12b4:	90 93 87 00 	sts	0x0087, r25
    12b8:	80 93 86 00 	sts	0x0086, r24
    12bc:	08 95       	ret
	    if(hour >= 240){
		hour = 23;	    
	    }   
	    break;
	case 2:
	    alarm_hour--;
    12be:	80 91 49 01 	lds	r24, 0x0149
    12c2:	81 50       	subi	r24, 0x01	; 1
    12c4:	80 93 49 01 	sts	0x0149, r24
	    if(alarm_hour >= 240){
    12c8:	80 3f       	cpi	r24, 0xF0	; 240
    12ca:	10 f3       	brcs	.-60     	; 0x1290 <left_dec+0x10>
		alarm_hour = 23;
    12cc:	87 e1       	ldi	r24, 0x17	; 23
    12ce:	80 93 49 01 	sts	0x0149, r24
    12d2:	08 95       	ret

000012d4 <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
    12d4:	cf 93       	push	r28
    12d6:	df 93       	push	r29
    uint8_t sw_index = 0;
    //Counter for preventing unneccessary reset    
    static uint8_t acount1 = 0;
    static uint8_t previous_encoder1 = 0; //Initialize previous    
    uint8_t direction = 0;                    //Direction variable
    encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
    12d8:	8c 70       	andi	r24, 0x0C	; 12
    12da:	c8 2f       	mov	r28, r24
    12dc:	d0 e0       	ldi	r29, 0x00	; 0
    12de:	d5 95       	asr	r29
    12e0:	c7 95       	ror	r28
    12e2:	d5 95       	asr	r29
    12e4:	c7 95       	ror	r28
    12e6:	9c 2f       	mov	r25, r28
    sw_index = (previous_encoder1 << 2) | encoder1; 
    12e8:	e0 91 3f 01 	lds	r30, 0x013F
    12ec:	ee 0f       	add	r30, r30
    12ee:	ee 0f       	add	r30, r30
    12f0:	ec 2b       	or	r30, r28
    /*shift previous to the left use it as an index Since
      we know the pattern of the knob when it is turning
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
    12f2:	f0 e0       	ldi	r31, 0x00	; 0
    12f4:	ee 5f       	subi	r30, 0xFE	; 254
    12f6:	fe 4f       	sbci	r31, 0xFE	; 254
    12f8:	80 81       	ld	r24, Z
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
    12fa:	81 30       	cpi	r24, 0x01	; 1
    12fc:	f9 f0       	breq	.+62     	; 0x133c <decode_spi_left_knob+0x68>
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
    12fe:	82 30       	cpi	r24, 0x02	; 2
    1300:	39 f0       	breq	.+14     	; 0x1310 <decode_spi_left_knob+0x3c>
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    1302:	93 30       	cpi	r25, 0x03	; 3
    1304:	61 f0       	breq	.+24     	; 0x131e <decode_spi_left_knob+0x4a>
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
    }
    previous_encoder1 = encoder1;
    1306:	c0 93 3f 01 	sts	0x013F, r28
}
    130a:	df 91       	pop	r29
    130c:	cf 91       	pop	r28
    130e:	08 95       	ret
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    1310:	80 91 3e 01 	lds	r24, 0x013E
    1314:	81 50       	subi	r24, 0x01	; 1
    1316:	80 93 3e 01 	sts	0x013E, r24
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    131a:	93 30       	cpi	r25, 0x03	; 3
    131c:	a1 f7       	brne	.-24     	; 0x1306 <decode_spi_left_knob+0x32>
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
    131e:	80 91 3e 01 	lds	r24, 0x013E
    1322:	9e ef       	ldi	r25, 0xFE	; 254
    1324:	98 0f       	add	r25, r24
    1326:	98 30       	cpi	r25, 0x08	; 8
    1328:	a0 f0       	brcs	.+40     	; 0x1352 <decode_spi_left_knob+0x7e>
	    left_inc();
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
    132a:	81 3f       	cpi	r24, 0xF1	; 241
    132c:	68 f4       	brcc	.+26     	; 0x1348 <decode_spi_left_knob+0x74>
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
    132e:	10 92 3e 01 	sts	0x013E, r1
    }
    previous_encoder1 = encoder1;
    1332:	c0 93 3f 01 	sts	0x013F, r28
}
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	08 95       	ret
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
	acount1++;
    133c:	80 91 3e 01 	lds	r24, 0x013E
    1340:	8f 5f       	subi	r24, 0xFF	; 255
    1342:	80 93 3e 01 	sts	0x013E, r24
    1346:	dd cf       	rjmp	.-70     	; 0x1302 <decode_spi_left_knob+0x2e>
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    left_inc();
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
    1348:	0e 94 40 09 	call	0x1280	; 0x1280 <left_dec>
	}
	acount1 = 0;                     //Reset counter
    134c:	10 92 3e 01 	sts	0x013E, r1
    1350:	f0 cf       	rjmp	.-32     	; 0x1332 <decode_spi_left_knob+0x5e>
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    left_inc();
    1352:	0e 94 18 09 	call	0x1230	; 0x1230 <left_inc>
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
    1356:	10 92 3e 01 	sts	0x013E, r1
    135a:	eb cf       	rjmp	.-42     	; 0x1332 <decode_spi_left_knob+0x5e>

0000135c <check_knobs>:
    __asm__ __volatile__ ("nop");
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    // Return incoming data from SPDR
    return(SPDR);  
}
void check_knobs(void){
    135c:	cf 93       	push	r28
    static uint8_t cnt = 0;
    static uint8_t encoder;
    cnt++;
    135e:	c0 91 41 01 	lds	r28, 0x0141
    1362:	cf 5f       	subi	r28, 0xFF	; 255
    1364:	c0 93 41 01 	sts	0x0141, r28
    encoder = SPI_Receive();
    1368:	0e 94 84 07 	call	0xf08	; 0xf08 <SPI_Receive>
    136c:	80 93 40 01 	sts	0x0140, r24
    //TIFR |= (1<<TOV2);
    if(cnt%2==0){
    1370:	c0 ff       	sbrs	r28, 0
    1372:	03 c0       	rjmp	.+6      	; 0x137a <check_knobs+0x1e>
	decode_spi_left_knob(encoder);
    }
    else{
	decode_spi_right_knob(encoder);
    }
}
    1374:	cf 91       	pop	r28
    //TIFR |= (1<<TOV2);
    if(cnt%2==0){
	decode_spi_left_knob(encoder);
    }
    else{
	decode_spi_right_knob(encoder);
    1376:	0c 94 d2 08 	jmp	0x11a4	; 0x11a4 <decode_spi_right_knob>
    }
}
    137a:	cf 91       	pop	r28
    static uint8_t encoder;
    cnt++;
    encoder = SPI_Receive();
    //TIFR |= (1<<TOV2);
    if(cnt%2==0){
	decode_spi_left_knob(encoder);
    137c:	0c 94 6a 09 	jmp	0x12d4	; 0x12d4 <decode_spi_left_knob>

00001380 <__vector_10>:
	notes++;               //move on to the next note
	play_song(song, notes);//and play it
    }
}

ISR(TIMER2_OVF_vect){
    1380:	1f 92       	push	r1
    1382:	0f 92       	push	r0
    1384:	0f b6       	in	r0, 0x3f	; 63
    1386:	0f 92       	push	r0
    1388:	11 24       	eor	r1, r1
    138a:	0b b6       	in	r0, 0x3b	; 59
    138c:	0f 92       	push	r0
    138e:	2f 93       	push	r18
    1390:	3f 93       	push	r19
    1392:	4f 93       	push	r20
    1394:	5f 93       	push	r21
    1396:	6f 93       	push	r22
    1398:	7f 93       	push	r23
    139a:	8f 93       	push	r24
    139c:	9f 93       	push	r25
    139e:	af 93       	push	r26
    13a0:	bf 93       	push	r27
    13a2:	cf 93       	push	r28
    13a4:	ef 93       	push	r30
    13a6:	ff 93       	push	r31
    static uint8_t count = 0;
    count++;
    13a8:	c0 91 44 01 	lds	r28, 0x0144
    13ac:	cf 5f       	subi	r28, 0xFF	; 255
    13ae:	c0 93 44 01 	sts	0x0144, r28
    //display_update();
    if(count%64 == 0){
    13b2:	8c 2f       	mov	r24, r28
    13b4:	8f 73       	andi	r24, 0x3F	; 63
    13b6:	c1 f0       	breq	.+48     	; 0x13e8 <__vector_10+0x68>
	button_routine();
    }
    if(count ==  255){
    }
    switch(count%8){
    13b8:	c7 70       	andi	r28, 0x07	; 7
    13ba:	11 f4       	brne	.+4      	; 0x13c0 <__vector_10+0x40>
	case 0:
	    check_knobs();
    13bc:	0e 94 ae 09 	call	0x135c	; 0x135c <check_knobs>
	       }*/
	    break;
	default:
	    break;
    }    
} 
    13c0:	ff 91       	pop	r31
    13c2:	ef 91       	pop	r30
    13c4:	cf 91       	pop	r28
    13c6:	bf 91       	pop	r27
    13c8:	af 91       	pop	r26
    13ca:	9f 91       	pop	r25
    13cc:	8f 91       	pop	r24
    13ce:	7f 91       	pop	r23
    13d0:	6f 91       	pop	r22
    13d2:	5f 91       	pop	r21
    13d4:	4f 91       	pop	r20
    13d6:	3f 91       	pop	r19
    13d8:	2f 91       	pop	r18
    13da:	0f 90       	pop	r0
    13dc:	0b be       	out	0x3b, r0	; 59
    13de:	0f 90       	pop	r0
    13e0:	0f be       	out	0x3f, r0	; 63
    13e2:	0f 90       	pop	r0
    13e4:	1f 90       	pop	r1
    13e6:	18 95       	reti
ISR(TIMER2_OVF_vect){
    static uint8_t count = 0;
    count++;
    //display_update();
    if(count%64 == 0){
	button_routine();
    13e8:	0e 94 ad 07 	call	0xf5a	; 0xf5a <button_routine>
    13ec:	e5 cf       	rjmp	.-54     	; 0x13b8 <__vector_10+0x38>

000013ee <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
    TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    13ee:	83 b7       	in	r24, 0x33	; 51
    13f0:	81 60       	ori	r24, 0x01	; 1
    13f2:	83 bf       	out	0x33, r24	; 51
    ASSR  |= (1<<AS0);
    13f4:	80 b7       	in	r24, 0x30	; 48
    13f6:	88 60       	ori	r24, 0x08	; 8
    13f8:	80 bf       	out	0x30, r24	; 48
    TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    13fa:	85 b5       	in	r24, 0x25	; 37
    13fc:	8a 67       	ori	r24, 0x7A	; 122
    13fe:	85 bd       	out	0x25, r24	; 37
    TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1400:	87 b7       	in	r24, 0x37	; 55
    1402:	81 64       	ori	r24, 0x41	; 65
    1404:	87 bf       	out	0x37, r24	; 55
    1406:	08 95       	ret

00001408 <ADC_init>:
}


void ADC_init(void){
    DDRF |= !(1<<PF0);
    1408:	e1 e6       	ldi	r30, 0x61	; 97
    140a:	f0 e0       	ldi	r31, 0x00	; 0
    140c:	80 81       	ld	r24, Z
    140e:	80 83       	st	Z, r24
    PORTF = 0x00;
    1410:	10 92 62 00 	sts	0x0062, r1
    ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1414:	87 b1       	in	r24, 0x07	; 7
    1416:	80 66       	ori	r24, 0x60	; 96
    1418:	87 b9       	out	0x07, r24	; 7
    ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    141a:	86 b1       	in	r24, 0x06	; 6
    141c:	8f 6e       	ori	r24, 0xEF	; 239
    141e:	86 b9       	out	0x06, r24	; 6
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    OCR2 = 0xFF;
    1420:	8f ef       	ldi	r24, 0xFF	; 255
    1422:	83 bd       	out	0x23, r24	; 35
    1424:	08 95       	ret

00001426 <volume_control_init>:
}

void volume_control_init(void){
    DDRE |= (1<<PE1);
    1426:	11 9a       	sbi	0x02, 1	; 2
    TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1428:	81 e8       	ldi	r24, 0x81	; 129
    142a:	80 93 8b 00 	sts	0x008B, r24
    TCCR3B = (1<<WGM32) | (1<<CS30);
    142e:	89 e0       	ldi	r24, 0x09	; 9
    1430:	80 93 8a 00 	sts	0x008A, r24
    OCR3A = volume;
    1434:	80 91 2b 01 	lds	r24, 0x012B
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	90 93 87 00 	sts	0x0087, r25
    143e:	80 93 86 00 	sts	0x0086, r24
    1442:	08 95       	ret

00001444 <strobe_lcd>:
}


void strobe_lcd(void) {
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1444:	e2 e6       	ldi	r30, 0x62	; 98
    1446:	f0 e0       	ldi	r31, 0x00	; 0
    1448:	80 81       	ld	r24, Z
    144a:	88 60       	ori	r24, 0x08	; 8
    144c:	80 83       	st	Z, r24
	PORTF &= ~0x08;
    144e:	80 81       	ld	r24, Z
    1450:	87 7f       	andi	r24, 0xF7	; 247
    1452:	80 83       	st	Z, r24
    1454:	08 95       	ret

00001456 <LCD_Clr>:
}

void LCD_Clr(void) {
	LCD_CMD(0x01);
    1456:	1f b8       	out	0x0f, r1	; 15
    1458:	77 9b       	sbis	0x0e, 7	; 14
    145a:	fe cf       	rjmp	.-4      	; 0x1458 <LCD_Clr+0x2>
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	8f b9       	out	0x0f, r24	; 15
    1460:	77 9b       	sbis	0x0e, 7	; 14
    1462:	fe cf       	rjmp	.-4      	; 0x1460 <LCD_Clr+0xa>
    1464:	80 91 62 00 	lds	r24, 0x0062
    1468:	88 60       	ori	r24, 0x08	; 8
    146a:	80 93 62 00 	sts	0x0062, r24
    146e:	80 91 62 00 	lds	r24, 0x0062
    1472:	87 7f       	andi	r24, 0xF7	; 247
    1474:	80 93 62 00 	sts	0x0062, r24
    1478:	8f e8       	ldi	r24, 0x8F	; 143
    147a:	91 e0       	ldi	r25, 0x01	; 1
    147c:	01 97       	sbiw	r24, 0x01	; 1
    147e:	f1 f7       	brne	.-4      	; 0x147c <LCD_Clr+0x26>
    1480:	00 c0       	rjmp	.+0      	; 0x1482 <LCD_Clr+0x2c>
    1482:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1484:	8f e3       	ldi	r24, 0x3F	; 63
    1486:	9f e1       	ldi	r25, 0x1F	; 31
    1488:	01 97       	sbiw	r24, 0x01	; 1
    148a:	f1 f7       	brne	.-4      	; 0x1488 <LCD_Clr+0x32>
    148c:	00 c0       	rjmp	.+0      	; 0x148e <LCD_Clr+0x38>
    148e:	00 00       	nop
    1490:	08 95       	ret

00001492 <LCD_MovCursorLn1>:
	_delay_ms(2);   //obligatory waiting for slow LCD
}

void LCD_MovCursorLn1(void) {
	LCD_CMD(0x80);
    1492:	1f b8       	out	0x0f, r1	; 15
    1494:	77 9b       	sbis	0x0e, 7	; 14
    1496:	fe cf       	rjmp	.-4      	; 0x1494 <LCD_MovCursorLn1+0x2>
    1498:	80 e8       	ldi	r24, 0x80	; 128
    149a:	8f b9       	out	0x0f, r24	; 15
    149c:	77 9b       	sbis	0x0e, 7	; 14
    149e:	fe cf       	rjmp	.-4      	; 0x149c <LCD_MovCursorLn1+0xa>
    14a0:	80 91 62 00 	lds	r24, 0x0062
    14a4:	88 60       	ori	r24, 0x08	; 8
    14a6:	80 93 62 00 	sts	0x0062, r24
    14aa:	80 91 62 00 	lds	r24, 0x0062
    14ae:	87 7f       	andi	r24, 0xF7	; 247
    14b0:	80 93 62 00 	sts	0x0062, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14b4:	8f e8       	ldi	r24, 0x8F	; 143
    14b6:	91 e0       	ldi	r25, 0x01	; 1
    14b8:	01 97       	sbiw	r24, 0x01	; 1
    14ba:	f1 f7       	brne	.-4      	; 0x14b8 <LCD_MovCursorLn1+0x26>
    14bc:	00 c0       	rjmp	.+0      	; 0x14be <LCD_MovCursorLn1+0x2c>
    14be:	00 00       	nop
    14c0:	08 95       	ret

000014c2 <LCD_MovCursorLn2>:
}

void LCD_MovCursorLn2(void) {
	LCD_CMD(0xC0);
    14c2:	1f b8       	out	0x0f, r1	; 15
    14c4:	77 9b       	sbis	0x0e, 7	; 14
    14c6:	fe cf       	rjmp	.-4      	; 0x14c4 <LCD_MovCursorLn2+0x2>
    14c8:	80 ec       	ldi	r24, 0xC0	; 192
    14ca:	8f b9       	out	0x0f, r24	; 15
    14cc:	77 9b       	sbis	0x0e, 7	; 14
    14ce:	fe cf       	rjmp	.-4      	; 0x14cc <LCD_MovCursorLn2+0xa>
    14d0:	80 91 62 00 	lds	r24, 0x0062
    14d4:	88 60       	ori	r24, 0x08	; 8
    14d6:	80 93 62 00 	sts	0x0062, r24
    14da:	80 91 62 00 	lds	r24, 0x0062
    14de:	87 7f       	andi	r24, 0xF7	; 247
    14e0:	80 93 62 00 	sts	0x0062, r24
    14e4:	8f e8       	ldi	r24, 0x8F	; 143
    14e6:	91 e0       	ldi	r25, 0x01	; 1
    14e8:	01 97       	sbiw	r24, 0x01	; 1
    14ea:	f1 f7       	brne	.-4      	; 0x14e8 <LCD_MovCursorLn2+0x26>
    14ec:	00 c0       	rjmp	.+0      	; 0x14ee <LCD_MovCursorLn2+0x2c>
    14ee:	00 00       	nop
    14f0:	08 95       	ret

000014f2 <LCD_CursorBlinkOn>:
}

void LCD_CursorBlinkOn(void) {
	LCD_CMD(0x0F);
    14f2:	1f b8       	out	0x0f, r1	; 15
    14f4:	77 9b       	sbis	0x0e, 7	; 14
    14f6:	fe cf       	rjmp	.-4      	; 0x14f4 <LCD_CursorBlinkOn+0x2>
    14f8:	8f e0       	ldi	r24, 0x0F	; 15
    14fa:	8f b9       	out	0x0f, r24	; 15
    14fc:	77 9b       	sbis	0x0e, 7	; 14
    14fe:	fe cf       	rjmp	.-4      	; 0x14fc <LCD_CursorBlinkOn+0xa>
    1500:	80 91 62 00 	lds	r24, 0x0062
    1504:	88 60       	ori	r24, 0x08	; 8
    1506:	80 93 62 00 	sts	0x0062, r24
    150a:	80 91 62 00 	lds	r24, 0x0062
    150e:	87 7f       	andi	r24, 0xF7	; 247
    1510:	80 93 62 00 	sts	0x0062, r24
    1514:	8f e8       	ldi	r24, 0x8F	; 143
    1516:	91 e0       	ldi	r25, 0x01	; 1
    1518:	01 97       	sbiw	r24, 0x01	; 1
    151a:	f1 f7       	brne	.-4      	; 0x1518 <LCD_CursorBlinkOn+0x26>
    151c:	00 c0       	rjmp	.+0      	; 0x151e <LCD_CursorBlinkOn+0x2c>
    151e:	00 00       	nop
    1520:	08 95       	ret

00001522 <LCD_CursorBlinkOff>:
}

void LCD_CursorBlinkOff(void) {
	LCD_CMD(0x0C);
    1522:	1f b8       	out	0x0f, r1	; 15
    1524:	77 9b       	sbis	0x0e, 7	; 14
    1526:	fe cf       	rjmp	.-4      	; 0x1524 <LCD_CursorBlinkOff+0x2>
    1528:	8c e0       	ldi	r24, 0x0C	; 12
    152a:	8f b9       	out	0x0f, r24	; 15
    152c:	77 9b       	sbis	0x0e, 7	; 14
    152e:	fe cf       	rjmp	.-4      	; 0x152c <LCD_CursorBlinkOff+0xa>
    1530:	80 91 62 00 	lds	r24, 0x0062
    1534:	88 60       	ori	r24, 0x08	; 8
    1536:	80 93 62 00 	sts	0x0062, r24
    153a:	80 91 62 00 	lds	r24, 0x0062
    153e:	87 7f       	andi	r24, 0xF7	; 247
    1540:	80 93 62 00 	sts	0x0062, r24
    1544:	8f e8       	ldi	r24, 0x8F	; 143
    1546:	91 e0       	ldi	r25, 0x01	; 1
    1548:	01 97       	sbiw	r24, 0x01	; 1
    154a:	f1 f7       	brne	.-4      	; 0x1548 <LCD_CursorBlinkOff+0x26>
    154c:	00 c0       	rjmp	.+0      	; 0x154e <LCD_CursorBlinkOff+0x2c>
    154e:	00 00       	nop
    1550:	08 95       	ret

00001552 <LCD_MovCursor>:
		
	The cursor will not be moved if an invalid location is provided
*/
void LCD_MovCursor(uint8_t line, uint8_t position) {
	uint8_t addr;
	if (position > 15)
    1552:	60 31       	cpi	r22, 0x10	; 16
    1554:	20 f4       	brcc	.+8      	; 0x155e <LCD_MovCursor+0xc>
		return;
	if (line == 1) {
    1556:	81 30       	cpi	r24, 0x01	; 1
    1558:	19 f0       	breq	.+6      	; 0x1560 <LCD_MovCursor+0xe>
		addr = 0x80 + position;
	} else if (line == 2) {
    155a:	82 30       	cpi	r24, 0x02	; 2
    155c:	c9 f0       	breq	.+50     	; 0x1590 <LCD_MovCursor+0x3e>
    155e:	08 95       	ret
void LCD_MovCursor(uint8_t line, uint8_t position) {
	uint8_t addr;
	if (position > 15)
		return;
	if (line == 1) {
		addr = 0x80 + position;
    1560:	60 58       	subi	r22, 0x80	; 128
		addr = 0xC0 + position;
	} else {
		// invalid line number
		return;
	}
	LCD_CMD(addr);
    1562:	1f b8       	out	0x0f, r1	; 15
    1564:	77 9b       	sbis	0x0e, 7	; 14
    1566:	fe cf       	rjmp	.-4      	; 0x1564 <LCD_MovCursor+0x12>
    1568:	6f b9       	out	0x0f, r22	; 15
    156a:	77 9b       	sbis	0x0e, 7	; 14
    156c:	fe cf       	rjmp	.-4      	; 0x156a <LCD_MovCursor+0x18>
    156e:	80 91 62 00 	lds	r24, 0x0062
    1572:	88 60       	ori	r24, 0x08	; 8
    1574:	80 93 62 00 	sts	0x0062, r24
    1578:	80 91 62 00 	lds	r24, 0x0062
    157c:	87 7f       	andi	r24, 0xF7	; 247
    157e:	80 93 62 00 	sts	0x0062, r24
    1582:	8f e8       	ldi	r24, 0x8F	; 143
    1584:	91 e0       	ldi	r25, 0x01	; 1
    1586:	01 97       	sbiw	r24, 0x01	; 1
    1588:	f1 f7       	brne	.-4      	; 0x1586 <LCD_MovCursor+0x34>
    158a:	00 c0       	rjmp	.+0      	; 0x158c <LCD_MovCursor+0x3a>
    158c:	00 00       	nop
    158e:	08 95       	ret
	if (position > 15)
		return;
	if (line == 1) {
		addr = 0x80 + position;
	} else if (line == 2) {
		addr = 0xC0 + position;
    1590:	60 54       	subi	r22, 0x40	; 64
    1592:	e7 cf       	rjmp	.-50     	; 0x1562 <LCD_MovCursor+0x10>

00001594 <LCD_FillSpaces>:
		return;
	}
	LCD_CMD(addr);
}

void LCD_FillSpaces(void) {
    1594:	80 e1       	ldi	r24, 0x10	; 16
    1596:	90 e0       	ldi	r25, 0x00	; 0
	int count;
	for (count=0; count<=15; count++){
		LCD_DATA(' ');
    1598:	41 e0       	ldi	r20, 0x01	; 1
    159a:	30 e2       	ldi	r19, 0x20	; 32
    159c:	4f b9       	out	0x0f, r20	; 15
    159e:	77 9b       	sbis	0x0e, 7	; 14
    15a0:	fe cf       	rjmp	.-4      	; 0x159e <LCD_FillSpaces+0xa>
    15a2:	3f b9       	out	0x0f, r19	; 15
    15a4:	77 9b       	sbis	0x0e, 7	; 14
    15a6:	fe cf       	rjmp	.-4      	; 0x15a4 <LCD_FillSpaces+0x10>
    15a8:	20 91 62 00 	lds	r18, 0x0062
    15ac:	28 60       	ori	r18, 0x08	; 8
    15ae:	20 93 62 00 	sts	0x0062, r18
    15b2:	20 91 62 00 	lds	r18, 0x0062
    15b6:	27 7f       	andi	r18, 0xF7	; 247
    15b8:	20 93 62 00 	sts	0x0062, r18
    15bc:	ef e8       	ldi	r30, 0x8F	; 143
    15be:	f1 e0       	ldi	r31, 0x01	; 1
    15c0:	31 97       	sbiw	r30, 0x01	; 1
    15c2:	f1 f7       	brne	.-4      	; 0x15c0 <LCD_FillSpaces+0x2c>
    15c4:	00 c0       	rjmp	.+0      	; 0x15c6 <LCD_FillSpaces+0x32>
    15c6:	00 00       	nop
    15c8:	01 97       	sbiw	r24, 0x01	; 1
	LCD_CMD(addr);
}

void LCD_FillSpaces(void) {
	int count;
	for (count=0; count<=15; count++){
    15ca:	00 97       	sbiw	r24, 0x00	; 0
    15cc:	39 f7       	brne	.-50     	; 0x159c <LCD_FillSpaces+0x8>
		LCD_DATA(' ');
	}
}
    15ce:	08 95       	ret

000015d0 <LCD_PutDec8>:
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 100) {
    15d0:	84 36       	cpi	r24, 0x64	; 100
    15d2:	08 f4       	brcc	.+2      	; 0x15d6 <LCD_PutDec8+0x6>
    15d4:	5d c0       	rjmp	.+186    	; 0x1690 <LCD_PutDec8+0xc0>
		digit++;
		num -= 100;
    15d6:	9c e9       	ldi	r25, 0x9C	; 156
    15d8:	98 0f       	add	r25, r24
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 100) {
    15da:	94 36       	cpi	r25, 0x64	; 100
    15dc:	08 f4       	brcc	.+2      	; 0x15e0 <LCD_PutDec8+0x10>
    15de:	5c c0       	rjmp	.+184    	; 0x1698 <LCD_PutDec8+0xc8>
		digit++;
		num -= 100;
    15e0:	88 5c       	subi	r24, 0xC8	; 200
    15e2:	22 e3       	ldi	r18, 0x32	; 50
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    15e4:	91 e0       	ldi	r25, 0x01	; 1
    15e6:	9f b9       	out	0x0f, r25	; 15
    15e8:	77 9b       	sbis	0x0e, 7	; 14
    15ea:	fe cf       	rjmp	.-4      	; 0x15e8 <LCD_PutDec8+0x18>
    15ec:	2f b9       	out	0x0f, r18	; 15
    15ee:	77 9b       	sbis	0x0e, 7	; 14
    15f0:	fe cf       	rjmp	.-4      	; 0x15ee <LCD_PutDec8+0x1e>
    15f2:	90 91 62 00 	lds	r25, 0x0062
    15f6:	98 60       	ori	r25, 0x08	; 8
    15f8:	90 93 62 00 	sts	0x0062, r25
    15fc:	90 91 62 00 	lds	r25, 0x0062
    1600:	97 7f       	andi	r25, 0xF7	; 247
    1602:	90 93 62 00 	sts	0x0062, r25
    1606:	ef e8       	ldi	r30, 0x8F	; 143
    1608:	f1 e0       	ldi	r31, 0x01	; 1
    160a:	31 97       	sbiw	r30, 0x01	; 1
    160c:	f1 f7       	brne	.-4      	; 0x160a <LCD_PutDec8+0x3a>
    160e:	00 c0       	rjmp	.+0      	; 0x1610 <LCD_PutDec8+0x40>
    1610:	00 00       	nop
		flag = 1;
    1612:	91 e0       	ldi	r25, 0x01	; 1
	}
	digit = 0;
	while (num >= 10) {
    1614:	8a 30       	cpi	r24, 0x0A	; 10
    1616:	c0 f1       	brcs	.+112    	; 0x1688 <LCD_PutDec8+0xb8>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    1618:	90 e0       	ldi	r25, 0x00	; 0
	while (num >= 10) {
		digit++;
    161a:	9f 5f       	subi	r25, 0xFF	; 255
		num -= 10;
    161c:	8a 50       	subi	r24, 0x0A	; 10
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 10) {
    161e:	8a 30       	cpi	r24, 0x0A	; 10
    1620:	e0 f7       	brcc	.-8      	; 0x161a <LCD_PutDec8+0x4a>
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    1622:	21 e0       	ldi	r18, 0x01	; 1
    1624:	2f b9       	out	0x0f, r18	; 15
    1626:	77 9b       	sbis	0x0e, 7	; 14
    1628:	fe cf       	rjmp	.-4      	; 0x1626 <LCD_PutDec8+0x56>
    162a:	90 5d       	subi	r25, 0xD0	; 208
    162c:	9f b9       	out	0x0f, r25	; 15
    162e:	77 9b       	sbis	0x0e, 7	; 14
    1630:	fe cf       	rjmp	.-4      	; 0x162e <LCD_PutDec8+0x5e>
    1632:	90 91 62 00 	lds	r25, 0x0062
    1636:	98 60       	ori	r25, 0x08	; 8
    1638:	90 93 62 00 	sts	0x0062, r25
    163c:	90 91 62 00 	lds	r25, 0x0062
    1640:	97 7f       	andi	r25, 0xF7	; 247
    1642:	90 93 62 00 	sts	0x0062, r25
    1646:	ef e8       	ldi	r30, 0x8F	; 143
    1648:	f1 e0       	ldi	r31, 0x01	; 1
    164a:	31 97       	sbiw	r30, 0x01	; 1
    164c:	f1 f7       	brne	.-4      	; 0x164a <LCD_PutDec8+0x7a>
    164e:	00 c0       	rjmp	.+0      	; 0x1650 <LCD_PutDec8+0x80>
    1650:	00 00       	nop
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    1652:	88 23       	and	r24, r24
    1654:	f9 f0       	breq	.+62     	; 0x1694 <LCD_PutDec8+0xc4>
    1656:	80 5d       	subi	r24, 0xD0	; 208
		digit++;
		num -= 1;
	}
	LCD_DATA(digit + 48);
    1658:	91 e0       	ldi	r25, 0x01	; 1
    165a:	9f b9       	out	0x0f, r25	; 15
    165c:	77 9b       	sbis	0x0e, 7	; 14
    165e:	fe cf       	rjmp	.-4      	; 0x165c <LCD_PutDec8+0x8c>
    1660:	8f b9       	out	0x0f, r24	; 15
    1662:	77 9b       	sbis	0x0e, 7	; 14
    1664:	fe cf       	rjmp	.-4      	; 0x1662 <LCD_PutDec8+0x92>
    1666:	80 91 62 00 	lds	r24, 0x0062
    166a:	88 60       	ori	r24, 0x08	; 8
    166c:	80 93 62 00 	sts	0x0062, r24
    1670:	80 91 62 00 	lds	r24, 0x0062
    1674:	87 7f       	andi	r24, 0xF7	; 247
    1676:	80 93 62 00 	sts	0x0062, r24
    167a:	8f e8       	ldi	r24, 0x8F	; 143
    167c:	91 e0       	ldi	r25, 0x01	; 1
    167e:	01 97       	sbiw	r24, 0x01	; 1
    1680:	f1 f7       	brne	.-4      	; 0x167e <LCD_PutDec8+0xae>
    1682:	00 c0       	rjmp	.+0      	; 0x1684 <LCD_PutDec8+0xb4>
    1684:	00 00       	nop
    1686:	08 95       	ret
	digit = 0;
	while (num >= 10) {
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
    1688:	91 30       	cpi	r25, 0x01	; 1
    168a:	19 f7       	brne	.-58     	; 0x1652 <LCD_PutDec8+0x82>
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	c9 cf       	rjmp	.-110    	; 0x1622 <LCD_PutDec8+0x52>
	Convert an 8 bit unsigned number to ASCII
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
    1690:	90 e0       	ldi	r25, 0x00	; 0
    1692:	c0 cf       	rjmp	.-128    	; 0x1614 <LCD_PutDec8+0x44>
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    1694:	80 e3       	ldi	r24, 0x30	; 48
    1696:	e0 cf       	rjmp	.-64     	; 0x1658 <LCD_PutDec8+0x88>
	and display the result.
*/
void LCD_PutDec8(uint8_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 100) {
    1698:	89 2f       	mov	r24, r25
    169a:	21 e3       	ldi	r18, 0x31	; 49
    169c:	a3 cf       	rjmp	.-186    	; 0x15e4 <LCD_PutDec8+0x14>

0000169e <LCD_PutDec16>:
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 10000) {
    169e:	80 31       	cpi	r24, 0x10	; 16
    16a0:	27 e2       	ldi	r18, 0x27	; 39
    16a2:	92 07       	cpc	r25, r18
    16a4:	08 f4       	brcc	.+2      	; 0x16a8 <LCD_PutDec16+0xa>
    16a6:	bf c0       	rjmp	.+382    	; 0x1826 <LCD_PutDec16+0x188>
/*
	Convert a 16 bit unsigned number to ASCII
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
    16a8:	20 e0       	ldi	r18, 0x00	; 0
    16aa:	01 c0       	rjmp	.+2      	; 0x16ae <LCD_PutDec16+0x10>
	uint8_t flag = 0;
	while (num >= 10000) {
		digit++;
    16ac:	23 2f       	mov	r18, r19
    16ae:	31 e0       	ldi	r19, 0x01	; 1
    16b0:	32 0f       	add	r19, r18
		num -= 10000;
    16b2:	80 51       	subi	r24, 0x10	; 16
    16b4:	97 42       	sbci	r25, 0x27	; 39
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
	while (num >= 10000) {
    16b6:	80 31       	cpi	r24, 0x10	; 16
    16b8:	47 e2       	ldi	r20, 0x27	; 39
    16ba:	94 07       	cpc	r25, r20
    16bc:	b8 f7       	brcc	.-18     	; 0x16ac <LCD_PutDec16+0xe>
		digit++;
		num -= 10000;
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    16be:	31 e0       	ldi	r19, 0x01	; 1
    16c0:	3f b9       	out	0x0f, r19	; 15
    16c2:	77 9b       	sbis	0x0e, 7	; 14
    16c4:	fe cf       	rjmp	.-4      	; 0x16c2 <LCD_PutDec16+0x24>
    16c6:	2f 5c       	subi	r18, 0xCF	; 207
    16c8:	2f b9       	out	0x0f, r18	; 15
    16ca:	77 9b       	sbis	0x0e, 7	; 14
    16cc:	fe cf       	rjmp	.-4      	; 0x16ca <LCD_PutDec16+0x2c>
    16ce:	20 91 62 00 	lds	r18, 0x0062
    16d2:	28 60       	ori	r18, 0x08	; 8
    16d4:	20 93 62 00 	sts	0x0062, r18
    16d8:	20 91 62 00 	lds	r18, 0x0062
    16dc:	27 7f       	andi	r18, 0xF7	; 247
    16de:	20 93 62 00 	sts	0x0062, r18
    16e2:	ef e8       	ldi	r30, 0x8F	; 143
    16e4:	f1 e0       	ldi	r31, 0x01	; 1
    16e6:	31 97       	sbiw	r30, 0x01	; 1
    16e8:	f1 f7       	brne	.-4      	; 0x16e6 <LCD_PutDec16+0x48>
    16ea:	00 c0       	rjmp	.+0      	; 0x16ec <LCD_PutDec16+0x4e>
    16ec:	00 00       	nop
		flag = 1;
    16ee:	21 e0       	ldi	r18, 0x01	; 1
	}
	digit = 0;
	while (num >= 1000) {
    16f0:	88 3e       	cpi	r24, 0xE8	; 232
    16f2:	f3 e0       	ldi	r31, 0x03	; 3
    16f4:	9f 07       	cpc	r25, r31
    16f6:	08 f4       	brcc	.+2      	; 0x16fa <LCD_PutDec16+0x5c>
    16f8:	8e c0       	rjmp	.+284    	; 0x1816 <LCD_PutDec16+0x178>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    16fa:	20 e0       	ldi	r18, 0x00	; 0
	while (num >= 1000) {
		digit++;
    16fc:	2f 5f       	subi	r18, 0xFF	; 255
		num -= 1000;
    16fe:	88 5e       	subi	r24, 0xE8	; 232
    1700:	93 40       	sbci	r25, 0x03	; 3
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 1000) {
    1702:	88 3e       	cpi	r24, 0xE8	; 232
    1704:	33 e0       	ldi	r19, 0x03	; 3
    1706:	93 07       	cpc	r25, r19
    1708:	c8 f7       	brcc	.-14     	; 0x16fc <LCD_PutDec16+0x5e>
		digit++;
		num -= 1000;
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
    170a:	31 e0       	ldi	r19, 0x01	; 1
    170c:	3f b9       	out	0x0f, r19	; 15
    170e:	77 9b       	sbis	0x0e, 7	; 14
    1710:	fe cf       	rjmp	.-4      	; 0x170e <LCD_PutDec16+0x70>
    1712:	20 5d       	subi	r18, 0xD0	; 208
    1714:	2f b9       	out	0x0f, r18	; 15
    1716:	77 9b       	sbis	0x0e, 7	; 14
    1718:	fe cf       	rjmp	.-4      	; 0x1716 <LCD_PutDec16+0x78>
    171a:	20 91 62 00 	lds	r18, 0x0062
    171e:	28 60       	ori	r18, 0x08	; 8
    1720:	20 93 62 00 	sts	0x0062, r18
    1724:	20 91 62 00 	lds	r18, 0x0062
    1728:	27 7f       	andi	r18, 0xF7	; 247
    172a:	20 93 62 00 	sts	0x0062, r18
    172e:	ef e8       	ldi	r30, 0x8F	; 143
    1730:	f1 e0       	ldi	r31, 0x01	; 1
    1732:	31 97       	sbiw	r30, 0x01	; 1
    1734:	f1 f7       	brne	.-4      	; 0x1732 <LCD_PutDec16+0x94>
    1736:	00 c0       	rjmp	.+0      	; 0x1738 <LCD_PutDec16+0x9a>
    1738:	00 00       	nop
		flag = 1;
    173a:	31 e0       	ldi	r19, 0x01	; 1
	}
	digit = 0;
	while (num >= 100) {
    173c:	84 36       	cpi	r24, 0x64	; 100
    173e:	91 05       	cpc	r25, r1
    1740:	08 f4       	brcc	.+2      	; 0x1744 <LCD_PutDec16+0xa6>
    1742:	65 c0       	rjmp	.+202    	; 0x180e <LCD_PutDec16+0x170>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    1744:	20 e0       	ldi	r18, 0x00	; 0
	while (num >= 100) {
		digit++;
    1746:	2f 5f       	subi	r18, 0xFF	; 255
		num -= 100;
    1748:	84 56       	subi	r24, 0x64	; 100
    174a:	91 09       	sbc	r25, r1
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 100) {
    174c:	84 36       	cpi	r24, 0x64	; 100
    174e:	91 05       	cpc	r25, r1
    1750:	d0 f7       	brcc	.-12     	; 0x1746 <LCD_PutDec16+0xa8>
		digit++;
		num -= 100;
	}
	if (digit > 0 || flag == 1) {
    1752:	22 23       	and	r18, r18
    1754:	09 f4       	brne	.+2      	; 0x1758 <LCD_PutDec16+0xba>
    1756:	5b c0       	rjmp	.+182    	; 0x180e <LCD_PutDec16+0x170>
		LCD_DATA(digit + 48);
    1758:	31 e0       	ldi	r19, 0x01	; 1
    175a:	3f b9       	out	0x0f, r19	; 15
    175c:	77 9b       	sbis	0x0e, 7	; 14
    175e:	fe cf       	rjmp	.-4      	; 0x175c <LCD_PutDec16+0xbe>
    1760:	20 5d       	subi	r18, 0xD0	; 208
    1762:	2f b9       	out	0x0f, r18	; 15
    1764:	77 9b       	sbis	0x0e, 7	; 14
    1766:	fe cf       	rjmp	.-4      	; 0x1764 <LCD_PutDec16+0xc6>
    1768:	20 91 62 00 	lds	r18, 0x0062
    176c:	28 60       	ori	r18, 0x08	; 8
    176e:	20 93 62 00 	sts	0x0062, r18
    1772:	20 91 62 00 	lds	r18, 0x0062
    1776:	27 7f       	andi	r18, 0xF7	; 247
    1778:	20 93 62 00 	sts	0x0062, r18
    177c:	ef e8       	ldi	r30, 0x8F	; 143
    177e:	f1 e0       	ldi	r31, 0x01	; 1
    1780:	31 97       	sbiw	r30, 0x01	; 1
    1782:	f1 f7       	brne	.-4      	; 0x1780 <LCD_PutDec16+0xe2>
    1784:	00 c0       	rjmp	.+0      	; 0x1786 <LCD_PutDec16+0xe8>
    1786:	00 00       	nop
		flag = 1;
    1788:	31 e0       	ldi	r19, 0x01	; 1
	}
	digit = 0;
	while (num >= 10) {
    178a:	8a 30       	cpi	r24, 0x0A	; 10
    178c:	91 05       	cpc	r25, r1
    178e:	d8 f1       	brcs	.+118    	; 0x1806 <LCD_PutDec16+0x168>
	}
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
    1790:	20 e0       	ldi	r18, 0x00	; 0
	while (num >= 10) {
		digit++;
    1792:	2f 5f       	subi	r18, 0xFF	; 255
		num -= 10;
    1794:	0a 97       	sbiw	r24, 0x0a	; 10
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 10) {
    1796:	8a 30       	cpi	r24, 0x0A	; 10
    1798:	91 05       	cpc	r25, r1
    179a:	d8 f7       	brcc	.-10     	; 0x1792 <LCD_PutDec16+0xf4>
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
    179c:	22 23       	and	r18, r18
    179e:	99 f1       	breq	.+102    	; 0x1806 <LCD_PutDec16+0x168>
		LCD_DATA(digit + 48);
    17a0:	31 e0       	ldi	r19, 0x01	; 1
    17a2:	3f b9       	out	0x0f, r19	; 15
    17a4:	77 9b       	sbis	0x0e, 7	; 14
    17a6:	fe cf       	rjmp	.-4      	; 0x17a4 <LCD_PutDec16+0x106>
    17a8:	20 5d       	subi	r18, 0xD0	; 208
    17aa:	2f b9       	out	0x0f, r18	; 15
    17ac:	77 9b       	sbis	0x0e, 7	; 14
    17ae:	fe cf       	rjmp	.-4      	; 0x17ac <LCD_PutDec16+0x10e>
    17b0:	20 91 62 00 	lds	r18, 0x0062
    17b4:	28 60       	ori	r18, 0x08	; 8
    17b6:	20 93 62 00 	sts	0x0062, r18
    17ba:	20 91 62 00 	lds	r18, 0x0062
    17be:	27 7f       	andi	r18, 0xF7	; 247
    17c0:	20 93 62 00 	sts	0x0062, r18
    17c4:	ef e8       	ldi	r30, 0x8F	; 143
    17c6:	f1 e0       	ldi	r31, 0x01	; 1
    17c8:	31 97       	sbiw	r30, 0x01	; 1
    17ca:	f1 f7       	brne	.-4      	; 0x17c8 <LCD_PutDec16+0x12a>
    17cc:	00 c0       	rjmp	.+0      	; 0x17ce <LCD_PutDec16+0x130>
    17ce:	00 00       	nop
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    17d0:	00 97       	sbiw	r24, 0x00	; 0
    17d2:	59 f1       	breq	.+86     	; 0x182a <LCD_PutDec16+0x18c>
    17d4:	80 5d       	subi	r24, 0xD0	; 208
		digit++;
		num -= 1;
	}
	LCD_DATA(digit + 48);
    17d6:	91 e0       	ldi	r25, 0x01	; 1
    17d8:	9f b9       	out	0x0f, r25	; 15
    17da:	77 9b       	sbis	0x0e, 7	; 14
    17dc:	fe cf       	rjmp	.-4      	; 0x17da <LCD_PutDec16+0x13c>
    17de:	8f b9       	out	0x0f, r24	; 15
    17e0:	77 9b       	sbis	0x0e, 7	; 14
    17e2:	fe cf       	rjmp	.-4      	; 0x17e0 <LCD_PutDec16+0x142>
    17e4:	80 91 62 00 	lds	r24, 0x0062
    17e8:	88 60       	ori	r24, 0x08	; 8
    17ea:	80 93 62 00 	sts	0x0062, r24
    17ee:	80 91 62 00 	lds	r24, 0x0062
    17f2:	87 7f       	andi	r24, 0xF7	; 247
    17f4:	80 93 62 00 	sts	0x0062, r24
    17f8:	8f e8       	ldi	r24, 0x8F	; 143
    17fa:	91 e0       	ldi	r25, 0x01	; 1
    17fc:	01 97       	sbiw	r24, 0x01	; 1
    17fe:	f1 f7       	brne	.-4      	; 0x17fc <LCD_PutDec16+0x15e>
    1800:	00 c0       	rjmp	.+0      	; 0x1802 <LCD_PutDec16+0x164>
    1802:	00 00       	nop
    1804:	08 95       	ret
	digit = 0;
	while (num >= 10) {
		digit++;
		num -= 10;
	}
	if (digit > 0 || flag == 1) {
    1806:	31 30       	cpi	r19, 0x01	; 1
    1808:	19 f7       	brne	.-58     	; 0x17d0 <LCD_PutDec16+0x132>
    180a:	20 e0       	ldi	r18, 0x00	; 0
    180c:	c9 cf       	rjmp	.-110    	; 0x17a0 <LCD_PutDec16+0x102>
	digit = 0;
	while (num >= 100) {
		digit++;
		num -= 100;
	}
	if (digit > 0 || flag == 1) {
    180e:	31 30       	cpi	r19, 0x01	; 1
    1810:	41 f0       	breq	.+16     	; 0x1822 <LCD_PutDec16+0x184>
    1812:	30 e0       	ldi	r19, 0x00	; 0
    1814:	ba cf       	rjmp	.-140    	; 0x178a <LCD_PutDec16+0xec>
	digit = 0;
	while (num >= 1000) {
		digit++;
		num -= 1000;
	}
	if (digit > 0 || flag == 1) {
    1816:	21 30       	cpi	r18, 0x01	; 1
    1818:	11 f0       	breq	.+4      	; 0x181e <LCD_PutDec16+0x180>
    181a:	30 e0       	ldi	r19, 0x00	; 0
    181c:	8f cf       	rjmp	.-226    	; 0x173c <LCD_PutDec16+0x9e>
    181e:	20 e0       	ldi	r18, 0x00	; 0
    1820:	74 cf       	rjmp	.-280    	; 0x170a <LCD_PutDec16+0x6c>
    1822:	20 e0       	ldi	r18, 0x00	; 0
    1824:	99 cf       	rjmp	.-206    	; 0x1758 <LCD_PutDec16+0xba>
	Convert a 16 bit unsigned number to ASCII
	and display the result.
*/
void LCD_PutDec16(uint16_t num) {
	uint8_t digit = 0;
	uint8_t flag = 0;
    1826:	20 e0       	ldi	r18, 0x00	; 0
    1828:	63 cf       	rjmp	.-314    	; 0x16f0 <LCD_PutDec16+0x52>
	if (digit > 0 || flag == 1) {
		LCD_DATA(digit + 48);
		flag = 1;
	}
	digit = 0;
	while (num >= 1) {
    182a:	80 e3       	ldi	r24, 0x30	; 48
    182c:	d4 cf       	rjmp	.-88     	; 0x17d6 <LCD_PutDec16+0x138>

0000182e <LCD_PutChar>:
/*
	Send an ASCII character to the LCD
	usage: LCD_PutChar('H');
*/
void LCD_PutChar(char a_char) {
	LCD_DATA(a_char);
    182e:	91 e0       	ldi	r25, 0x01	; 1
    1830:	9f b9       	out	0x0f, r25	; 15
    1832:	77 9b       	sbis	0x0e, 7	; 14
    1834:	fe cf       	rjmp	.-4      	; 0x1832 <LCD_PutChar+0x4>
    1836:	8f b9       	out	0x0f, r24	; 15
    1838:	77 9b       	sbis	0x0e, 7	; 14
    183a:	fe cf       	rjmp	.-4      	; 0x1838 <LCD_PutChar+0xa>
    183c:	80 91 62 00 	lds	r24, 0x0062
    1840:	88 60       	ori	r24, 0x08	; 8
    1842:	80 93 62 00 	sts	0x0062, r24
    1846:	80 91 62 00 	lds	r24, 0x0062
    184a:	87 7f       	andi	r24, 0xF7	; 247
    184c:	80 93 62 00 	sts	0x0062, r24
    1850:	8f e8       	ldi	r24, 0x8F	; 143
    1852:	91 e0       	ldi	r25, 0x01	; 1
    1854:	01 97       	sbiw	r24, 0x01	; 1
    1856:	f1 f7       	brne	.-4      	; 0x1854 <LCD_PutChar+0x26>
    1858:	00 c0       	rjmp	.+0      	; 0x185a <LCD_PutChar+0x2c>
    185a:	00 00       	nop
    185c:	08 95       	ret

0000185e <LCD_PutStr>:
}

/*
	Send an ASCII string to the LCD
*/
void LCD_PutStr(char *lcd_str) {
    185e:	dc 01       	movw	r26, r24
	uint8_t count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1860:	20 e0       	ldi	r18, 0x00	; 0
    1862:	30 e0       	ldi	r19, 0x00	; 0
    1864:	90 e0       	ldi	r25, 0x00	; 0
		LCD_DATA(lcd_str[count]);
    1866:	41 e0       	ldi	r20, 0x01	; 1
    1868:	4f b9       	out	0x0f, r20	; 15
    186a:	77 9b       	sbis	0x0e, 7	; 14
    186c:	fe cf       	rjmp	.-4      	; 0x186a <LCD_PutStr+0xc>
    186e:	fd 01       	movw	r30, r26
    1870:	e2 0f       	add	r30, r18
    1872:	f3 1f       	adc	r31, r19
    1874:	80 81       	ld	r24, Z
    1876:	8f b9       	out	0x0f, r24	; 15
    1878:	77 9b       	sbis	0x0e, 7	; 14
    187a:	fe cf       	rjmp	.-4      	; 0x1878 <LCD_PutStr+0x1a>
    187c:	80 91 62 00 	lds	r24, 0x0062
    1880:	88 60       	ori	r24, 0x08	; 8
    1882:	80 93 62 00 	sts	0x0062, r24
    1886:	80 91 62 00 	lds	r24, 0x0062
    188a:	87 7f       	andi	r24, 0xF7	; 247
    188c:	80 93 62 00 	sts	0x0062, r24
    1890:	ef e8       	ldi	r30, 0x8F	; 143
    1892:	f1 e0       	ldi	r31, 0x01	; 1
    1894:	31 97       	sbiw	r30, 0x01	; 1
    1896:	f1 f7       	brne	.-4      	; 0x1894 <LCD_PutStr+0x36>
    1898:	00 c0       	rjmp	.+0      	; 0x189a <LCD_PutStr+0x3c>
    189a:	00 00       	nop
/*
	Send an ASCII string to the LCD
*/
void LCD_PutStr(char *lcd_str) {
	uint8_t count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    189c:	9f 5f       	subi	r25, 0xFF	; 255
    189e:	29 2f       	mov	r18, r25
    18a0:	30 e0       	ldi	r19, 0x00	; 0
    18a2:	fd 01       	movw	r30, r26
    18a4:	01 90       	ld	r0, Z+
    18a6:	00 20       	and	r0, r0
    18a8:	e9 f7       	brne	.-6      	; 0x18a4 <LCD_PutStr+0x46>
    18aa:	ea 1b       	sub	r30, r26
    18ac:	fb 0b       	sbc	r31, r27
    18ae:	32 97       	sbiw	r30, 0x02	; 2
    18b0:	e2 17       	cp	r30, r18
    18b2:	f3 07       	cpc	r31, r19
    18b4:	c8 f6       	brcc	.-78     	; 0x1868 <LCD_PutStr+0xa>
		LCD_DATA(lcd_str[count]);
	}
}
    18b6:	08 95       	ret

000018b8 <LCD_SPIInit>:

void LCD_SPIInit(void) {
	DDRF |= 0x08;  //port F bit 3 is enable for LCD
    18b8:	e1 e6       	ldi	r30, 0x61	; 97
    18ba:	f0 e0       	ldi	r31, 0x00	; 0
    18bc:	80 81       	ld	r24, Z
    18be:	88 60       	ori	r24, 0x08	; 8
    18c0:	80 83       	st	Z, r24
	PORTB |= 0x00; //port B initialization for SPI
    18c2:	88 b3       	in	r24, 0x18	; 24
    18c4:	88 bb       	out	0x18, r24	; 24
	DDRB |= 0x07;  //Turn on SS, MOSI, SCLK
    18c6:	87 b3       	in	r24, 0x17	; 23
    18c8:	87 60       	ori	r24, 0x07	; 7
    18ca:	87 bb       	out	0x17, r24	; 23
	//Master mode, Clock=clk/2, Cycle half phase, Low polarity, MSB first
	SPCR = 0x50;
    18cc:	80 e5       	ldi	r24, 0x50	; 80
    18ce:	8d b9       	out	0x0d, r24	; 13
	SPSR = 0x01;
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	8e b9       	out	0x0e, r24	; 14
    18d4:	08 95       	ret

000018d6 <LCD_Init>:
    18d6:	80 91 61 00 	lds	r24, 0x0061
    18da:	88 60       	ori	r24, 0x08	; 8
    18dc:	80 93 61 00 	sts	0x0061, r24
    18e0:	88 b3       	in	r24, 0x18	; 24
    18e2:	88 bb       	out	0x18, r24	; 24
    18e4:	87 b3       	in	r24, 0x17	; 23
    18e6:	87 60       	ori	r24, 0x07	; 7
    18e8:	87 bb       	out	0x17, r24	; 23
    18ea:	80 e5       	ldi	r24, 0x50	; 80
    18ec:	8d b9       	out	0x0d, r24	; 13
    18ee:	81 e0       	ldi	r24, 0x01	; 1
    18f0:	8e b9       	out	0x0e, r24	; 14
    18f2:	80 91 61 00 	lds	r24, 0x0061
    18f6:	88 60       	ori	r24, 0x08	; 8
    18f8:	80 93 61 00 	sts	0x0061, r24
    18fc:	8f e5       	ldi	r24, 0x5F	; 95
    18fe:	9a ee       	ldi	r25, 0xEA	; 234
    1900:	01 97       	sbiw	r24, 0x01	; 1
    1902:	f1 f7       	brne	.-4      	; 0x1900 <LCD_Init+0x2a>
    1904:	00 c0       	rjmp	.+0      	; 0x1906 <LCD_Init+0x30>
    1906:	00 00       	nop
    1908:	1f b8       	out	0x0f, r1	; 15
    190a:	77 9b       	sbis	0x0e, 7	; 14
    190c:	fe cf       	rjmp	.-4      	; 0x190a <LCD_Init+0x34>
    190e:	88 e3       	ldi	r24, 0x38	; 56
    1910:	8f b9       	out	0x0f, r24	; 15
    1912:	77 9b       	sbis	0x0e, 7	; 14
    1914:	fe cf       	rjmp	.-4      	; 0x1912 <LCD_Init+0x3c>
    1916:	80 91 62 00 	lds	r24, 0x0062
    191a:	88 60       	ori	r24, 0x08	; 8
    191c:	80 93 62 00 	sts	0x0062, r24
    1920:	80 91 62 00 	lds	r24, 0x0062
    1924:	87 7f       	andi	r24, 0xF7	; 247
    1926:	80 93 62 00 	sts	0x0062, r24
    192a:	8f e8       	ldi	r24, 0x8F	; 143
    192c:	91 e0       	ldi	r25, 0x01	; 1
    192e:	01 97       	sbiw	r24, 0x01	; 1
    1930:	f1 f7       	brne	.-4      	; 0x192e <LCD_Init+0x58>
    1932:	00 c0       	rjmp	.+0      	; 0x1934 <LCD_Init+0x5e>
    1934:	00 00       	nop
    1936:	8f e1       	ldi	r24, 0x1F	; 31
    1938:	9e e4       	ldi	r25, 0x4E	; 78
    193a:	01 97       	sbiw	r24, 0x01	; 1
    193c:	f1 f7       	brne	.-4      	; 0x193a <LCD_Init+0x64>
    193e:	00 c0       	rjmp	.+0      	; 0x1940 <LCD_Init+0x6a>
    1940:	00 00       	nop
    1942:	1f b8       	out	0x0f, r1	; 15
    1944:	77 9b       	sbis	0x0e, 7	; 14
    1946:	fe cf       	rjmp	.-4      	; 0x1944 <LCD_Init+0x6e>
    1948:	88 e0       	ldi	r24, 0x08	; 8
    194a:	8f b9       	out	0x0f, r24	; 15
    194c:	77 9b       	sbis	0x0e, 7	; 14
    194e:	fe cf       	rjmp	.-4      	; 0x194c <LCD_Init+0x76>
    1950:	80 91 62 00 	lds	r24, 0x0062
    1954:	88 60       	ori	r24, 0x08	; 8
    1956:	80 93 62 00 	sts	0x0062, r24
    195a:	80 91 62 00 	lds	r24, 0x0062
    195e:	87 7f       	andi	r24, 0xF7	; 247
    1960:	80 93 62 00 	sts	0x0062, r24
    1964:	8f e8       	ldi	r24, 0x8F	; 143
    1966:	91 e0       	ldi	r25, 0x01	; 1
    1968:	01 97       	sbiw	r24, 0x01	; 1
    196a:	f1 f7       	brne	.-4      	; 0x1968 <LCD_Init+0x92>
    196c:	00 c0       	rjmp	.+0      	; 0x196e <LCD_Init+0x98>
    196e:	00 00       	nop
    1970:	8f e3       	ldi	r24, 0x3F	; 63
    1972:	9f e1       	ldi	r25, 0x1F	; 31
    1974:	01 97       	sbiw	r24, 0x01	; 1
    1976:	f1 f7       	brne	.-4      	; 0x1974 <LCD_Init+0x9e>
    1978:	00 c0       	rjmp	.+0      	; 0x197a <LCD_Init+0xa4>
    197a:	00 00       	nop
    197c:	1f b8       	out	0x0f, r1	; 15
    197e:	77 9b       	sbis	0x0e, 7	; 14
    1980:	fe cf       	rjmp	.-4      	; 0x197e <LCD_Init+0xa8>
    1982:	86 e0       	ldi	r24, 0x06	; 6
    1984:	8f b9       	out	0x0f, r24	; 15
    1986:	77 9b       	sbis	0x0e, 7	; 14
    1988:	fe cf       	rjmp	.-4      	; 0x1986 <LCD_Init+0xb0>
    198a:	80 91 62 00 	lds	r24, 0x0062
    198e:	88 60       	ori	r24, 0x08	; 8
    1990:	80 93 62 00 	sts	0x0062, r24
    1994:	80 91 62 00 	lds	r24, 0x0062
    1998:	87 7f       	andi	r24, 0xF7	; 247
    199a:	80 93 62 00 	sts	0x0062, r24
    199e:	8f e8       	ldi	r24, 0x8F	; 143
    19a0:	91 e0       	ldi	r25, 0x01	; 1
    19a2:	01 97       	sbiw	r24, 0x01	; 1
    19a4:	f1 f7       	brne	.-4      	; 0x19a2 <LCD_Init+0xcc>
    19a6:	00 c0       	rjmp	.+0      	; 0x19a8 <LCD_Init+0xd2>
    19a8:	00 00       	nop
    19aa:	1f b8       	out	0x0f, r1	; 15
    19ac:	77 9b       	sbis	0x0e, 7	; 14
    19ae:	fe cf       	rjmp	.-4      	; 0x19ac <LCD_Init+0xd6>
    19b0:	80 e4       	ldi	r24, 0x40	; 64
    19b2:	8f b9       	out	0x0f, r24	; 15
    19b4:	77 9b       	sbis	0x0e, 7	; 14
    19b6:	fe cf       	rjmp	.-4      	; 0x19b4 <LCD_Init+0xde>
    19b8:	80 91 62 00 	lds	r24, 0x0062
    19bc:	88 60       	ori	r24, 0x08	; 8
    19be:	80 93 62 00 	sts	0x0062, r24
    19c2:	80 91 62 00 	lds	r24, 0x0062
    19c6:	87 7f       	andi	r24, 0xF7	; 247
    19c8:	80 93 62 00 	sts	0x0062, r24
    19cc:	8f e8       	ldi	r24, 0x8F	; 143
    19ce:	91 e0       	ldi	r25, 0x01	; 1
    19d0:	01 97       	sbiw	r24, 0x01	; 1
    19d2:	f1 f7       	brne	.-4      	; 0x19d0 <LCD_Init+0xfa>
    19d4:	00 c0       	rjmp	.+0      	; 0x19d6 <LCD_Init+0x100>
    19d6:	00 00       	nop
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	8f b9       	out	0x0f, r24	; 15
    19dc:	77 9b       	sbis	0x0e, 7	; 14
    19de:	fe cf       	rjmp	.-4      	; 0x19dc <LCD_Init+0x106>
    19e0:	8e e0       	ldi	r24, 0x0E	; 14
    19e2:	8f b9       	out	0x0f, r24	; 15
    19e4:	77 9b       	sbis	0x0e, 7	; 14
    19e6:	fe cf       	rjmp	.-4      	; 0x19e4 <LCD_Init+0x10e>
    19e8:	80 91 62 00 	lds	r24, 0x0062
    19ec:	88 60       	ori	r24, 0x08	; 8
    19ee:	80 93 62 00 	sts	0x0062, r24
    19f2:	80 91 62 00 	lds	r24, 0x0062
    19f6:	87 7f       	andi	r24, 0xF7	; 247
    19f8:	80 93 62 00 	sts	0x0062, r24
    19fc:	8f e8       	ldi	r24, 0x8F	; 143
    19fe:	91 e0       	ldi	r25, 0x01	; 1
    1a00:	01 97       	sbiw	r24, 0x01	; 1
    1a02:	f1 f7       	brne	.-4      	; 0x1a00 <LCD_Init+0x12a>
    1a04:	00 c0       	rjmp	.+0      	; 0x1a06 <LCD_Init+0x130>
    1a06:	00 00       	nop
    1a08:	81 e0       	ldi	r24, 0x01	; 1
    1a0a:	8f b9       	out	0x0f, r24	; 15
    1a0c:	77 9b       	sbis	0x0e, 7	; 14
    1a0e:	fe cf       	rjmp	.-4      	; 0x1a0c <LCD_Init+0x136>
    1a10:	8b e1       	ldi	r24, 0x1B	; 27
    1a12:	8f b9       	out	0x0f, r24	; 15
    1a14:	77 9b       	sbis	0x0e, 7	; 14
    1a16:	fe cf       	rjmp	.-4      	; 0x1a14 <LCD_Init+0x13e>
    1a18:	80 91 62 00 	lds	r24, 0x0062
    1a1c:	88 60       	ori	r24, 0x08	; 8
    1a1e:	80 93 62 00 	sts	0x0062, r24
    1a22:	80 91 62 00 	lds	r24, 0x0062
    1a26:	87 7f       	andi	r24, 0xF7	; 247
    1a28:	80 93 62 00 	sts	0x0062, r24
    1a2c:	8f e8       	ldi	r24, 0x8F	; 143
    1a2e:	91 e0       	ldi	r25, 0x01	; 1
    1a30:	01 97       	sbiw	r24, 0x01	; 1
    1a32:	f1 f7       	brne	.-4      	; 0x1a30 <LCD_Init+0x15a>
    1a34:	00 c0       	rjmp	.+0      	; 0x1a36 <LCD_Init+0x160>
    1a36:	00 00       	nop
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	8f b9       	out	0x0f, r24	; 15
    1a3c:	77 9b       	sbis	0x0e, 7	; 14
    1a3e:	fe cf       	rjmp	.-4      	; 0x1a3c <LCD_Init+0x166>
    1a40:	81 e1       	ldi	r24, 0x11	; 17
    1a42:	8f b9       	out	0x0f, r24	; 15
    1a44:	77 9b       	sbis	0x0e, 7	; 14
    1a46:	fe cf       	rjmp	.-4      	; 0x1a44 <LCD_Init+0x16e>
    1a48:	80 91 62 00 	lds	r24, 0x0062
    1a4c:	88 60       	ori	r24, 0x08	; 8
    1a4e:	80 93 62 00 	sts	0x0062, r24
    1a52:	80 91 62 00 	lds	r24, 0x0062
    1a56:	87 7f       	andi	r24, 0xF7	; 247
    1a58:	80 93 62 00 	sts	0x0062, r24
    1a5c:	8f e8       	ldi	r24, 0x8F	; 143
    1a5e:	91 e0       	ldi	r25, 0x01	; 1
    1a60:	01 97       	sbiw	r24, 0x01	; 1
    1a62:	f1 f7       	brne	.-4      	; 0x1a60 <LCD_Init+0x18a>
    1a64:	00 c0       	rjmp	.+0      	; 0x1a66 <LCD_Init+0x190>
    1a66:	00 00       	nop
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	8f b9       	out	0x0f, r24	; 15
    1a6c:	77 9b       	sbis	0x0e, 7	; 14
    1a6e:	fe cf       	rjmp	.-4      	; 0x1a6c <LCD_Init+0x196>
    1a70:	81 e1       	ldi	r24, 0x11	; 17
    1a72:	8f b9       	out	0x0f, r24	; 15
    1a74:	77 9b       	sbis	0x0e, 7	; 14
    1a76:	fe cf       	rjmp	.-4      	; 0x1a74 <LCD_Init+0x19e>
    1a78:	80 91 62 00 	lds	r24, 0x0062
    1a7c:	88 60       	ori	r24, 0x08	; 8
    1a7e:	80 93 62 00 	sts	0x0062, r24
    1a82:	80 91 62 00 	lds	r24, 0x0062
    1a86:	87 7f       	andi	r24, 0xF7	; 247
    1a88:	80 93 62 00 	sts	0x0062, r24
    1a8c:	8f e8       	ldi	r24, 0x8F	; 143
    1a8e:	91 e0       	ldi	r25, 0x01	; 1
    1a90:	01 97       	sbiw	r24, 0x01	; 1
    1a92:	f1 f7       	brne	.-4      	; 0x1a90 <LCD_Init+0x1ba>
    1a94:	00 c0       	rjmp	.+0      	; 0x1a96 <LCD_Init+0x1c0>
    1a96:	00 00       	nop
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	8f b9       	out	0x0f, r24	; 15
    1a9c:	77 9b       	sbis	0x0e, 7	; 14
    1a9e:	fe cf       	rjmp	.-4      	; 0x1a9c <LCD_Init+0x1c6>
    1aa0:	81 e1       	ldi	r24, 0x11	; 17
    1aa2:	8f b9       	out	0x0f, r24	; 15
    1aa4:	77 9b       	sbis	0x0e, 7	; 14
    1aa6:	fe cf       	rjmp	.-4      	; 0x1aa4 <LCD_Init+0x1ce>
    1aa8:	80 91 62 00 	lds	r24, 0x0062
    1aac:	88 60       	ori	r24, 0x08	; 8
    1aae:	80 93 62 00 	sts	0x0062, r24
    1ab2:	80 91 62 00 	lds	r24, 0x0062
    1ab6:	87 7f       	andi	r24, 0xF7	; 247
    1ab8:	80 93 62 00 	sts	0x0062, r24
    1abc:	8f e8       	ldi	r24, 0x8F	; 143
    1abe:	91 e0       	ldi	r25, 0x01	; 1
    1ac0:	01 97       	sbiw	r24, 0x01	; 1
    1ac2:	f1 f7       	brne	.-4      	; 0x1ac0 <LCD_Init+0x1ea>
    1ac4:	00 c0       	rjmp	.+0      	; 0x1ac6 <LCD_Init+0x1f0>
    1ac6:	00 00       	nop
    1ac8:	81 e0       	ldi	r24, 0x01	; 1
    1aca:	8f b9       	out	0x0f, r24	; 15
    1acc:	77 9b       	sbis	0x0e, 7	; 14
    1ace:	fe cf       	rjmp	.-4      	; 0x1acc <LCD_Init+0x1f6>
    1ad0:	81 e1       	ldi	r24, 0x11	; 17
    1ad2:	8f b9       	out	0x0f, r24	; 15
    1ad4:	77 9b       	sbis	0x0e, 7	; 14
    1ad6:	fe cf       	rjmp	.-4      	; 0x1ad4 <LCD_Init+0x1fe>
    1ad8:	80 91 62 00 	lds	r24, 0x0062
    1adc:	88 60       	ori	r24, 0x08	; 8
    1ade:	80 93 62 00 	sts	0x0062, r24
    1ae2:	80 91 62 00 	lds	r24, 0x0062
    1ae6:	87 7f       	andi	r24, 0xF7	; 247
    1ae8:	80 93 62 00 	sts	0x0062, r24
    1aec:	8f e8       	ldi	r24, 0x8F	; 143
    1aee:	91 e0       	ldi	r25, 0x01	; 1
    1af0:	01 97       	sbiw	r24, 0x01	; 1
    1af2:	f1 f7       	brne	.-4      	; 0x1af0 <LCD_Init+0x21a>
    1af4:	00 c0       	rjmp	.+0      	; 0x1af6 <LCD_Init+0x220>
    1af6:	00 00       	nop
    1af8:	81 e0       	ldi	r24, 0x01	; 1
    1afa:	8f b9       	out	0x0f, r24	; 15
    1afc:	77 9b       	sbis	0x0e, 7	; 14
    1afe:	fe cf       	rjmp	.-4      	; 0x1afc <LCD_Init+0x226>
    1b00:	81 e1       	ldi	r24, 0x11	; 17
    1b02:	8f b9       	out	0x0f, r24	; 15
    1b04:	77 9b       	sbis	0x0e, 7	; 14
    1b06:	fe cf       	rjmp	.-4      	; 0x1b04 <LCD_Init+0x22e>
    1b08:	80 91 62 00 	lds	r24, 0x0062
    1b0c:	88 60       	ori	r24, 0x08	; 8
    1b0e:	80 93 62 00 	sts	0x0062, r24
    1b12:	80 91 62 00 	lds	r24, 0x0062
    1b16:	87 7f       	andi	r24, 0xF7	; 247
    1b18:	80 93 62 00 	sts	0x0062, r24
    1b1c:	8f e8       	ldi	r24, 0x8F	; 143
    1b1e:	91 e0       	ldi	r25, 0x01	; 1
    1b20:	01 97       	sbiw	r24, 0x01	; 1
    1b22:	f1 f7       	brne	.-4      	; 0x1b20 <LCD_Init+0x24a>
    1b24:	00 c0       	rjmp	.+0      	; 0x1b26 <LCD_Init+0x250>
    1b26:	00 00       	nop
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	8f b9       	out	0x0f, r24	; 15
    1b2c:	77 9b       	sbis	0x0e, 7	; 14
    1b2e:	fe cf       	rjmp	.-4      	; 0x1b2c <LCD_Init+0x256>
    1b30:	8f e1       	ldi	r24, 0x1F	; 31
    1b32:	8f b9       	out	0x0f, r24	; 15
    1b34:	77 9b       	sbis	0x0e, 7	; 14
    1b36:	fe cf       	rjmp	.-4      	; 0x1b34 <LCD_Init+0x25e>
    1b38:	80 91 62 00 	lds	r24, 0x0062
    1b3c:	88 60       	ori	r24, 0x08	; 8
    1b3e:	80 93 62 00 	sts	0x0062, r24
    1b42:	80 91 62 00 	lds	r24, 0x0062
    1b46:	87 7f       	andi	r24, 0xF7	; 247
    1b48:	80 93 62 00 	sts	0x0062, r24
    1b4c:	8f e8       	ldi	r24, 0x8F	; 143
    1b4e:	91 e0       	ldi	r25, 0x01	; 1
    1b50:	01 97       	sbiw	r24, 0x01	; 1
    1b52:	f1 f7       	brne	.-4      	; 0x1b50 <LCD_Init+0x27a>
    1b54:	00 c0       	rjmp	.+0      	; 0x1b56 <LCD_Init+0x280>
    1b56:	00 00       	nop
    1b58:	1f b8       	out	0x0f, r1	; 15
    1b5a:	77 9b       	sbis	0x0e, 7	; 14
    1b5c:	fe cf       	rjmp	.-4      	; 0x1b5a <LCD_Init+0x284>
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	8f b9       	out	0x0f, r24	; 15
    1b62:	77 9b       	sbis	0x0e, 7	; 14
    1b64:	fe cf       	rjmp	.-4      	; 0x1b62 <LCD_Init+0x28c>
    1b66:	80 91 62 00 	lds	r24, 0x0062
    1b6a:	88 60       	ori	r24, 0x08	; 8
    1b6c:	80 93 62 00 	sts	0x0062, r24
    1b70:	80 91 62 00 	lds	r24, 0x0062
    1b74:	87 7f       	andi	r24, 0xF7	; 247
    1b76:	80 93 62 00 	sts	0x0062, r24
    1b7a:	8f e8       	ldi	r24, 0x8F	; 143
    1b7c:	91 e0       	ldi	r25, 0x01	; 1
    1b7e:	01 97       	sbiw	r24, 0x01	; 1
    1b80:	f1 f7       	brne	.-4      	; 0x1b7e <LCD_Init+0x2a8>
    1b82:	00 c0       	rjmp	.+0      	; 0x1b84 <LCD_Init+0x2ae>
    1b84:	00 00       	nop
    1b86:	8f e1       	ldi	r24, 0x1F	; 31
    1b88:	9e e4       	ldi	r25, 0x4E	; 78
    1b8a:	01 97       	sbiw	r24, 0x01	; 1
    1b8c:	f1 f7       	brne	.-4      	; 0x1b8a <LCD_Init+0x2b4>
    1b8e:	00 c0       	rjmp	.+0      	; 0x1b90 <LCD_Init+0x2ba>
    1b90:	00 00       	nop
    1b92:	1f b8       	out	0x0f, r1	; 15
    1b94:	77 9b       	sbis	0x0e, 7	; 14
    1b96:	fe cf       	rjmp	.-4      	; 0x1b94 <LCD_Init+0x2be>
    1b98:	8c e0       	ldi	r24, 0x0C	; 12
    1b9a:	8f b9       	out	0x0f, r24	; 15
    1b9c:	77 9b       	sbis	0x0e, 7	; 14
    1b9e:	fe cf       	rjmp	.-4      	; 0x1b9c <LCD_Init+0x2c6>
    1ba0:	80 91 62 00 	lds	r24, 0x0062
    1ba4:	88 60       	ori	r24, 0x08	; 8
    1ba6:	80 93 62 00 	sts	0x0062, r24
    1baa:	80 91 62 00 	lds	r24, 0x0062
    1bae:	87 7f       	andi	r24, 0xF7	; 247
    1bb0:	80 93 62 00 	sts	0x0062, r24
    1bb4:	8f e8       	ldi	r24, 0x8F	; 143
    1bb6:	91 e0       	ldi	r25, 0x01	; 1
    1bb8:	01 97       	sbiw	r24, 0x01	; 1
    1bba:	f1 f7       	brne	.-4      	; 0x1bb8 <LCD_Init+0x2e2>
    1bbc:	00 c0       	rjmp	.+0      	; 0x1bbe <LCD_Init+0x2e8>
    1bbe:	00 00       	nop
    1bc0:	08 95       	ret

00001bc2 <main>:

int main()
{
    //set port bits 4-7 B as outputs
    //uint8_t c = 0;
    DDRE = 0xc0;
    1bc2:	80 ec       	ldi	r24, 0xC0	; 192
    1bc4:	82 b9       	out	0x02, r24	; 2
    PORTE &= 0x7F;
    1bc6:	1f 98       	cbi	0x03, 7	; 3
    DDRB = 0xF7;
    1bc8:	87 ef       	ldi	r24, 0xF7	; 247
    1bca:	87 bb       	out	0x17, r24	; 23
    DDRD |= (1 << PB2);
    1bcc:	8a 9a       	sbi	0x11, 2	; 17

    volume = 100;
    1bce:	84 e6       	ldi	r24, 0x64	; 100
    1bd0:	80 93 2b 01 	sts	0x012B, r24
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
    TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1bd4:	83 b7       	in	r24, 0x33	; 51
    1bd6:	81 60       	ori	r24, 0x01	; 1
    1bd8:	83 bf       	out	0x33, r24	; 51
    ASSR  |= (1<<AS0);
    1bda:	80 b7       	in	r24, 0x30	; 48
    1bdc:	88 60       	ori	r24, 0x08	; 8
    1bde:	80 bf       	out	0x30, r24	; 48
    TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1be0:	85 b5       	in	r24, 0x25	; 37
    1be2:	8a 67       	ori	r24, 0x7A	; 122
    1be4:	85 bd       	out	0x25, r24	; 37
    TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1be6:	87 b7       	in	r24, 0x37	; 55
    1be8:	81 64       	ori	r24, 0x41	; 65
    1bea:	87 bf       	out	0x37, r24	; 55
}


void ADC_init(void){
    DDRF |= !(1<<PF0);
    1bec:	80 91 61 00 	lds	r24, 0x0061
    1bf0:	80 93 61 00 	sts	0x0061, r24
    PORTF = 0x00;
    1bf4:	10 92 62 00 	sts	0x0062, r1
    ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1bf8:	87 b1       	in	r24, 0x07	; 7
    1bfa:	80 66       	ori	r24, 0x60	; 96
    1bfc:	87 b9       	out	0x07, r24	; 7
    ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1bfe:	86 b1       	in	r24, 0x06	; 6
    1c00:	8f 6e       	ori	r24, 0xEF	; 239
    1c02:	86 b9       	out	0x06, r24	; 6
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    OCR2 = 0xFF;
    1c04:	8f ef       	ldi	r24, 0xFF	; 255
    1c06:	83 bd       	out	0x23, r24	; 35
    DDRD |= (1 << PB2);

    volume = 100;
    timer_init();
    ADC_init();
    music_init();   
    1c08:	0e 94 11 05 	call	0xa22	; 0xa22 <music_init>
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
    1c0c:	81 e5       	ldi	r24, 0x51	; 81
    1c0e:	8d b9       	out	0x0d, r24	; 13
    volume = 100;
    timer_init();
    ADC_init();
    music_init();   
    SPI_init();
    LCD_SPIInit();
    1c10:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <LCD_SPIInit>
    LCD_Init();
    1c14:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <LCD_Init>
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    OCR2 = 0xFF;
}

void volume_control_init(void){
    DDRE |= (1<<PE1);
    1c18:	11 9a       	sbi	0x02, 1	; 2
    TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1c1a:	81 e8       	ldi	r24, 0x81	; 129
    1c1c:	80 93 8b 00 	sts	0x008B, r24
    TCCR3B = (1<<WGM32) | (1<<CS30);
    1c20:	89 e0       	ldi	r24, 0x09	; 9
    1c22:	80 93 8a 00 	sts	0x008A, r24
    OCR3A = volume;
    1c26:	80 91 2b 01 	lds	r24, 0x012B
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	90 93 87 00 	sts	0x0087, r25
    1c30:	80 93 86 00 	sts	0x0086, r24
    LCD_Init();
    volume_control_init();
    // lcd_init();
    // clear_display();
    // string2lcd("hello");
    sei();
    1c34:	78 94       	sei
    while(1){
	display_update();
    1c36:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <display_update>
	update_time();
    1c3a:	0e 94 01 07 	call	0xe02	; 0xe02 <update_time>
	if(update_LCD){
    1c3e:	80 91 3b 01 	lds	r24, 0x013B
    1c42:	88 23       	and	r24, r24
    1c44:	c1 f3       	breq	.-16     	; 0x1c36 <main+0x74>
		LCD_Clr();
    1c46:	0e 94 2b 0a 	call	0x1456	; 0x1456 <LCD_Clr>
		if(alarm_on){
    1c4a:	80 91 2d 01 	lds	r24, 0x012D
    1c4e:	88 23       	and	r24, r24
    1c50:	39 f0       	breq	.+14     	; 0x1c60 <main+0x9e>
               		LCD_PutStr("ALARM ON!!");
    1c52:	82 e1       	ldi	r24, 0x12	; 18
    1c54:	91 e0       	ldi	r25, 0x01	; 1
    1c56:	0e 94 2f 0c 	call	0x185e	; 0x185e <LCD_PutStr>
		}
		else{
               		LCD_PutStr("ALARM OFF!!");
		}
		update_LCD = 0;
    1c5a:	10 92 3b 01 	sts	0x013B, r1
    1c5e:	eb cf       	rjmp	.-42     	; 0x1c36 <main+0x74>
		LCD_Clr();
		if(alarm_on){
               		LCD_PutStr("ALARM ON!!");
		}
		else{
               		LCD_PutStr("ALARM OFF!!");
    1c60:	8d e1       	ldi	r24, 0x1D	; 29
    1c62:	91 e0       	ldi	r25, 0x01	; 1
    1c64:	0e 94 2f 0c 	call	0x185e	; 0x185e <LCD_PutStr>
    1c68:	f8 cf       	rjmp	.-16     	; 0x1c5a <main+0x98>

00001c6a <__tablejump2__>:
    1c6a:	ee 0f       	add	r30, r30
    1c6c:	ff 1f       	adc	r31, r31

00001c6e <__tablejump__>:
    1c6e:	05 90       	lpm	r0, Z+
    1c70:	f4 91       	lpm	r31, Z
    1c72:	e0 2d       	mov	r30, r0
    1c74:	09 94       	ijmp

00001c76 <__umulhisi3>:
    1c76:	a2 9f       	mul	r26, r18
    1c78:	b0 01       	movw	r22, r0
    1c7a:	b3 9f       	mul	r27, r19
    1c7c:	c0 01       	movw	r24, r0
    1c7e:	a3 9f       	mul	r26, r19
    1c80:	70 0d       	add	r23, r0
    1c82:	81 1d       	adc	r24, r1
    1c84:	11 24       	eor	r1, r1
    1c86:	91 1d       	adc	r25, r1
    1c88:	b2 9f       	mul	r27, r18
    1c8a:	70 0d       	add	r23, r0
    1c8c:	81 1d       	adc	r24, r1
    1c8e:	11 24       	eor	r1, r1
    1c90:	91 1d       	adc	r25, r1
    1c92:	08 95       	ret

00001c94 <_exit>:
    1c94:	f8 94       	cli

00001c96 <__stop_program>:
    1c96:	ff cf       	rjmp	.-2      	; 0x1c96 <__stop_program>
