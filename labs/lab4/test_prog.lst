
test_prog.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000930  000009c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000930  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000028  00800110  00800110  000009d4  2**0
                  ALLOC
  3 .stab         00001a94  00000000  00000000  000009d4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000103f  00000000  00000000  00002468  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000034a7  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 d6 03 	jmp	0x7ac	; 0x7ac <__vector_10>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 9b 01 	jmp	0x336	; 0x336 <__vector_12>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 02 02 	jmp	0x404	; 0x404 <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 a5 01 	jmp	0x34a	; 0x34a <__vector_21>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 e3       	ldi	r30, 0x30	; 48
  a0:	f9 e0       	ldi	r31, 0x09	; 9
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 31       	cpi	r26, 0x10	; 16
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a0 e1       	ldi	r26, 0x10	; 16
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a8 33       	cpi	r26, 0x38	; 56
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <main>
  c6:	0c 94 96 04 	jmp	0x92c	; 0x92c <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
  ce:	20 91 1d 01 	lds	r18, 0x011D
  d2:	30 91 1e 01 	lds	r19, 0x011E
  d6:	22 0f       	add	r18, r18
  d8:	33 1f       	adc	r19, r19
  da:	49 b3       	in	r20, 0x19	; 25
  dc:	50 e0       	ldi	r21, 0x00	; 0
  de:	02 c0       	rjmp	.+4      	; 0xe4 <chk_buttons+0x16>
  e0:	55 95       	asr	r21
  e2:	47 95       	ror	r20
  e4:	8a 95       	dec	r24
  e6:	e2 f7       	brpl	.-8      	; 0xe0 <chk_buttons+0x12>
  e8:	40 fd       	sbrc	r20, 0
  ea:	0e c0       	rjmp	.+28     	; 0x108 <chk_buttons+0x3a>
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	90 ee       	ldi	r25, 0xE0	; 224
  f0:	28 2b       	or	r18, r24
  f2:	39 2b       	or	r19, r25
  f4:	30 93 1e 01 	sts	0x011E, r19
  f8:	20 93 1d 01 	sts	0x011D, r18
    if (state == 0xF000){
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	21 15       	cp	r18, r1
 100:	30 4f       	sbci	r19, 0xF0	; 240
 102:	09 f0       	breq	.+2      	; 0x106 <chk_buttons+0x38>
 104:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
    }
    return 0;
}
 106:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	90 ee       	ldi	r25, 0xE0	; 224
 10c:	f1 cf       	rjmp	.-30     	; 0xf0 <chk_buttons+0x22>

0000010e <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
 10e:	81 11       	cpse	r24, r1
 110:	02 c0       	rjmp	.+4      	; 0x116 <int2seg+0x8>
	return ZERO;
 112:	80 ec       	ldi	r24, 0xC0	; 192
 114:	08 95       	ret
    }
    else if(number == 1 ){
 116:	81 30       	cpi	r24, 0x01	; 1
 118:	91 f0       	breq	.+36     	; 0x13e <int2seg+0x30>
	return ONE;
    }
    else if(number == 2 ){
 11a:	82 30       	cpi	r24, 0x02	; 2
 11c:	91 f0       	breq	.+36     	; 0x142 <int2seg+0x34>
	return TWO;
    }
    else if(number == 3 ){
 11e:	83 30       	cpi	r24, 0x03	; 3
 120:	a1 f0       	breq	.+40     	; 0x14a <int2seg+0x3c>
	return THREE;
    }
    else if(number == 4 ){
 122:	84 30       	cpi	r24, 0x04	; 4
 124:	81 f0       	breq	.+32     	; 0x146 <int2seg+0x38>
	return FOUR;
    }
    else if(number == 5 ){
 126:	85 30       	cpi	r24, 0x05	; 5
 128:	91 f0       	breq	.+36     	; 0x14e <int2seg+0x40>
	return FIVE;
    }
    else if(number == 6 ){
 12a:	86 30       	cpi	r24, 0x06	; 6
 12c:	91 f0       	breq	.+36     	; 0x152 <int2seg+0x44>
	return  SIX;
    }
    else if(number == 7 ){
 12e:	87 30       	cpi	r24, 0x07	; 7
 130:	91 f0       	breq	.+36     	; 0x156 <int2seg+0x48>
	return SEVEN;
    }
    else if(number == 8 ){
 132:	88 30       	cpi	r24, 0x08	; 8
 134:	91 f0       	breq	.+36     	; 0x15a <int2seg+0x4c>
	return EIGHT;
    }
    else if(number == 9 ){
 136:	89 30       	cpi	r24, 0x09	; 9
 138:	91 f0       	breq	.+36     	; 0x15e <int2seg+0x50>
	return NINE;
    }
    else{ 
	return 0;
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	08 95       	ret
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
	return ZERO;
    }
    else if(number == 1 ){
	return ONE;
 13e:	89 ef       	ldi	r24, 0xF9	; 249
 140:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
 142:	84 ea       	ldi	r24, 0xA4	; 164
 144:	08 95       	ret
    }
    else if(number == 3 ){
	return THREE;
    }
    else if(number == 4 ){
	return FOUR;
 146:	89 e9       	ldi	r24, 0x99	; 153
 148:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
    }
    else if(number == 3 ){
	return THREE;
 14a:	80 eb       	ldi	r24, 0xB0	; 176
 14c:	08 95       	ret
    }
    else if(number == 4 ){
	return FOUR;
    }
    else if(number == 5 ){
	return FIVE;
 14e:	82 e9       	ldi	r24, 0x92	; 146
 150:	08 95       	ret
    }
    else if(number == 6 ){
	return  SIX;
 152:	82 e8       	ldi	r24, 0x82	; 130
 154:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
 156:	88 ef       	ldi	r24, 0xF8	; 248
	return NINE;
    }
    else{ 
	return 0;
    }
}
 158:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
    }
    else if(number == 8 ){
	return EIGHT;
 15a:	80 e8       	ldi	r24, 0x80	; 128
 15c:	08 95       	ret
    }
    else if(number == 9 ){
	return NINE;
 15e:	80 e9       	ldi	r24, 0x90	; 144
 160:	08 95       	ret

00000162 <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
 162:	0f 93       	push	r16
 164:	1f 93       	push	r17
 166:	cf 93       	push	r28
 168:	df 93       	push	r29
 16a:	ec 01       	movw	r28, r24
    //determine how many digits there are 
    //int digit;
    // Break down the digits
    
    if(ticker%2 == 1){
 16c:	80 91 1f 01 	lds	r24, 0x011F
 170:	80 ff       	sbrs	r24, 0
 172:	79 c0       	rjmp	.+242    	; 0x266 <segsum+0x104>
	segment_data[2] = 0xFC;
 174:	8c ef       	ldi	r24, 0xFC	; 252
 176:	80 93 35 01 	sts	0x0135, r24
	segment_data[2] = 0xFF;
    } 
    //When setting alarm is on)
    //break up decimal sum into 4 digit-segments
    
    segment_data[0] = int2seg(sum % 10); //ones
 17a:	9e 01       	movw	r18, r28
 17c:	ad ec       	ldi	r26, 0xCD	; 205
 17e:	bc ec       	ldi	r27, 0xCC	; 204
 180:	0e 94 87 04 	call	0x90e	; 0x90e <__umulhisi3>
 184:	96 95       	lsr	r25
 186:	87 95       	ror	r24
 188:	96 95       	lsr	r25
 18a:	87 95       	ror	r24
 18c:	96 95       	lsr	r25
 18e:	87 95       	ror	r24
 190:	3c 2f       	mov	r19, r28
 192:	2a e0       	ldi	r18, 0x0A	; 10
 194:	82 9f       	mul	r24, r18
 196:	30 19       	sub	r19, r0
 198:	11 24       	eor	r1, r1
 19a:	83 2f       	mov	r24, r19
 19c:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 1a0:	80 93 33 01 	sts	0x0133, r24
    segment_data[1] = int2seg((sum % 100)/10); //tens
 1a4:	9e 01       	movw	r18, r28
 1a6:	36 95       	lsr	r19
 1a8:	27 95       	ror	r18
 1aa:	36 95       	lsr	r19
 1ac:	27 95       	ror	r18
 1ae:	ab e7       	ldi	r26, 0x7B	; 123
 1b0:	b4 e1       	ldi	r27, 0x14	; 20
 1b2:	0e 94 87 04 	call	0x90e	; 0x90e <__umulhisi3>
 1b6:	96 95       	lsr	r25
 1b8:	87 95       	ror	r24
 1ba:	44 e6       	ldi	r20, 0x64	; 100
 1bc:	48 9f       	mul	r20, r24
 1be:	90 01       	movw	r18, r0
 1c0:	49 9f       	mul	r20, r25
 1c2:	30 0d       	add	r19, r0
 1c4:	11 24       	eor	r1, r1
 1c6:	ce 01       	movw	r24, r28
 1c8:	82 1b       	sub	r24, r18
 1ca:	93 0b       	sbc	r25, r19
 1cc:	9c 01       	movw	r18, r24
 1ce:	ad ec       	ldi	r26, 0xCD	; 205
 1d0:	bc ec       	ldi	r27, 0xCC	; 204
 1d2:	0e 94 87 04 	call	0x90e	; 0x90e <__umulhisi3>
 1d6:	96 95       	lsr	r25
 1d8:	87 95       	ror	r24
 1da:	96 95       	lsr	r25
 1dc:	87 95       	ror	r24
 1de:	96 95       	lsr	r25
 1e0:	87 95       	ror	r24
 1e2:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 1e6:	80 93 34 01 	sts	0x0134, r24
    //segment_data[2] = 1; //decimal
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
 1ea:	9e 01       	movw	r18, r28
 1ec:	36 95       	lsr	r19
 1ee:	27 95       	ror	r18
 1f0:	36 95       	lsr	r19
 1f2:	27 95       	ror	r18
 1f4:	36 95       	lsr	r19
 1f6:	27 95       	ror	r18
 1f8:	a5 ec       	ldi	r26, 0xC5	; 197
 1fa:	b0 e2       	ldi	r27, 0x20	; 32
 1fc:	0e 94 87 04 	call	0x90e	; 0x90e <__umulhisi3>
 200:	8c 01       	movw	r16, r24
 202:	12 95       	swap	r17
 204:	02 95       	swap	r16
 206:	0f 70       	andi	r16, 0x0F	; 15
 208:	01 27       	eor	r16, r17
 20a:	1f 70       	andi	r17, 0x0F	; 15
 20c:	01 27       	eor	r16, r17
 20e:	28 ee       	ldi	r18, 0xE8	; 232
 210:	33 e0       	ldi	r19, 0x03	; 3
 212:	02 9f       	mul	r16, r18
 214:	c0 01       	movw	r24, r0
 216:	03 9f       	mul	r16, r19
 218:	90 0d       	add	r25, r0
 21a:	12 9f       	mul	r17, r18
 21c:	90 0d       	add	r25, r0
 21e:	11 24       	eor	r1, r1
 220:	9e 01       	movw	r18, r28
 222:	28 1b       	sub	r18, r24
 224:	39 0b       	sbc	r19, r25
 226:	36 95       	lsr	r19
 228:	27 95       	ror	r18
 22a:	36 95       	lsr	r19
 22c:	27 95       	ror	r18
 22e:	ab e7       	ldi	r26, 0x7B	; 123
 230:	b4 e1       	ldi	r27, 0x14	; 20
 232:	0e 94 87 04 	call	0x90e	; 0x90e <__umulhisi3>
 236:	96 95       	lsr	r25
 238:	87 95       	ror	r24
 23a:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 23e:	80 93 36 01 	sts	0x0136, r24
    segment_data[4] = int2seg(sum/1000); //thousands
 242:	80 2f       	mov	r24, r16
 244:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 248:	80 93 37 01 	sts	0x0137, r24
    //blank out leading zero digits 
    //now move data to right place for misplaced colon position
    if(mode == 3){
 24c:	80 91 25 01 	lds	r24, 0x0125
 250:	83 30       	cpi	r24, 0x03	; 3
 252:	f9 f0       	breq	.+62     	; 0x292 <segsum+0x130>
	//segment_data[4] = 0xFF;
	// segment_data[3] = 0xFF;
	segment_data[2] = 0xFF;
    }

    else if(mode == 2){
 254:	82 30       	cpi	r24, 0x02	; 2
 256:	29 f1       	breq	.+74     	; 0x2a2 <segsum+0x140>
	segment_data[2] = 0x00;
    }                                         
    else if(mode == 1 && blink){
 258:	81 30       	cpi	r24, 0x01	; 1
 25a:	49 f0       	breq	.+18     	; 0x26e <segsum+0x10c>
	segment_data[4] = 0xFF;
	segment_data[3] = 0xFF;
	segment_data[1] = 0xFF;
	segment_data[0] = 0xFF;
    }
}//segment_sum
 25c:	df 91       	pop	r29
 25e:	cf 91       	pop	r28
 260:	1f 91       	pop	r17
 262:	0f 91       	pop	r16
 264:	08 95       	ret
    
    if(ticker%2 == 1){
	segment_data[2] = 0xFC;
    }
    else{
	segment_data[2] = 0xFF;
 266:	8f ef       	ldi	r24, 0xFF	; 255
 268:	80 93 35 01 	sts	0x0135, r24
 26c:	86 cf       	rjmp	.-244    	; 0x17a <segsum+0x18>
    }

    else if(mode == 2){
	segment_data[2] = 0x00;
    }                                         
    else if(mode == 1 && blink){
 26e:	80 91 10 01 	lds	r24, 0x0110
 272:	88 23       	and	r24, r24
 274:	99 f3       	breq	.-26     	; 0x25c <segsum+0xfa>
	segment_data[4] = 0xFF;
 276:	8f ef       	ldi	r24, 0xFF	; 255
 278:	80 93 37 01 	sts	0x0137, r24
	segment_data[3] = 0xFF;
 27c:	80 93 36 01 	sts	0x0136, r24
	segment_data[1] = 0xFF;
 280:	80 93 34 01 	sts	0x0134, r24
	segment_data[0] = 0xFF;
 284:	80 93 33 01 	sts	0x0133, r24
    }
}//segment_sum
 288:	df 91       	pop	r29
 28a:	cf 91       	pop	r28
 28c:	1f 91       	pop	r17
 28e:	0f 91       	pop	r16
 290:	08 95       	ret
    //blank out leading zero digits 
    //now move data to right place for misplaced colon position
    if(mode == 3){
	//segment_data[4] = 0xFF;
	// segment_data[3] = 0xFF;
	segment_data[2] = 0xFF;
 292:	8f ef       	ldi	r24, 0xFF	; 255
 294:	80 93 35 01 	sts	0x0135, r24
	segment_data[4] = 0xFF;
	segment_data[3] = 0xFF;
	segment_data[1] = 0xFF;
	segment_data[0] = 0xFF;
    }
}//segment_sum
 298:	df 91       	pop	r29
 29a:	cf 91       	pop	r28
 29c:	1f 91       	pop	r17
 29e:	0f 91       	pop	r16
 2a0:	08 95       	ret
	// segment_data[3] = 0xFF;
	segment_data[2] = 0xFF;
    }

    else if(mode == 2){
	segment_data[2] = 0x00;
 2a2:	10 92 35 01 	sts	0x0135, r1
	segment_data[4] = 0xFF;
	segment_data[3] = 0xFF;
	segment_data[1] = 0xFF;
	segment_data[0] = 0xFF;
    }
}//segment_sum
 2a6:	df 91       	pop	r29
 2a8:	cf 91       	pop	r28
 2aa:	1f 91       	pop	r17
 2ac:	0f 91       	pop	r16
 2ae:	08 95       	ret

000002b0 <button_routine>:
//***********************************************************************************
void button_routine(){
    uint8_t button = 0;
    int previous_mode;   
    DDRA  = 0x00; // PORTA input mode
 2b0:	1a ba       	out	0x1a, r1	; 26
    PORTA = 0xFF; //Pull ups
 2b2:	8f ef       	ldi	r24, 0xFF	; 255
 2b4:	8b bb       	out	0x1b, r24	; 27
    __asm__ __volatile__ ("nop");
 2b6:	00 00       	nop
    __asm__ __volatile__ ("nop");
 2b8:	00 00       	nop
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
 2ba:	88 b3       	in	r24, 0x18	; 24
 2bc:	80 67       	ori	r24, 0x70	; 112
 2be:	88 bb       	out	0x18, r24	; 24
    __asm__ __volatile__ ("nop");
 2c0:	00 00       	nop
    __asm__ __volatile__ ("nop");
 2c2:	00 00       	nop
    //now check each button and increment the count as needed
    previous_mode = mode;
 2c4:	e0 91 25 01 	lds	r30, 0x0125
 2c8:	f0 e0       	ldi	r31, 0x00	; 0
 2ca:	20 91 1d 01 	lds	r18, 0x011D
 2ce:	30 91 1e 01 	lds	r19, 0x011E
 2d2:	81 e0       	ldi	r24, 0x01	; 1
 2d4:	90 e0       	ldi	r25, 0x00	; 0
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 2d6:	a9 01       	movw	r20, r18
 2d8:	44 0f       	add	r20, r20
 2da:	55 1f       	adc	r21, r21
 2dc:	29 b3       	in	r18, 0x19	; 25
 2de:	30 e0       	ldi	r19, 0x00	; 0
 2e0:	bc 01       	movw	r22, r24
 2e2:	61 50       	subi	r22, 0x01	; 1
 2e4:	71 09       	sbc	r23, r1
 2e6:	02 c0       	rjmp	.+4      	; 0x2ec <button_routine+0x3c>
 2e8:	35 95       	asr	r19
 2ea:	27 95       	ror	r18
 2ec:	6a 95       	dec	r22
 2ee:	e2 f7       	brpl	.-8      	; 0x2e8 <button_routine+0x38>
 2f0:	20 fd       	sbrc	r18, 0
 2f2:	15 c0       	rjmp	.+42     	; 0x31e <button_routine+0x6e>
 2f4:	21 e0       	ldi	r18, 0x01	; 1
 2f6:	30 ee       	ldi	r19, 0xE0	; 224
 2f8:	24 2b       	or	r18, r20
 2fa:	35 2b       	or	r19, r21
 2fc:	30 93 1e 01 	sts	0x011E, r19
 300:	20 93 1d 01 	sts	0x011D, r18
    if (state == 0xF000){
 304:	21 15       	cp	r18, r1
 306:	40 ef       	ldi	r20, 0xF0	; 240
 308:	34 07       	cpc	r19, r20
 30a:	61 f0       	breq	.+24     	; 0x324 <button_routine+0x74>
 30c:	01 96       	adiw	r24, 0x01	; 1
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    previous_mode = mode;

    for (button = 0 ; button < BUTTON_COUNT ; button++){
 30e:	85 30       	cpi	r24, 0x05	; 5
 310:	91 05       	cpc	r25, r1
 312:	09 f7       	brne	.-62     	; 0x2d6 <button_routine+0x26>
	    else{
		mode = button+1;
	    }
	}
    }
    DDRA = 0xFF;  //switch PORTA to output
 314:	8f ef       	ldi	r24, 0xFF	; 255
 316:	8a bb       	out	0x1a, r24	; 26
    __asm__ __volatile__ ("nop"); //Buffer
 318:	00 00       	nop
    __asm__ __volatile__ ("nop"); //Buffer 
 31a:	00 00       	nop
 31c:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 31e:	20 e0       	ldi	r18, 0x00	; 0
 320:	30 ee       	ldi	r19, 0xE0	; 224
 322:	ea cf       	rjmp	.-44     	; 0x2f8 <button_routine+0x48>
    previous_mode = mode;

    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    if(previous_mode == button + 1 ){
 324:	8e 17       	cp	r24, r30
 326:	9f 07       	cpc	r25, r31
 328:	19 f0       	breq	.+6      	; 0x330 <button_routine+0x80>
		mode = 0;
		return;
	    }

	    else{
		mode = button+1;
 32a:	80 93 25 01 	sts	0x0125, r24
 32e:	ee cf       	rjmp	.-36     	; 0x30c <button_routine+0x5c>

    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    if(previous_mode == button + 1 ){
		mode = 0;
 330:	10 92 25 01 	sts	0x0125, r1
		return;
 334:	08 95       	ret

00000336 <__vector_12>:
	second++;    
    }

}

ISR(TIMER1_COMPA_vect){
 336:	1f 92       	push	r1
 338:	0f 92       	push	r0
 33a:	0f b6       	in	r0, 0x3f	; 63
 33c:	0f 92       	push	r0
 33e:	11 24       	eor	r1, r1



}
 340:	0f 90       	pop	r0
 342:	0f be       	out	0x3f, r0	; 63
 344:	0f 90       	pop	r0
 346:	1f 90       	pop	r1
 348:	18 95       	reti

0000034a <__vector_21>:
	default:
	    break;
    }
} 

ISR(ADC_vect){
 34a:	1f 92       	push	r1
 34c:	0f 92       	push	r0
 34e:	0f b6       	in	r0, 0x3f	; 63
 350:	0f 92       	push	r0
 352:	11 24       	eor	r1, r1
 354:	8f 93       	push	r24
 356:	9f 93       	push	r25

    if(ADCH < 100){
 358:	85 b1       	in	r24, 0x05	; 5
 35a:	84 36       	cpi	r24, 0x64	; 100
 35c:	48 f0       	brcs	.+18     	; 0x370 <__vector_21+0x26>
	OCR2 = 100-ADCH;
    }  
    else{
	OCR2 = 1;// brightness_level;
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	83 bd       	out	0x23, r24	; 35
    }
}
 362:	9f 91       	pop	r25
 364:	8f 91       	pop	r24
 366:	0f 90       	pop	r0
 368:	0f be       	out	0x3f, r0	; 63
 36a:	0f 90       	pop	r0
 36c:	1f 90       	pop	r1
 36e:	18 95       	reti
} 

ISR(ADC_vect){

    if(ADCH < 100){
	OCR2 = 100-ADCH;
 370:	95 b1       	in	r25, 0x05	; 5
 372:	84 e6       	ldi	r24, 0x64	; 100
 374:	89 1b       	sub	r24, r25
 376:	83 bd       	out	0x23, r24	; 35
    }  
    else{
	OCR2 = 1;// brightness_level;
    }
}
 378:	9f 91       	pop	r25
 37a:	8f 91       	pop	r24
 37c:	0f 90       	pop	r0
 37e:	0f be       	out	0x3f, r0	; 63
 380:	0f 90       	pop	r0
 382:	1f 90       	pop	r1
 384:	18 95       	reti

00000386 <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){

    if (second >= 60){
 386:	80 91 24 01 	lds	r24, 0x0124
 38a:	8c 33       	cpi	r24, 0x3C	; 60
 38c:	10 f5       	brcc	.+68     	; 0x3d2 <update_time+0x4c>
 38e:	80 91 23 01 	lds	r24, 0x0123
	minute++;
	second = 0;
    }             
    if(minute >=60){
	hour++;
 392:	20 91 22 01 	lds	r18, 0x0122

    if (second >= 60){
	minute++;
	second = 0;
    }             
    if(minute >=60){
 396:	8c 33       	cpi	r24, 0x3C	; 60
 398:	38 f5       	brcc	.+78     	; 0x3e8 <update_time+0x62>
 39a:	90 e0       	ldi	r25, 0x00	; 0
	hour++;
	minute = 0;
    }
    if(hour >= 24){
 39c:	28 31       	cpi	r18, 0x18	; 24
 39e:	68 f1       	brcs	.+90     	; 0x3fa <update_time+0x74>
	hour = 0;
 3a0:	10 92 22 01 	sts	0x0122, r1
 3a4:	20 e0       	ldi	r18, 0x00	; 0
 3a6:	30 e0       	ldi	r19, 0x00	; 0
      alarm_hour = 0;
      }*/    

    //update_number();
    //time = (minute * 100) + second;
    time = (hour * 100) + minute;
 3a8:	82 0f       	add	r24, r18
 3aa:	93 1f       	adc	r25, r19
 3ac:	90 93 14 01 	sts	0x0114, r25
 3b0:	80 93 13 01 	sts	0x0113, r24
    //time = 100;  
    alarm_time = (alarm_hour * 100) + alarm_minute;
 3b4:	20 91 20 01 	lds	r18, 0x0120
 3b8:	80 91 21 01 	lds	r24, 0x0121
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	34 e6       	ldi	r19, 0x64	; 100
 3c0:	23 9f       	mul	r18, r19
 3c2:	80 0d       	add	r24, r0
 3c4:	91 1d       	adc	r25, r1
 3c6:	11 24       	eor	r1, r1
 3c8:	90 93 12 01 	sts	0x0112, r25
 3cc:	80 93 11 01 	sts	0x0111, r24
 3d0:	08 95       	ret
  Initialize SPI 
 ****************************************************************************/
void update_time(void){

    if (second >= 60){
	minute++;
 3d2:	80 91 23 01 	lds	r24, 0x0123
 3d6:	8f 5f       	subi	r24, 0xFF	; 255
 3d8:	80 93 23 01 	sts	0x0123, r24
	second = 0;
 3dc:	10 92 24 01 	sts	0x0124, r1
    }             
    if(minute >=60){
	hour++;
 3e0:	20 91 22 01 	lds	r18, 0x0122

    if (second >= 60){
	minute++;
	second = 0;
    }             
    if(minute >=60){
 3e4:	8c 33       	cpi	r24, 0x3C	; 60
 3e6:	c8 f2       	brcs	.-78     	; 0x39a <update_time+0x14>
	hour++;
 3e8:	2f 5f       	subi	r18, 0xFF	; 255
 3ea:	20 93 22 01 	sts	0x0122, r18
	minute = 0;
 3ee:	10 92 23 01 	sts	0x0123, r1
 3f2:	80 e0       	ldi	r24, 0x00	; 0
 3f4:	90 e0       	ldi	r25, 0x00	; 0
    }
    if(hour >= 24){
 3f6:	28 31       	cpi	r18, 0x18	; 24
 3f8:	98 f6       	brcc	.-90     	; 0x3a0 <update_time+0x1a>
 3fa:	44 e6       	ldi	r20, 0x64	; 100
 3fc:	24 9f       	mul	r18, r20
 3fe:	90 01       	movw	r18, r0
 400:	11 24       	eor	r1, r1
 402:	d2 cf       	rjmp	.-92     	; 0x3a8 <update_time+0x22>

00000404 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
 404:	1f 92       	push	r1
 406:	0f 92       	push	r0
 408:	0f b6       	in	r0, 0x3f	; 63
 40a:	0f 92       	push	r0
 40c:	11 24       	eor	r1, r1
 40e:	0b b6       	in	r0, 0x3b	; 59
 410:	0f 92       	push	r0
 412:	2f 93       	push	r18
 414:	3f 93       	push	r19
 416:	4f 93       	push	r20
 418:	5f 93       	push	r21
 41a:	6f 93       	push	r22
 41c:	7f 93       	push	r23
 41e:	8f 93       	push	r24
 420:	9f 93       	push	r25
 422:	af 93       	push	r26
 424:	bf 93       	push	r27
 426:	cf 93       	push	r28
 428:	ef 93       	push	r30
 42a:	ff 93       	push	r31
    static uint8_t count = 0;
    count++;
 42c:	c0 91 1c 01 	lds	r28, 0x011C
 430:	cf 5f       	subi	r28, 0xFF	; 255
 432:	c0 93 1c 01 	sts	0x011C, r28
    update_time();
 436:	0e 94 c3 01 	call	0x386	; 0x386 <update_time>
    if((count%32) == 0){
 43a:	8c 2f       	mov	r24, r28
 43c:	8f 71       	andi	r24, 0x1F	; 31
 43e:	39 f4       	brne	.+14     	; 0x44e <__vector_16+0x4a>
	blink = !blink;
 440:	81 e0       	ldi	r24, 0x01	; 1
 442:	90 91 10 01 	lds	r25, 0x0110
 446:	91 11       	cpse	r25, r1
 448:	22 c0       	rjmp	.+68     	; 0x48e <__vector_16+0x8a>
 44a:	80 93 10 01 	sts	0x0110, r24
    }
    if((count%128)==0){
 44e:	cf 77       	andi	r28, 0x7F	; 127
 450:	51 f4       	brne	.+20     	; 0x466 <__vector_16+0x62>
	ticker++;     
 452:	80 91 1f 01 	lds	r24, 0x011F
 456:	8f 5f       	subi	r24, 0xFF	; 255
 458:	80 93 1f 01 	sts	0x011F, r24
	second++;    
 45c:	80 91 24 01 	lds	r24, 0x0124
 460:	8f 5f       	subi	r24, 0xFF	; 255
 462:	80 93 24 01 	sts	0x0124, r24
    }

}
 466:	ff 91       	pop	r31
 468:	ef 91       	pop	r30
 46a:	cf 91       	pop	r28
 46c:	bf 91       	pop	r27
 46e:	af 91       	pop	r26
 470:	9f 91       	pop	r25
 472:	8f 91       	pop	r24
 474:	7f 91       	pop	r23
 476:	6f 91       	pop	r22
 478:	5f 91       	pop	r21
 47a:	4f 91       	pop	r20
 47c:	3f 91       	pop	r19
 47e:	2f 91       	pop	r18
 480:	0f 90       	pop	r0
 482:	0b be       	out	0x3b, r0	; 59
 484:	0f 90       	pop	r0
 486:	0f be       	out	0x3f, r0	; 63
 488:	0f 90       	pop	r0
 48a:	1f 90       	pop	r1
 48c:	18 95       	reti
ISR(TIMER0_OVF_vect){
    static uint8_t count = 0;
    count++;
    update_time();
    if((count%32) == 0){
	blink = !blink;
 48e:	80 e0       	ldi	r24, 0x00	; 0
 490:	dc cf       	rjmp	.-72     	; 0x44a <__vector_16+0x46>

00000492 <SPI_init>:
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 492:	81 e5       	ldi	r24, 0x51	; 81
 494:	8d b9       	out	0x0d, r24	; 13
 496:	08 95       	ret

00000498 <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
 498:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 49a:	77 9b       	sbis	0x0e, 7	; 14
 49c:	fe cf       	rjmp	.-4      	; 0x49a <SPI_Transmit+0x2>
}
 49e:	08 95       	ret

000004a0 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
    PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
 4a0:	83 b1       	in	r24, 0x03	; 3
 4a2:	13 b8       	out	0x03, r1	; 3
    __asm__ __volatile__ ("nop");
 4a4:	00 00       	nop
    __asm__ __volatile__ ("nop");
 4a6:	00 00       	nop
    // Wait until 8 clock cycles are done 
    SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
 4a8:	1f b8       	out	0x0f, r1	; 15
    PORTE |= (1 << PE6);  
 4aa:	1e 9a       	sbi	0x03, 6	; 3
    __asm__ __volatile__ ("nop");
 4ac:	00 00       	nop
    __asm__ __volatile__ ("nop");
 4ae:	00 00       	nop
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
 4b0:	77 9b       	sbis	0x0e, 7	; 14
 4b2:	fe cf       	rjmp	.-4      	; 0x4b0 <SPI_Receive+0x10>
    // Return incoming data from SPDR
    return(SPDR);  
 4b4:	8f b1       	in	r24, 0x0f	; 15
}
 4b6:	08 95       	ret

000004b8 <bar_graph>:
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    if(mode == 0){
 4b8:	80 91 25 01 	lds	r24, 0x0125
 4bc:	88 23       	and	r24, r24
 4be:	99 f0       	breq	.+38     	; 0x4e6 <bar_graph+0x2e>
	write = 0x00;
    }
    else{
	write = 1<<(mode-1);
 4c0:	9f ef       	ldi	r25, 0xFF	; 255
 4c2:	98 0f       	add	r25, r24
 4c4:	81 e0       	ldi	r24, 0x01	; 1
 4c6:	01 c0       	rjmp	.+2      	; 0x4ca <bar_graph+0x12>
 4c8:	88 0f       	add	r24, r24
 4ca:	9a 95       	dec	r25
 4cc:	ea f7       	brpl	.-6      	; 0x4c8 <bar_graph+0x10>

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
 4ce:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 4d0:	77 9b       	sbis	0x0e, 7	; 14
 4d2:	fe cf       	rjmp	.-4      	; 0x4d0 <bar_graph+0x18>
    else{
	write = 1<<(mode-1);
    }
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
 4d4:	84 e0       	ldi	r24, 0x04	; 4
 4d6:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop"); //Buffer
 4d8:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 4da:	00 00       	nop


    PORTD = (2 << PD2);  // Push data out of SPI
 4dc:	88 e0       	ldi	r24, 0x08	; 8
 4de:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop");  //Buffer
 4e0:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 4e2:	00 00       	nop
 4e4:	08 95       	ret
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    if(mode == 0){
	write = 0x00;
 4e6:	80 e0       	ldi	r24, 0x00	; 0
 4e8:	f2 cf       	rjmp	.-28     	; 0x4ce <bar_graph+0x16>

000004ea <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    uint8_t display_segment = 0;
    static uint8_t rotate_7seg = 0;
    switch(mode){
 4ea:	80 91 25 01 	lds	r24, 0x0125
 4ee:	81 30       	cpi	r24, 0x01	; 1
 4f0:	79 f1       	breq	.+94     	; 0x550 <display_update+0x66>
 4f2:	70 f1       	brcs	.+92     	; 0x550 <display_update+0x66>
 4f4:	82 30       	cpi	r24, 0x02	; 2
 4f6:	29 f1       	breq	.+74     	; 0x542 <display_update+0x58>
 4f8:	83 30       	cpi	r24, 0x03	; 3
 4fa:	21 f4       	brne	.+8      	; 0x504 <display_update+0x1a>
	    break;
	case 2:
	    segsum(alarm_time);
	    break;
	case 3:
	    segsum(ADCH);
 4fc:	85 b1       	in	r24, 0x05	; 5
 4fe:	90 e0       	ldi	r25, 0x00	; 0
 500:	0e 94 b1 00 	call	0x162	; 0x162 <segsum>
       PORTA = segment_data[display_segment];
       _delay_us(30);
       PORTA = OFF;
       }
     */ 
    if(rotate_7seg > 4){
 504:	80 91 19 01 	lds	r24, 0x0119
 508:	85 30       	cpi	r24, 0x05	; 5
 50a:	10 f0       	brcs	.+4      	; 0x510 <display_update+0x26>
	rotate_7seg = 0;
 50c:	10 92 19 01 	sts	0x0119, r1
    }
    PORTB &= 0x8F;
 510:	88 b3       	in	r24, 0x18	; 24
 512:	8f 78       	andi	r24, 0x8F	; 143
 514:	88 bb       	out	0x18, r24	; 24
    PORTB |= rotate_7seg << 4;
 516:	28 b3       	in	r18, 0x18	; 24
 518:	80 91 19 01 	lds	r24, 0x0119
 51c:	30 e1       	ldi	r19, 0x10	; 16
 51e:	83 9f       	mul	r24, r19
 520:	c0 01       	movw	r24, r0
 522:	11 24       	eor	r1, r1
 524:	28 2b       	or	r18, r24
 526:	28 bb       	out	0x18, r18	; 24
    PORTA = segment_data[rotate_7seg];	
 528:	e0 91 19 01 	lds	r30, 0x0119
 52c:	f0 e0       	ldi	r31, 0x00	; 0
 52e:	ed 5c       	subi	r30, 0xCD	; 205
 530:	fe 4f       	sbci	r31, 0xFE	; 254
 532:	80 81       	ld	r24, Z
 534:	8b bb       	out	0x1b, r24	; 27
    rotate_7seg++;
 536:	80 91 19 01 	lds	r24, 0x0119
 53a:	8f 5f       	subi	r24, 0xFF	; 255
 53c:	80 93 19 01 	sts	0x0119, r24
 540:	08 95       	ret
	    break;
	case 1:
	    segsum(time);
	    break;
	case 2:
	    segsum(alarm_time);
 542:	80 91 11 01 	lds	r24, 0x0111
 546:	90 91 12 01 	lds	r25, 0x0112
 54a:	0e 94 b1 00 	call	0x162	; 0x162 <segsum>
	    break;
 54e:	da cf       	rjmp	.-76     	; 0x504 <display_update+0x1a>
    switch(mode){
	case 0:
	    segsum(time);
	    break;
	case 1:
	    segsum(time);
 550:	80 91 13 01 	lds	r24, 0x0113
 554:	90 91 14 01 	lds	r25, 0x0114
 558:	0e 94 b1 00 	call	0x162	; 0x162 <segsum>
	    break;
 55c:	d3 cf       	rjmp	.-90     	; 0x504 <display_update+0x1a>

0000055e <set_brightness>:
 - 1 == increase
 - 2 == decrease
 Brightness level goes from 1-10
 ***************************************************************************/
void set_brightness(int setting){
    if(setting == 1){
 55e:	81 30       	cpi	r24, 0x01	; 1
 560:	91 05       	cpc	r25, r1
 562:	69 f0       	breq	.+26     	; 0x57e <set_brightness+0x20>
	}
	else{
	    brightness_level++;
	}
    }
    else if(setting == 2){
 564:	02 97       	sbiw	r24, 0x02	; 2
 566:	09 f0       	breq	.+2      	; 0x56a <set_brightness+0xc>
 568:	08 95       	ret
	brightness_level--;
 56a:	80 91 32 01 	lds	r24, 0x0132
 56e:	81 50       	subi	r24, 0x01	; 1
 570:	80 93 32 01 	sts	0x0132, r24
	if(brightness_level >= 240){
 574:	80 3f       	cpi	r24, 0xF0	; 240
 576:	c0 f3       	brcs	.-16     	; 0x568 <set_brightness+0xa>
	    brightness_level = 0;
 578:	10 92 32 01 	sts	0x0132, r1
 57c:	08 95       	ret
 - 2 == decrease
 Brightness level goes from 1-10
 ***************************************************************************/
void set_brightness(int setting){
    if(setting == 1){
	if(brightness_level >= 9){
 57e:	80 91 32 01 	lds	r24, 0x0132
 582:	89 30       	cpi	r24, 0x09	; 9
 584:	20 f0       	brcs	.+8      	; 0x58e <set_brightness+0x30>
	    brightness_level = 9;
 586:	89 e0       	ldi	r24, 0x09	; 9
 588:	80 93 32 01 	sts	0x0132, r24
 58c:	08 95       	ret
	}
	else{
	    brightness_level++;
 58e:	8f 5f       	subi	r24, 0xFF	; 255
 590:	80 93 32 01 	sts	0x0132, r24
 594:	08 95       	ret

00000596 <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
    switch(mode){
 596:	80 91 25 01 	lds	r24, 0x0125
 59a:	81 30       	cpi	r24, 0x01	; 1
 59c:	59 f0       	breq	.+22     	; 0x5b4 <right_inc+0x1e>
 59e:	82 30       	cpi	r24, 0x02	; 2
 5a0:	41 f4       	brne	.+16     	; 0x5b2 <right_inc+0x1c>
		minute = 0;	    
	    }
	    second++;
	    break;
	case 2: 
	    alarm_minute++;
 5a2:	80 91 21 01 	lds	r24, 0x0121
 5a6:	8f 5f       	subi	r24, 0xFF	; 255
	    if(alarm_minute >= 60){
 5a8:	8c 33       	cpi	r24, 0x3C	; 60
 5aa:	88 f0       	brcs	.+34     	; 0x5ce <right_inc+0x38>
		alarm_minute = 0;	
 5ac:	10 92 21 01 	sts	0x0121, r1
 5b0:	08 95       	ret
 5b2:	08 95       	ret
void right_inc(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute++;
 5b4:	80 91 23 01 	lds	r24, 0x0123
 5b8:	8f 5f       	subi	r24, 0xFF	; 255
	    if(minute >= 60){
 5ba:	8c 33       	cpi	r24, 0x3C	; 60
 5bc:	58 f0       	brcs	.+22     	; 0x5d4 <right_inc+0x3e>
		minute = 0;	    
 5be:	10 92 23 01 	sts	0x0123, r1
	    }
	    second++;
 5c2:	80 91 24 01 	lds	r24, 0x0124
 5c6:	8f 5f       	subi	r24, 0xFF	; 255
 5c8:	80 93 24 01 	sts	0x0124, r24
	    break;
 5cc:	08 95       	ret
	case 2: 
	    alarm_minute++;
 5ce:	80 93 21 01 	sts	0x0121, r24
 5d2:	08 95       	ret
void right_inc(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute++;
 5d4:	80 93 23 01 	sts	0x0123, r24
	    if(minute >= 60){
		minute = 0;	    
	    }
	    second++;
 5d8:	80 91 24 01 	lds	r24, 0x0124
 5dc:	8f 5f       	subi	r24, 0xFF	; 255
 5de:	80 93 24 01 	sts	0x0124, r24
	    break;
 5e2:	08 95       	ret

000005e4 <right_dec>:
	default:
	    break;             
    }
}
void right_dec(){
    switch(mode){
 5e4:	80 91 25 01 	lds	r24, 0x0125
 5e8:	81 30       	cpi	r24, 0x01	; 1
 5ea:	71 f0       	breq	.+28     	; 0x608 <right_dec+0x24>
 5ec:	82 30       	cpi	r24, 0x02	; 2
 5ee:	59 f4       	brne	.+22     	; 0x606 <right_dec+0x22>
	    if(minute >= 240){
		minute = 59;	    
	    }   
	    break;
	case 2: 
	    alarm_minute--;
 5f0:	80 91 21 01 	lds	r24, 0x0121
 5f4:	81 50       	subi	r24, 0x01	; 1
 5f6:	80 93 21 01 	sts	0x0121, r24
	    if(alarm_minute >= 240){
 5fa:	80 3f       	cpi	r24, 0xF0	; 240
 5fc:	18 f0       	brcs	.+6      	; 0x604 <right_dec+0x20>
		alarm_minute = 59;	
 5fe:	8b e3       	ldi	r24, 0x3B	; 59
 600:	80 93 21 01 	sts	0x0121, r24
 604:	08 95       	ret
 606:	08 95       	ret
void right_dec(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    minute--;
 608:	80 91 23 01 	lds	r24, 0x0123
 60c:	81 50       	subi	r24, 0x01	; 1
 60e:	80 93 23 01 	sts	0x0123, r24
	    if(minute >= 240){
 612:	80 3f       	cpi	r24, 0xF0	; 240
 614:	b8 f3       	brcs	.-18     	; 0x604 <right_dec+0x20>
		minute = 59;	    
 616:	8b e3       	ldi	r24, 0x3B	; 59
 618:	80 93 23 01 	sts	0x0123, r24
 61c:	08 95       	ret

0000061e <decode_spi_right_knob>:
    previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
 61e:	cf 93       	push	r28
    uint8_t sw_index = 0;
    static uint8_t acount2 = 0;
    static uint8_t previous_encoder2 = 0;
    uint8_t direction = 0;
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
 620:	c8 2f       	mov	r28, r24
 622:	c3 70       	andi	r28, 0x03	; 3
    sw_index = (previous_encoder2 << 2) | encoder2;
 624:	e0 91 16 01 	lds	r30, 0x0116
 628:	ee 0f       	add	r30, r30
 62a:	ee 0f       	add	r30, r30
 62c:	ec 2b       	or	r30, r28
    direction = sw_table[sw_index];
 62e:	f0 e0       	ldi	r31, 0x00	; 0
 630:	e0 50       	subi	r30, 0x00	; 0
 632:	ff 4f       	sbci	r31, 0xFF	; 255
 634:	80 81       	ld	r24, Z
    //value = modeA;
    if(direction == CW){
 636:	81 30       	cpi	r24, 0x01	; 1
 638:	e9 f0       	breq	.+58     	; 0x674 <decode_spi_right_knob+0x56>
	acount2++;
    }	
    if(direction == CCW){
 63a:	82 30       	cpi	r24, 0x02	; 2
 63c:	31 f0       	breq	.+12     	; 0x64a <decode_spi_right_knob+0x2c>
	acount2--;
    }
    if(encoder2 == 3){
 63e:	c3 30       	cpi	r28, 0x03	; 3
 640:	59 f0       	breq	.+22     	; 0x658 <decode_spi_right_knob+0x3a>
	    right_dec();
	}
	//update_number();
	acount2 = 0;
    }
    previous_encoder2 = encoder2;
 642:	c0 93 16 01 	sts	0x0116, r28
}
 646:	cf 91       	pop	r28
 648:	08 95       	ret
    //value = modeA;
    if(direction == CW){
	acount2++;
    }	
    if(direction == CCW){
	acount2--;
 64a:	80 91 15 01 	lds	r24, 0x0115
 64e:	81 50       	subi	r24, 0x01	; 1
 650:	80 93 15 01 	sts	0x0115, r24
    }
    if(encoder2 == 3){
 654:	c3 30       	cpi	r28, 0x03	; 3
 656:	a9 f7       	brne	.-22     	; 0x642 <decode_spi_right_knob+0x24>
	if((acount2 > 1) && (acount2 < 10)){
 658:	80 91 15 01 	lds	r24, 0x0115
 65c:	9e ef       	ldi	r25, 0xFE	; 254
 65e:	98 0f       	add	r25, r24
 660:	98 30       	cpi	r25, 0x08	; 8
 662:	98 f0       	brcs	.+38     	; 0x68a <decode_spi_right_knob+0x6c>
	    right_inc();
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
 664:	81 3f       	cpi	r24, 0xF1	; 241
 666:	60 f4       	brcc	.+24     	; 0x680 <decode_spi_right_knob+0x62>
	    right_dec();
	}
	//update_number();
	acount2 = 0;
 668:	10 92 15 01 	sts	0x0115, r1
    }
    previous_encoder2 = encoder2;
 66c:	c0 93 16 01 	sts	0x0116, r28
}
 670:	cf 91       	pop	r28
 672:	08 95       	ret
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    sw_index = (previous_encoder2 << 2) | encoder2;
    direction = sw_table[sw_index];
    //value = modeA;
    if(direction == CW){
	acount2++;
 674:	80 91 15 01 	lds	r24, 0x0115
 678:	8f 5f       	subi	r24, 0xFF	; 255
 67a:	80 93 15 01 	sts	0x0115, r24
 67e:	df cf       	rjmp	.-66     	; 0x63e <decode_spi_right_knob+0x20>
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    right_inc();
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
	    right_dec();
 680:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <right_dec>
	}
	//update_number();
	acount2 = 0;
 684:	10 92 15 01 	sts	0x0115, r1
 688:	f1 cf       	rjmp	.-30     	; 0x66c <decode_spi_right_knob+0x4e>
    if(direction == CCW){
	acount2--;
    }
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    right_inc();
 68a:	0e 94 cb 02 	call	0x596	; 0x596 <right_inc>
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
	    right_dec();
	}
	//update_number();
	acount2 = 0;
 68e:	10 92 15 01 	sts	0x0115, r1
 692:	ec cf       	rjmp	.-40     	; 0x66c <decode_spi_right_knob+0x4e>

00000694 <left_inc>:
	    break;
    }

}
void left_inc(){
    switch(mode){
 694:	80 91 25 01 	lds	r24, 0x0125
 698:	81 30       	cpi	r24, 0x01	; 1
 69a:	69 f0       	breq	.+26     	; 0x6b6 <left_inc+0x22>
 69c:	82 30       	cpi	r24, 0x02	; 2
 69e:	51 f4       	brne	.+20     	; 0x6b4 <left_inc+0x20>
	    if(hour >= 24){
		hour = 0;	    
	    }   
	    break;
	case 2: 
	    alarm_hour++;
 6a0:	80 91 20 01 	lds	r24, 0x0120
 6a4:	8f 5f       	subi	r24, 0xFF	; 255
 6a6:	80 93 20 01 	sts	0x0120, r24
	    if(alarm_hour >= 24){
 6aa:	88 31       	cpi	r24, 0x18	; 24
 6ac:	10 f0       	brcs	.+4      	; 0x6b2 <left_inc+0x1e>
		alarm_hour = 0;
 6ae:	10 92 20 01 	sts	0x0120, r1
 6b2:	08 95       	ret
 6b4:	08 95       	ret
void left_inc(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    hour++;
 6b6:	80 91 22 01 	lds	r24, 0x0122
 6ba:	8f 5f       	subi	r24, 0xFF	; 255
 6bc:	80 93 22 01 	sts	0x0122, r24
	    if(hour >= 24){
 6c0:	88 31       	cpi	r24, 0x18	; 24
 6c2:	b8 f3       	brcs	.-18     	; 0x6b2 <left_inc+0x1e>
		hour = 0;	    
 6c4:	10 92 22 01 	sts	0x0122, r1
 6c8:	08 95       	ret

000006ca <left_dec>:
	default:
	    break;
    }
}
void left_dec(){
    switch(mode){
 6ca:	80 91 25 01 	lds	r24, 0x0125
 6ce:	81 30       	cpi	r24, 0x01	; 1
 6d0:	71 f0       	breq	.+28     	; 0x6ee <left_dec+0x24>
 6d2:	82 30       	cpi	r24, 0x02	; 2
 6d4:	59 f4       	brne	.+22     	; 0x6ec <left_dec+0x22>
	    if(hour >= 240){
		hour = 23;	    
	    }   
	    break;
	case 2:
	    alarm_hour--;
 6d6:	80 91 20 01 	lds	r24, 0x0120
 6da:	81 50       	subi	r24, 0x01	; 1
 6dc:	80 93 20 01 	sts	0x0120, r24
	    if(alarm_hour >= 240){
 6e0:	80 3f       	cpi	r24, 0xF0	; 240
 6e2:	18 f0       	brcs	.+6      	; 0x6ea <left_dec+0x20>
		alarm_hour = 23;
 6e4:	87 e1       	ldi	r24, 0x17	; 23
 6e6:	80 93 20 01 	sts	0x0120, r24
 6ea:	08 95       	ret
 6ec:	08 95       	ret
void left_dec(){
    switch(mode){
	case 0: 
	    break;
	case 1:
	    hour--;    
 6ee:	80 91 22 01 	lds	r24, 0x0122
 6f2:	81 50       	subi	r24, 0x01	; 1
 6f4:	80 93 22 01 	sts	0x0122, r24
	    if(hour >= 240){
 6f8:	80 3f       	cpi	r24, 0xF0	; 240
 6fa:	b8 f3       	brcs	.-18     	; 0x6ea <left_dec+0x20>
		hour = 23;	    
 6fc:	87 e1       	ldi	r24, 0x17	; 23
 6fe:	80 93 22 01 	sts	0x0122, r24
 702:	08 95       	ret

00000704 <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
 704:	cf 93       	push	r28
 706:	df 93       	push	r29
    uint8_t sw_index = 0;
    //Counter for preventing unneccessary reset    
    static uint8_t acount1 = 0;
    static uint8_t previous_encoder1 = 0; //Initialize previous    
    uint8_t direction = 0;                    //Direction variable
    encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
 708:	8c 70       	andi	r24, 0x0C	; 12
 70a:	c8 2f       	mov	r28, r24
 70c:	d0 e0       	ldi	r29, 0x00	; 0
 70e:	d5 95       	asr	r29
 710:	c7 95       	ror	r28
 712:	d5 95       	asr	r29
 714:	c7 95       	ror	r28
 716:	9c 2f       	mov	r25, r28
    sw_index = (previous_encoder1 << 2) | encoder1; 
 718:	e0 91 18 01 	lds	r30, 0x0118
 71c:	ee 0f       	add	r30, r30
 71e:	ee 0f       	add	r30, r30
 720:	ec 2b       	or	r30, r28
    /*shift previous to the left use it as an index Since
      we know the pattern of the knob when it is turning
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
 722:	f0 e0       	ldi	r31, 0x00	; 0
 724:	e0 50       	subi	r30, 0x00	; 0
 726:	ff 4f       	sbci	r31, 0xFF	; 255
 728:	80 81       	ld	r24, Z
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
 72a:	81 30       	cpi	r24, 0x01	; 1
 72c:	f9 f0       	breq	.+62     	; 0x76c <decode_spi_left_knob+0x68>
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
 72e:	82 30       	cpi	r24, 0x02	; 2
 730:	39 f0       	breq	.+14     	; 0x740 <decode_spi_left_knob+0x3c>
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 732:	93 30       	cpi	r25, 0x03	; 3
 734:	61 f0       	breq	.+24     	; 0x74e <decode_spi_left_knob+0x4a>
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
    }
    previous_encoder1 = encoder1;
 736:	c0 93 18 01 	sts	0x0118, r28
}
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	08 95       	ret
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
 740:	80 91 17 01 	lds	r24, 0x0117
 744:	81 50       	subi	r24, 0x01	; 1
 746:	80 93 17 01 	sts	0x0117, r24
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 74a:	93 30       	cpi	r25, 0x03	; 3
 74c:	a1 f7       	brne	.-24     	; 0x736 <decode_spi_left_knob+0x32>
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
 74e:	80 91 17 01 	lds	r24, 0x0117
 752:	9e ef       	ldi	r25, 0xFE	; 254
 754:	98 0f       	add	r25, r24
 756:	98 30       	cpi	r25, 0x08	; 8
 758:	a0 f0       	brcs	.+40     	; 0x782 <decode_spi_left_knob+0x7e>
	    left_inc();
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
 75a:	81 3f       	cpi	r24, 0xF1	; 241
 75c:	68 f4       	brcc	.+26     	; 0x778 <decode_spi_left_knob+0x74>
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
 75e:	10 92 17 01 	sts	0x0117, r1
    }
    previous_encoder1 = encoder1;
 762:	c0 93 18 01 	sts	0x0118, r28
}
 766:	df 91       	pop	r29
 768:	cf 91       	pop	r28
 76a:	08 95       	ret
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
    //Read out the direction from table
    if(direction == CW){  //If CW, add counter
	acount1++;
 76c:	80 91 17 01 	lds	r24, 0x0117
 770:	8f 5f       	subi	r24, 0xFF	; 255
 772:	80 93 17 01 	sts	0x0117, r24
 776:	dd cf       	rjmp	.-70     	; 0x732 <decode_spi_left_knob+0x2e>
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    left_inc();
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
 778:	0e 94 65 03 	call	0x6ca	; 0x6ca <left_dec>
	}
	acount1 = 0;                     //Reset counter
 77c:	10 92 17 01 	sts	0x0117, r1
 780:	f0 cf       	rjmp	.-32     	; 0x762 <decode_spi_left_knob+0x5e>
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    left_inc();
 782:	0e 94 4a 03 	call	0x694	; 0x694 <left_inc>
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
	    left_dec();
	}
	acount1 = 0;                     //Reset counter
 786:	10 92 17 01 	sts	0x0117, r1
 78a:	eb cf       	rjmp	.-42     	; 0x762 <decode_spi_left_knob+0x5e>

0000078c <check_knobs>:
    __asm__ __volatile__ ("nop");
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    // Return incoming data from SPDR
    return(SPDR);  
}
void check_knobs(void){
 78c:	cf 93       	push	r28
 78e:	df 93       	push	r29
    static uint8_t encoder;
    //TIFR |= (1<<TOV2);
    encoder = SPI_Receive();
 790:	0e 94 50 02 	call	0x4a0	; 0x4a0 <SPI_Receive>
 794:	80 93 1a 01 	sts	0x011A, r24
    decode_spi_left_knob(encoder);
 798:	c8 2f       	mov	r28, r24
 79a:	d0 e0       	ldi	r29, 0x00	; 0
 79c:	ce 01       	movw	r24, r28
 79e:	0e 94 82 03 	call	0x704	; 0x704 <decode_spi_left_knob>
    decode_spi_right_knob(encoder);
 7a2:	ce 01       	movw	r24, r28
}
 7a4:	df 91       	pop	r29
 7a6:	cf 91       	pop	r28
void check_knobs(void){
    static uint8_t encoder;
    //TIFR |= (1<<TOV2);
    encoder = SPI_Receive();
    decode_spi_left_knob(encoder);
    decode_spi_right_knob(encoder);
 7a8:	0c 94 0f 03 	jmp	0x61e	; 0x61e <decode_spi_right_knob>

000007ac <__vector_10>:



}

ISR(TIMER2_OVF_vect){
 7ac:	1f 92       	push	r1
 7ae:	0f 92       	push	r0
 7b0:	0f b6       	in	r0, 0x3f	; 63
 7b2:	0f 92       	push	r0
 7b4:	11 24       	eor	r1, r1
 7b6:	0b b6       	in	r0, 0x3b	; 59
 7b8:	0f 92       	push	r0
 7ba:	2f 93       	push	r18
 7bc:	3f 93       	push	r19
 7be:	4f 93       	push	r20
 7c0:	5f 93       	push	r21
 7c2:	6f 93       	push	r22
 7c4:	7f 93       	push	r23
 7c6:	8f 93       	push	r24
 7c8:	9f 93       	push	r25
 7ca:	af 93       	push	r26
 7cc:	bf 93       	push	r27
 7ce:	cf 93       	push	r28
 7d0:	ef 93       	push	r30
 7d2:	ff 93       	push	r31
    static uint8_t count = 0;
    count++;
 7d4:	c0 91 1b 01 	lds	r28, 0x011B
 7d8:	cf 5f       	subi	r28, 0xFF	; 255
 7da:	c0 93 1b 01 	sts	0x011B, r28
    if(count%32 == 0){
 7de:	8c 2f       	mov	r24, r28
 7e0:	8f 71       	andi	r24, 0x1F	; 31
 7e2:	d9 f0       	breq	.+54     	; 0x81a <__vector_10+0x6e>
	button_routine();
	bar_graph();
    }
    switch(count%2){
 7e4:	c0 ff       	sbrs	r28, 0
 7e6:	16 c0       	rjmp	.+44     	; 0x814 <__vector_10+0x68>
	case 0:
	    check_knobs();
	    break;
	case 1:	
	    display_update();
 7e8:	0e 94 75 02 	call	0x4ea	; 0x4ea <display_update>
	    break;
	default:
	    break;
    }
} 
 7ec:	ff 91       	pop	r31
 7ee:	ef 91       	pop	r30
 7f0:	cf 91       	pop	r28
 7f2:	bf 91       	pop	r27
 7f4:	af 91       	pop	r26
 7f6:	9f 91       	pop	r25
 7f8:	8f 91       	pop	r24
 7fa:	7f 91       	pop	r23
 7fc:	6f 91       	pop	r22
 7fe:	5f 91       	pop	r21
 800:	4f 91       	pop	r20
 802:	3f 91       	pop	r19
 804:	2f 91       	pop	r18
 806:	0f 90       	pop	r0
 808:	0b be       	out	0x3b, r0	; 59
 80a:	0f 90       	pop	r0
 80c:	0f be       	out	0x3f, r0	; 63
 80e:	0f 90       	pop	r0
 810:	1f 90       	pop	r1
 812:	18 95       	reti
	button_routine();
	bar_graph();
    }
    switch(count%2){
	case 0:
	    check_knobs();
 814:	0e 94 c6 03 	call	0x78c	; 0x78c <check_knobs>
	    break;
 818:	e9 cf       	rjmp	.-46     	; 0x7ec <__vector_10+0x40>

ISR(TIMER2_OVF_vect){
    static uint8_t count = 0;
    count++;
    if(count%32 == 0){
	button_routine();
 81a:	0e 94 58 01 	call	0x2b0	; 0x2b0 <button_routine>
	bar_graph();
 81e:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <bar_graph>
 822:	e0 cf       	rjmp	.-64     	; 0x7e4 <__vector_10+0x38>

00000824 <cleanup_alarm>:
    }
}

void cleanup_alarm(){

    if(alarm_minute >= 60){
 824:	80 91 21 01 	lds	r24, 0x0121
 828:	8c 33       	cpi	r24, 0x3C	; 60
 82a:	10 f0       	brcs	.+4      	; 0x830 <cleanup_alarm+0xc>
	alarm_minute = 0;	
 82c:	10 92 21 01 	sts	0x0121, r1

    if(alarm_minute >= 240){
	alarm_minute = 59;	
    }

    if(alarm_hour >= 24){
 830:	80 91 20 01 	lds	r24, 0x0120
 834:	88 31       	cpi	r24, 0x18	; 24
 836:	10 f0       	brcs	.+4      	; 0x83c <cleanup_alarm+0x18>
	alarm_hour = 0;
 838:	10 92 20 01 	sts	0x0120, r1
 83c:	08 95       	ret

0000083e <cleanup>:
	alarm_hour = 23;
    }
}

void cleanup(){
    if(hour >= 240){
 83e:	80 91 22 01 	lds	r24, 0x0122
 842:	80 3f       	cpi	r24, 0xF0	; 240
 844:	50 f0       	brcs	.+20     	; 0x85a <cleanup+0x1c>
	hour = 23;	    
 846:	87 e1       	ldi	r24, 0x17	; 23
 848:	80 93 22 01 	sts	0x0122, r24
    }
    if(hour >= 24){
	hour = 0;	    
    }
    if(minute >= 60){
 84c:	80 91 23 01 	lds	r24, 0x0123
 850:	8c 33       	cpi	r24, 0x3C	; 60
 852:	10 f0       	brcs	.+4      	; 0x858 <cleanup+0x1a>
	minute = 0;
 854:	10 92 23 01 	sts	0x0123, r1
 858:	08 95       	ret

void cleanup(){
    if(hour >= 240){
	hour = 23;	    
    }
    if(hour >= 24){
 85a:	88 31       	cpi	r24, 0x18	; 24
 85c:	b8 f3       	brcs	.-18     	; 0x84c <cleanup+0xe>
	hour = 0;	    
 85e:	10 92 22 01 	sts	0x0122, r1
 862:	f4 cf       	rjmp	.-24     	; 0x84c <cleanup+0xe>

00000864 <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
    TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
 864:	83 b7       	in	r24, 0x33	; 51
 866:	81 60       	ori	r24, 0x01	; 1
 868:	83 bf       	out	0x33, r24	; 51
    ASSR  |= (1<<AS0);
 86a:	80 b7       	in	r24, 0x30	; 48
 86c:	88 60       	ori	r24, 0x08	; 8
 86e:	80 bf       	out	0x30, r24	; 48
    TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
 870:	85 b5       	in	r24, 0x25	; 37
 872:	8a 67       	ori	r24, 0x7A	; 122
 874:	85 bd       	out	0x25, r24	; 37
    TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
 876:	87 b7       	in	r24, 0x37	; 55
 878:	81 64       	ori	r24, 0x41	; 65
 87a:	87 bf       	out	0x37, r24	; 55
 87c:	08 95       	ret

0000087e <ADC_init>:

}


void ADC_init(void){
    DDRF |= !(1<<PF0);
 87e:	e1 e6       	ldi	r30, 0x61	; 97
 880:	f0 e0       	ldi	r31, 0x00	; 0
 882:	80 81       	ld	r24, Z
 884:	80 83       	st	Z, r24
    PORTF = 0x00;
 886:	10 92 62 00 	sts	0x0062, r1
    ADMUX  |= (1<<ADLAR) | (1<<REFS0);
 88a:	87 b1       	in	r24, 0x07	; 7
 88c:	80 66       	ori	r24, 0x60	; 96
 88e:	87 b9       	out	0x07, r24	; 7
    ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
 890:	86 b1       	in	r24, 0x06	; 6
 892:	8f 6e       	ori	r24, 0xEF	; 239
 894:	86 b9       	out	0x06, r24	; 6
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);

    OCR2 = 0xFF;
 896:	8f ef       	ldi	r24, 0xFF	; 255
 898:	83 bd       	out	0x23, r24	; 35
 89a:	08 95       	ret

0000089c <audio_on>:
}

void audio_on(){
	TCCR1B |= (1<<CS11)|(1<CS10);
 89c:	8e b5       	in	r24, 0x2e	; 46
 89e:	82 60       	ori	r24, 0x02	; 2
 8a0:	8e bd       	out	0x2e, r24	; 46
 8a2:	08 95       	ret

000008a4 <audio_off>:
}
void audio_off(){
	TCCR1B &= ~((1<<CS11) | (1<<CS10)); 
 8a4:	8e b5       	in	r24, 0x2e	; 46
 8a6:	8c 7f       	andi	r24, 0xFC	; 252
 8a8:	8e bd       	out	0x2e, r24	; 46
 8aa:	08 95       	ret

000008ac <audio_init>:
}

void audio_init(){
	DDRC |= (1<<PC7);
 8ac:	a7 9a       	sbi	0x14, 7	; 20
	TIMSK |= (1<<OCIE1A);
 8ae:	87 b7       	in	r24, 0x37	; 55
 8b0:	80 61       	ori	r24, 0x10	; 16
 8b2:	87 bf       	out	0x37, r24	; 55
	TCCR1B = (1<<WGM12);
 8b4:	88 e0       	ldi	r24, 0x08	; 8
 8b6:	8e bd       	out	0x2e, r24	; 46
	OCR1A = 0xFFFF;
 8b8:	8f ef       	ldi	r24, 0xFF	; 255
 8ba:	9f ef       	ldi	r25, 0xFF	; 255
 8bc:	9b bd       	out	0x2b, r25	; 43
 8be:	8a bd       	out	0x2a, r24	; 42
 8c0:	08 95       	ret

000008c2 <main>:

int main()
{
    //set port bits 4-7 B as outputs
    uint8_t c = 0;
    DDRE = 0xc0;
 8c2:	80 ec       	ldi	r24, 0xC0	; 192
 8c4:	82 b9       	out	0x02, r24	; 2
    PORTE &= 0x7F;
 8c6:	1f 98       	cbi	0x03, 7	; 3
    DDRB = 0xF7;
 8c8:	87 ef       	ldi	r24, 0xF7	; 247
 8ca:	87 bb       	out	0x17, r24	; 23
    DDRD |= (1 << PB2);
 8cc:	8a 9a       	sbi	0x11, 2	; 17
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 8ce:	81 e5       	ldi	r24, 0x51	; 81
 8d0:	8d b9       	out	0x0d, r24	; 13
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
    TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
 8d2:	83 b7       	in	r24, 0x33	; 51
 8d4:	81 60       	ori	r24, 0x01	; 1
 8d6:	83 bf       	out	0x33, r24	; 51
    ASSR  |= (1<<AS0);
 8d8:	80 b7       	in	r24, 0x30	; 48
 8da:	88 60       	ori	r24, 0x08	; 8
 8dc:	80 bf       	out	0x30, r24	; 48
    TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
 8de:	85 b5       	in	r24, 0x25	; 37
 8e0:	8a 67       	ori	r24, 0x7A	; 122
 8e2:	85 bd       	out	0x25, r24	; 37
    TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
 8e4:	87 b7       	in	r24, 0x37	; 55
 8e6:	81 64       	ori	r24, 0x41	; 65
 8e8:	87 bf       	out	0x37, r24	; 55

}


void ADC_init(void){
    DDRF |= !(1<<PF0);
 8ea:	80 91 61 00 	lds	r24, 0x0061
 8ee:	80 93 61 00 	sts	0x0061, r24
    PORTF = 0x00;
 8f2:	10 92 62 00 	sts	0x0062, r1
    ADMUX  |= (1<<ADLAR) | (1<<REFS0);
 8f6:	87 b1       	in	r24, 0x07	; 7
 8f8:	80 66       	ori	r24, 0x60	; 96
 8fa:	87 b9       	out	0x07, r24	; 7
    ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
 8fc:	86 b1       	in	r24, 0x06	; 6
 8fe:	8f 6e       	ori	r24, 0xEF	; 239
 900:	86 b9       	out	0x06, r24	; 6
	      |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);

    OCR2 = 0xFF;
 902:	8f ef       	ldi	r24, 0xFF	; 255
 904:	83 bd       	out	0x23, r24	; 35

    SPI_init();
    timer_init();
    ADC_init();
    //music_init();   
    sei();
 906:	78 94       	sei
    while(1){
	//display_update();
	bar_graph();
 908:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <bar_graph>
 90c:	fd cf       	rjmp	.-6      	; 0x908 <main+0x46>

0000090e <__umulhisi3>:
 90e:	a2 9f       	mul	r26, r18
 910:	b0 01       	movw	r22, r0
 912:	b3 9f       	mul	r27, r19
 914:	c0 01       	movw	r24, r0
 916:	a3 9f       	mul	r26, r19
 918:	70 0d       	add	r23, r0
 91a:	81 1d       	adc	r24, r1
 91c:	11 24       	eor	r1, r1
 91e:	91 1d       	adc	r25, r1
 920:	b2 9f       	mul	r27, r18
 922:	70 0d       	add	r23, r0
 924:	81 1d       	adc	r24, r1
 926:	11 24       	eor	r1, r1
 928:	91 1d       	adc	r25, r1
 92a:	08 95       	ret

0000092c <_exit>:
 92c:	f8 94       	cli

0000092e <__stop_program>:
 92e:	ff cf       	rjmp	.-2      	; 0x92e <__stop_program>
