
lab4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  000006fc  00000790  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000024  00800112  00800112  000007a2  2**0
                  ALLOC
  3 .stab         00001284  00000000  00000000  000007a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ee7  00000000  00000000  00001a28  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000290f  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 02 03 	jmp	0x604	; 0x604 <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ec ef       	ldi	r30, 0xFC	; 252
  a0:	f6 e0       	ldi	r31, 0x06	; 6
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 31       	cpi	r26, 0x12	; 18
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a2 e1       	ldi	r26, 0x12	; 18
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a6 33       	cpi	r26, 0x36	; 54
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 4e 03 	call	0x69c	; 0x69c <main>
  c6:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <chk_buttons>:



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
  ce:	20 91 21 01 	lds	r18, 0x0121
  d2:	30 91 22 01 	lds	r19, 0x0122
  d6:	22 0f       	add	r18, r18
  d8:	33 1f       	adc	r19, r19
  da:	49 b3       	in	r20, 0x19	; 25
  dc:	50 e0       	ldi	r21, 0x00	; 0
  de:	02 c0       	rjmp	.+4      	; 0xe4 <chk_buttons+0x16>
  e0:	55 95       	asr	r21
  e2:	47 95       	ror	r20
  e4:	8a 95       	dec	r24
  e6:	e2 f7       	brpl	.-8      	; 0xe0 <chk_buttons+0x12>
  e8:	40 fd       	sbrc	r20, 0
  ea:	0e c0       	rjmp	.+28     	; 0x108 <chk_buttons+0x3a>
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	90 ee       	ldi	r25, 0xE0	; 224
  f0:	28 2b       	or	r18, r24
  f2:	39 2b       	or	r19, r25
  f4:	30 93 22 01 	sts	0x0122, r19
  f8:	20 93 21 01 	sts	0x0121, r18
    if (state == 0xF000){
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	21 15       	cp	r18, r1
 100:	30 4f       	sbci	r19, 0xF0	; 240
 102:	09 f0       	breq	.+2      	; 0x106 <chk_buttons+0x38>
 104:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
    }
    return 0;

}
 106:	08 95       	ret



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	90 ee       	ldi	r25, 0xE0	; 224
 10c:	f1 cf       	rjmp	.-30     	; 0xf0 <chk_buttons+0x22>

0000010e <int2seg>:
}
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
 10e:	81 11       	cpse	r24, r1
 110:	02 c0       	rjmp	.+4      	; 0x116 <int2seg+0x8>
	return ZERO;
 112:	80 ec       	ldi	r24, 0xC0	; 192
 114:	08 95       	ret
    }
    else if(number == 1 ){
 116:	81 30       	cpi	r24, 0x01	; 1
 118:	91 f0       	breq	.+36     	; 0x13e <int2seg+0x30>
	return ONE;
    }
    else if(number == 2 ){
 11a:	82 30       	cpi	r24, 0x02	; 2
 11c:	91 f0       	breq	.+36     	; 0x142 <int2seg+0x34>
	return TWO;
    }
    else if(number == 3 ){
 11e:	83 30       	cpi	r24, 0x03	; 3
 120:	a1 f0       	breq	.+40     	; 0x14a <int2seg+0x3c>
	return THREE;
    }
    else if(number == 4 ){
 122:	84 30       	cpi	r24, 0x04	; 4
 124:	81 f0       	breq	.+32     	; 0x146 <int2seg+0x38>
	return FOUR;
    }
    else if(number == 5 ){
 126:	85 30       	cpi	r24, 0x05	; 5
 128:	91 f0       	breq	.+36     	; 0x14e <int2seg+0x40>
	return FIVE;
    }
    else if(number == 6 ){
 12a:	86 30       	cpi	r24, 0x06	; 6
 12c:	91 f0       	breq	.+36     	; 0x152 <int2seg+0x44>
	return  SIX;
    }
    else if(number == 7 ){
 12e:	87 30       	cpi	r24, 0x07	; 7
 130:	91 f0       	breq	.+36     	; 0x156 <int2seg+0x48>
	return SEVEN;
    }
    else if(number == 8 ){
 132:	88 30       	cpi	r24, 0x08	; 8
 134:	91 f0       	breq	.+36     	; 0x15a <int2seg+0x4c>
	return EIGHT;
    }
    else if(number == 9 ){
 136:	89 30       	cpi	r24, 0x09	; 9
 138:	91 f0       	breq	.+36     	; 0x15e <int2seg+0x50>
	return NINE;
    }
    else{ 
	return 0;
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	08 95       	ret
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
	return ZERO;
    }
    else if(number == 1 ){
	return ONE;
 13e:	89 ef       	ldi	r24, 0xF9	; 249
 140:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
 142:	84 ea       	ldi	r24, 0xA4	; 164
 144:	08 95       	ret
    }
    else if(number == 3 ){
	return THREE;
    }
    else if(number == 4 ){
	return FOUR;
 146:	89 e9       	ldi	r24, 0x99	; 153
 148:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
    }
    else if(number == 3 ){
	return THREE;
 14a:	80 eb       	ldi	r24, 0xB0	; 176
 14c:	08 95       	ret
    }
    else if(number == 4 ){
	return FOUR;
    }
    else if(number == 5 ){
	return FIVE;
 14e:	82 e9       	ldi	r24, 0x92	; 146
 150:	08 95       	ret
    }
    else if(number == 6 ){
	return  SIX;
 152:	82 e8       	ldi	r24, 0x82	; 130
 154:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
 156:	88 ef       	ldi	r24, 0xF8	; 248
	return NINE;
    }
    else{ 
	return 0;
    }
}
 158:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
    }
    else if(number == 8 ){
	return EIGHT;
 15a:	80 e8       	ldi	r24, 0x80	; 128
 15c:	08 95       	ret
    }
    else if(number == 9 ){
	return NINE;
 15e:	80 e9       	ldi	r24, 0x90	; 144
 160:	08 95       	ret

00000162 <segsum>:
//                                   segment_sum                                    
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|

void segsum(uint16_t sum) {
 162:	0f 93       	push	r16
 164:	1f 93       	push	r17
 166:	cf 93       	push	r28
 168:	df 93       	push	r29
 16a:	ec 01       	movw	r28, r24
    }
    else if (sum <10){
	digit = 1;
    }
    //break up decimal sum into 4 digit-segments
    segment_data[0] = int2seg(sum % 10); //ones
 16c:	9c 01       	movw	r18, r24
 16e:	ad ec       	ldi	r26, 0xCD	; 205
 170:	bc ec       	ldi	r27, 0xCC	; 204
 172:	0e 94 6d 03 	call	0x6da	; 0x6da <__umulhisi3>
 176:	96 95       	lsr	r25
 178:	87 95       	ror	r24
 17a:	96 95       	lsr	r25
 17c:	87 95       	ror	r24
 17e:	96 95       	lsr	r25
 180:	87 95       	ror	r24
 182:	3c 2f       	mov	r19, r28
 184:	2a e0       	ldi	r18, 0x0A	; 10
 186:	82 9f       	mul	r24, r18
 188:	30 19       	sub	r19, r0
 18a:	11 24       	eor	r1, r1
 18c:	83 2f       	mov	r24, r19
 18e:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 192:	80 93 31 01 	sts	0x0131, r24
    segment_data[1] = int2seg((sum % 100)/10); //tens
 196:	9e 01       	movw	r18, r28
 198:	36 95       	lsr	r19
 19a:	27 95       	ror	r18
 19c:	36 95       	lsr	r19
 19e:	27 95       	ror	r18
 1a0:	ab e7       	ldi	r26, 0x7B	; 123
 1a2:	b4 e1       	ldi	r27, 0x14	; 20
 1a4:	0e 94 6d 03 	call	0x6da	; 0x6da <__umulhisi3>
 1a8:	96 95       	lsr	r25
 1aa:	87 95       	ror	r24
 1ac:	44 e6       	ldi	r20, 0x64	; 100
 1ae:	48 9f       	mul	r20, r24
 1b0:	90 01       	movw	r18, r0
 1b2:	49 9f       	mul	r20, r25
 1b4:	30 0d       	add	r19, r0
 1b6:	11 24       	eor	r1, r1
 1b8:	ce 01       	movw	r24, r28
 1ba:	82 1b       	sub	r24, r18
 1bc:	93 0b       	sbc	r25, r19
 1be:	9c 01       	movw	r18, r24
 1c0:	ad ec       	ldi	r26, 0xCD	; 205
 1c2:	bc ec       	ldi	r27, 0xCC	; 204
 1c4:	0e 94 6d 03 	call	0x6da	; 0x6da <__umulhisi3>
 1c8:	96 95       	lsr	r25
 1ca:	87 95       	ror	r24
 1cc:	96 95       	lsr	r25
 1ce:	87 95       	ror	r24
 1d0:	96 95       	lsr	r25
 1d2:	87 95       	ror	r24
 1d4:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 1d8:	80 93 32 01 	sts	0x0132, r24
    //segment_data[2] = 1; //decimal
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
 1dc:	8e 01       	movw	r16, r28
 1de:	16 95       	lsr	r17
 1e0:	07 95       	ror	r16
 1e2:	16 95       	lsr	r17
 1e4:	07 95       	ror	r16
 1e6:	16 95       	lsr	r17
 1e8:	07 95       	ror	r16
 1ea:	98 01       	movw	r18, r16
 1ec:	a5 ec       	ldi	r26, 0xC5	; 197
 1ee:	b0 e2       	ldi	r27, 0x20	; 32
 1f0:	0e 94 6d 03 	call	0x6da	; 0x6da <__umulhisi3>
 1f4:	92 95       	swap	r25
 1f6:	82 95       	swap	r24
 1f8:	8f 70       	andi	r24, 0x0F	; 15
 1fa:	89 27       	eor	r24, r25
 1fc:	9f 70       	andi	r25, 0x0F	; 15
 1fe:	89 27       	eor	r24, r25
 200:	48 ee       	ldi	r20, 0xE8	; 232
 202:	53 e0       	ldi	r21, 0x03	; 3
 204:	84 9f       	mul	r24, r20
 206:	90 01       	movw	r18, r0
 208:	85 9f       	mul	r24, r21
 20a:	30 0d       	add	r19, r0
 20c:	94 9f       	mul	r25, r20
 20e:	30 0d       	add	r19, r0
 210:	11 24       	eor	r1, r1
 212:	ce 01       	movw	r24, r28
 214:	82 1b       	sub	r24, r18
 216:	93 0b       	sbc	r25, r19
 218:	9c 01       	movw	r18, r24
 21a:	36 95       	lsr	r19
 21c:	27 95       	ror	r18
 21e:	36 95       	lsr	r19
 220:	27 95       	ror	r18
 222:	ab e7       	ldi	r26, 0x7B	; 123
 224:	b4 e1       	ldi	r27, 0x14	; 20
 226:	0e 94 6d 03 	call	0x6da	; 0x6da <__umulhisi3>
 22a:	96 95       	lsr	r25
 22c:	87 95       	ror	r24
 22e:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 232:	80 93 34 01 	sts	0x0134, r24
    segment_data[4] = int2seg(sum/1000); //thousands
 236:	98 01       	movw	r18, r16
 238:	a5 ec       	ldi	r26, 0xC5	; 197
 23a:	b0 e2       	ldi	r27, 0x20	; 32
 23c:	0e 94 6d 03 	call	0x6da	; 0x6da <__umulhisi3>
 240:	92 95       	swap	r25
 242:	82 95       	swap	r24
 244:	8f 70       	andi	r24, 0x0F	; 15
 246:	89 27       	eor	r24, r25
 248:	9f 70       	andi	r25, 0x0F	; 15
 24a:	89 27       	eor	r24, r25
 24c:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 250:	80 93 35 01 	sts	0x0135, r24
    //blank out leading zero digits 
//now move data to right place for misplaced colon position
}//segment_sum
 254:	df 91       	pop	r29
 256:	cf 91       	pop	r28
 258:	1f 91       	pop	r17
 25a:	0f 91       	pop	r16
 25c:	08 95       	ret

0000025e <button_routine>:
//***********************************************************************************
void button_routine(){
    uint8_t button;
    DDRA  = 0x00; // PORTA input mode
 25e:	1a ba       	out	0x1a, r1	; 26
    PORTA = 0xFF; //Pull ups
 260:	8f ef       	ldi	r24, 0xFF	; 255
 262:	8b bb       	out	0x1b, r24	; 27
    __asm__ __volatile__ ("nop");
 264:	00 00       	nop
    __asm__ __volatile__ ("nop");
 266:	00 00       	nop
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
 268:	88 b3       	in	r24, 0x18	; 24
 26a:	80 67       	ori	r24, 0x70	; 112
 26c:	88 bb       	out	0x18, r24	; 24
    __asm__ __volatile__ ("nop");
 26e:	00 00       	nop
    __asm__ __volatile__ ("nop");
 270:	00 00       	nop
 272:	20 91 21 01 	lds	r18, 0x0121
 276:	30 91 22 01 	lds	r19, 0x0122
 27a:	80 e0       	ldi	r24, 0x00	; 0
 27c:	90 e0       	ldi	r25, 0x00	; 0
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
	    }
	    else {               //both off add 1
		dif = 1;
 27e:	61 e0       	ldi	r22, 0x01	; 1
		// value = 4;
		dif =  2;
	    }
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
 280:	e4 e0       	ldi	r30, 0x04	; 4
		dif = 0;
	    }
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
 282:	72 e0       	ldi	r23, 0x02	; 2



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 284:	a9 01       	movw	r20, r18
 286:	44 0f       	add	r20, r20
 288:	55 1f       	adc	r21, r21
 28a:	29 b3       	in	r18, 0x19	; 25
 28c:	30 e0       	ldi	r19, 0x00	; 0
 28e:	08 2e       	mov	r0, r24
 290:	02 c0       	rjmp	.+4      	; 0x296 <button_routine+0x38>
 292:	35 95       	asr	r19
 294:	27 95       	ror	r18
 296:	0a 94       	dec	r0
 298:	e2 f7       	brpl	.-8      	; 0x292 <button_routine+0x34>
 29a:	20 fd       	sbrc	r18, 0
 29c:	11 c0       	rjmp	.+34     	; 0x2c0 <button_routine+0x62>
 29e:	21 e0       	ldi	r18, 0x01	; 1
 2a0:	30 ee       	ldi	r19, 0xE0	; 224
 2a2:	24 2b       	or	r18, r20
 2a4:	35 2b       	or	r19, r21
 2a6:	30 93 22 01 	sts	0x0122, r19
 2aa:	20 93 21 01 	sts	0x0121, r18
    if (state == 0xF000){
 2ae:	21 15       	cp	r18, r1
 2b0:	40 ef       	ldi	r20, 0xF0	; 240
 2b2:	34 07       	cpc	r19, r20
 2b4:	41 f0       	breq	.+16     	; 0x2c6 <button_routine+0x68>
 2b6:	01 96       	adiw	r24, 0x01	; 1
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
 2b8:	83 30       	cpi	r24, 0x03	; 3
 2ba:	91 05       	cpc	r25, r1
 2bc:	19 f7       	brne	.-58     	; 0x284 <button_routine+0x26>
 2be:	08 95       	ret



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 2c0:	20 e0       	ldi	r18, 0x00	; 0
 2c2:	30 ee       	ldi	r19, 0xE0	; 224
 2c4:	ee cf       	rjmp	.-36     	; 0x2a2 <button_routine+0x44>
 2c6:	48 2f       	mov	r20, r24
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    if(button == 0){
 2c8:	88 23       	and	r24, r24
 2ca:	09 f1       	breq	.+66     	; 0x30e <button_routine+0xb0>
		modeA = !modeA;   //Inverse everytime button0 is pressed
		//value = 1;
	    }
	    else if( button == 1){  //Inverse everytime button1 is pressed  
 2cc:	41 30       	cpi	r20, 0x01	; 1
 2ce:	c1 f0       	breq	.+48     	; 0x300 <button_routine+0xa2>
		modeB = !modeB;
		//value = 2;
	    } 
	    //value = value + 100;
	    if (modeA && modeB){    //If both modes are on, add 0
 2d0:	40 91 24 01 	lds	r20, 0x0124
 2d4:	41 11       	cpse	r20, r1
 2d6:	07 c0       	rjmp	.+14     	; 0x2e6 <button_routine+0x88>
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
	    }
	    else if (modeB && !modeA){ //1-off 2-on add 4
 2d8:	40 91 23 01 	lds	r20, 0x0123
 2dc:	44 23       	and	r20, r20
 2de:	69 f0       	breq	.+26     	; 0x2fa <button_routine+0x9c>
		//value = modeB;
		dif =  4;
 2e0:	e0 93 00 01 	sts	0x0100, r30
 2e4:	e8 cf       	rjmp	.-48     	; 0x2b6 <button_routine+0x58>
	    else if( button == 1){  //Inverse everytime button1 is pressed  
		modeB = !modeB;
		//value = 2;
	    } 
	    //value = value + 100;
	    if (modeA && modeB){    //If both modes are on, add 0
 2e6:	40 91 23 01 	lds	r20, 0x0123
 2ea:	44 23       	and	r20, r20
 2ec:	19 f0       	breq	.+6      	; 0x2f4 <button_routine+0x96>
		//value = 4;
		dif = 0;
 2ee:	10 92 00 01 	sts	0x0100, r1
 2f2:	e1 cf       	rjmp	.-62     	; 0x2b6 <button_routine+0x58>
	    }
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
 2f4:	70 93 00 01 	sts	0x0100, r23
 2f8:	de cf       	rjmp	.-68     	; 0x2b6 <button_routine+0x58>
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
	    }
	    else {               //both off add 1
		dif = 1;
 2fa:	60 93 00 01 	sts	0x0100, r22
 2fe:	db cf       	rjmp	.-74     	; 0x2b6 <button_routine+0x58>
	    if(button == 0){
		modeA = !modeA;   //Inverse everytime button0 is pressed
		//value = 1;
	    }
	    else if( button == 1){  //Inverse everytime button1 is pressed  
		modeB = !modeB;
 300:	50 91 23 01 	lds	r21, 0x0123
 304:	51 11       	cpse	r21, r1
 306:	40 e0       	ldi	r20, 0x00	; 0
 308:	40 93 23 01 	sts	0x0123, r20
 30c:	e1 cf       	rjmp	.-62     	; 0x2d0 <button_routine+0x72>
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    if(button == 0){
		modeA = !modeA;   //Inverse everytime button0 is pressed
 30e:	41 e0       	ldi	r20, 0x01	; 1
 310:	50 91 24 01 	lds	r21, 0x0124
 314:	51 11       	cpse	r21, r1
 316:	40 e0       	ldi	r20, 0x00	; 0
 318:	40 93 24 01 	sts	0x0124, r20
 31c:	d9 cf       	rjmp	.-78     	; 0x2d0 <button_routine+0x72>

0000031e <update_time>:
void update_time(void){
    static uint32_t counter = 0;
    static uint8_t second = 0;
    static uint8_t minute = 0;
    static uint8_t hour = 0;
    counter++;
 31e:	80 91 1d 01 	lds	r24, 0x011D
 322:	90 91 1e 01 	lds	r25, 0x011E
 326:	a0 91 1f 01 	lds	r26, 0x011F
 32a:	b0 91 20 01 	lds	r27, 0x0120
 32e:	01 96       	adiw	r24, 0x01	; 1
 330:	a1 1d       	adc	r26, r1
 332:	b1 1d       	adc	r27, r1
 334:	80 93 1d 01 	sts	0x011D, r24
 338:	90 93 1e 01 	sts	0x011E, r25
 33c:	a0 93 1f 01 	sts	0x011F, r26
 340:	b0 93 20 01 	sts	0x0120, r27
    //value++;
    //value = counter;

    if(counter >= SECOND_MULTIPLIER){
 344:	8f 3c       	cpi	r24, 0xCF	; 207
 346:	97 40       	sbci	r25, 0x07	; 7
 348:	a1 05       	cpc	r26, r1
 34a:	b1 05       	cpc	r27, r1
 34c:	a8 f5       	brcc	.+106    	; 0x3b8 <update_time+0x9a>
 34e:	20 91 1c 01 	lds	r18, 0x011C
	second++;
	counter = 0;
    }
    if (second >= 60){
	minute++;
 352:	90 91 1b 01 	lds	r25, 0x011B

    if(counter >= SECOND_MULTIPLIER){
	second++;
	counter = 0;
    }
    if (second >= 60){
 356:	2c 33       	cpi	r18, 0x3C	; 60
 358:	30 f5       	brcc	.+76     	; 0x3a6 <update_time+0x88>
 35a:	42 2f       	mov	r20, r18
 35c:	41 70       	andi	r20, 0x01	; 1
 35e:	30 e0       	ldi	r19, 0x00	; 0
	minute++;
	second = 0;
    }             
    if(minute >=60){
 360:	9c 33       	cpi	r25, 0x3C	; 60
 362:	b0 f4       	brcc	.+44     	; 0x390 <update_time+0x72>
 364:	50 91 1a 01 	lds	r21, 0x011A
 368:	64 e6       	ldi	r22, 0x64	; 100
 36a:	96 9f       	mul	r25, r22
 36c:	c0 01       	movw	r24, r0
 36e:	11 24       	eor	r1, r1
	hour++;
	minute = 0;
    }
    if(hour >= 24){
 370:	58 31       	cpi	r21, 0x18	; 24
 372:	10 f0       	brcs	.+4      	; 0x378 <update_time+0x5a>
	hour = 0;
 374:	10 92 1a 01 	sts	0x011A, r1
    }    
    if(second%2 == 1){
 378:	41 11       	cpse	r20, r1
 37a:	2c c0       	rjmp	.+88     	; 0x3d4 <update_time+0xb6>
	segment_data[2] = 0xFC;
    }
    else{
	segment_data[2] = 0xFF;
 37c:	4f ef       	ldi	r20, 0xFF	; 255
 37e:	40 93 33 01 	sts	0x0133, r20
    }  
    value = (minute * 100) + second;
 382:	82 0f       	add	r24, r18
 384:	93 1f       	adc	r25, r19
 386:	90 93 14 01 	sts	0x0114, r25
 38a:	80 93 13 01 	sts	0x0113, r24
 38e:	08 95       	ret
    if (second >= 60){
	minute++;
	second = 0;
    }             
    if(minute >=60){
	hour++;
 390:	80 91 1a 01 	lds	r24, 0x011A
 394:	8f 5f       	subi	r24, 0xFF	; 255
 396:	80 93 1a 01 	sts	0x011A, r24
	minute = 0;
 39a:	10 92 1b 01 	sts	0x011B, r1
 39e:	58 2f       	mov	r21, r24
 3a0:	80 e0       	ldi	r24, 0x00	; 0
 3a2:	90 e0       	ldi	r25, 0x00	; 0
 3a4:	e5 cf       	rjmp	.-54     	; 0x370 <update_time+0x52>
    if(counter >= SECOND_MULTIPLIER){
	second++;
	counter = 0;
    }
    if (second >= 60){
	minute++;
 3a6:	9f 5f       	subi	r25, 0xFF	; 255
 3a8:	90 93 1b 01 	sts	0x011B, r25
	second = 0;
 3ac:	10 92 1c 01 	sts	0x011C, r1
 3b0:	20 e0       	ldi	r18, 0x00	; 0
 3b2:	30 e0       	ldi	r19, 0x00	; 0
 3b4:	40 e0       	ldi	r20, 0x00	; 0
 3b6:	d4 cf       	rjmp	.-88     	; 0x360 <update_time+0x42>
    counter++;
    //value++;
    //value = counter;

    if(counter >= SECOND_MULTIPLIER){
	second++;
 3b8:	20 91 1c 01 	lds	r18, 0x011C
 3bc:	2f 5f       	subi	r18, 0xFF	; 255
 3be:	20 93 1c 01 	sts	0x011C, r18
	counter = 0;
 3c2:	10 92 1d 01 	sts	0x011D, r1
 3c6:	10 92 1e 01 	sts	0x011E, r1
 3ca:	10 92 1f 01 	sts	0x011F, r1
 3ce:	10 92 20 01 	sts	0x0120, r1
 3d2:	bf cf       	rjmp	.-130    	; 0x352 <update_time+0x34>
    }
    if(hour >= 24){
	hour = 0;
    }    
    if(second%2 == 1){
	segment_data[2] = 0xFC;
 3d4:	4c ef       	ldi	r20, 0xFC	; 252
 3d6:	40 93 33 01 	sts	0x0133, r20
    }
    else{
	segment_data[2] = 0xFF;
    }  
    value = (minute * 100) + second;
 3da:	82 0f       	add	r24, r18
 3dc:	93 1f       	adc	r25, r19
 3de:	90 93 14 01 	sts	0x0114, r25
 3e2:	80 93 13 01 	sts	0x0113, r24
 3e6:	08 95       	ret

000003e8 <SPI_init>:
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 3e8:	81 e5       	ldi	r24, 0x51	; 81
 3ea:	8d b9       	out	0x0d, r24	; 13
 3ec:	08 95       	ret

000003ee <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
 3ee:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 3f0:	77 9b       	sbis	0x0e, 7	; 14
 3f2:	fe cf       	rjmp	.-4      	; 0x3f0 <SPI_Transmit+0x2>
}
 3f4:	08 95       	ret

000003f6 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
    PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
 3f6:	83 b1       	in	r24, 0x03	; 3
 3f8:	13 b8       	out	0x03, r1	; 3
    __asm__ __volatile__ ("nop");
 3fa:	00 00       	nop
    __asm__ __volatile__ ("nop");
 3fc:	00 00       	nop
    // Wait until 8 clock cycles are done 
    SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
 3fe:	1f b8       	out	0x0f, r1	; 15
    PORTE |= (1 << PE6);  
 400:	1e 9a       	sbi	0x03, 6	; 3
    __asm__ __volatile__ ("nop");
 402:	00 00       	nop
    __asm__ __volatile__ ("nop");
 404:	00 00       	nop
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
 406:	77 9b       	sbis	0x0e, 7	; 14
 408:	fe cf       	rjmp	.-4      	; 0x406 <SPI_Receive+0x10>
    // Return incoming data from SPDR
    return(SPDR);  
 40a:	8f b1       	in	r24, 0x0f	; 15
}
 40c:	08 95       	ret

0000040e <bar_graph>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
 40e:	8f ef       	ldi	r24, 0xFF	; 255
 410:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 412:	77 9b       	sbis	0x0e, 7	; 14
 414:	fe cf       	rjmp	.-4      	; 0x412 <bar_graph+0x4>
    }

    write = 0xFF;
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
 416:	84 e0       	ldi	r24, 0x04	; 4
 418:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop"); //Buffer
 41a:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 41c:	00 00       	nop


    PORTD = (2 << PD2);  // Push data out of SPI
 41e:	88 e0       	ldi	r24, 0x08	; 8
 420:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop");  //Buffer
 422:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 424:	00 00       	nop
 426:	08 95       	ret

00000428 <display_update>:
    }
    previous_encoder2 = encoder2;
}

void update_number(void){
    if (value > (0-MAX_SUM)){
 428:	20 91 13 01 	lds	r18, 0x0113
 42c:	30 91 14 01 	lds	r19, 0x0114
 430:	22 30       	cpi	r18, 0x02	; 2
 432:	8c ef       	ldi	r24, 0xFC	; 252
 434:	38 07       	cpc	r19, r24
 436:	b0 f1       	brcs	.+108    	; 0x4a4 <display_update+0x7c>
	value = MAX_SUM - (dif-1);                       	
 438:	80 91 00 01 	lds	r24, 0x0100
 43c:	20 e0       	ldi	r18, 0x00	; 0
 43e:	34 e0       	ldi	r19, 0x04	; 4
 440:	28 1b       	sub	r18, r24
 442:	31 09       	sbc	r19, r1
 444:	30 93 14 01 	sts	0x0114, r19
 448:	20 93 13 01 	sts	0x0113, r18
 44c:	c9 01       	movw	r24, r18
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    update_number();
    segsum(value);
 44e:	0e 94 b1 00 	call	0x162	; 0x162 <segsum>
    if(rotate_7seg > 4){
 452:	80 91 12 01 	lds	r24, 0x0112
 456:	85 30       	cpi	r24, 0x05	; 5
 458:	10 f0       	brcs	.+4      	; 0x45e <display_update+0x36>
	rotate_7seg = 0;
 45a:	10 92 12 01 	sts	0x0112, r1
    }
    DDRA = 0xFF;  //switch PORTA to output
 45e:	8f ef       	ldi	r24, 0xFF	; 255
 460:	8a bb       	out	0x1a, r24	; 26
    __asm__ __volatile__ ("nop"); //Buffer
 462:	00 00       	nop
    __asm__ __volatile__ ("nop"); //Buffer 
 464:	00 00       	nop
    PORTB &= 0x8F;
 466:	88 b3       	in	r24, 0x18	; 24
 468:	8f 78       	andi	r24, 0x8F	; 143
 46a:	88 bb       	out	0x18, r24	; 24
    PORTB |= rotate_7seg << 4;
 46c:	28 b3       	in	r18, 0x18	; 24
 46e:	80 91 12 01 	lds	r24, 0x0112
 472:	30 e1       	ldi	r19, 0x10	; 16
 474:	83 9f       	mul	r24, r19
 476:	c0 01       	movw	r24, r0
 478:	11 24       	eor	r1, r1
 47a:	28 2b       	or	r18, r24
 47c:	28 bb       	out	0x18, r18	; 24
    PORTA = segment_data[rotate_7seg];	
 47e:	e0 91 12 01 	lds	r30, 0x0112
 482:	f0 e0       	ldi	r31, 0x00	; 0
 484:	ef 5c       	subi	r30, 0xCF	; 207
 486:	fe 4f       	sbci	r31, 0xFE	; 254
 488:	80 81       	ld	r24, Z
 48a:	8b bb       	out	0x1b, r24	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 48c:	8f e8       	ldi	r24, 0x8F	; 143
 48e:	91 e0       	ldi	r25, 0x01	; 1
 490:	01 97       	sbiw	r24, 0x01	; 1
 492:	f1 f7       	brne	.-4      	; 0x490 <display_update+0x68>
 494:	00 c0       	rjmp	.+0      	; 0x496 <display_update+0x6e>
 496:	00 00       	nop
    _delay_us(100);
    rotate_7seg++;
 498:	80 91 12 01 	lds	r24, 0x0112
 49c:	8f 5f       	subi	r24, 0xFF	; 255
 49e:	80 93 12 01 	sts	0x0112, r24
 4a2:	08 95       	ret

void update_number(void){
    if (value > (0-MAX_SUM)){
	value = MAX_SUM - (dif-1);                       	
    }
    else if (value > MAX_SUM){
 4a4:	21 15       	cp	r18, r1
 4a6:	94 e0       	ldi	r25, 0x04	; 4
 4a8:	39 07       	cpc	r19, r25
 4aa:	40 f0       	brcs	.+16     	; 0x4bc <display_update+0x94>
	value = value - MAX_SUM;
 4ac:	2f 5f       	subi	r18, 0xFF	; 255
 4ae:	33 40       	sbci	r19, 0x03	; 3
 4b0:	30 93 14 01 	sts	0x0114, r19
 4b4:	20 93 13 01 	sts	0x0113, r18
 4b8:	c9 01       	movw	r24, r18
 4ba:	c9 cf       	rjmp	.-110    	; 0x44e <display_update+0x26>

void update_number(void){
    if (value > (0-MAX_SUM)){
	value = MAX_SUM - (dif-1);                       	
    }
    else if (value > MAX_SUM){
 4bc:	c9 01       	movw	r24, r18
 4be:	c7 cf       	rjmp	.-114    	; 0x44e <display_update+0x26>

000004c0 <decode_spi_left_knob>:
    uint8_t sw_index = 0;
    //Counter for preventing unneccessary reset    
    static uint8_t acount1 = 0;
    static uint8_t previous_encoder1 = 0; //Initialize previous    
    uint8_t direction = 0;                    //Direction variable
    encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
 4c0:	8c 70       	andi	r24, 0x0C	; 12
 4c2:	90 e0       	ldi	r25, 0x00	; 0
 4c4:	95 95       	asr	r25
 4c6:	87 95       	ror	r24
 4c8:	95 95       	asr	r25
 4ca:	87 95       	ror	r24
 4cc:	38 2f       	mov	r19, r24
    sw_index = (previous_encoder1 << 2) | encoder1; 
 4ce:	e0 91 18 01 	lds	r30, 0x0118
 4d2:	ee 0f       	add	r30, r30
 4d4:	ee 0f       	add	r30, r30
 4d6:	e8 2b       	or	r30, r24
    /*shift previous to the left use it as an index Since
      we know the pattern of the knob when it is turning
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
 4d8:	f0 e0       	ldi	r31, 0x00	; 0
 4da:	ef 5f       	subi	r30, 0xFF	; 255
 4dc:	fe 4f       	sbci	r31, 0xFE	; 254
 4de:	20 81       	ld	r18, Z
    //Read out the direction from table
    //value = acount2;
    if(direction == CW){  //If CW, add counter
 4e0:	21 30       	cpi	r18, 0x01	; 1
 4e2:	39 f1       	breq	.+78     	; 0x532 <decode_spi_left_knob+0x72>
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
 4e4:	22 30       	cpi	r18, 0x02	; 2
 4e6:	29 f0       	breq	.+10     	; 0x4f2 <decode_spi_left_knob+0x32>
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 4e8:	33 30       	cpi	r19, 0x03	; 3
 4ea:	51 f0       	breq	.+20     	; 0x500 <decode_spi_left_knob+0x40>
	    value = value - dif;
	}
	//update_number();                 //Check number in the routine
	acount1 = 0;                     //Reset counter
    }
    previous_encoder1 = encoder1;
 4ec:	80 93 18 01 	sts	0x0118, r24
 4f0:	08 95       	ret
    //value = acount2;
    if(direction == CW){  //If CW, add counter
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
 4f2:	20 91 17 01 	lds	r18, 0x0117
 4f6:	21 50       	subi	r18, 0x01	; 1
 4f8:	20 93 17 01 	sts	0x0117, r18
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 4fc:	33 30       	cpi	r19, 0x03	; 3
 4fe:	b1 f7       	brne	.-20     	; 0x4ec <decode_spi_left_knob+0x2c>
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
 500:	20 91 17 01 	lds	r18, 0x0117
 504:	3e ef       	ldi	r19, 0xFE	; 254
 506:	32 0f       	add	r19, r18
 508:	38 30       	cpi	r19, 0x08	; 8
 50a:	c8 f0       	brcs	.+50     	; 0x53e <decode_spi_left_knob+0x7e>
	    value = value + dif;
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
 50c:	21 3f       	cpi	r18, 0xF1	; 241
 50e:	60 f0       	brcs	.+24     	; 0x528 <decode_spi_left_knob+0x68>
	    value = value - dif;
 510:	40 91 00 01 	lds	r20, 0x0100
 514:	20 91 13 01 	lds	r18, 0x0113
 518:	30 91 14 01 	lds	r19, 0x0114
 51c:	24 1b       	sub	r18, r20
 51e:	31 09       	sbc	r19, r1
 520:	30 93 14 01 	sts	0x0114, r19
 524:	20 93 13 01 	sts	0x0113, r18
	}
	//update_number();                 //Check number in the routine
	acount1 = 0;                     //Reset counter
 528:	10 92 17 01 	sts	0x0117, r1
    }
    previous_encoder1 = encoder1;
 52c:	80 93 18 01 	sts	0x0118, r24
 530:	08 95       	ret
      Which way it is turning*/
    direction = sw_table[sw_index];
    //Read out the direction from table
    //value = acount2;
    if(direction == CW){  //If CW, add counter
	acount1++;
 532:	20 91 17 01 	lds	r18, 0x0117
 536:	2f 5f       	subi	r18, 0xFF	; 255
 538:	20 93 17 01 	sts	0x0117, r18
 53c:	d5 cf       	rjmp	.-86     	; 0x4e8 <decode_spi_left_knob+0x28>
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    value = value + dif;
 53e:	40 91 00 01 	lds	r20, 0x0100
 542:	20 91 13 01 	lds	r18, 0x0113
 546:	30 91 14 01 	lds	r19, 0x0114
 54a:	24 0f       	add	r18, r20
 54c:	31 1d       	adc	r19, r1
 54e:	30 93 14 01 	sts	0x0114, r19
 552:	20 93 13 01 	sts	0x0113, r18
 556:	e8 cf       	rjmp	.-48     	; 0x528 <decode_spi_left_knob+0x68>

00000558 <decode_spi_right_knob>:
void decode_spi_right_knob(uint8_t encoder2){
    uint8_t sw_index = 0;
    static uint8_t acount2 = 0;
    static uint8_t previous_encoder2 = 0;
    uint8_t direction = 0;
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
 558:	83 70       	andi	r24, 0x03	; 3
    sw_index = (previous_encoder2 << 2) | encoder2;
 55a:	e0 91 16 01 	lds	r30, 0x0116
 55e:	ee 0f       	add	r30, r30
 560:	ee 0f       	add	r30, r30
 562:	e8 2b       	or	r30, r24
    direction = sw_table[sw_index];
 564:	f0 e0       	ldi	r31, 0x00	; 0
 566:	ef 5f       	subi	r30, 0xFF	; 255
 568:	fe 4f       	sbci	r31, 0xFE	; 254
 56a:	90 81       	ld	r25, Z
    //value = modeA;
    if(direction == CW){
 56c:	91 30       	cpi	r25, 0x01	; 1
 56e:	39 f1       	breq	.+78     	; 0x5be <decode_spi_right_knob+0x66>
	acount2++;
    }	
    if(direction == CCW){
 570:	92 30       	cpi	r25, 0x02	; 2
 572:	29 f0       	breq	.+10     	; 0x57e <decode_spi_right_knob+0x26>
	acount2--;
    }
    if(encoder2 == 3){
 574:	83 30       	cpi	r24, 0x03	; 3
 576:	51 f0       	breq	.+20     	; 0x58c <decode_spi_right_knob+0x34>
	    value = value - dif;
	}
	//update_number();
	acount2 = 0;
    }
    previous_encoder2 = encoder2;
 578:	80 93 16 01 	sts	0x0116, r24
 57c:	08 95       	ret
    //value = modeA;
    if(direction == CW){
	acount2++;
    }	
    if(direction == CCW){
	acount2--;
 57e:	90 91 15 01 	lds	r25, 0x0115
 582:	91 50       	subi	r25, 0x01	; 1
 584:	90 93 15 01 	sts	0x0115, r25
    }
    if(encoder2 == 3){
 588:	83 30       	cpi	r24, 0x03	; 3
 58a:	b1 f7       	brne	.-20     	; 0x578 <decode_spi_right_knob+0x20>
	if((acount2 > 1) && (acount2 < 10)){
 58c:	90 91 15 01 	lds	r25, 0x0115
 590:	2e ef       	ldi	r18, 0xFE	; 254
 592:	29 0f       	add	r18, r25
 594:	28 30       	cpi	r18, 0x08	; 8
 596:	c8 f0       	brcs	.+50     	; 0x5ca <decode_spi_right_knob+0x72>
	    value = value + dif;
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
 598:	91 3f       	cpi	r25, 0xF1	; 241
 59a:	60 f0       	brcs	.+24     	; 0x5b4 <decode_spi_right_knob+0x5c>
	    value = value - dif;
 59c:	90 91 00 01 	lds	r25, 0x0100
 5a0:	20 91 13 01 	lds	r18, 0x0113
 5a4:	30 91 14 01 	lds	r19, 0x0114
 5a8:	29 1b       	sub	r18, r25
 5aa:	31 09       	sbc	r19, r1
 5ac:	30 93 14 01 	sts	0x0114, r19
 5b0:	20 93 13 01 	sts	0x0113, r18
	}
	//update_number();
	acount2 = 0;
 5b4:	10 92 15 01 	sts	0x0115, r1
    }
    previous_encoder2 = encoder2;
 5b8:	80 93 16 01 	sts	0x0116, r24
 5bc:	08 95       	ret
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    sw_index = (previous_encoder2 << 2) | encoder2;
    direction = sw_table[sw_index];
    //value = modeA;
    if(direction == CW){
	acount2++;
 5be:	90 91 15 01 	lds	r25, 0x0115
 5c2:	9f 5f       	subi	r25, 0xFF	; 255
 5c4:	90 93 15 01 	sts	0x0115, r25
 5c8:	d5 cf       	rjmp	.-86     	; 0x574 <decode_spi_right_knob+0x1c>
    if(direction == CCW){
	acount2--;
    }
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    value = value + dif;
 5ca:	90 91 00 01 	lds	r25, 0x0100
 5ce:	20 91 13 01 	lds	r18, 0x0113
 5d2:	30 91 14 01 	lds	r19, 0x0114
 5d6:	29 0f       	add	r18, r25
 5d8:	31 1d       	adc	r19, r1
 5da:	30 93 14 01 	sts	0x0114, r19
 5de:	20 93 13 01 	sts	0x0113, r18
 5e2:	e8 cf       	rjmp	.-48     	; 0x5b4 <decode_spi_right_knob+0x5c>

000005e4 <check_knobs>:
    __asm__ __volatile__ ("nop");
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    // Return incoming data from SPDR
    return(SPDR);  
}
void check_knobs(void){
 5e4:	cf 93       	push	r28
 5e6:	df 93       	push	r29
    static uint8_t encoder;
    encoder  = SPI_Receive();
 5e8:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <SPI_Receive>
 5ec:	80 93 19 01 	sts	0x0119, r24
    decode_spi_left_knob(encoder);
 5f0:	c8 2f       	mov	r28, r24
 5f2:	d0 e0       	ldi	r29, 0x00	; 0
 5f4:	ce 01       	movw	r24, r28
 5f6:	0e 94 60 02 	call	0x4c0	; 0x4c0 <decode_spi_left_knob>
    decode_spi_right_knob(encoder);
 5fa:	ce 01       	movw	r24, r28
}
 5fc:	df 91       	pop	r29
 5fe:	cf 91       	pop	r28
}
void check_knobs(void){
    static uint8_t encoder;
    encoder  = SPI_Receive();
    decode_spi_left_knob(encoder);
    decode_spi_right_knob(encoder);
 600:	0c 94 ac 02 	jmp	0x558	; 0x558 <decode_spi_right_knob>

00000604 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
 604:	1f 92       	push	r1
 606:	0f 92       	push	r0
 608:	0f b6       	in	r0, 0x3f	; 63
 60a:	0f 92       	push	r0
 60c:	11 24       	eor	r1, r1
 60e:	0b b6       	in	r0, 0x3b	; 59
 610:	0f 92       	push	r0
 612:	2f 93       	push	r18
 614:	3f 93       	push	r19
 616:	4f 93       	push	r20
 618:	5f 93       	push	r21
 61a:	6f 93       	push	r22
 61c:	7f 93       	push	r23
 61e:	8f 93       	push	r24
 620:	9f 93       	push	r25
 622:	af 93       	push	r26
 624:	bf 93       	push	r27
 626:	ef 93       	push	r30
 628:	ff 93       	push	r31
    update_time();
 62a:	0e 94 8f 01 	call	0x31e	; 0x31e <update_time>
    check_knobs();
 62e:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <check_knobs>
    display_update();
 632:	0e 94 14 02 	call	0x428	; 0x428 <display_update>
    button_routine();
 636:	0e 94 2f 01 	call	0x25e	; 0x25e <button_routine>
}
 63a:	ff 91       	pop	r31
 63c:	ef 91       	pop	r30
 63e:	bf 91       	pop	r27
 640:	af 91       	pop	r26
 642:	9f 91       	pop	r25
 644:	8f 91       	pop	r24
 646:	7f 91       	pop	r23
 648:	6f 91       	pop	r22
 64a:	5f 91       	pop	r21
 64c:	4f 91       	pop	r20
 64e:	3f 91       	pop	r19
 650:	2f 91       	pop	r18
 652:	0f 90       	pop	r0
 654:	0b be       	out	0x3b, r0	; 59
 656:	0f 90       	pop	r0
 658:	0f be       	out	0x3f, r0	; 63
 65a:	0f 90       	pop	r0
 65c:	1f 90       	pop	r1
 65e:	18 95       	reti

00000660 <update_number>:
    }
    previous_encoder2 = encoder2;
}

void update_number(void){
    if (value > (0-MAX_SUM)){
 660:	80 91 13 01 	lds	r24, 0x0113
 664:	90 91 14 01 	lds	r25, 0x0114
 668:	82 30       	cpi	r24, 0x02	; 2
 66a:	2c ef       	ldi	r18, 0xFC	; 252
 66c:	92 07       	cpc	r25, r18
 66e:	58 f4       	brcc	.+22     	; 0x686 <update_number+0x26>
	value = MAX_SUM - (dif-1);                       	
    }
    else if (value > MAX_SUM){
 670:	81 15       	cp	r24, r1
 672:	24 e0       	ldi	r18, 0x04	; 4
 674:	92 07       	cpc	r25, r18
 676:	30 f0       	brcs	.+12     	; 0x684 <update_number+0x24>
	value = value - MAX_SUM;
 678:	8f 5f       	subi	r24, 0xFF	; 255
 67a:	93 40       	sbci	r25, 0x03	; 3
 67c:	90 93 14 01 	sts	0x0114, r25
 680:	80 93 13 01 	sts	0x0113, r24
 684:	08 95       	ret
    previous_encoder2 = encoder2;
}

void update_number(void){
    if (value > (0-MAX_SUM)){
	value = MAX_SUM - (dif-1);                       	
 686:	20 91 00 01 	lds	r18, 0x0100
 68a:	80 e0       	ldi	r24, 0x00	; 0
 68c:	94 e0       	ldi	r25, 0x04	; 4
 68e:	82 1b       	sub	r24, r18
 690:	91 09       	sbc	r25, r1
 692:	90 93 14 01 	sts	0x0114, r25
 696:	80 93 13 01 	sts	0x0113, r24
 69a:	08 95       	ret

0000069c <main>:

//***********************************************************************************
int main()
{
    //set port bits 4-7 B as outputs
    DDRE = 0xc0;
 69c:	80 ec       	ldi	r24, 0xC0	; 192
 69e:	82 b9       	out	0x02, r24	; 2
    PORTE &= 0x7F;
 6a0:	1f 98       	cbi	0x03, 7	; 3
    DDRB = 0xF7;
 6a2:	87 ef       	ldi	r24, 0xF7	; 247
 6a4:	87 bb       	out	0x17, r24	; 23
    DDRD |= (1 << PB2);
 6a6:	8a 9a       	sbi	0x11, 2	; 17

    segment_data[2] = OFF;
 6a8:	8f ef       	ldi	r24, 0xFF	; 255
 6aa:	80 93 33 01 	sts	0x0133, r24

    TIMSK |= (1<<TOIE0);             //enable interrupts
 6ae:	87 b7       	in	r24, 0x37	; 55
 6b0:	81 60       	ori	r24, 0x01	; 1
 6b2:	87 bf       	out	0x37, r24	; 55
    TCCR0 |= (1<<CS00) | (1<<CS10);  //normal mode, prescale by 32
 6b4:	83 b7       	in	r24, 0x33	; 51
 6b6:	81 60       	ori	r24, 0x01	; 1
 6b8:	83 bf       	out	0x33, r24	; 51
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 6ba:	81 e5       	ldi	r24, 0x51	; 81
 6bc:	8d b9       	out	0x0d, r24	; 13
    segment_data[2] = OFF;

    TIMSK |= (1<<TOIE0);             //enable interrupts
    TCCR0 |= (1<<CS00) | (1<<CS10);  //normal mode, prescale by 32
    SPI_init();
    sei();
 6be:	78 94       	sei

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
 6c0:	2f ef       	ldi	r18, 0xFF	; 255
    }

    write = 0xFF;
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
 6c2:	94 e0       	ldi	r25, 0x04	; 4
    __asm__ __volatile__ ("nop"); //Buffer
    __asm__ __volatile__ ("nop");  //Buffer


    PORTD = (2 << PD2);  // Push data out of SPI
 6c4:	88 e0       	ldi	r24, 0x08	; 8

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
    SPDR = data;    //Write data to SPDR
 6c6:	2f b9       	out	0x0f, r18	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 6c8:	77 9b       	sbis	0x0e, 7	; 14
 6ca:	fe cf       	rjmp	.-4      	; 0x6c8 <main+0x2c>
    }

    write = 0xFF;
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
 6cc:	92 bb       	out	0x12, r25	; 18
    __asm__ __volatile__ ("nop"); //Buffer
 6ce:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 6d0:	00 00       	nop


    PORTD = (2 << PD2);  // Push data out of SPI
 6d2:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop");  //Buffer
 6d4:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 6d6:	00 00       	nop
 6d8:	f6 cf       	rjmp	.-20     	; 0x6c6 <main+0x2a>

000006da <__umulhisi3>:
 6da:	a2 9f       	mul	r26, r18
 6dc:	b0 01       	movw	r22, r0
 6de:	b3 9f       	mul	r27, r19
 6e0:	c0 01       	movw	r24, r0
 6e2:	a3 9f       	mul	r26, r19
 6e4:	70 0d       	add	r23, r0
 6e6:	81 1d       	adc	r24, r1
 6e8:	11 24       	eor	r1, r1
 6ea:	91 1d       	adc	r25, r1
 6ec:	b2 9f       	mul	r27, r18
 6ee:	70 0d       	add	r23, r0
 6f0:	81 1d       	adc	r24, r1
 6f2:	11 24       	eor	r1, r1
 6f4:	91 1d       	adc	r25, r1
 6f6:	08 95       	ret

000006f8 <_exit>:
 6f8:	f8 94       	cli

000006fa <__stop_program>:
 6fa:	ff cf       	rjmp	.-2      	; 0x6fa <__stop_program>
