
lab6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000048  00800100  000021fc  00002290  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000021fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000fd  00800148  00800148  000022d8  2**0
                  ALLOC
  3 .stab         000061b0  00000000  00000000  000022d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001ee0  00000000  00000000  00008488  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000a368  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      1c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      20:	0c 94 0f 08 	jmp	0x101e	; 0x101e <__vector_8>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 5e 09 	jmp	0x12bc	; 0x12bc <__vector_10>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 ce 07 	jmp	0xf9c	; 0xf9c <__vector_12>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 43 07 	jmp	0xe86	; 0xe86 <__vector_16>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 2b 08 	jmp	0x1056	; 0x1056 <__vector_21>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 48 0c 	jmp	0x1890	; 0x1890 <__vector_33>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	87 01       	movw	r16, r14
      8e:	8f 01       	movw	r16, r30
      90:	97 01       	movw	r18, r14
      92:	9f 01       	movw	r18, r30
      94:	a7 01       	movw	r20, r14
      96:	b0 01       	movw	r22, r0
      98:	b9 01       	movw	r22, r18
      9a:	77 01       	movw	r14, r14
      9c:	7f 01       	movw	r14, r30
      9e:	0d 03       	fmul	r16, r21
      a0:	05 03       	mulsu	r16, r21
      a2:	00 03       	mulsu	r16, r16
      a4:	2a 03       	fmul	r18, r18
      a6:	1d 03       	fmul	r17, r21
      a8:	25 03       	mulsu	r18, r21
      aa:	15 03       	mulsu	r17, r21
      ac:	de 02       	muls	r29, r30
      ae:	d6 02       	muls	r29, r22
      b0:	d1 02       	muls	r29, r17
      b2:	c9 02       	muls	r28, r25
      b4:	32 03       	mulsu	r19, r18
      b6:	e6 02       	muls	r30, r22
      b8:	bc 02       	muls	r27, r28
      ba:	a4 02       	muls	r26, r20
      bc:	52 03       	mulsu	r21, r18
      be:	fb 02       	muls	r31, r27
      c0:	f3 02       	muls	r31, r19
      c2:	eb 02       	muls	r30, r27
      c4:	72 03       	mulsu	r23, r18
      c6:	ac 02       	muls	r26, r28
      c8:	62 03       	mulsu	r22, r18
      ca:	b4 02       	muls	r27, r20
      cc:	7f 03       	fmul	r23, r23
      ce:	4a 03       	fmul	r20, r18
      d0:	6a 03       	fmul	r22, r18
      d2:	c4 02       	muls	r28, r20
      d4:	42 03       	mulsu	r20, r18
      d6:	3a 03       	fmul	r19, r18
      d8:	5a 03       	fmul	r21, r18
      da:	9f 02       	muls	r25, r31
      dc:	6d 02       	muls	r22, r29
      de:	65 02       	muls	r22, r21
      e0:	75 02       	muls	r23, r21
      e2:	77 03       	mulsu	r23, r23
      e4:	58 02       	muls	r21, r24
      e6:	50 02       	muls	r21, r16
      e8:	7a 02       	muls	r23, r26
      ea:	33 02       	muls	r19, r19
      ec:	97 02       	muls	r25, r23
      ee:	60 02       	muls	r22, r16
      f0:	43 02       	muls	r20, r19
      f2:	3b 02       	muls	r19, r27
      f4:	87 02       	muls	r24, r23
      f6:	4b 02       	muls	r20, r27
      f8:	7f 02       	muls	r23, r31
      fa:	2b 02       	muls	r18, r27
      fc:	11 02       	muls	r17, r17
      fe:	8f 02       	muls	r24, r31
     100:	01 02       	muls	r16, r17
     102:	f9 01       	movw	r30, r18
     104:	1e 02       	muls	r17, r30
     106:	16 02       	muls	r17, r22
     108:	23 02       	muls	r18, r19
     10a:	f4 01       	movw	r30, r8
     10c:	09 02       	muls	r16, r25
     10e:	dc 01       	movw	r26, r24
     110:	ec 01       	movw	r28, r24
     112:	d7 01       	movw	r26, r14
     114:	cf 01       	movw	r24, r30
     116:	c7 01       	movw	r24, r14
     118:	c2 01       	movw	r24, r4
     11a:	e4 01       	movw	r28, r8
     11c:	89 04       	cpc	r8, r9
     11e:	a7 04       	cpc	r10, r7
     120:	83 04       	cpc	r8, r3
     122:	95 04       	cpc	r9, r5
     124:	77 04       	cpc	r7, r7
     126:	7d 04       	cpc	r7, r13
     128:	77 04       	cpc	r7, r7
     12a:	7d 04       	cpc	r7, r13
     12c:	ad 04       	cpc	r10, r13
     12e:	89 04       	cpc	r8, r9
     130:	a7 04       	cpc	r10, r7
     132:	83 04       	cpc	r8, r3
     134:	95 04       	cpc	r9, r5
     136:	8f 04       	cpc	r8, r15
     138:	71 04       	cpc	r7, r1
     13a:	8f 04       	cpc	r8, r15
     13c:	71 04       	cpc	r7, r1
     13e:	d7 04       	cpc	r13, r7
     140:	13 05       	cpc	r17, r3
     142:	cb 04       	cpc	r12, r11
     144:	43 05       	cpc	r20, r3
     146:	cb 04       	cpc	r12, r11
     148:	07 05       	cpc	r16, r7
     14a:	01 05       	cpc	r16, r1
     14c:	71 04       	cpc	r7, r1
     14e:	dd 04       	cpc	r13, r13
     150:	71 04       	cpc	r7, r1
     152:	ef 04       	cpc	r14, r15
     154:	9b 04       	cpc	r9, r11
     156:	31 05       	cpc	r19, r1
     158:	77 04       	cpc	r7, r7
     15a:	25 05       	cpc	r18, r5
     15c:	b3 04       	cpc	r11, r3
     15e:	2b 05       	cpc	r18, r11
     160:	b9 04       	cpc	r11, r9
     162:	37 05       	cpc	r19, r7
     164:	fb 04       	cpc	r15, r11
     166:	a1 04       	cpc	r10, r1
     168:	9b 04       	cpc	r9, r11
     16a:	e3 04       	cpc	r14, r3
     16c:	bf 04       	cpc	r11, r15
     16e:	89 04       	cpc	r8, r9
     170:	a7 04       	cpc	r10, r7
     172:	83 04       	cpc	r8, r3
     174:	95 04       	cpc	r9, r5
     176:	77 04       	cpc	r7, r7
     178:	7d 04       	cpc	r7, r13
     17a:	77 04       	cpc	r7, r7
     17c:	7d 04       	cpc	r7, r13
     17e:	ad 04       	cpc	r10, r13
     180:	89 04       	cpc	r8, r9
     182:	0d 05       	cpc	r16, r13
     184:	a1 04       	cpc	r10, r1
     186:	83 04       	cpc	r8, r3
     188:	8f 04       	cpc	r8, r15
     18a:	71 04       	cpc	r7, r1
     18c:	8f 04       	cpc	r8, r15
     18e:	71 04       	cpc	r7, r1
     190:	d7 04       	cpc	r13, r7
     192:	19 05       	cpc	r17, r9
     194:	e9 04       	cpc	r14, r9
     196:	ad 04       	cpc	r10, r13
     198:	1f 05       	cpc	r17, r15
     19a:	dd 04       	cpc	r13, r13
     19c:	b3 04       	cpc	r11, r3
     19e:	b9 04       	cpc	r11, r9
     1a0:	9b 04       	cpc	r9, r11
     1a2:	a1 04       	cpc	r10, r1
     1a4:	3d 05       	cpc	r19, r13
     1a6:	bf 04       	cpc	r11, r15
     1a8:	05 07       	cpc	r16, r21
     1aa:	fc 06       	cpc	r15, r28
     1ac:	f3 06       	cpc	r15, r19
     1ae:	da 06       	cpc	r13, r26
     1b0:	d0 06       	cpc	r13, r16
     1b2:	0e 07       	cpc	r16, r30
     1b4:	25 07       	cpc	r18, r21
     1b6:	88 0c       	add	r8, r8
     1b8:	5f 0c       	add	r5, r15
     1ba:	5f 0c       	add	r5, r15
     1bc:	5f 0c       	add	r5, r15
     1be:	5f 0c       	add	r5, r15
     1c0:	5f 0c       	add	r5, r15
     1c2:	5f 0c       	add	r5, r15
     1c4:	5f 0c       	add	r5, r15
     1c6:	88 0c       	add	r8, r8
     1c8:	5f 0c       	add	r5, r15
     1ca:	5f 0c       	add	r5, r15
     1cc:	5f 0c       	add	r5, r15
     1ce:	5f 0c       	add	r5, r15
     1d0:	5f 0c       	add	r5, r15
     1d2:	5f 0c       	add	r5, r15
     1d4:	5f 0c       	add	r5, r15
     1d6:	92 0c       	add	r9, r2
     1d8:	5f 0c       	add	r5, r15
     1da:	5f 0c       	add	r5, r15
     1dc:	5f 0c       	add	r5, r15
     1de:	5f 0c       	add	r5, r15
     1e0:	5f 0c       	add	r5, r15
     1e2:	5f 0c       	add	r5, r15
     1e4:	5f 0c       	add	r5, r15
     1e6:	5f 0c       	add	r5, r15
     1e8:	5f 0c       	add	r5, r15
     1ea:	5f 0c       	add	r5, r15
     1ec:	5f 0c       	add	r5, r15
     1ee:	5f 0c       	add	r5, r15
     1f0:	5f 0c       	add	r5, r15
     1f2:	5f 0c       	add	r5, r15
     1f4:	5f 0c       	add	r5, r15
     1f6:	92 0c       	add	r9, r2
     1f8:	5f 0c       	add	r5, r15
     1fa:	5f 0c       	add	r5, r15
     1fc:	5f 0c       	add	r5, r15
     1fe:	5f 0c       	add	r5, r15
     200:	5f 0c       	add	r5, r15
     202:	5f 0c       	add	r5, r15
     204:	5f 0c       	add	r5, r15
     206:	5f 0c       	add	r5, r15
     208:	5f 0c       	add	r5, r15
     20a:	5f 0c       	add	r5, r15
     20c:	5f 0c       	add	r5, r15
     20e:	5f 0c       	add	r5, r15
     210:	5f 0c       	add	r5, r15
     212:	5f 0c       	add	r5, r15
     214:	5f 0c       	add	r5, r15
     216:	a9 0c       	add	r10, r9
     218:	5f 0c       	add	r5, r15
     21a:	5f 0c       	add	r5, r15
     21c:	5f 0c       	add	r5, r15
     21e:	5f 0c       	add	r5, r15
     220:	5f 0c       	add	r5, r15
     222:	5f 0c       	add	r5, r15
     224:	5f 0c       	add	r5, r15
     226:	ad 0c       	add	r10, r13
     228:	5f 0c       	add	r5, r15
     22a:	5f 0c       	add	r5, r15
     22c:	5f 0c       	add	r5, r15
     22e:	5f 0c       	add	r5, r15
     230:	5f 0c       	add	r5, r15
     232:	5f 0c       	add	r5, r15
     234:	5f 0c       	add	r5, r15
     236:	5f 0c       	add	r5, r15
     238:	5f 0c       	add	r5, r15
     23a:	5f 0c       	add	r5, r15
     23c:	5f 0c       	add	r5, r15
     23e:	5f 0c       	add	r5, r15
     240:	5f 0c       	add	r5, r15
     242:	5f 0c       	add	r5, r15
     244:	5f 0c       	add	r5, r15
     246:	bb 0c       	add	r11, r11
     248:	5f 0c       	add	r5, r15
     24a:	5f 0c       	add	r5, r15
     24c:	5f 0c       	add	r5, r15
     24e:	5f 0c       	add	r5, r15
     250:	5f 0c       	add	r5, r15
     252:	5f 0c       	add	r5, r15
     254:	5f 0c       	add	r5, r15
     256:	79 0c       	add	r7, r9

00000258 <__ctors_end>:
     258:	11 24       	eor	r1, r1
     25a:	1f be       	out	0x3f, r1	; 63
     25c:	cf ef       	ldi	r28, 0xFF	; 255
     25e:	d0 e1       	ldi	r29, 0x10	; 16
     260:	de bf       	out	0x3e, r29	; 62
     262:	cd bf       	out	0x3d, r28	; 61

00000264 <__do_copy_data>:
     264:	11 e0       	ldi	r17, 0x01	; 1
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b1 e0       	ldi	r27, 0x01	; 1
     26a:	ec ef       	ldi	r30, 0xFC	; 252
     26c:	f1 e2       	ldi	r31, 0x21	; 33
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	a8 34       	cpi	r26, 0x48	; 72
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	22 e0       	ldi	r18, 0x02	; 2
     280:	a8 e4       	ldi	r26, 0x48	; 72
     282:	b1 e0       	ldi	r27, 0x01	; 1
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	a5 34       	cpi	r26, 0x45	; 69
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 11 10 	call	0x2022	; 0x2022 <main>
     292:	0c 94 fc 10 	jmp	0x21f8	; 0x21f8 <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <play_rest>:
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     29a:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     29c:	10 92 98 01 	sts	0x0198, r1
     2a0:	10 92 97 01 	sts	0x0197, r1
  max_beat = duration;
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	90 93 94 01 	sts	0x0194, r25
     2aa:	80 93 93 01 	sts	0x0193, r24
     2ae:	08 95       	ret

000002b0 <play_note>:
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
     2b0:	cf 93       	push	r28
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
     2b2:	92 98       	cbi	0x12, 2	; 18
  beat = 0;             //reset the beat counter
     2b4:	10 92 98 01 	sts	0x0198, r1
     2b8:	10 92 97 01 	sts	0x0197, r1
  max_beat = duration;  //set the max beat
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	30 93 94 01 	sts	0x0194, r19
     2c2:	20 93 93 01 	sts	0x0193, r18
  switch (octave) {
     2c6:	50 e0       	ldi	r21, 0x00	; 0
     2c8:	49 30       	cpi	r20, 0x09	; 9
     2ca:	51 05       	cpc	r21, r1
     2cc:	20 f0       	brcs	.+8      	; 0x2d6 <play_note+0x26>
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
     2ce:	1b bc       	out	0x2b, r1	; 43
     2d0:	1a bc       	out	0x2a, r1	; 42
  }
}
     2d2:	cf 91       	pop	r28
     2d4:	08 95       	ret
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2d6:	4a 5b       	subi	r20, 0xBA	; 186
     2d8:	5f 4f       	sbci	r21, 0xFF	; 255
     2da:	fa 01       	movw	r30, r20
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2dc:	99 27       	eor	r25, r25
     2de:	87 fd       	sbrc	r24, 7
     2e0:	90 95       	com	r25
     2e2:	a9 2f       	mov	r26, r25
     2e4:	b9 2f       	mov	r27, r25
     2e6:	81 54       	subi	r24, 0x41	; 65
     2e8:	91 09       	sbc	r25, r1
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2ea:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
     2ee:	87 30       	cpi	r24, 0x07	; 7
     2f0:	91 05       	cpc	r25, r1
     2f2:	78 f7       	brcc	.-34     	; 0x2d2 <play_note+0x22>
     2f4:	81 5b       	subi	r24, 0xB1	; 177
     2f6:	9f 4f       	sbci	r25, 0xFF	; 255
     2f8:	fc 01       	movw	r30, r24
     2fa:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2fe:	87 30       	cpi	r24, 0x07	; 7
     300:	91 05       	cpc	r25, r1
     302:	38 f7       	brcc	.-50     	; 0x2d2 <play_note+0x22>
     304:	8a 5a       	subi	r24, 0xAA	; 170
     306:	9f 4f       	sbci	r25, 0xFF	; 255
     308:	fc 01       	movw	r30, r24
     30a:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
     30e:	87 30       	cpi	r24, 0x07	; 7
     310:	91 05       	cpc	r25, r1
     312:	f8 f6       	brcc	.-66     	; 0x2d2 <play_note+0x22>
     314:	83 5a       	subi	r24, 0xA3	; 163
     316:	9f 4f       	sbci	r25, 0xFF	; 255
     318:	fc 01       	movw	r30, r24
     31a:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
     31e:	87 30       	cpi	r24, 0x07	; 7
     320:	91 05       	cpc	r25, r1
     322:	b8 f6       	brcc	.-82     	; 0x2d2 <play_note+0x22>
     324:	8c 59       	subi	r24, 0x9C	; 156
     326:	9f 4f       	sbci	r25, 0xFF	; 255
     328:	fc 01       	movw	r30, r24
     32a:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
     32e:	87 30       	cpi	r24, 0x07	; 7
     330:	91 05       	cpc	r25, r1
     332:	78 f6       	brcc	.-98     	; 0x2d2 <play_note+0x22>
     334:	85 59       	subi	r24, 0x95	; 149
     336:	9f 4f       	sbci	r25, 0xFF	; 255
     338:	fc 01       	movw	r30, r24
     33a:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
     33e:	87 30       	cpi	r24, 0x07	; 7
     340:	91 05       	cpc	r25, r1
     342:	38 f6       	brcc	.-114    	; 0x2d2 <play_note+0x22>
     344:	8e 58       	subi	r24, 0x8E	; 142
     346:	9f 4f       	sbci	r25, 0xFF	; 255
     348:	fc 01       	movw	r30, r24
     34a:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
     34e:	87 30       	cpi	r24, 0x07	; 7
     350:	91 05       	cpc	r25, r1
     352:	08 f0       	brcs	.+2      	; 0x356 <play_note+0xa6>
     354:	be cf       	rjmp	.-132    	; 0x2d2 <play_note+0x22>
     356:	87 58       	subi	r24, 0x87	; 135
     358:	9f 4f       	sbci	r25, 0xFF	; 255
     35a:	fc 01       	movw	r30, r24
     35c:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
     360:	87 30       	cpi	r24, 0x07	; 7
     362:	91 05       	cpc	r25, r1
     364:	08 f0       	brcs	.+2      	; 0x368 <play_note+0xb8>
     366:	b5 cf       	rjmp	.-150    	; 0x2d2 <play_note+0x22>
     368:	80 58       	subi	r24, 0x80	; 128
     36a:	9f 4f       	sbci	r25, 0xFF	; 255
     36c:	fc 01       	movw	r30, r24
     36e:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
     372:	87 30       	cpi	r24, 0x07	; 7
     374:	91 05       	cpc	r25, r1
     376:	08 f0       	brcs	.+2      	; 0x37a <play_note+0xca>
     378:	ac cf       	rjmp	.-168    	; 0x2d2 <play_note+0x22>
     37a:	89 57       	subi	r24, 0x79	; 121
     37c:	9f 4f       	sbci	r25, 0xFF	; 255
     37e:	fc 01       	movw	r30, r24
     380:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
     384:	88 e5       	ldi	r24, 0x58	; 88
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	9b bd       	out	0x2b, r25	; 43
     38a:	8a bd       	out	0x2a, r24	; 42
	break;
     38c:	a2 cf       	rjmp	.-188    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
     38e:	66 23       	and	r22, r22
     390:	09 f4       	brne	.+2      	; 0x394 <play_note+0xe4>
     392:	0f c2       	rjmp	.+1054   	; 0x7b2 <play_note+0x502>
     394:	83 e6       	ldi	r24, 0x63	; 99
     396:	90 e0       	ldi	r25, 0x00	; 0
     398:	9b bd       	out	0x2b, r25	; 43
     39a:	8a bd       	out	0x2a, r24	; 42
     39c:	9a cf       	rjmp	.-204    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
     39e:	66 23       	and	r22, r22
     3a0:	09 f4       	brne	.+2      	; 0x3a4 <play_note+0xf4>
     3a2:	11 c2       	rjmp	.+1058   	; 0x7c6 <play_note+0x516>
     3a4:	8f e6       	ldi	r24, 0x6F	; 111
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	9b bd       	out	0x2b, r25	; 43
     3aa:	8a bd       	out	0x2a, r24	; 42
     3ac:	92 cf       	rjmp	.-220    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
     3ae:	86 e7       	ldi	r24, 0x76	; 118
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	9b bd       	out	0x2b, r25	; 43
     3b4:	8a bd       	out	0x2a, r24	; 42
	break;
     3b6:	8d cf       	rjmp	.-230    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
     3b8:	66 23       	and	r22, r22
     3ba:	09 f4       	brne	.+2      	; 0x3be <play_note+0x10e>
     3bc:	ff c1       	rjmp	.+1022   	; 0x7bc <play_note+0x50c>
     3be:	8a e4       	ldi	r24, 0x4A	; 74
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	9b bd       	out	0x2b, r25	; 43
     3c4:	8a bd       	out	0x2a, r24	; 42
     3c6:	85 cf       	rjmp	.-246    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
     3c8:	66 23       	and	r22, r22
     3ca:	09 f4       	brne	.+2      	; 0x3ce <play_note+0x11e>
     3cc:	01 c2       	rjmp	.+1026   	; 0x7d0 <play_note+0x520>
     3ce:	83 e5       	ldi	r24, 0x53	; 83
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	9b bd       	out	0x2b, r25	; 43
     3d4:	8a bd       	out	0x2a, r24	; 42
     3d6:	7d cf       	rjmp	.-262    	; 0x2d2 <play_note+0x22>
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
     3d8:	66 23       	and	r22, r22
     3da:	09 f4       	brne	.+2      	; 0x3de <play_note+0x12e>
     3dc:	b8 c1       	rjmp	.+880    	; 0x74e <play_note+0x49e>
     3de:	82 e4       	ldi	r24, 0x42	; 66
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	9b bd       	out	0x2b, r25	; 43
     3e4:	8a bd       	out	0x2a, r24	; 42
     3e6:	75 cf       	rjmp	.-278    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
     3e8:	81 eb       	ldi	r24, 0xB1	; 177
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	9b bd       	out	0x2b, r25	; 43
     3ee:	8a bd       	out	0x2a, r24	; 42
	break;
     3f0:	70 cf       	rjmp	.-288    	; 0x2d2 <play_note+0x22>
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
     3f2:	66 23       	and	r22, r22
     3f4:	09 f4       	brne	.+2      	; 0x3f8 <play_note+0x148>
     3f6:	d3 c1       	rjmp	.+934    	; 0x79e <play_note+0x4ee>
     3f8:	85 e8       	ldi	r24, 0x85	; 133
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	9b bd       	out	0x2b, r25	; 43
     3fe:	8a bd       	out	0x2a, r24	; 42
     400:	68 cf       	rjmp	.-304    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
     402:	66 23       	and	r22, r22
     404:	09 f4       	brne	.+2      	; 0x408 <play_note+0x158>
     406:	c1 c1       	rjmp	.+898    	; 0x78a <play_note+0x4da>
     408:	85 e9       	ldi	r24, 0x95	; 149
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	9b bd       	out	0x2b, r25	; 43
     40e:	8a bd       	out	0x2a, r24	; 42
     410:	60 cf       	rjmp	.-320    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
     412:	66 23       	and	r22, r22
     414:	09 f4       	brne	.+2      	; 0x418 <play_note+0x168>
     416:	be c1       	rjmp	.+892    	; 0x794 <play_note+0x4e4>
     418:	87 ea       	ldi	r24, 0xA7	; 167
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9b bd       	out	0x2b, r25	; 43
     41e:	8a bd       	out	0x2a, r24	; 42
     420:	58 cf       	rjmp	.-336    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
     422:	84 e6       	ldi	r24, 0x64	; 100
     424:	91 e0       	ldi	r25, 0x01	; 1
     426:	9b bd       	out	0x2b, r25	; 43
     428:	8a bd       	out	0x2a, r24	; 42
	break;
     42a:	53 cf       	rjmp	.-346    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
     42c:	66 23       	and	r22, r22
     42e:	09 f4       	brne	.+2      	; 0x432 <play_note+0x182>
     430:	bb c1       	rjmp	.+886    	; 0x7a8 <play_note+0x4f8>
     432:	80 ee       	ldi	r24, 0xE0	; 224
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	9b bd       	out	0x2b, r25	; 43
     438:	8a bd       	out	0x2a, r24	; 42
     43a:	4b cf       	rjmp	.-362    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
     43c:	8d ee       	ldi	r24, 0xED	; 237
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	9b bd       	out	0x2b, r25	; 43
     442:	8a bd       	out	0x2a, r24	; 42
	break;
     444:	46 cf       	rjmp	.-372    	; 0x2d2 <play_note+0x22>
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
     446:	66 23       	and	r22, r22
     448:	09 f4       	brne	.+2      	; 0x44c <play_note+0x19c>
     44a:	8b c1       	rjmp	.+790    	; 0x762 <play_note+0x4b2>
     44c:	87 ec       	ldi	r24, 0xC7	; 199
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	9b bd       	out	0x2b, r25	; 43
     452:	8a bd       	out	0x2a, r24	; 42
     454:	3e cf       	rjmp	.-388    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
     456:	66 23       	and	r22, r22
     458:	09 f4       	brne	.+2      	; 0x45c <play_note+0x1ac>
     45a:	74 c1       	rjmp	.+744    	; 0x744 <play_note+0x494>
     45c:	80 e9       	ldi	r24, 0x90	; 144
     45e:	91 e0       	ldi	r25, 0x01	; 1
     460:	9b bd       	out	0x2b, r25	; 43
     462:	8a bd       	out	0x2a, r24	; 42
     464:	36 cf       	rjmp	.-404    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
     466:	66 23       	and	r22, r22
     468:	09 f4       	brne	.+2      	; 0x46c <play_note+0x1bc>
     46a:	cb c1       	rjmp	.+918    	; 0x802 <play_note+0x552>
     46c:	84 e8       	ldi	r24, 0x84	; 132
     46e:	93 e0       	ldi	r25, 0x03	; 3
     470:	9b bd       	out	0x2b, r25	; 43
     472:	8a bd       	out	0x2a, r24	; 42
     474:	2e cf       	rjmp	.-420    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
     476:	66 23       	and	r22, r22
     478:	09 f4       	brne	.+2      	; 0x47c <play_note+0x1cc>
     47a:	af c1       	rjmp	.+862    	; 0x7da <play_note+0x52a>
     47c:	8b e2       	ldi	r24, 0x2B	; 43
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	9b bd       	out	0x2b, r25	; 43
     482:	8a bd       	out	0x2a, r24	; 42
     484:	26 cf       	rjmp	.-436    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
     486:	66 23       	and	r22, r22
     488:	09 f4       	brne	.+2      	; 0x48c <play_note+0x1dc>
     48a:	b1 c1       	rjmp	.+866    	; 0x7ee <play_note+0x53e>
     48c:	82 ea       	ldi	r24, 0xA2	; 162
     48e:	92 e0       	ldi	r25, 0x02	; 2
     490:	9b bd       	out	0x2b, r25	; 43
     492:	8a bd       	out	0x2a, r24	; 42
     494:	1e cf       	rjmp	.-452    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
     496:	8c ed       	ldi	r24, 0xDC	; 220
     498:	91 e0       	ldi	r25, 0x01	; 1
     49a:	9b bd       	out	0x2b, r25	; 43
     49c:	8a bd       	out	0x2a, r24	; 42
	break;
     49e:	19 cf       	rjmp	.-462    	; 0x2d2 <play_note+0x22>
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
     4a0:	66 23       	and	r22, r22
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <play_note+0x1f6>
     4a4:	59 c1       	rjmp	.+690    	; 0x758 <play_note+0x4a8>
     4a6:	87 e1       	ldi	r24, 0x17	; 23
     4a8:	92 e0       	ldi	r25, 0x02	; 2
     4aa:	9b bd       	out	0x2b, r25	; 43
     4ac:	8a bd       	out	0x2a, r24	; 42
     4ae:	11 cf       	rjmp	.-478    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
     4b0:	66 23       	and	r22, r22
     4b2:	09 f4       	brne	.+2      	; 0x4b6 <play_note+0x206>
     4b4:	b0 c1       	rjmp	.+864    	; 0x816 <play_note+0x566>
     4b6:	88 e5       	ldi	r24, 0x58	; 88
     4b8:	92 e0       	ldi	r25, 0x02	; 2
     4ba:	9b bd       	out	0x2b, r25	; 43
     4bc:	8a bd       	out	0x2a, r24	; 42
     4be:	09 cf       	rjmp	.-494    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
     4c0:	8a ec       	ldi	r24, 0xCA	; 202
     4c2:	92 e0       	ldi	r25, 0x02	; 2
     4c4:	9b bd       	out	0x2b, r25	; 43
     4c6:	8a bd       	out	0x2a, r24	; 42
	break;
     4c8:	04 cf       	rjmp	.-504    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
     4ca:	66 23       	and	r22, r22
     4cc:	09 f4       	brne	.+2      	; 0x4d0 <play_note+0x220>
     4ce:	35 c1       	rjmp	.+618    	; 0x73a <play_note+0x48a>
     4d0:	86 e4       	ldi	r24, 0x46	; 70
     4d2:	96 e0       	ldi	r25, 0x06	; 6
     4d4:	9b bd       	out	0x2b, r25	; 43
     4d6:	8a bd       	out	0x2a, r24	; 42
     4d8:	fc ce       	rjmp	.-520    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
     4da:	66 23       	and	r22, r22
     4dc:	09 f4       	brne	.+2      	; 0x4e0 <play_note+0x230>
     4de:	82 c1       	rjmp	.+772    	; 0x7e4 <play_note+0x534>
     4e0:	8a e0       	ldi	r24, 0x0A	; 10
     4e2:	97 e0       	ldi	r25, 0x07	; 7
     4e4:	9b bd       	out	0x2b, r25	; 43
     4e6:	8a bd       	out	0x2a, r24	; 42
     4e8:	f4 ce       	rjmp	.-536    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
     4ea:	86 e9       	ldi	r24, 0x96	; 150
     4ec:	95 e0       	ldi	r25, 0x05	; 5
     4ee:	9b bd       	out	0x2b, r25	; 43
     4f0:	8a bd       	out	0x2a, r24	; 42
	break;
     4f2:	ef ce       	rjmp	.-546    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
     4f4:	8a eb       	ldi	r24, 0xBA	; 186
     4f6:	93 e0       	ldi	r25, 0x03	; 3
     4f8:	9b bd       	out	0x2b, r25	; 43
     4fa:	8a bd       	out	0x2a, r24	; 42
	break;
     4fc:	ea ce       	rjmp	.-556    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
     4fe:	66 23       	and	r22, r22
     500:	09 f4       	brne	.+2      	; 0x504 <play_note+0x254>
     502:	7a c1       	rjmp	.+756    	; 0x7f8 <play_note+0x548>
     504:	81 ec       	ldi	r24, 0xC1	; 193
     506:	91 e0       	ldi	r25, 0x01	; 1
     508:	9b bd       	out	0x2b, r25	; 43
     50a:	8a bd       	out	0x2a, r24	; 42
     50c:	e2 ce       	rjmp	.-572    	; 0x2d2 <play_note+0x22>
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
     50e:	66 23       	and	r22, r22
     510:	09 f4       	brne	.+2      	; 0x514 <play_note+0x264>
     512:	7c c1       	rjmp	.+760    	; 0x80c <play_note+0x55c>
     514:	8b e0       	ldi	r24, 0x0B	; 11
     516:	91 e0       	ldi	r25, 0x01	; 1
     518:	9b bd       	out	0x2b, r25	; 43
     51a:	8a bd       	out	0x2a, r24	; 42
     51c:	da ce       	rjmp	.-588    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
     51e:	66 23       	and	r22, r22
     520:	09 f4       	brne	.+2      	; 0x524 <play_note+0x274>
     522:	7e c1       	rjmp	.+764    	; 0x820 <play_note+0x570>
     524:	80 e5       	ldi	r24, 0x50	; 80
     526:	91 e0       	ldi	r25, 0x01	; 1
     528:	9b bd       	out	0x2b, r25	; 43
     52a:	8a bd       	out	0x2a, r24	; 42
     52c:	d2 ce       	rjmp	.-604    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
     52e:	66 23       	and	r22, r22
     530:	09 f4       	brne	.+2      	; 0x534 <play_note+0x284>
     532:	ad c1       	rjmp	.+858    	; 0x88e <play_note+0x5de>
     534:	82 e2       	ldi	r24, 0x22	; 34
     536:	93 e0       	ldi	r25, 0x03	; 3
     538:	9b bd       	out	0x2b, r25	; 43
     53a:	8a bd       	out	0x2a, r24	; 42
     53c:	ca ce       	rjmp	.-620    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
     53e:	86 e7       	ldi	r24, 0x76	; 118
     540:	97 e0       	ldi	r25, 0x07	; 7
     542:	9b bd       	out	0x2b, r25	; 43
     544:	8a bd       	out	0x2a, r24	; 42
	break;
     546:	c5 ce       	rjmp	.-630    	; 0x2d2 <play_note+0x22>
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
     548:	66 23       	and	r22, r22
     54a:	09 f4       	brne	.+2      	; 0x54e <play_note+0x29e>
     54c:	0f c1       	rjmp	.+542    	; 0x76c <play_note+0x4bc>
     54e:	8e ec       	ldi	r24, 0xCE	; 206
     550:	92 e1       	ldi	r25, 0x12	; 18
     552:	9b bd       	out	0x2b, r25	; 43
     554:	8a bd       	out	0x2a, r24	; 42
     556:	bd ce       	rjmp	.-646    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
     558:	66 23       	and	r22, r22
     55a:	09 f4       	brne	.+2      	; 0x55e <play_note+0x2ae>
     55c:	7a c1       	rjmp	.+756    	; 0x852 <play_note+0x5a2>
     55e:	8d e1       	ldi	r24, 0x1D	; 29
     560:	95 e1       	ldi	r25, 0x15	; 21
     562:	9b bd       	out	0x2b, r25	; 43
     564:	8a bd       	out	0x2a, r24	; 42
     566:	b5 ce       	rjmp	.-662    	; 0x2d2 <play_note+0x22>
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
     568:	66 23       	and	r22, r22
     56a:	09 f4       	brne	.+2      	; 0x56e <play_note+0x2be>
     56c:	dc c0       	rjmp	.+440    	; 0x726 <play_note+0x476>
     56e:	80 e6       	ldi	r24, 0x60	; 96
     570:	98 e0       	ldi	r25, 0x08	; 8
     572:	9b bd       	out	0x2b, r25	; 43
     574:	8a bd       	out	0x2a, r24	; 42
     576:	ad ce       	rjmp	.-678    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
     578:	66 23       	and	r22, r22
     57a:	09 f4       	brne	.+2      	; 0x57e <play_note+0x2ce>
     57c:	92 c1       	rjmp	.+804    	; 0x8a2 <play_note+0x5f2>
     57e:	80 e1       	ldi	r24, 0x10	; 16
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	9b bd       	out	0x2b, r25	; 43
     584:	8a bd       	out	0x2a, r24	; 42
     586:	a5 ce       	rjmp	.-694    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
     588:	8e e2       	ldi	r24, 0x2E	; 46
     58a:	9b e0       	ldi	r25, 0x0B	; 11
     58c:	9b bd       	out	0x2b, r25	; 43
     58e:	8a bd       	out	0x2a, r24	; 42
	break;
     590:	a0 ce       	rjmp	.-704    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
     592:	66 23       	and	r22, r22
     594:	09 f4       	brne	.+2      	; 0x598 <play_note+0x2e8>
     596:	49 c1       	rjmp	.+658    	; 0x82a <play_note+0x57a>
     598:	8b e1       	ldi	r24, 0x1B	; 27
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	9b bd       	out	0x2b, r25	; 43
     59e:	8a bd       	out	0x2a, r24	; 42
     5a0:	98 ce       	rjmp	.-720    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
     5a2:	8c e1       	ldi	r24, 0x1C	; 28
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	9b bd       	out	0x2b, r25	; 43
     5a8:	8a bd       	out	0x2a, r24	; 42
	break;
     5aa:	93 ce       	rjmp	.-730    	; 0x2d2 <play_note+0x22>
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
     5ac:	66 23       	and	r22, r22
     5ae:	09 f4       	brne	.+2      	; 0x5b2 <play_note+0x302>
     5b0:	41 c1       	rjmp	.+642    	; 0x834 <play_note+0x584>
     5b2:	87 e0       	ldi	r24, 0x07	; 7
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	9b bd       	out	0x2b, r25	; 43
     5b8:	8a bd       	out	0x2a, r24	; 42
     5ba:	8b ce       	rjmp	.-746    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
     5bc:	66 23       	and	r22, r22
     5be:	09 f4       	brne	.+2      	; 0x5c2 <play_note+0x312>
     5c0:	da c0       	rjmp	.+436    	; 0x776 <play_note+0x4c6>
     5c2:	8b e0       	ldi	r24, 0x0B	; 11
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	9b bd       	out	0x2b, r25	; 43
     5c8:	8a bd       	out	0x2a, r24	; 42
     5ca:	83 ce       	rjmp	.-762    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
     5cc:	82 e1       	ldi	r24, 0x12	; 18
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	9b bd       	out	0x2b, r25	; 43
     5d2:	8a bd       	out	0x2a, r24	; 42
	break;
     5d4:	7e ce       	rjmp	.-772    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
     5d6:	66 23       	and	r22, r22
     5d8:	09 f4       	brne	.+2      	; 0x5dc <play_note+0x32c>
     5da:	9b c0       	rjmp	.+310    	; 0x712 <play_note+0x462>
     5dc:	89 e1       	ldi	r24, 0x19	; 25
     5de:	99 e1       	ldi	r25, 0x19	; 25
     5e0:	9b bd       	out	0x2b, r25	; 43
     5e2:	8a bd       	out	0x2a, r24	; 42
     5e4:	76 ce       	rjmp	.-788    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
     5e6:	66 23       	and	r22, r22
     5e8:	09 f4       	brne	.+2      	; 0x5ec <play_note+0x33c>
     5ea:	29 c1       	rjmp	.+594    	; 0x83e <play_note+0x58e>
     5ec:	80 e3       	ldi	r24, 0x30	; 48
     5ee:	9c e1       	ldi	r25, 0x1C	; 28
     5f0:	9b bd       	out	0x2b, r25	; 43
     5f2:	8a bd       	out	0x2a, r24	; 42
     5f4:	6e ce       	rjmp	.-804    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
     5f6:	8c ed       	ldi	r24, 0xDC	; 220
     5f8:	9d e1       	ldi	r25, 0x1D	; 29
     5fa:	9b bd       	out	0x2b, r25	; 43
     5fc:	8a bd       	out	0x2a, r24	; 42
	break;
     5fe:	69 ce       	rjmp	.-814    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
     600:	8a e3       	ldi	r24, 0x3A	; 58
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	9b bd       	out	0x2b, r25	; 43
     606:	8a bd       	out	0x2a, r24	; 42
	break;
     608:	64 ce       	rjmp	.-824    	; 0x2d2 <play_note+0x22>
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
     60a:	66 23       	and	r22, r22
     60c:	09 f4       	brne	.+2      	; 0x610 <play_note+0x360>
     60e:	35 c1       	rjmp	.+618    	; 0x87a <play_note+0x5ca>
     610:	80 e2       	ldi	r24, 0x20	; 32
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	9b bd       	out	0x2b, r25	; 43
     616:	8a bd       	out	0x2a, r24	; 42
     618:	5c ce       	rjmp	.-840    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
     61a:	66 23       	and	r22, r22
     61c:	09 f4       	brne	.+2      	; 0x620 <play_note+0x370>
     61e:	32 c1       	rjmp	.+612    	; 0x884 <play_note+0x5d4>
     620:	84 e2       	ldi	r24, 0x24	; 36
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	9b bd       	out	0x2b, r25	; 43
     626:	8a bd       	out	0x2a, r24	; 42
     628:	54 ce       	rjmp	.-856    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
     62a:	66 23       	and	r22, r22
     62c:	09 f4       	brne	.+2      	; 0x630 <play_note+0x380>
     62e:	76 c0       	rjmp	.+236    	; 0x71c <play_note+0x46c>
     630:	89 e2       	ldi	r24, 0x29	; 41
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	9b bd       	out	0x2b, r25	; 43
     636:	8a bd       	out	0x2a, r24	; 42
     638:	4c ce       	rjmp	.-872    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
     63a:	66 23       	and	r22, r22
     63c:	09 f4       	brne	.+2      	; 0x640 <play_note+0x390>
     63e:	78 c0       	rjmp	.+240    	; 0x730 <play_note+0x480>
     640:	81 e3       	ldi	r24, 0x31	; 49
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	9b bd       	out	0x2b, r25	; 43
     646:	8a bd       	out	0x2a, r24	; 42
     648:	44 ce       	rjmp	.-888    	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
     64a:	8b e2       	ldi	r24, 0x2B	; 43
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	9b bd       	out	0x2b, r25	; 43
     650:	8a bd       	out	0x2a, r24	; 42
	break;
     652:	3f ce       	rjmp	.-898    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
     654:	66 23       	and	r22, r22
     656:	09 f4       	brne	.+2      	; 0x65a <play_note+0x3aa>
     658:	93 c0       	rjmp	.+294    	; 0x780 <play_note+0x4d0>
     65a:	87 e3       	ldi	r24, 0x37	; 55
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	9b bd       	out	0x2b, r25	; 43
     660:	8a bd       	out	0x2a, r24	; 42
     662:	37 ce       	rjmp	.-914    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
     664:	66 23       	and	r22, r22
     666:	09 f4       	brne	.+2      	; 0x66a <play_note+0x3ba>
     668:	4f c0       	rjmp	.+158    	; 0x708 <play_note+0x458>
     66a:	88 e1       	ldi	r24, 0x18	; 24
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	9b bd       	out	0x2b, r25	; 43
     670:	8a bd       	out	0x2a, r24	; 42
     672:	2f ce       	rjmp	.-930    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
     674:	66 23       	and	r22, r22
     676:	09 f4       	brne	.+2      	; 0x67a <play_note+0x3ca>
     678:	f6 c0       	rjmp	.+492    	; 0x866 <play_note+0x5b6>
     67a:	82 eb       	ldi	r24, 0xB2	; 178
     67c:	94 e0       	ldi	r25, 0x04	; 4
     67e:	9b bd       	out	0x2b, r25	; 43
     680:	8a bd       	out	0x2a, r24	; 42
     682:	27 ce       	rjmp	.-946    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
     684:	66 23       	and	r22, r22
     686:	09 f4       	brne	.+2      	; 0x68a <play_note+0x3da>
     688:	16 c1       	rjmp	.+556    	; 0x8b6 <play_note+0x606>
     68a:	8d e8       	ldi	r24, 0x8D	; 141
     68c:	9a e0       	ldi	r25, 0x0A	; 10
     68e:	9b bd       	out	0x2b, r25	; 43
     690:	8a bd       	out	0x2a, r24	; 42
     692:	1f ce       	rjmp	.-962    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
     694:	66 23       	and	r22, r22
     696:	09 f4       	brne	.+2      	; 0x69a <play_note+0x3ea>
     698:	d7 c0       	rjmp	.+430    	; 0x848 <play_note+0x598>
     69a:	86 e1       	ldi	r24, 0x16	; 22
     69c:	9e e0       	ldi	r25, 0x0E	; 14
     69e:	9b bd       	out	0x2b, r25	; 43
     6a0:	8a bd       	out	0x2a, r24	; 42
     6a2:	17 ce       	rjmp	.-978    	; 0x2d2 <play_note+0x22>
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
     6a4:	66 23       	and	r22, r22
     6a6:	09 f4       	brne	.+2      	; 0x6aa <play_note+0x3fa>
     6a8:	f7 c0       	rjmp	.+494    	; 0x898 <play_note+0x5e8>
     6aa:	80 ec       	ldi	r24, 0xC0	; 192
     6ac:	90 e1       	ldi	r25, 0x10	; 16
     6ae:	9b bd       	out	0x2b, r25	; 43
     6b0:	8a bd       	out	0x2a, r24	; 42
     6b2:	0f ce       	rjmp	.-994    	; 0x2d2 <play_note+0x22>
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
     6b4:	66 23       	and	r22, r22
     6b6:	09 f4       	brne	.+2      	; 0x6ba <play_note+0x40a>
     6b8:	d1 c0       	rjmp	.+418    	; 0x85c <play_note+0x5ac>
     6ba:	8f e2       	ldi	r24, 0x2F	; 47
     6bc:	94 e0       	ldi	r25, 0x04	; 4
     6be:	9b bd       	out	0x2b, r25	; 43
     6c0:	8a bd       	out	0x2a, r24	; 42
     6c2:	07 ce       	rjmp	.-1010   	; 0x2d2 <play_note+0x22>
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
     6c4:	66 23       	and	r22, r22
     6c6:	09 f4       	brne	.+2      	; 0x6ca <play_note+0x41a>
     6c8:	f1 c0       	rjmp	.+482    	; 0x8ac <play_note+0x5fc>
     6ca:	87 e6       	ldi	r24, 0x67	; 103
     6cc:	99 e0       	ldi	r25, 0x09	; 9
     6ce:	9b bd       	out	0x2b, r25	; 43
     6d0:	8a bd       	out	0x2a, r24	; 42
     6d2:	ff cd       	rjmp	.-1026   	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
     6d4:	66 23       	and	r22, r22
     6d6:	09 f4       	brne	.+2      	; 0x6da <play_note+0x42a>
     6d8:	cb c0       	rjmp	.+406    	; 0x870 <play_note+0x5c0>
     6da:	8d e8       	ldi	r24, 0x8D	; 141
     6dc:	9c e0       	ldi	r25, 0x0C	; 12
     6de:	9b bd       	out	0x2b, r25	; 43
     6e0:	8a bd       	out	0x2a, r24	; 42
     6e2:	f7 cd       	rjmp	.-1042   	; 0x2d2 <play_note+0x22>
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
     6e4:	8d e5       	ldi	r24, 0x5D	; 93
     6e6:	96 e1       	ldi	r25, 0x16	; 22
     6e8:	9b bd       	out	0x2b, r25	; 43
     6ea:	8a bd       	out	0x2a, r24	; 42
	break;
     6ec:	f2 cd       	rjmp	.-1052   	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
     6ee:	66 23       	and	r22, r22
     6f0:	09 f4       	brne	.+2      	; 0x6f4 <play_note+0x444>
     6f2:	e6 c0       	rjmp	.+460    	; 0x8c0 <play_note+0x610>
     6f4:	86 e4       	ldi	r24, 0x46	; 70
     6f6:	95 e0       	ldi	r25, 0x05	; 5
     6f8:	9b bd       	out	0x2b, r25	; 43
     6fa:	8a bd       	out	0x2a, r24	; 42
     6fc:	ea cd       	rjmp	.-1068   	; 0x2d2 <play_note+0x22>
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
     6fe:	8d ee       	ldi	r24, 0xED	; 237
     700:	9e e0       	ldi	r25, 0x0E	; 14
     702:	9b bd       	out	0x2b, r25	; 43
     704:	8a bd       	out	0x2a, r24	; 42
	break;
     706:	e5 cd       	rjmp	.-1078   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
     708:	85 e1       	ldi	r24, 0x15	; 21
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	9b bd       	out	0x2b, r25	; 43
     70e:	8a bd       	out	0x2a, r24	; 42
     710:	e0 cd       	rjmp	.-1088   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
     712:	82 eb       	ldi	r24, 0xB2	; 178
     714:	97 e1       	ldi	r25, 0x17	; 23
     716:	9b bd       	out	0x2b, r25	; 43
     718:	8a bd       	out	0x2a, r24	; 42
     71a:	db cd       	rjmp	.-1098   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
     71c:	86 e2       	ldi	r24, 0x26	; 38
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	9b bd       	out	0x2b, r25	; 43
     722:	8a bd       	out	0x2a, r24	; 42
     724:	d6 cd       	rjmp	.-1108   	; 0x2d2 <play_note+0x22>
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
     726:	87 ee       	ldi	r24, 0xE7	; 231
     728:	97 e0       	ldi	r25, 0x07	; 7
     72a:	9b bd       	out	0x2b, r25	; 43
     72c:	8a bd       	out	0x2a, r24	; 42
     72e:	d1 cd       	rjmp	.-1118   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
     730:	8e e2       	ldi	r24, 0x2E	; 46
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9b bd       	out	0x2b, r25	; 43
     736:	8a bd       	out	0x2a, r24	; 42
     738:	cc cd       	rjmp	.-1128   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
     73a:	8b ee       	ldi	r24, 0xEB	; 235
     73c:	95 e0       	ldi	r25, 0x05	; 5
     73e:	9b bd       	out	0x2b, r25	; 43
     740:	8a bd       	out	0x2a, r24	; 42
     742:	c7 cd       	rjmp	.-1138   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
     744:	8a e7       	ldi	r24, 0x7A	; 122
     746:	91 e0       	ldi	r25, 0x01	; 1
     748:	9b bd       	out	0x2b, r25	; 43
     74a:	8a bd       	out	0x2a, r24	; 42
     74c:	c2 cd       	rjmp	.-1148   	; 0x2d2 <play_note+0x22>
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
     74e:	8e e3       	ldi	r24, 0x3E	; 62
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	9b bd       	out	0x2b, r25	; 43
     754:	8a bd       	out	0x2a, r24	; 42
     756:	bd cd       	rjmp	.-1158   	; 0x2d2 <play_note+0x22>
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
     758:	89 ef       	ldi	r24, 0xF9	; 249
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	9b bd       	out	0x2b, r25	; 43
     75e:	8a bd       	out	0x2a, r24	; 42
     760:	b8 cd       	rjmp	.-1168   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
     762:	8c eb       	ldi	r24, 0xBC	; 188
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	9b bd       	out	0x2b, r25	; 43
     768:	8a bd       	out	0x2a, r24	; 42
     76a:	b3 cd       	rjmp	.-1178   	; 0x2d2 <play_note+0x22>
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
     76c:	80 ec       	ldi	r24, 0xC0	; 192
     76e:	91 e1       	ldi	r25, 0x11	; 17
     770:	9b bd       	out	0x2b, r25	; 43
     772:	8a bd       	out	0x2a, r24	; 42
     774:	ae cd       	rjmp	.-1188   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
     776:	89 e0       	ldi	r24, 0x09	; 9
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	9b bd       	out	0x2b, r25	; 43
     77c:	8a bd       	out	0x2a, r24	; 42
     77e:	a9 cd       	rjmp	.-1198   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
     780:	84 e3       	ldi	r24, 0x34	; 52
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	9b bd       	out	0x2b, r25	; 43
     786:	8a bd       	out	0x2a, r24	; 42
     788:	a4 cd       	rjmp	.-1208   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
     78a:	8d e8       	ldi	r24, 0x8D	; 141
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	9b bd       	out	0x2b, r25	; 43
     790:	8a bd       	out	0x2a, r24	; 42
     792:	9f cd       	rjmp	.-1218   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
     794:	8e e9       	ldi	r24, 0x9E	; 158
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	9b bd       	out	0x2b, r25	; 43
     79a:	8a bd       	out	0x2a, r24	; 42
     79c:	9a cd       	rjmp	.-1228   	; 0x2d2 <play_note+0x22>
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
     79e:	8d e7       	ldi	r24, 0x7D	; 125
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	9b bd       	out	0x2b, r25	; 43
     7a4:	8a bd       	out	0x2a, r24	; 42
     7a6:	95 cd       	rjmp	.-1238   	; 0x2d2 <play_note+0x22>
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
     7a8:	83 ed       	ldi	r24, 0xD3	; 211
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	9b bd       	out	0x2b, r25	; 43
     7ae:	8a bd       	out	0x2a, r24	; 42
     7b0:	90 cd       	rjmp	.-1248   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
     7b2:	8d e5       	ldi	r24, 0x5D	; 93
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	9b bd       	out	0x2b, r25	; 43
     7b8:	8a bd       	out	0x2a, r24	; 42
     7ba:	8b cd       	rjmp	.-1258   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
     7bc:	86 e4       	ldi	r24, 0x46	; 70
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	9b bd       	out	0x2b, r25	; 43
     7c2:	8a bd       	out	0x2a, r24	; 42
     7c4:	86 cd       	rjmp	.-1268   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
     7c6:	89 e6       	ldi	r24, 0x69	; 105
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	9b bd       	out	0x2b, r25	; 43
     7cc:	8a bd       	out	0x2a, r24	; 42
     7ce:	81 cd       	rjmp	.-1278   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
     7d0:	8e e4       	ldi	r24, 0x4E	; 78
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	9b bd       	out	0x2b, r25	; 43
     7d6:	8a bd       	out	0x2a, r24	; 42
     7d8:	7c cd       	rjmp	.-1288   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
     7da:	8b e1       	ldi	r24, 0x1B	; 27
     7dc:	91 e0       	ldi	r25, 0x01	; 1
     7de:	9b bd       	out	0x2b, r25	; 43
     7e0:	8a bd       	out	0x2a, r24	; 42
     7e2:	77 cd       	rjmp	.-1298   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
     7e4:	85 ea       	ldi	r24, 0xA5	; 165
     7e6:	96 e0       	ldi	r25, 0x06	; 6
     7e8:	9b bd       	out	0x2b, r25	; 43
     7ea:	8a bd       	out	0x2a, r24	; 42
     7ec:	72 cd       	rjmp	.-1308   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
     7ee:	8c e7       	ldi	r24, 0x7C	; 124
     7f0:	92 e0       	ldi	r25, 0x02	; 2
     7f2:	9b bd       	out	0x2b, r25	; 43
     7f4:	8a bd       	out	0x2a, r24	; 42
     7f6:	6d cd       	rjmp	.-1318   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
     7f8:	88 ea       	ldi	r24, 0xA8	; 168
     7fa:	91 e0       	ldi	r25, 0x01	; 1
     7fc:	9b bd       	out	0x2b, r25	; 43
     7fe:	8a bd       	out	0x2a, r24	; 42
     800:	68 cd       	rjmp	.-1328   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
     802:	82 e5       	ldi	r24, 0x52	; 82
     804:	93 e0       	ldi	r25, 0x03	; 3
     806:	9b bd       	out	0x2b, r25	; 43
     808:	8a bd       	out	0x2a, r24	; 42
     80a:	63 cd       	rjmp	.-1338   	; 0x2d2 <play_note+0x22>
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
     80c:	8c ef       	ldi	r24, 0xFC	; 252
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	9b bd       	out	0x2b, r25	; 43
     812:	8a bd       	out	0x2a, r24	; 42
     814:	5e cd       	rjmp	.-1348   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
     816:	87 e3       	ldi	r24, 0x37	; 55
     818:	92 e0       	ldi	r25, 0x02	; 2
     81a:	9b bd       	out	0x2b, r25	; 43
     81c:	8a bd       	out	0x2a, r24	; 42
     81e:	59 cd       	rjmp	.-1358   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
     820:	8d e3       	ldi	r24, 0x3D	; 61
     822:	91 e0       	ldi	r25, 0x01	; 1
     824:	9b bd       	out	0x2b, r25	; 43
     826:	8a bd       	out	0x2a, r24	; 42
     828:	54 cd       	rjmp	.-1368   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
     82a:	89 e1       	ldi	r24, 0x19	; 25
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	9b bd       	out	0x2b, r25	; 43
     830:	8a bd       	out	0x2a, r24	; 42
     832:	4f cd       	rjmp	.-1378   	; 0x2d2 <play_note+0x22>
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
     834:	85 e0       	ldi	r24, 0x05	; 5
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	9b bd       	out	0x2b, r25	; 43
     83a:	8a bd       	out	0x2a, r24	; 42
     83c:	4a cd       	rjmp	.-1388   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
     83e:	8a e9       	ldi	r24, 0x9A	; 154
     840:	9a e1       	ldi	r25, 0x1A	; 26
     842:	9b bd       	out	0x2b, r25	; 43
     844:	8a bd       	out	0x2a, r24	; 42
     846:	45 cd       	rjmp	.-1398   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
     848:	8c e4       	ldi	r24, 0x4C	; 76
     84a:	9d e0       	ldi	r25, 0x0D	; 13
     84c:	9b bd       	out	0x2b, r25	; 43
     84e:	8a bd       	out	0x2a, r24	; 42
     850:	40 cd       	rjmp	.-1408   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
     852:	8d ee       	ldi	r24, 0xED	; 237
     854:	93 e1       	ldi	r25, 0x13	; 19
     856:	9b bd       	out	0x2b, r25	; 43
     858:	8a bd       	out	0x2a, r24	; 42
     85a:	3b cd       	rjmp	.-1418   	; 0x2d2 <play_note+0x22>
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
     85c:	83 ef       	ldi	r24, 0xF3	; 243
     85e:	93 e0       	ldi	r25, 0x03	; 3
     860:	9b bd       	out	0x2b, r25	; 43
     862:	8a bd       	out	0x2a, r24	; 42
     864:	36 cd       	rjmp	.-1428   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
     866:	8f e6       	ldi	r24, 0x6F	; 111
     868:	94 e0       	ldi	r25, 0x04	; 4
     86a:	9b bd       	out	0x2b, r25	; 43
     86c:	8a bd       	out	0x2a, r24	; 42
     86e:	31 cd       	rjmp	.-1438   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
     870:	88 ed       	ldi	r24, 0xD8	; 216
     872:	9b e0       	ldi	r25, 0x0B	; 11
     874:	9b bd       	out	0x2b, r25	; 43
     876:	8a bd       	out	0x2a, r24	; 42
     878:	2c cd       	rjmp	.-1448   	; 0x2d2 <play_note+0x22>
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
     87a:	8e e1       	ldi	r24, 0x1E	; 30
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	9b bd       	out	0x2b, r25	; 43
     880:	8a bd       	out	0x2a, r24	; 42
     882:	27 cd       	rjmp	.-1458   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
     884:	82 e2       	ldi	r24, 0x22	; 34
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	9b bd       	out	0x2b, r25	; 43
     88a:	8a bd       	out	0x2a, r24	; 42
     88c:	22 cd       	rjmp	.-1468   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
     88e:	85 ef       	ldi	r24, 0xF5	; 245
     890:	92 e0       	ldi	r25, 0x02	; 2
     892:	9b bd       	out	0x2b, r25	; 43
     894:	8a bd       	out	0x2a, r24	; 42
     896:	1d cd       	rjmp	.-1478   	; 0x2d2 <play_note+0x22>
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
     898:	80 ed       	ldi	r24, 0xD0	; 208
     89a:	9f e0       	ldi	r25, 0x0F	; 15
     89c:	9b bd       	out	0x2b, r25	; 43
     89e:	8a bd       	out	0x2a, r24	; 42
     8a0:	18 cd       	rjmp	.-1488   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
     8a2:	8d e0       	ldi	r24, 0x0D	; 13
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	9b bd       	out	0x2b, r25	; 43
     8a8:	8a bd       	out	0x2a, r24	; 42
     8aa:	13 cd       	rjmp	.-1498   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
     8ac:	8f ed       	ldi	r24, 0xDF	; 223
     8ae:	98 e0       	ldi	r25, 0x08	; 8
     8b0:	9b bd       	out	0x2b, r25	; 43
     8b2:	8a bd       	out	0x2a, r24	; 42
     8b4:	0e cd       	rjmp	.-1508   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
     8b6:	86 ef       	ldi	r24, 0xF6	; 246
     8b8:	99 e0       	ldi	r25, 0x09	; 9
     8ba:	9b bd       	out	0x2b, r25	; 43
     8bc:	8a bd       	out	0x2a, r24	; 42
     8be:	09 cd       	rjmp	.-1518   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
     8c0:	8a ef       	ldi	r24, 0xFA	; 250
     8c2:	94 e0       	ldi	r25, 0x04	; 4
     8c4:	9b bd       	out	0x2b, r25	; 43
     8c6:	8a bd       	out	0x2a, r24	; 42
     8c8:	04 cd       	rjmp	.-1528   	; 0x2d2 <play_note+0x22>

000008ca <song0>:
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8ca:	86 34       	cpi	r24, 0x46	; 70
     8cc:	91 05       	cpc	r25, r1
     8ce:	20 f0       	brcs	.+8      	; 0x8d8 <song0+0xe>
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	80 93 85 01 	sts	0x0185, r24
     8d6:	08 95       	ret
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8d8:	fc 01       	movw	r30, r24
     8da:	e2 57       	subi	r30, 0x72	; 114
     8dc:	ff 4f       	sbci	r31, 0xFF	; 255
     8de:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
     8e2:	22 e0       	ldi	r18, 0x02	; 2
     8e4:	44 e0       	ldi	r20, 0x04	; 4
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	81 e4       	ldi	r24, 0x41	; 65
     8ea:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
     8ee:	26 e0       	ldi	r18, 0x06	; 6
     8f0:	44 e0       	ldi	r20, 0x04	; 4
     8f2:	60 e0       	ldi	r22, 0x00	; 0
     8f4:	81 e4       	ldi	r24, 0x41	; 65
     8f6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
     8fa:	22 e0       	ldi	r18, 0x02	; 2
     8fc:	44 e0       	ldi	r20, 0x04	; 4
     8fe:	61 e0       	ldi	r22, 0x01	; 1
     900:	81 e4       	ldi	r24, 0x41	; 65
     902:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
     906:	28 e0       	ldi	r18, 0x08	; 8
     908:	44 e0       	ldi	r20, 0x04	; 4
     90a:	60 e0       	ldi	r22, 0x00	; 0
     90c:	84 e4       	ldi	r24, 0x44	; 68
     90e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
     912:	28 e0       	ldi	r18, 0x08	; 8
     914:	44 e0       	ldi	r20, 0x04	; 4
     916:	60 e0       	ldi	r22, 0x00	; 0
     918:	86 e4       	ldi	r24, 0x46	; 70
     91a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
     91e:	26 e0       	ldi	r18, 0x06	; 6
     920:	44 e0       	ldi	r20, 0x04	; 4
     922:	61 e0       	ldi	r22, 0x01	; 1
     924:	82 e4       	ldi	r24, 0x42	; 66
     926:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
     92a:	28 e0       	ldi	r18, 0x08	; 8
     92c:	44 e0       	ldi	r20, 0x04	; 4
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	83 e4       	ldi	r24, 0x43	; 67
     932:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
     936:	28 e0       	ldi	r18, 0x08	; 8
     938:	44 e0       	ldi	r20, 0x04	; 4
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	81 e4       	ldi	r24, 0x41	; 65
     93e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 67: play_note('G', 0, 4, 8);
     942:	28 e0       	ldi	r18, 0x08	; 8
     944:	44 e0       	ldi	r20, 0x04	; 4
     946:	60 e0       	ldi	r22, 0x00	; 0
     948:	87 e4       	ldi	r24, 0x47	; 71
     94a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
     94e:	28 e0       	ldi	r18, 0x08	; 8
     950:	44 e0       	ldi	r20, 0x04	; 4
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	85 e4       	ldi	r24, 0x45	; 69
     956:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
     95a:	20 e1       	ldi	r18, 0x10	; 16
     95c:	44 e0       	ldi	r20, 0x04	; 4
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	81 e4       	ldi	r24, 0x41	; 65
     962:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
     966:	24 e0       	ldi	r18, 0x04	; 4
     968:	45 e0       	ldi	r20, 0x05	; 5
     96a:	60 e0       	ldi	r22, 0x00	; 0
     96c:	83 e4       	ldi	r24, 0x43	; 67
     96e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 65: play_note('D', 0, 5, 4);
     972:	24 e0       	ldi	r18, 0x04	; 4
     974:	45 e0       	ldi	r20, 0x05	; 5
     976:	60 e0       	ldi	r22, 0x00	; 0
     978:	84 e4       	ldi	r24, 0x44	; 68
     97a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     97e:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     980:	10 92 98 01 	sts	0x0198, r1
     984:	10 92 97 01 	sts	0x0197, r1
  max_beat = duration;
     988:	88 e0       	ldi	r24, 0x08	; 8
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	90 93 94 01 	sts	0x0194, r25
     990:	80 93 93 01 	sts	0x0193, r24
     994:	08 95       	ret
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     996:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     998:	10 92 98 01 	sts	0x0198, r1
     99c:	10 92 97 01 	sts	0x0197, r1
  max_beat = duration;
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	90 93 94 01 	sts	0x0194, r25
     9a8:	80 93 93 01 	sts	0x0193, r24
     9ac:	08 95       	ret
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
     9ae:	20 e1       	ldi	r18, 0x10	; 16
     9b0:	44 e0       	ldi	r20, 0x04	; 4
     9b2:	61 e0       	ldi	r22, 0x01	; 1
     9b4:	82 e4       	ldi	r24, 0x42	; 66
     9b6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
     9ba:	28 e0       	ldi	r18, 0x08	; 8
     9bc:	44 e0       	ldi	r20, 0x04	; 4
     9be:	61 e0       	ldi	r22, 0x01	; 1
     9c0:	82 e4       	ldi	r24, 0x42	; 66
     9c2:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
     9c6:	28 e1       	ldi	r18, 0x18	; 24
     9c8:	44 e0       	ldi	r20, 0x04	; 4
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	87 e4       	ldi	r24, 0x47	; 71
     9ce:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
     9d2:	20 e1       	ldi	r18, 0x10	; 16
     9d4:	45 e0       	ldi	r20, 0x05	; 5
     9d6:	60 e0       	ldi	r22, 0x00	; 0
     9d8:	84 e4       	ldi	r24, 0x44	; 68
     9da:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     9de:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     9e0:	10 92 98 01 	sts	0x0198, r1
     9e4:	10 92 97 01 	sts	0x0197, r1
  max_beat = duration;
     9e8:	82 e0       	ldi	r24, 0x02	; 2
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	90 93 94 01 	sts	0x0194, r25
     9f0:	80 93 93 01 	sts	0x0193, r24
     9f4:	08 95       	ret
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
     9f6:	24 e0       	ldi	r18, 0x04	; 4
     9f8:	44 e0       	ldi	r20, 0x04	; 4
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	81 e4       	ldi	r24, 0x41	; 65
     9fe:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
     a02:	26 e0       	ldi	r18, 0x06	; 6
     a04:	44 e0       	ldi	r20, 0x04	; 4
     a06:	60 e0       	ldi	r22, 0x00	; 0
     a08:	87 e4       	ldi	r24, 0x47	; 71
     a0a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
     a0e:	24 e0       	ldi	r18, 0x04	; 4
     a10:	44 e0       	ldi	r20, 0x04	; 4
     a12:	61 e0       	ldi	r22, 0x01	; 1
     a14:	87 e4       	ldi	r24, 0x47	; 71
     a16:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
     a1a:	28 e0       	ldi	r18, 0x08	; 8
     a1c:	44 e0       	ldi	r20, 0x04	; 4
     a1e:	61 e0       	ldi	r22, 0x01	; 1
     a20:	87 e4       	ldi	r24, 0x47	; 71
     a22:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
     a26:	23 e0       	ldi	r18, 0x03	; 3
     a28:	44 e0       	ldi	r20, 0x04	; 4
     a2a:	60 e0       	ldi	r22, 0x00	; 0
     a2c:	87 e4       	ldi	r24, 0x47	; 71
     a2e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
     a32:	20 e1       	ldi	r18, 0x10	; 16
     a34:	44 e0       	ldi	r20, 0x04	; 4
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	84 e4       	ldi	r24, 0x44	; 68
     a3a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
     a3e:	20 e1       	ldi	r18, 0x10	; 16
     a40:	45 e0       	ldi	r20, 0x05	; 5
     a42:	60 e0       	ldi	r22, 0x00	; 0
     a44:	83 e4       	ldi	r24, 0x43	; 67
     a46:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
     a4a:	22 e0       	ldi	r18, 0x02	; 2
     a4c:	44 e0       	ldi	r20, 0x04	; 4
     a4e:	61 e0       	ldi	r22, 0x01	; 1
     a50:	82 e4       	ldi	r24, 0x42	; 66
     a52:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
     a56:	24 e0       	ldi	r18, 0x04	; 4
     a58:	45 e0       	ldi	r20, 0x05	; 5
     a5a:	61 e0       	ldi	r22, 0x01	; 1
     a5c:	84 e4       	ldi	r24, 0x44	; 68
     a5e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
     a62:	24 e0       	ldi	r18, 0x04	; 4
     a64:	44 e0       	ldi	r20, 0x04	; 4
     a66:	61 e0       	ldi	r22, 0x01	; 1
     a68:	81 e4       	ldi	r24, 0x41	; 65
     a6a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
     a6e:	28 e0       	ldi	r18, 0x08	; 8
     a70:	44 e0       	ldi	r20, 0x04	; 4
     a72:	60 e0       	ldi	r22, 0x00	; 0
     a74:	82 e4       	ldi	r24, 0x42	; 66
     a76:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
     a7a:	28 e1       	ldi	r18, 0x18	; 24
     a7c:	44 e0       	ldi	r20, 0x04	; 4
     a7e:	60 e0       	ldi	r22, 0x00	; 0
     a80:	86 e4       	ldi	r24, 0x46	; 70
     a82:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
     a86:	27 e0       	ldi	r18, 0x07	; 7
     a88:	44 e0       	ldi	r20, 0x04	; 4
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	87 e4       	ldi	r24, 0x47	; 71
     a8e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>

00000a92 <play_song>:
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     a92:	86 2f       	mov	r24, r22
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000a9a <music_off>:
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     a9a:	10 92 85 01 	sts	0x0185, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     a9e:	8e b5       	in	r24, 0x2e	; 46
     aa0:	8c 7f       	andi	r24, 0xFC	; 252
     aa2:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     aa4:	92 9a       	sbi	0x12, 2	; 18
     aa6:	08 95       	ret

00000aa8 <music_on>:
}

void music_on(void) {
  //this starts the alarm timer running
  notes=0;
     aa8:	10 92 85 01 	sts	0x0185, r1
  TCCR1B |= (1<<CS11)|(1<<CS10);
     aac:	8e b5       	in	r24, 0x2e	; 46
     aae:	83 60       	ori	r24, 0x03	; 3
     ab0:	8e bd       	out	0x2e, r24	; 46
  //unmutes the output
  PORTD &= unmute;
     ab2:	92 98       	cbi	0x12, 2	; 18
  //and starts the selected song
  play_song(song, notes);
     ab4:	80 91 85 01 	lds	r24, 0x0185
     ab8:	90 91 92 01 	lds	r25, 0x0192
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000ac2 <music_init>:
  play_song(song, notes);
}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  DDRD |= (1<<PD7);
     ac2:	8f 9a       	sbi	0x11, 7	; 17
  TIMSK |= (1<<OCIE1A) | (1<<TOIE0);  //enable timer interrupt 1 on compare
     ac4:	87 b7       	in	r24, 0x37	; 55
     ac6:	81 61       	ori	r24, 0x11	; 17
     ac8:	87 bf       	out	0x37, r24	; 55
  TCCR1A = 0x00;         //TCNT1, normal port operation
     aca:	1f bc       	out	0x2f, r1	; 47
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
     acc:	8e b5       	in	r24, 0x2e	; 46
     ace:	88 60       	ori	r24, 0x08	; 8
     ad0:	8e bd       	out	0x2e, r24	; 46
  TCCR1C = 0x00;         //no forced compare
     ad2:	10 92 7a 00 	sts	0x007A, r1
  OCR1A = 0x0033;        //(use to vary alarm frequency)
     ad6:	83 e3       	ldi	r24, 0x33	; 51
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	9b bd       	out	0x2b, r25	; 43
     adc:	8a bd       	out	0x2a, r24	; 42
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     ade:	10 92 85 01 	sts	0x0185, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     ae2:	8e b5       	in	r24, 0x2e	; 46
     ae4:	8c 7f       	andi	r24, 0xFC	; 252
     ae6:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     ae8:	92 9a       	sbi	0x12, 2	; 18
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0033;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
     aea:	10 92 98 01 	sts	0x0198, r1
     aee:	10 92 97 01 	sts	0x0197, r1
  max_beat = 0;
     af2:	10 92 94 01 	sts	0x0194, r1
     af6:	10 92 93 01 	sts	0x0193, r1
  notes = 0;
     afa:	10 92 85 01 	sts	0x0185, r1
  song = 0;              //beaver fight song
     afe:	10 92 92 01 	sts	0x0192, r1
     b02:	08 95       	ret

00000b04 <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b04:	20 91 71 01 	lds	r18, 0x0171
     b08:	30 91 72 01 	lds	r19, 0x0172
     b0c:	22 0f       	add	r18, r18
     b0e:	33 1f       	adc	r19, r19
     b10:	49 b3       	in	r20, 0x19	; 25
     b12:	50 e0       	ldi	r21, 0x00	; 0
     b14:	02 c0       	rjmp	.+4      	; 0xb1a <chk_buttons+0x16>
     b16:	55 95       	asr	r21
     b18:	47 95       	ror	r20
     b1a:	8a 95       	dec	r24
     b1c:	e2 f7       	brpl	.-8      	; 0xb16 <chk_buttons+0x12>
     b1e:	40 fd       	sbrc	r20, 0
     b20:	0e c0       	rjmp	.+28     	; 0xb3e <chk_buttons+0x3a>
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	90 ee       	ldi	r25, 0xE0	; 224
     b26:	28 2b       	or	r18, r24
     b28:	39 2b       	or	r19, r25
     b2a:	30 93 72 01 	sts	0x0172, r19
     b2e:	20 93 71 01 	sts	0x0171, r18
	if (state == 0xF000){
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	21 15       	cp	r18, r1
     b36:	30 4f       	sbci	r19, 0xF0	; 240
     b38:	09 f0       	breq	.+2      	; 0xb3c <chk_buttons+0x38>
     b3a:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}
	return 0;
}
     b3c:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	90 ee       	ldi	r25, 0xE0	; 224
     b42:	f1 cf       	rjmp	.-30     	; 0xb26 <chk_buttons+0x22>

00000b44 <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
     b44:	81 11       	cpse	r24, r1
     b46:	02 c0       	rjmp	.+4      	; 0xb4c <int2seg+0x8>
		return ZERO;
     b48:	80 ec       	ldi	r24, 0xC0	; 192
     b4a:	08 95       	ret
	}
	else if(number == 1 ){
     b4c:	81 30       	cpi	r24, 0x01	; 1
     b4e:	91 f0       	breq	.+36     	; 0xb74 <int2seg+0x30>
		return ONE;
	}
	else if(number == 2 ){
     b50:	82 30       	cpi	r24, 0x02	; 2
     b52:	91 f0       	breq	.+36     	; 0xb78 <int2seg+0x34>
		return TWO;
	}
	else if(number == 3 ){
     b54:	83 30       	cpi	r24, 0x03	; 3
     b56:	a1 f0       	breq	.+40     	; 0xb80 <int2seg+0x3c>
		return THREE;
	}
	else if(number == 4 ){
     b58:	84 30       	cpi	r24, 0x04	; 4
     b5a:	81 f0       	breq	.+32     	; 0xb7c <int2seg+0x38>
		return FOUR;
	}
	else if(number == 5 ){
     b5c:	85 30       	cpi	r24, 0x05	; 5
     b5e:	91 f0       	breq	.+36     	; 0xb84 <int2seg+0x40>
		return FIVE;
	}
	else if(number == 6 ){
     b60:	86 30       	cpi	r24, 0x06	; 6
     b62:	91 f0       	breq	.+36     	; 0xb88 <int2seg+0x44>
		return  SIX;
	}
	else if(number == 7 ){
     b64:	87 30       	cpi	r24, 0x07	; 7
     b66:	91 f0       	breq	.+36     	; 0xb8c <int2seg+0x48>
		return SEVEN;
	}
	else if(number == 8 ){
     b68:	88 30       	cpi	r24, 0x08	; 8
     b6a:	91 f0       	breq	.+36     	; 0xb90 <int2seg+0x4c>
		return EIGHT;
	}
	else if(number == 9 ){
     b6c:	89 30       	cpi	r24, 0x09	; 9
     b6e:	91 f0       	breq	.+36     	; 0xb94 <int2seg+0x50>
		return NINE;
	}
	else{ 
		return 0;
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	08 95       	ret
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
		return ZERO;
	}
	else if(number == 1 ){
		return ONE;
     b74:	89 ef       	ldi	r24, 0xF9	; 249
     b76:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
     b78:	84 ea       	ldi	r24, 0xA4	; 164
     b7a:	08 95       	ret
	}
	else if(number == 3 ){
		return THREE;
	}
	else if(number == 4 ){
		return FOUR;
     b7c:	89 e9       	ldi	r24, 0x99	; 153
     b7e:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
	}
	else if(number == 3 ){
		return THREE;
     b80:	80 eb       	ldi	r24, 0xB0	; 176
     b82:	08 95       	ret
	}
	else if(number == 4 ){
		return FOUR;
	}
	else if(number == 5 ){
		return FIVE;
     b84:	82 e9       	ldi	r24, 0x92	; 146
     b86:	08 95       	ret
	}
	else if(number == 6 ){
		return  SIX;
     b88:	82 e8       	ldi	r24, 0x82	; 130
     b8a:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
     b8c:	88 ef       	ldi	r24, 0xF8	; 248
		return NINE;
	}
	else{ 
		return 0;
	}
}
     b8e:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
	}
	else if(number == 8 ){
		return EIGHT;
     b90:	80 e8       	ldi	r24, 0x80	; 128
     b92:	08 95       	ret
	}
	else if(number == 9 ){
		return NINE;
     b94:	80 e9       	ldi	r24, 0x90	; 144
     b96:	08 95       	ret

00000b98 <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
     b98:	ff 92       	push	r15
     b9a:	0f 93       	push	r16
     b9c:	1f 93       	push	r17
     b9e:	cf 93       	push	r28
     ba0:	df 93       	push	r29
     ba2:	ec 01       	movw	r28, r24
	//determine how many digits there are 
	//int digit;
	// Break down the digits

	if(ticker%2 == 1){
     ba4:	80 91 73 01 	lds	r24, 0x0173
     ba8:	80 ff       	sbrs	r24, 0
     baa:	82 c0       	rjmp	.+260    	; 0xcb0 <segsum+0x118>
		segment_data[2] = 0xFC;
     bac:	8c ef       	ldi	r24, 0xFC	; 252
     bae:	80 93 a4 01 	sts	0x01A4, r24
		segment_data[2] = 0xFF;
	} 
	//When setting alarm is on)
	//break up decimal sum into 4 digit-segments

	segment_data[0] = int2seg(sum % 10); //ones
     bb2:	9e 01       	movw	r18, r28
     bb4:	ad ec       	ldi	r26, 0xCD	; 205
     bb6:	bc ec       	ldi	r27, 0xCC	; 204
     bb8:	0e 94 b8 10 	call	0x2170	; 0x2170 <__umulhisi3>
     bbc:	96 95       	lsr	r25
     bbe:	87 95       	ror	r24
     bc0:	96 95       	lsr	r25
     bc2:	87 95       	ror	r24
     bc4:	96 95       	lsr	r25
     bc6:	87 95       	ror	r24
     bc8:	3c 2f       	mov	r19, r28
     bca:	2a e0       	ldi	r18, 0x0A	; 10
     bcc:	82 9f       	mul	r24, r18
     bce:	30 19       	sub	r19, r0
     bd0:	11 24       	eor	r1, r1
     bd2:	83 2f       	mov	r24, r19
     bd4:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     bd8:	f8 2e       	mov	r15, r24
	segment_data[1] = int2seg((sum % 100)/10); //tens
     bda:	9e 01       	movw	r18, r28
     bdc:	36 95       	lsr	r19
     bde:	27 95       	ror	r18
     be0:	36 95       	lsr	r19
     be2:	27 95       	ror	r18
     be4:	ab e7       	ldi	r26, 0x7B	; 123
     be6:	b4 e1       	ldi	r27, 0x14	; 20
     be8:	0e 94 b8 10 	call	0x2170	; 0x2170 <__umulhisi3>
     bec:	96 95       	lsr	r25
     bee:	87 95       	ror	r24
     bf0:	44 e6       	ldi	r20, 0x64	; 100
     bf2:	48 9f       	mul	r20, r24
     bf4:	90 01       	movw	r18, r0
     bf6:	49 9f       	mul	r20, r25
     bf8:	30 0d       	add	r19, r0
     bfa:	11 24       	eor	r1, r1
     bfc:	ce 01       	movw	r24, r28
     bfe:	82 1b       	sub	r24, r18
     c00:	93 0b       	sbc	r25, r19
     c02:	9c 01       	movw	r18, r24
     c04:	ad ec       	ldi	r26, 0xCD	; 205
     c06:	bc ec       	ldi	r27, 0xCC	; 204
     c08:	0e 94 b8 10 	call	0x2170	; 0x2170 <__umulhisi3>
     c0c:	96 95       	lsr	r25
     c0e:	87 95       	ror	r24
     c10:	96 95       	lsr	r25
     c12:	87 95       	ror	r24
     c14:	96 95       	lsr	r25
     c16:	87 95       	ror	r24
     c18:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c1c:	80 93 a3 01 	sts	0x01A3, r24
	//segment_data[2] = 1; //decimal
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
     c20:	9e 01       	movw	r18, r28
     c22:	36 95       	lsr	r19
     c24:	27 95       	ror	r18
     c26:	36 95       	lsr	r19
     c28:	27 95       	ror	r18
     c2a:	36 95       	lsr	r19
     c2c:	27 95       	ror	r18
     c2e:	a5 ec       	ldi	r26, 0xC5	; 197
     c30:	b0 e2       	ldi	r27, 0x20	; 32
     c32:	0e 94 b8 10 	call	0x2170	; 0x2170 <__umulhisi3>
     c36:	8c 01       	movw	r16, r24
     c38:	12 95       	swap	r17
     c3a:	02 95       	swap	r16
     c3c:	0f 70       	andi	r16, 0x0F	; 15
     c3e:	01 27       	eor	r16, r17
     c40:	1f 70       	andi	r17, 0x0F	; 15
     c42:	01 27       	eor	r16, r17
     c44:	48 ee       	ldi	r20, 0xE8	; 232
     c46:	53 e0       	ldi	r21, 0x03	; 3
     c48:	04 9f       	mul	r16, r20
     c4a:	90 01       	movw	r18, r0
     c4c:	05 9f       	mul	r16, r21
     c4e:	30 0d       	add	r19, r0
     c50:	14 9f       	mul	r17, r20
     c52:	30 0d       	add	r19, r0
     c54:	11 24       	eor	r1, r1
     c56:	ce 01       	movw	r24, r28
     c58:	82 1b       	sub	r24, r18
     c5a:	93 0b       	sbc	r25, r19
     c5c:	9c 01       	movw	r18, r24
     c5e:	36 95       	lsr	r19
     c60:	27 95       	ror	r18
     c62:	36 95       	lsr	r19
     c64:	27 95       	ror	r18
     c66:	ab e7       	ldi	r26, 0x7B	; 123
     c68:	b4 e1       	ldi	r27, 0x14	; 20
     c6a:	0e 94 b8 10 	call	0x2170	; 0x2170 <__umulhisi3>
     c6e:	96 95       	lsr	r25
     c70:	87 95       	ror	r24
     c72:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c76:	80 93 a5 01 	sts	0x01A5, r24
	segment_data[4] = int2seg(sum/1000); //thousands
     c7a:	80 2f       	mov	r24, r16
     c7c:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c80:	80 93 a6 01 	sts	0x01A6, r24
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
     c84:	80 91 57 01 	lds	r24, 0x0157
     c88:	88 23       	and	r24, r24
     c8a:	21 f0       	breq	.+8      	; 0xc94 <segsum+0xfc>
     c8c:	80 91 82 01 	lds	r24, 0x0182
     c90:	81 11       	cpse	r24, r1
     c92:	12 c0       	rjmp	.+36     	; 0xcb8 <segsum+0x120>
		segment_data[0] &= 0x7F;
	}
	else{
		segment_data[0] |= 0b10000000;
     c94:	8f 2d       	mov	r24, r15
     c96:	80 68       	ori	r24, 0x80	; 128
     c98:	80 93 a2 01 	sts	0x01A2, r24
	}
	if(mode == 1 && blink){
     c9c:	80 91 79 01 	lds	r24, 0x0179
     ca0:	81 30       	cpi	r24, 0x01	; 1
     ca2:	91 f0       	breq	.+36     	; 0xcc8 <segsum+0x130>
		segment_data[4] = 0xFF;
		segment_data[3] = 0xFF;
		segment_data[1] = 0xFF;
		segment_data[0] = 0xFF;
	}
}//segment_sum
     ca4:	df 91       	pop	r29
     ca6:	cf 91       	pop	r28
     ca8:	1f 91       	pop	r17
     caa:	0f 91       	pop	r16
     cac:	ff 90       	pop	r15
     cae:	08 95       	ret

	if(ticker%2 == 1){
		segment_data[2] = 0xFC;
	}
	else{
		segment_data[2] = 0xFF;
     cb0:	8f ef       	ldi	r24, 0xFF	; 255
     cb2:	80 93 a4 01 	sts	0x01A4, r24
     cb6:	7d cf       	rjmp	.-262    	; 0xbb2 <segsum+0x1a>
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
	segment_data[4] = int2seg(sum/1000); //thousands
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
		segment_data[0] &= 0x7F;
     cb8:	8f 2d       	mov	r24, r15
     cba:	8f 77       	andi	r24, 0x7F	; 127
     cbc:	80 93 a2 01 	sts	0x01A2, r24
	}
	else{
		segment_data[0] |= 0b10000000;
	}
	if(mode == 1 && blink){
     cc0:	80 91 79 01 	lds	r24, 0x0179
     cc4:	81 30       	cpi	r24, 0x01	; 1
     cc6:	71 f7       	brne	.-36     	; 0xca4 <segsum+0x10c>
     cc8:	80 91 4e 01 	lds	r24, 0x014E
     ccc:	88 23       	and	r24, r24
     cce:	51 f3       	breq	.-44     	; 0xca4 <segsum+0x10c>
		segment_data[4] = 0xFF;
     cd0:	8f ef       	ldi	r24, 0xFF	; 255
     cd2:	80 93 a6 01 	sts	0x01A6, r24
		segment_data[3] = 0xFF;
     cd6:	80 93 a5 01 	sts	0x01A5, r24
		segment_data[1] = 0xFF;
     cda:	80 93 a3 01 	sts	0x01A3, r24
		segment_data[0] = 0xFF;
     cde:	80 93 a2 01 	sts	0x01A2, r24
	}
}//segment_sum
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	08 95       	ret

00000cee <button_routine>:
//***********************************************************************************
void button_routine(){
     cee:	ff 92       	push	r15
     cf0:	0f 93       	push	r16
     cf2:	1f 93       	push	r17
     cf4:	cf 93       	push	r28
     cf6:	df 93       	push	r29
	// L -> R
	// 3 2 1 0 7 6 5 4
	static uint8_t rotate_LCD_mode = 1;
	uint8_t button = 0;
	//static int previous_mode;   
	DDRA  = 0x00; // PORTA input mode
     cf8:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0xFF; //Pull ups
     cfa:	8f ef       	ldi	r24, 0xFF	; 255
     cfc:	8b bb       	out	0x1b, r24	; 27
	__asm__ __volatile__ ("nop");
     cfe:	00 00       	nop
	__asm__ __volatile__ ("nop");
     d00:	00 00       	nop
	//enable tristate buffer for pushbutton switches
	PORTB |= 0x70; //Set S2,S1,S0 to 111
     d02:	88 b3       	in	r24, 0x18	; 24
     d04:	80 67       	ori	r24, 0x70	; 112
     d06:	88 bb       	out	0x18, r24	; 24
	__asm__ __volatile__ ("nop");
     d08:	00 00       	nop
	__asm__ __volatile__ ("nop");
     d0a:	00 00       	nop
     d0c:	20 e0       	ldi	r18, 0x00	; 0
     d0e:	30 e0       	ldi	r19, 0x00	; 0
				case 7:
					if(alarm_on && music_status){
						music_off();
						music_status = 0;
					}
					alarm_on = !alarm_on;
     d10:	01 e0       	ldi	r16, 0x01	; 1
					break;
				case 4:
					//temp_mode = !temp_mode;
					rotate_LCD_mode++;
					clear_LCD = 1;
					LCD_mode = rotate_LCD_mode%3;
     d12:	cb ea       	ldi	r28, 0xAB	; 171
     d14:	fc 2e       	mov	r15, r28
					if(!LCD_mode){
						mode = 4;
     d16:	14 e0       	ldi	r17, 0x04	; 4
				case 3:
					if(mode == 3){
						mode = 0;			
					}
					else{
						mode = 3;
     d18:	d3 e0       	ldi	r29, 0x03	; 3
				case 2:
					if(mode == 2){
						mode = 0;	
					}
					else{
						mode = 2;
     d1a:	c2 e0       	ldi	r28, 0x02	; 2
     d1c:	10 c0       	rjmp	.+32     	; 0xd3e <button_routine+0x50>
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d1e:	61 e0       	ldi	r22, 0x01	; 1
     d20:	70 ee       	ldi	r23, 0xE0	; 224
     d22:	46 2b       	or	r20, r22
     d24:	57 2b       	or	r21, r23
     d26:	50 93 72 01 	sts	0x0172, r21
     d2a:	40 93 71 01 	sts	0x0171, r20
	if (state == 0xF000){
     d2e:	41 15       	cp	r20, r1
     d30:	50 4f       	sbci	r21, 0xF0	; 240
     d32:	c9 f0       	breq	.+50     	; 0xd66 <button_routine+0x78>
     d34:	2f 5f       	subi	r18, 0xFF	; 255
     d36:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d38:	28 30       	cpi	r18, 0x08	; 8
     d3a:	31 05       	cpc	r19, r1
     d3c:	11 f1       	breq	.+68     	; 0xd82 <button_routine+0x94>
     d3e:	82 2f       	mov	r24, r18
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d40:	40 91 71 01 	lds	r20, 0x0171
     d44:	50 91 72 01 	lds	r21, 0x0172
     d48:	44 0f       	add	r20, r20
     d4a:	55 1f       	adc	r21, r21
     d4c:	69 b3       	in	r22, 0x19	; 25
     d4e:	70 e0       	ldi	r23, 0x00	; 0
     d50:	02 2e       	mov	r0, r18
     d52:	02 c0       	rjmp	.+4      	; 0xd58 <button_routine+0x6a>
     d54:	75 95       	asr	r23
     d56:	67 95       	ror	r22
     d58:	0a 94       	dec	r0
     d5a:	e2 f7       	brpl	.-8      	; 0xd54 <button_routine+0x66>
     d5c:	60 ff       	sbrs	r22, 0
     d5e:	df cf       	rjmp	.-66     	; 0xd1e <button_routine+0x30>
     d60:	60 e0       	ldi	r22, 0x00	; 0
     d62:	70 ee       	ldi	r23, 0xE0	; 224
     d64:	de cf       	rjmp	.-68     	; 0xd22 <button_routine+0x34>
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
     d66:	90 e0       	ldi	r25, 0x00	; 0
     d68:	01 97       	sbiw	r24, 0x01	; 1
     d6a:	87 30       	cpi	r24, 0x07	; 7
     d6c:	91 05       	cpc	r25, r1
     d6e:	98 f0       	brcs	.+38     	; 0xd96 <button_routine+0xa8>
				case 0:  
					radio = 1;
     d70:	00 93 5f 01 	sts	0x015F, r16
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     d74:	00 93 61 01 	sts	0x0161, r16
     d78:	2f 5f       	subi	r18, 0xFF	; 255
     d7a:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d7c:	28 30       	cpi	r18, 0x08	; 8
     d7e:	31 05       	cpc	r19, r1
     d80:	f1 f6       	brne	.-68     	; 0xd3e <button_routine+0x50>
					break;
			}
			bar_graph_flag = 1;	
		}
	}
	DDRA = 0xFF;  //switch PORTA to output
     d82:	8f ef       	ldi	r24, 0xFF	; 255
     d84:	8a bb       	out	0x1a, r24	; 26
	__asm__ __volatile__ ("nop"); //Buffer
     d86:	00 00       	nop
	__asm__ __volatile__ ("nop"); //Buffer 
     d88:	00 00       	nop

}
     d8a:	df 91       	pop	r29
     d8c:	cf 91       	pop	r28
     d8e:	1f 91       	pop	r17
     d90:	0f 91       	pop	r16
     d92:	ff 90       	pop	r15
     d94:	08 95       	ret
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
     d96:	8c 52       	subi	r24, 0x2C	; 44
     d98:	9f 4f       	sbci	r25, 0xFF	; 255
     d9a:	fc 01       	movw	r30, r24
     d9c:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
					else{
						mode = 0;
					}
					break;
				case 5:
					show_ampm = !show_ampm;
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	90 91 82 01 	lds	r25, 0x0182
     da6:	91 11       	cpse	r25, r1
     da8:	80 e0       	ldi	r24, 0x00	; 0
     daa:	80 93 82 01 	sts	0x0182, r24
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     dae:	00 93 61 01 	sts	0x0161, r16
     db2:	e2 cf       	rjmp	.-60     	; 0xd78 <button_routine+0x8a>
						mode = 3;
					}
					break;
				case 4:
					//temp_mode = !temp_mode;
					rotate_LCD_mode++;
     db4:	90 91 00 01 	lds	r25, 0x0100
     db8:	9f 5f       	subi	r25, 0xFF	; 255
     dba:	90 93 00 01 	sts	0x0100, r25
					clear_LCD = 1;
     dbe:	00 93 96 01 	sts	0x0196, r16
					LCD_mode = rotate_LCD_mode%3;
     dc2:	9f 9d       	mul	r25, r15
     dc4:	81 2d       	mov	r24, r1
     dc6:	11 24       	eor	r1, r1
     dc8:	86 95       	lsr	r24
     dca:	48 2f       	mov	r20, r24
     dcc:	44 0f       	add	r20, r20
     dce:	48 0f       	add	r20, r24
     dd0:	89 2f       	mov	r24, r25
     dd2:	84 1b       	sub	r24, r20
     dd4:	80 93 4c 01 	sts	0x014C, r24
					if(!LCD_mode){
     dd8:	81 11       	cpse	r24, r1
     dda:	32 c0       	rjmp	.+100    	; 0xe40 <button_routine+0x152>
						mode = 4;
     ddc:	10 93 79 01 	sts	0x0179, r17
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     de0:	00 93 61 01 	sts	0x0161, r16
     de4:	c9 cf       	rjmp	.-110    	; 0xd78 <button_routine+0x8a>
					else{
						mode = 2;
					}
					break;
				case 3:
					if(mode == 3){
     de6:	80 91 79 01 	lds	r24, 0x0179
     dea:	83 30       	cpi	r24, 0x03	; 3
     dec:	49 f1       	breq	.+82     	; 0xe40 <button_routine+0x152>
						mode = 0;			
					}
					else{
						mode = 3;
     dee:	d0 93 79 01 	sts	0x0179, r29
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     df2:	00 93 61 01 	sts	0x0161, r16
     df6:	c0 cf       	rjmp	.-128    	; 0xd78 <button_routine+0x8a>
					else{
						mode = 1;
					}
					break;
				case 2:
					if(mode == 2){
     df8:	80 91 79 01 	lds	r24, 0x0179
     dfc:	82 30       	cpi	r24, 0x02	; 2
     dfe:	01 f1       	breq	.+64     	; 0xe40 <button_routine+0x152>
						mode = 0;	
					}
					else{
						mode = 2;
     e00:	c0 93 79 01 	sts	0x0179, r28
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     e04:	00 93 61 01 	sts	0x0161, r16
     e08:	b7 cf       	rjmp	.-146    	; 0xd78 <button_routine+0x8a>
			switch(button){
				case 0:  
					radio = 1;
					break;
				case 1:
					if(mode == 1){
     e0a:	80 91 79 01 	lds	r24, 0x0179
     e0e:	81 30       	cpi	r24, 0x01	; 1
     e10:	b9 f0       	breq	.+46     	; 0xe40 <button_routine+0x152>
						mode = 0;	
					}
					else{
						mode = 1;
     e12:	00 93 79 01 	sts	0x0179, r16
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     e16:	00 93 61 01 	sts	0x0161, r16
     e1a:	ae cf       	rjmp	.-164    	; 0xd78 <button_routine+0x8a>
				case 5:
					show_ampm = !show_ampm;
					//show_temp = !show_temp;
					break;
				case 6:
					if(music_status){
     e1c:	80 91 4f 01 	lds	r24, 0x014F
     e20:	88 23       	and	r24, r24
     e22:	09 f4       	brne	.+2      	; 0xe26 <button_routine+0x138>
     e24:	a7 cf       	rjmp	.-178    	; 0xd74 <button_routine+0x86>
						snooze_flag = 1;
     e26:	00 93 51 01 	sts	0x0151, r16
						music_status = 0;
     e2a:	10 92 4f 01 	sts	0x014F, r1
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     e2e:	10 92 85 01 	sts	0x0185, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     e32:	8e b5       	in	r24, 0x2e	; 46
     e34:	8c 7f       	andi	r24, 0xFC	; 252
     e36:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     e38:	92 9a       	sbi	0x12, 2	; 18
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     e3a:	00 93 61 01 	sts	0x0161, r16
     e3e:	9c cf       	rjmp	.-200    	; 0xd78 <button_routine+0x8a>
					LCD_mode = rotate_LCD_mode%3;
					if(!LCD_mode){
						mode = 4;
					}
					else{
						mode = 0;
     e40:	10 92 79 01 	sts	0x0179, r1
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     e44:	00 93 61 01 	sts	0x0161, r16
     e48:	97 cf       	rjmp	.-210    	; 0xd78 <button_routine+0x8a>
						music_status = 0;
						music_off();
					}
					break;
				case 7:
					if(alarm_on && music_status){
     e4a:	80 91 50 01 	lds	r24, 0x0150
     e4e:	88 23       	and	r24, r24
     e50:	79 f0       	breq	.+30     	; 0xe70 <button_routine+0x182>
     e52:	90 91 4f 01 	lds	r25, 0x014F
     e56:	99 23       	and	r25, r25
     e58:	a1 f0       	breq	.+40     	; 0xe82 <button_routine+0x194>
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     e5a:	10 92 85 01 	sts	0x0185, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     e5e:	8e b5       	in	r24, 0x2e	; 46
     e60:	8c 7f       	andi	r24, 0xFC	; 252
     e62:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     e64:	92 9a       	sbi	0x12, 2	; 18
						music_off();
						music_status = 0;
     e66:	10 92 4f 01 	sts	0x014F, r1
     e6a:	90 91 50 01 	lds	r25, 0x0150
     e6e:	01 c0       	rjmp	.+2      	; 0xe72 <button_routine+0x184>
     e70:	90 e0       	ldi	r25, 0x00	; 0
					}
					alarm_on = !alarm_on;
     e72:	81 e0       	ldi	r24, 0x01	; 1
     e74:	91 11       	cpse	r25, r1
     e76:	80 e0       	ldi	r24, 0x00	; 0
     e78:	80 93 50 01 	sts	0x0150, r24
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     e7c:	00 93 61 01 	sts	0x0161, r16
     e80:	7b cf       	rjmp	.-266    	; 0xd78 <button_routine+0x8a>
     e82:	98 2f       	mov	r25, r24
     e84:	f6 cf       	rjmp	.-20     	; 0xe72 <button_routine+0x184>

00000e86 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
     e86:	1f 92       	push	r1
     e88:	0f 92       	push	r0
     e8a:	0f b6       	in	r0, 0x3f	; 63
     e8c:	0f 92       	push	r0
     e8e:	11 24       	eor	r1, r1
     e90:	0b b6       	in	r0, 0x3b	; 59
     e92:	0f 92       	push	r0
     e94:	2f 93       	push	r18
     e96:	3f 93       	push	r19
     e98:	4f 93       	push	r20
     e9a:	5f 93       	push	r21
     e9c:	6f 93       	push	r22
     e9e:	7f 93       	push	r23
     ea0:	8f 93       	push	r24
     ea2:	9f 93       	push	r25
     ea4:	af 93       	push	r26
     ea6:	bf 93       	push	r27
     ea8:	cf 93       	push	r28
     eaa:	ef 93       	push	r30
     eac:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
     eae:	20 91 70 01 	lds	r18, 0x0170
     eb2:	2f 5f       	subi	r18, 0xFF	; 255
     eb4:	20 93 70 01 	sts	0x0170, r18
	//update_time();
	if(count%2 == 0){
     eb8:	20 fd       	sbrc	r18, 0
     eba:	03 c0       	rjmp	.+6      	; 0xec2 <__vector_16+0x3c>
		update_LCD = 1;
     ebc:	81 e0       	ldi	r24, 0x01	; 1
     ebe:	80 93 63 01 	sts	0x0163, r24

	}
	if(count%8 == 0){
     ec2:	82 2f       	mov	r24, r18
     ec4:	87 70       	andi	r24, 0x07	; 7
     ec6:	81 f4       	brne	.+32     	; 0xee8 <__vector_16+0x62>
		//	update_LCD = 1;
		beat++;
     ec8:	80 91 97 01 	lds	r24, 0x0197
     ecc:	90 91 98 01 	lds	r25, 0x0198
     ed0:	01 96       	adiw	r24, 0x01	; 1
     ed2:	90 93 98 01 	sts	0x0198, r25
     ed6:	80 93 97 01 	sts	0x0197, r24
		blink = !blink;
     eda:	81 e0       	ldi	r24, 0x01	; 1
     edc:	90 91 4e 01 	lds	r25, 0x014E
     ee0:	91 11       	cpse	r25, r1
     ee2:	3f c0       	rjmp	.+126    	; 0xf62 <__vector_16+0xdc>
     ee4:	80 93 4e 01 	sts	0x014E, r24
	}
	if((count%128)==0){
     ee8:	2f 77       	andi	r18, 0x7F	; 127
     eea:	39 f5       	brne	.+78     	; 0xf3a <__vector_16+0xb4>
		ticker++;     
     eec:	80 91 73 01 	lds	r24, 0x0173
     ef0:	8f 5f       	subi	r24, 0xFF	; 255
     ef2:	80 93 73 01 	sts	0x0173, r24
		second++; 
     ef6:	80 91 78 01 	lds	r24, 0x0178
     efa:	8f 5f       	subi	r24, 0xFF	; 255
     efc:	80 93 78 01 	sts	0x0178, r24
		reset_temp = 1;   
     f00:	c1 e0       	ldi	r28, 0x01	; 1
     f02:	c0 93 62 01 	sts	0x0162, r28
		if(alarm_on){
     f06:	80 91 50 01 	lds	r24, 0x0150
     f0a:	88 23       	and	r24, r24
     f0c:	b1 f0       	breq	.+44     	; 0xf3a <__vector_16+0xb4>
			if ((alarm_time == time) && !snooze_flag && !music_status){
     f0e:	20 91 5b 01 	lds	r18, 0x015B
     f12:	30 91 5c 01 	lds	r19, 0x015C
     f16:	80 91 5d 01 	lds	r24, 0x015D
     f1a:	90 91 5e 01 	lds	r25, 0x015E
     f1e:	28 17       	cp	r18, r24
     f20:	39 07       	cpc	r19, r25
     f22:	41 f1       	breq	.+80     	; 0xf74 <__vector_16+0xee>
					//play music
					music_on();
					music_status = 1;
				}
			}
			else if(snooze_flag){
     f24:	80 91 51 01 	lds	r24, 0x0151
     f28:	88 23       	and	r24, r24
     f2a:	39 f0       	breq	.+14     	; 0xf3a <__vector_16+0xb4>
				snooze_second++;
     f2c:	80 91 52 01 	lds	r24, 0x0152
     f30:	8f 5f       	subi	r24, 0xFF	; 255
     f32:	80 93 52 01 	sts	0x0152, r24
				if(snooze_second >= 10){
     f36:	8a 30       	cpi	r24, 0x0A	; 10
     f38:	b0 f4       	brcc	.+44     	; 0xf66 <__vector_16+0xe0>
				}	
			}

		}
	}
}
     f3a:	ff 91       	pop	r31
     f3c:	ef 91       	pop	r30
     f3e:	cf 91       	pop	r28
     f40:	bf 91       	pop	r27
     f42:	af 91       	pop	r26
     f44:	9f 91       	pop	r25
     f46:	8f 91       	pop	r24
     f48:	7f 91       	pop	r23
     f4a:	6f 91       	pop	r22
     f4c:	5f 91       	pop	r21
     f4e:	4f 91       	pop	r20
     f50:	3f 91       	pop	r19
     f52:	2f 91       	pop	r18
     f54:	0f 90       	pop	r0
     f56:	0b be       	out	0x3b, r0	; 59
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	0f 90       	pop	r0
     f5e:	1f 90       	pop	r1
     f60:	18 95       	reti

	}
	if(count%8 == 0){
		//	update_LCD = 1;
		beat++;
		blink = !blink;
     f62:	80 e0       	ldi	r24, 0x00	; 0
     f64:	bf cf       	rjmp	.-130    	; 0xee4 <__vector_16+0x5e>
				}
			}
			else if(snooze_flag){
				snooze_second++;
				if(snooze_second >= 10){
					snooze_flag = 0;
     f66:	10 92 51 01 	sts	0x0151, r1
					music_on();
     f6a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
					snooze_second = 0;
     f6e:	10 92 52 01 	sts	0x0152, r1
     f72:	e3 cf       	rjmp	.-58     	; 0xf3a <__vector_16+0xb4>
	if((count%128)==0){
		ticker++;     
		second++; 
		reset_temp = 1;   
		if(alarm_on){
			if ((alarm_time == time) && !snooze_flag && !music_status){
     f74:	80 91 51 01 	lds	r24, 0x0151
     f78:	81 11       	cpse	r24, r1
     f7a:	d8 cf       	rjmp	.-80     	; 0xf2c <__vector_16+0xa6>
     f7c:	80 91 4f 01 	lds	r24, 0x014F
     f80:	81 11       	cpse	r24, r1
     f82:	db cf       	rjmp	.-74     	; 0xf3a <__vector_16+0xb4>
				if(alarm_is_radio){
     f84:	80 91 a1 01 	lds	r24, 0x01A1
     f88:	88 23       	and	r24, r24
     f8a:	19 f0       	breq	.+6      	; 0xf92 <__vector_16+0x10c>
					turn_radio_on = 1;
     f8c:	c0 93 4a 01 	sts	0x014A, r28
     f90:	d4 cf       	rjmp	.-88     	; 0xf3a <__vector_16+0xb4>
				}
				else{
					//play music
					music_on();
     f92:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
					music_status = 1;
     f96:	c0 93 4f 01 	sts	0x014F, r28
     f9a:	cf cf       	rjmp	.-98     	; 0xf3a <__vector_16+0xb4>

00000f9c <__vector_12>:

		}
	}
}

ISR(TIMER1_COMPA_vect){
     f9c:	1f 92       	push	r1
     f9e:	0f 92       	push	r0
     fa0:	0f b6       	in	r0, 0x3f	; 63
     fa2:	0f 92       	push	r0
     fa4:	11 24       	eor	r1, r1
     fa6:	0b b6       	in	r0, 0x3b	; 59
     fa8:	0f 92       	push	r0
     faa:	2f 93       	push	r18
     fac:	3f 93       	push	r19
     fae:	4f 93       	push	r20
     fb0:	5f 93       	push	r21
     fb2:	6f 93       	push	r22
     fb4:	7f 93       	push	r23
     fb6:	8f 93       	push	r24
     fb8:	9f 93       	push	r25
     fba:	af 93       	push	r26
     fbc:	bf 93       	push	r27
     fbe:	ef 93       	push	r30
     fc0:	ff 93       	push	r31
	PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
     fc2:	82 b3       	in	r24, 0x12	; 18
     fc4:	80 58       	subi	r24, 0x80	; 128
     fc6:	82 bb       	out	0x12, r24	; 18
	PORTB |= (1<<PB0);
     fc8:	c0 9a       	sbi	0x18, 0	; 24
	if(beat >= max_beat) {   //if we've played the note long enough
     fca:	20 91 97 01 	lds	r18, 0x0197
     fce:	30 91 98 01 	lds	r19, 0x0198
     fd2:	80 91 93 01 	lds	r24, 0x0193
     fd6:	90 91 94 01 	lds	r25, 0x0194
     fda:	28 17       	cp	r18, r24
     fdc:	39 07       	cpc	r19, r25
     fde:	60 f0       	brcs	.+24     	; 0xff8 <__vector_12+0x5c>
		notes++;               //move on to the next note
     fe0:	80 91 85 01 	lds	r24, 0x0185
     fe4:	8f 5f       	subi	r24, 0xFF	; 255
     fe6:	80 93 85 01 	sts	0x0185, r24
		play_song(song, notes);//and play it
     fea:	80 91 85 01 	lds	r24, 0x0185
     fee:	90 91 92 01 	lds	r25, 0x0192
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	0e 94 65 04 	call	0x8ca	; 0x8ca <song0>
	}
}
     ff8:	ff 91       	pop	r31
     ffa:	ef 91       	pop	r30
     ffc:	bf 91       	pop	r27
     ffe:	af 91       	pop	r26
    1000:	9f 91       	pop	r25
    1002:	8f 91       	pop	r24
    1004:	7f 91       	pop	r23
    1006:	6f 91       	pop	r22
    1008:	5f 91       	pop	r21
    100a:	4f 91       	pop	r20
    100c:	3f 91       	pop	r19
    100e:	2f 91       	pop	r18
    1010:	0f 90       	pop	r0
    1012:	0b be       	out	0x3b, r0	; 59
    1014:	0f 90       	pop	r0
    1016:	0f be       	out	0x3f, r0	; 63
    1018:	0f 90       	pop	r0
    101a:	1f 90       	pop	r1
    101c:	18 95       	reti

0000101e <__vector_8>:
		default:
			break;
	}    
} 

ISR(INT7_vect){
    101e:	1f 92       	push	r1
    1020:	0f 92       	push	r0
    1022:	0f b6       	in	r0, 0x3f	; 63
    1024:	0f 92       	push	r0
    1026:	11 24       	eor	r1, r1
    1028:	8f 93       	push	r24
    102a:	9f 93       	push	r25
	STC_interrupt = TRUE;
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	80 93 9c 01 	sts	0x019C, r24
	minute++;
    1032:	80 91 77 01 	lds	r24, 0x0177
    1036:	8f 5f       	subi	r24, 0xFF	; 255
    1038:	80 93 77 01 	sts	0x0177, r24
	time = 1919;
    103c:	8f e7       	ldi	r24, 0x7F	; 127
    103e:	97 e0       	ldi	r25, 0x07	; 7
    1040:	90 93 5e 01 	sts	0x015E, r25
    1044:	80 93 5d 01 	sts	0x015D, r24
}
    1048:	9f 91       	pop	r25
    104a:	8f 91       	pop	r24
    104c:	0f 90       	pop	r0
    104e:	0f be       	out	0x3f, r0	; 63
    1050:	0f 90       	pop	r0
    1052:	1f 90       	pop	r1
    1054:	18 95       	reti

00001056 <__vector_21>:

ISR(ADC_vect){
    1056:	1f 92       	push	r1
    1058:	0f 92       	push	r0
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	0f 92       	push	r0
    105e:	11 24       	eor	r1, r1
    1060:	8f 93       	push	r24
    1062:	9f 93       	push	r25

	if(ADCH < 100){
    1064:	85 b1       	in	r24, 0x05	; 5
    1066:	84 36       	cpi	r24, 0x64	; 100
    1068:	48 f0       	brcs	.+18     	; 0x107c <__vector_21+0x26>
		OCR2 = 100-ADCH;
	}  
	else{
		OCR2 = 1;// brightness_level;
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	83 bd       	out	0x23, r24	; 35
	}
}
    106e:	9f 91       	pop	r25
    1070:	8f 91       	pop	r24
    1072:	0f 90       	pop	r0
    1074:	0f be       	out	0x3f, r0	; 63
    1076:	0f 90       	pop	r0
    1078:	1f 90       	pop	r1
    107a:	18 95       	reti
}

ISR(ADC_vect){

	if(ADCH < 100){
		OCR2 = 100-ADCH;
    107c:	95 b1       	in	r25, 0x05	; 5
    107e:	84 e6       	ldi	r24, 0x64	; 100
    1080:	89 1b       	sub	r24, r25
    1082:	83 bd       	out	0x23, r24	; 35
	}  
	else{
		OCR2 = 1;// brightness_level;
	}
}
    1084:	9f 91       	pop	r25
    1086:	8f 91       	pop	r24
    1088:	0f 90       	pop	r0
    108a:	0f be       	out	0x3f, r0	; 63
    108c:	0f 90       	pop	r0
    108e:	1f 90       	pop	r1
    1090:	18 95       	reti

00001092 <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
    1092:	80 91 78 01 	lds	r24, 0x0178
		minute++;
    1096:	20 91 77 01 	lds	r18, 0x0177
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
    109a:	8c 33       	cpi	r24, 0x3C	; 60
    109c:	28 f0       	brcs	.+10     	; 0x10a8 <update_time+0x16>
		minute++;
    109e:	2f 5f       	subi	r18, 0xFF	; 255
    10a0:	20 93 77 01 	sts	0x0177, r18
		second = 0;
    10a4:	10 92 78 01 	sts	0x0178, r1
	}             
	if(minute >=60){
		hour++;
    10a8:	e0 91 76 01 	lds	r30, 0x0176
	// static int minute_change = 0;
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
    10ac:	2c 33       	cpi	r18, 0x3C	; 60
    10ae:	c0 f5       	brcc	.+112    	; 0x1120 <__stack+0x21>
    10b0:	30 e0       	ldi	r19, 0x00	; 0
		hour++;
		minute = 0;
	}
	if(hour >= 24){
    10b2:	e8 31       	cpi	r30, 0x18	; 24
    10b4:	f0 f5       	brcc	.+124    	; 0x1132 <__stack+0x33>
    10b6:	6e 2f       	mov	r22, r30
    10b8:	70 e0       	ldi	r23, 0x00	; 0
    10ba:	84 e6       	ldi	r24, 0x64	; 100
    10bc:	e8 9f       	mul	r30, r24
    10be:	a0 01       	movw	r20, r0
    10c0:	11 24       	eor	r1, r1
		hour = 0;
	} 

	alarm_time = (alarm_hour * 100) + alarm_minute;
    10c2:	f0 91 74 01 	lds	r31, 0x0174
    10c6:	80 91 75 01 	lds	r24, 0x0175
    10ca:	90 e0       	ldi	r25, 0x00	; 0
    10cc:	a4 e6       	ldi	r26, 0x64	; 100
    10ce:	fa 9f       	mul	r31, r26
    10d0:	80 0d       	add	r24, r0
    10d2:	91 1d       	adc	r25, r1
    10d4:	11 24       	eor	r1, r1
    10d6:	90 93 5c 01 	sts	0x015C, r25
    10da:	80 93 5b 01 	sts	0x015B, r24
	// if(minute_change){
	time = (hour * 100) + minute;
    10de:	c9 01       	movw	r24, r18
    10e0:	84 0f       	add	r24, r20
    10e2:	95 1f       	adc	r25, r21
    10e4:	90 93 5e 01 	sts	0x015E, r25
    10e8:	80 93 5d 01 	sts	0x015D, r24
	// minute_change = 0;

	if(show_ampm){
    10ec:	40 91 82 01 	lds	r20, 0x0182
    10f0:	44 23       	and	r20, r20
    10f2:	39 f1       	breq	.+78     	; 0x1142 <__stack+0x43>
		if(hour>=12){
    10f4:	ec 30       	cpi	r30, 0x0C	; 12
    10f6:	50 f1       	brcs	.+84     	; 0x114c <__stack+0x4d>
			if(hour == 12){
    10f8:	ec 30       	cpi	r30, 0x0C	; 12
    10fa:	d1 f1       	breq	.+116    	; 0x1170 <__stack+0x71>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour-12)*100 + minute;
    10fc:	6c 50       	subi	r22, 0x0C	; 12
    10fe:	71 09       	sbc	r23, r1
    1100:	44 e6       	ldi	r20, 0x64	; 100
    1102:	46 9f       	mul	r20, r22
    1104:	c0 01       	movw	r24, r0
    1106:	47 9f       	mul	r20, r23
    1108:	90 0d       	add	r25, r0
    110a:	11 24       	eor	r1, r1
    110c:	82 0f       	add	r24, r18
    110e:	93 1f       	adc	r25, r19
    1110:	90 93 5a 01 	sts	0x015A, r25
    1114:	80 93 59 01 	sts	0x0159, r24
				am_pm = 1;
    1118:	81 e0       	ldi	r24, 0x01	; 1
    111a:	80 93 57 01 	sts	0x0157, r24
    111e:	08 95       	ret
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
		hour++;
    1120:	ef 5f       	subi	r30, 0xFF	; 255
    1122:	e0 93 76 01 	sts	0x0176, r30
		minute = 0;
    1126:	10 92 77 01 	sts	0x0177, r1
    112a:	20 e0       	ldi	r18, 0x00	; 0
    112c:	30 e0       	ldi	r19, 0x00	; 0
	}
	if(hour >= 24){
    112e:	e8 31       	cpi	r30, 0x18	; 24
    1130:	10 f2       	brcs	.-124    	; 0x10b6 <update_time+0x24>
		hour = 0;
    1132:	10 92 76 01 	sts	0x0176, r1
    1136:	40 e0       	ldi	r20, 0x00	; 0
    1138:	50 e0       	ldi	r21, 0x00	; 0
    113a:	60 e0       	ldi	r22, 0x00	; 0
    113c:	70 e0       	ldi	r23, 0x00	; 0
    113e:	e0 e0       	ldi	r30, 0x00	; 0
    1140:	c0 cf       	rjmp	.-128    	; 0x10c2 <update_time+0x30>
			}
			am_pm = 0;
		}
	}
	else{
		show_time = (hour * 100) + minute;
    1142:	90 93 5a 01 	sts	0x015A, r25
    1146:	80 93 59 01 	sts	0x0159, r24
    114a:	08 95       	ret
				show_time = (hour-12)*100 + minute;
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
    114c:	ee 23       	and	r30, r30
    114e:	39 f0       	breq	.+14     	; 0x115e <__stack+0x5f>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour)*100 + minute;
    1150:	90 93 5a 01 	sts	0x015A, r25
    1154:	80 93 59 01 	sts	0x0159, r24
			}
			am_pm = 0;
    1158:	10 92 57 01 	sts	0x0157, r1
    115c:	08 95       	ret
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
				show_time = 1200 + minute;
    115e:	20 55       	subi	r18, 0x50	; 80
    1160:	3b 4f       	sbci	r19, 0xFB	; 251
    1162:	30 93 5a 01 	sts	0x015A, r19
    1166:	20 93 59 01 	sts	0x0159, r18
			}
			else{
				show_time = (hour)*100 + minute;
			}
			am_pm = 0;
    116a:	10 92 57 01 	sts	0x0157, r1
    116e:	08 95       	ret
	// minute_change = 0;

	if(show_ampm){
		if(hour>=12){
			if(hour == 12){
				show_time = 1200 + minute;
    1170:	20 55       	subi	r18, 0x50	; 80
    1172:	3b 4f       	sbci	r19, 0xFB	; 251
    1174:	30 93 5a 01 	sts	0x015A, r19
    1178:	20 93 59 01 	sts	0x0159, r18
    117c:	08 95       	ret

0000117e <SPI_init>:
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    117e:	80 e5       	ldi	r24, 0x50	; 80
    1180:	8d b9       	out	0x0d, r24	; 13
    1182:	08 95       	ret

00001184 <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    1184:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    1186:	77 9b       	sbis	0x0e, 7	; 14
    1188:	fe cf       	rjmp	.-4      	; 0x1186 <SPI_Transmit+0x2>
}
    118a:	08 95       	ret

0000118c <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
	PORTE &= 0xBF;       //Write 0 to PE6 to trigger SPI on radio board
    118c:	1e 98       	cbi	0x03, 6	; 3
	__asm__ __volatile__ ("nop");
    118e:	00 00       	nop
	__asm__ __volatile__ ("nop");
    1190:	00 00       	nop
	// Wait until 8 clock cycles are done 
	SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
    1192:	1f b8       	out	0x0f, r1	; 15
	PORTE |= (1 << PE6);  
    1194:	1e 9a       	sbi	0x03, 6	; 3
	__asm__ __volatile__ ("nop");
    1196:	00 00       	nop
	__asm__ __volatile__ ("nop");
    1198:	00 00       	nop
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    119a:	77 9b       	sbis	0x0e, 7	; 14
    119c:	fe cf       	rjmp	.-4      	; 0x119a <SPI_Receive+0xe>
	// Return incoming data from SPDR
	return(SPDR);  
    119e:	8f b1       	in	r24, 0x0f	; 15
}
    11a0:	08 95       	ret

000011a2 <bar_graph>:
 *void bar_graph()
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
    11a2:	80 91 79 01 	lds	r24, 0x0179
    11a6:	88 23       	and	r24, r24
    11a8:	b9 f0       	breq	.+46     	; 0x11d8 <bar_graph+0x36>
		write = 0x00;
	}
	else{
		write = 1<<(mode-1);
    11aa:	9f ef       	ldi	r25, 0xFF	; 255
    11ac:	98 0f       	add	r25, r24
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	01 c0       	rjmp	.+2      	; 0x11b4 <bar_graph+0x12>
    11b2:	88 0f       	add	r24, r24
    11b4:	9a 95       	dec	r25
    11b6:	ea f7       	brpl	.-6      	; 0x11b2 <bar_graph+0x10>
	}

	if(alarm_on != 0){
    11b8:	90 91 50 01 	lds	r25, 0x0150
    11bc:	91 11       	cpse	r25, r1
		write = 0xFF;
    11be:	8f ef       	ldi	r24, 0xFF	; 255

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    11c0:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    11c2:	77 9b       	sbis	0x0e, 7	; 14
    11c4:	fe cf       	rjmp	.-4      	; 0x11c2 <bar_graph+0x20>

	if(alarm_on != 0){
		write = 0xFF;
	}
	SPI_Transmit(write);
	PORTD = (1 << PD2);  //Push data out of SPI
    11c6:	84 e0       	ldi	r24, 0x04	; 4
    11c8:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop"); //Buffer
    11ca:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    11cc:	00 00       	nop


	PORTD = (2 << PD2);  // Push data out of SPI
    11ce:	88 e0       	ldi	r24, 0x08	; 8
    11d0:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop");  //Buffer
    11d2:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    11d4:	00 00       	nop
    11d6:	08 95       	ret
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
		write = 0x00;
    11d8:	80 e0       	ldi	r24, 0x00	; 0
    11da:	ee cf       	rjmp	.-36     	; 0x11b8 <bar_graph+0x16>

000011dc <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
	//uint8_t display_segment = 0;
	static uint8_t rotate_7seg = 0;
	switch(mode){
    11dc:	80 91 79 01 	lds	r24, 0x0179
    11e0:	83 30       	cpi	r24, 0x03	; 3
    11e2:	09 f4       	brne	.+2      	; 0x11e6 <display_update+0xa>
    11e4:	41 c0       	rjmp	.+130    	; 0x1268 <display_update+0x8c>
    11e6:	84 30       	cpi	r24, 0x04	; 4
    11e8:	41 f0       	breq	.+16     	; 0x11fa <display_update+0x1e>
    11ea:	82 30       	cpi	r24, 0x02	; 2
    11ec:	a1 f1       	breq	.+104    	; 0x1256 <display_update+0x7a>
			segment_data[2] = 0xFF; //decimal
			break;
		case 4:
			break;
		default:
			segsum(show_time);
    11ee:	80 91 59 01 	lds	r24, 0x0159
    11f2:	90 91 5a 01 	lds	r25, 0x015A
    11f6:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
	   PORTA = segment_data[display_segment];
	   _delay_us(80);
	   PORTA = OFF;
	   }
	 */
	switch(rotate_7seg%5){
    11fa:	20 91 6c 01 	lds	r18, 0x016C
    11fe:	8d ec       	ldi	r24, 0xCD	; 205
    1200:	28 9f       	mul	r18, r24
    1202:	81 2d       	mov	r24, r1
    1204:	11 24       	eor	r1, r1
    1206:	86 95       	lsr	r24
    1208:	86 95       	lsr	r24
    120a:	98 2f       	mov	r25, r24
    120c:	99 0f       	add	r25, r25
    120e:	99 0f       	add	r25, r25
    1210:	98 0f       	add	r25, r24
    1212:	82 2f       	mov	r24, r18
    1214:	89 1b       	sub	r24, r25
    1216:	82 30       	cpi	r24, 0x02	; 2
    1218:	09 f4       	brne	.+2      	; 0x121c <display_update+0x40>
    121a:	45 c0       	rjmp	.+138    	; 0x12a6 <display_update+0xca>
    121c:	78 f0       	brcs	.+30     	; 0x123c <display_update+0x60>
    121e:	83 30       	cpi	r24, 0x03	; 3
    1220:	b9 f1       	breq	.+110    	; 0x1290 <display_update+0xb4>
    1222:	84 30       	cpi	r24, 0x04	; 4
    1224:	59 f5       	brne	.+86     	; 0x127c <display_update+0xa0>
		case 3:
			PORTB = 3 << 4;
			PORTA = segment_data[3];
			break;
		case 4:
			PORTB = 4 << 4;
    1226:	80 e4       	ldi	r24, 0x40	; 64
    1228:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[4];
    122a:	80 91 a6 01 	lds	r24, 0x01A6
    122e:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    1230:	80 91 6c 01 	lds	r24, 0x016C
    1234:	8f 5f       	subi	r24, 0xFF	; 255
    1236:	80 93 6c 01 	sts	0x016C, r24
    123a:	08 95       	ret
	   PORTA = segment_data[display_segment];
	   _delay_us(80);
	   PORTA = OFF;
	   }
	 */
	switch(rotate_7seg%5){
    123c:	81 30       	cpi	r24, 0x01	; 1
    123e:	f1 f4       	brne	.+60     	; 0x127c <display_update+0xa0>
			PORTB = 0 << 4;
			PORTA = segment_data[0];
			break;

		case 1:
			PORTB = 1 << 4;
    1240:	80 e1       	ldi	r24, 0x10	; 16
    1242:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[1];
    1244:	80 91 a3 01 	lds	r24, 0x01A3
    1248:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    124a:	80 91 6c 01 	lds	r24, 0x016C
    124e:	8f 5f       	subi	r24, 0xFF	; 255
    1250:	80 93 6c 01 	sts	0x016C, r24
    1254:	08 95       	ret
void display_update(){
	//uint8_t display_segment = 0;
	static uint8_t rotate_7seg = 0;
	switch(mode){
		case 2:
			segsum(alarm_time);
    1256:	80 91 5b 01 	lds	r24, 0x015B
    125a:	90 91 5c 01 	lds	r25, 0x015C
    125e:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0x00;
    1262:	10 92 a4 01 	sts	0x01A4, r1
			break;
    1266:	c9 cf       	rjmp	.-110    	; 0x11fa <display_update+0x1e>
		case 3:
			segsum(OCR3A);
    1268:	80 91 86 00 	lds	r24, 0x0086
    126c:	90 91 87 00 	lds	r25, 0x0087
    1270:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0xFF; //decimal
    1274:	8f ef       	ldi	r24, 0xFF	; 255
    1276:	80 93 a4 01 	sts	0x01A4, r24
			break;
    127a:	bf cf       	rjmp	.-130    	; 0x11fa <display_update+0x1e>
	   PORTA = OFF;
	   }
	 */
	switch(rotate_7seg%5){
		case 0:
			PORTB = 0 << 4;
    127c:	18 ba       	out	0x18, r1	; 24
			PORTA = segment_data[0];
    127e:	80 91 a2 01 	lds	r24, 0x01A2
    1282:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    1284:	80 91 6c 01 	lds	r24, 0x016C
    1288:	8f 5f       	subi	r24, 0xFF	; 255
    128a:	80 93 6c 01 	sts	0x016C, r24
    128e:	08 95       	ret
		case 2:
			PORTB = 2 << 4;
			PORTA = segment_data[2];
			break;
		case 3:
			PORTB = 3 << 4;
    1290:	80 e3       	ldi	r24, 0x30	; 48
    1292:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[3];
    1294:	80 91 a5 01 	lds	r24, 0x01A5
    1298:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    129a:	80 91 6c 01 	lds	r24, 0x016C
    129e:	8f 5f       	subi	r24, 0xFF	; 255
    12a0:	80 93 6c 01 	sts	0x016C, r24
    12a4:	08 95       	ret
		case 1:
			PORTB = 1 << 4;
			PORTA = segment_data[1];
			break;
		case 2:
			PORTB = 2 << 4;
    12a6:	80 e2       	ldi	r24, 0x20	; 32
    12a8:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[2];
    12aa:	80 91 a4 01 	lds	r24, 0x01A4
    12ae:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    12b0:	80 91 6c 01 	lds	r24, 0x016C
    12b4:	8f 5f       	subi	r24, 0xFF	; 255
    12b6:	80 93 6c 01 	sts	0x016C, r24
    12ba:	08 95       	ret

000012bc <__vector_10>:
		notes++;               //move on to the next note
		play_song(song, notes);//and play it
	}
}

ISR(TIMER2_OVF_vect){
    12bc:	1f 92       	push	r1
    12be:	0f 92       	push	r0
    12c0:	0f b6       	in	r0, 0x3f	; 63
    12c2:	0f 92       	push	r0
    12c4:	11 24       	eor	r1, r1
    12c6:	0b b6       	in	r0, 0x3b	; 59
    12c8:	0f 92       	push	r0
    12ca:	2f 93       	push	r18
    12cc:	3f 93       	push	r19
    12ce:	4f 93       	push	r20
    12d0:	5f 93       	push	r21
    12d2:	6f 93       	push	r22
    12d4:	7f 93       	push	r23
    12d6:	8f 93       	push	r24
    12d8:	9f 93       	push	r25
    12da:	af 93       	push	r26
    12dc:	bf 93       	push	r27
    12de:	cf 93       	push	r28
    12e0:	ef 93       	push	r30
    12e2:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
    12e4:	c0 91 6f 01 	lds	r28, 0x016F
    12e8:	cf 5f       	subi	r28, 0xFF	; 255
    12ea:	c0 93 6f 01 	sts	0x016F, r28
	//display_update();

	if(count%64 == 0){
    12ee:	8c 2f       	mov	r24, r28
    12f0:	8f 73       	andi	r24, 0x3F	; 63
    12f2:	f1 f0       	breq	.+60     	; 0x1330 <__vector_10+0x74>
		button_routine();
	}

	switch(count%8){
    12f4:	c7 70       	andi	r28, 0x07	; 7
    12f6:	c1 f0       	breq	.+48     	; 0x1328 <__vector_10+0x6c>
    12f8:	c1 30       	cpi	r28, 0x01	; 1
    12fa:	11 f4       	brne	.+4      	; 0x1300 <__vector_10+0x44>
		case 0:
			encode_flag = 1;
			//check_knobs();
			break;
		case 1:
			display_update();
    12fc:	0e 94 ee 08 	call	0x11dc	; 0x11dc <display_update>
			break;
		default:
			break;
	}    
} 
    1300:	ff 91       	pop	r31
    1302:	ef 91       	pop	r30
    1304:	cf 91       	pop	r28
    1306:	bf 91       	pop	r27
    1308:	af 91       	pop	r26
    130a:	9f 91       	pop	r25
    130c:	8f 91       	pop	r24
    130e:	7f 91       	pop	r23
    1310:	6f 91       	pop	r22
    1312:	5f 91       	pop	r21
    1314:	4f 91       	pop	r20
    1316:	3f 91       	pop	r19
    1318:	2f 91       	pop	r18
    131a:	0f 90       	pop	r0
    131c:	0b be       	out	0x3b, r0	; 59
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63
    1322:	0f 90       	pop	r0
    1324:	1f 90       	pop	r1
    1326:	18 95       	reti
		button_routine();
	}

	switch(count%8){
		case 0:
			encode_flag = 1;
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	80 93 65 01 	sts	0x0165, r24
			//check_knobs();
			break;
    132e:	e8 cf       	rjmp	.-48     	; 0x1300 <__vector_10+0x44>
	static uint8_t count = 0;
	count++;
	//display_update();

	if(count%64 == 0){
		button_routine();
    1330:	0e 94 77 06 	call	0xcee	; 0xcee <button_routine>
    1334:	df cf       	rjmp	.-66     	; 0x12f4 <__vector_10+0x38>

00001336 <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
	switch(mode){
    1336:	80 91 79 01 	lds	r24, 0x0179
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	59 f0       	breq	.+22     	; 0x1354 <right_inc+0x1e>
    133e:	82 30       	cpi	r24, 0x02	; 2
    1340:	41 f4       	brne	.+16     	; 0x1352 <right_inc+0x1c>
				minute = 0;	    
			}     
			second++;
			break;
		case 2: 
			alarm_minute++;
    1342:	80 91 75 01 	lds	r24, 0x0175
    1346:	8f 5f       	subi	r24, 0xFF	; 255
			if(alarm_minute >= 60){
    1348:	8c 33       	cpi	r24, 0x3C	; 60
    134a:	88 f0       	brcs	.+34     	; 0x136e <right_inc+0x38>
				alarm_minute = 0;	
    134c:	10 92 75 01 	sts	0x0175, r1
    1350:	08 95       	ret
    1352:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    1354:	80 91 77 01 	lds	r24, 0x0177
    1358:	8f 5f       	subi	r24, 0xFF	; 255
			if(minute >= 60){
    135a:	8c 33       	cpi	r24, 0x3C	; 60
    135c:	58 f0       	brcs	.+22     	; 0x1374 <right_inc+0x3e>
				minute = 0;	    
    135e:	10 92 77 01 	sts	0x0177, r1
			}     
			second++;
    1362:	80 91 78 01 	lds	r24, 0x0178
    1366:	8f 5f       	subi	r24, 0xFF	; 255
    1368:	80 93 78 01 	sts	0x0178, r24
			break;
    136c:	08 95       	ret
		case 2: 
			alarm_minute++;
    136e:	80 93 75 01 	sts	0x0175, r24
    1372:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    1374:	80 93 77 01 	sts	0x0177, r24
			if(minute >= 60){
				minute = 0;	    
			}     
			second++;
    1378:	80 91 78 01 	lds	r24, 0x0178
    137c:	8f 5f       	subi	r24, 0xFF	; 255
    137e:	80 93 78 01 	sts	0x0178, r24
			break;
    1382:	08 95       	ret

00001384 <right_dec>:
		default:
			break;             
	}
}
void right_dec(){
	switch(mode){
    1384:	80 91 79 01 	lds	r24, 0x0179
    1388:	81 30       	cpi	r24, 0x01	; 1
    138a:	71 f0       	breq	.+28     	; 0x13a8 <right_dec+0x24>
    138c:	82 30       	cpi	r24, 0x02	; 2
    138e:	59 f4       	brne	.+22     	; 0x13a6 <right_dec+0x22>
			if(minute >= 240){
				minute = 59;	    
			}   
			break;
		case 2: 
			alarm_minute--;
    1390:	80 91 75 01 	lds	r24, 0x0175
    1394:	81 50       	subi	r24, 0x01	; 1
    1396:	80 93 75 01 	sts	0x0175, r24
			if(alarm_minute >= 240){
    139a:	80 3f       	cpi	r24, 0xF0	; 240
    139c:	18 f0       	brcs	.+6      	; 0x13a4 <right_dec+0x20>
				alarm_minute = 59;	
    139e:	8b e3       	ldi	r24, 0x3B	; 59
    13a0:	80 93 75 01 	sts	0x0175, r24
    13a4:	08 95       	ret
    13a6:	08 95       	ret
void right_dec(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute--;
    13a8:	80 91 77 01 	lds	r24, 0x0177
    13ac:	81 50       	subi	r24, 0x01	; 1
    13ae:	80 93 77 01 	sts	0x0177, r24
			if(minute >= 240){
    13b2:	80 3f       	cpi	r24, 0xF0	; 240
    13b4:	b8 f3       	brcs	.-18     	; 0x13a4 <right_dec+0x20>
				minute = 59;	    
    13b6:	8b e3       	ldi	r24, 0x3B	; 59
    13b8:	80 93 77 01 	sts	0x0177, r24
    13bc:	08 95       	ret

000013be <decode_spi_right_knob>:
	previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
    13be:	cf 93       	push	r28
    13c0:	df 93       	push	r29
    13c2:	1f 92       	push	r1
    13c4:	cd b7       	in	r28, 0x3d	; 61
    13c6:	de b7       	in	r29, 0x3e	; 62
	uint8_t sw_index = 0;
	static uint8_t acount2 = 0;
	static uint8_t previous_encoder2 = 0;
	uint8_t direction = 0;
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    13c8:	83 70       	andi	r24, 0x03	; 3
	sw_index = (previous_encoder2 << 2) | encoder2;
    13ca:	e0 91 69 01 	lds	r30, 0x0169
    13ce:	ee 0f       	add	r30, r30
    13d0:	ee 0f       	add	r30, r30
    13d2:	e8 2b       	or	r30, r24
	direction = sw_table[sw_index];
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	ec 5f       	subi	r30, 0xFC	; 252
    13d8:	fe 4f       	sbci	r31, 0xFE	; 254
    13da:	90 81       	ld	r25, Z
	//value = modeA;
	if(direction == CW){
    13dc:	91 30       	cpi	r25, 0x01	; 1
    13de:	09 f1       	breq	.+66     	; 0x1422 <decode_spi_right_knob+0x64>
		acount2++;
	}	
	if(direction == CCW){
    13e0:	92 30       	cpi	r25, 0x02	; 2
    13e2:	41 f0       	breq	.+16     	; 0x13f4 <decode_spi_right_knob+0x36>
		acount2--;
	}
	if(encoder2 == 3){
    13e4:	83 30       	cpi	r24, 0x03	; 3
    13e6:	69 f0       	breq	.+26     	; 0x1402 <decode_spi_right_knob+0x44>
			right_dec();
		}
		//update_number();
		acount2 = 0;
	}
	previous_encoder2 = encoder2;
    13e8:	80 93 69 01 	sts	0x0169, r24
}
    13ec:	0f 90       	pop	r0
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	08 95       	ret
	//value = modeA;
	if(direction == CW){
		acount2++;
	}	
	if(direction == CCW){
		acount2--;
    13f4:	90 91 68 01 	lds	r25, 0x0168
    13f8:	91 50       	subi	r25, 0x01	; 1
    13fa:	90 93 68 01 	sts	0x0168, r25
	}
	if(encoder2 == 3){
    13fe:	83 30       	cpi	r24, 0x03	; 3
    1400:	99 f7       	brne	.-26     	; 0x13e8 <decode_spi_right_knob+0x2a>
		if((acount2 > 1) && (acount2 < 10)){
    1402:	90 91 68 01 	lds	r25, 0x0168
    1406:	2e ef       	ldi	r18, 0xFE	; 254
    1408:	29 0f       	add	r18, r25
    140a:	28 30       	cpi	r18, 0x08	; 8
    140c:	b8 f0       	brcs	.+46     	; 0x143c <decode_spi_right_knob+0x7e>
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
    140e:	91 3f       	cpi	r25, 0xF1	; 241
    1410:	70 f4       	brcc	.+28     	; 0x142e <decode_spi_right_knob+0x70>
			right_dec();
		}
		//update_number();
		acount2 = 0;
    1412:	10 92 68 01 	sts	0x0168, r1
	}
	previous_encoder2 = encoder2;
    1416:	80 93 69 01 	sts	0x0169, r24
}
    141a:	0f 90       	pop	r0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
	sw_index = (previous_encoder2 << 2) | encoder2;
	direction = sw_table[sw_index];
	//value = modeA;
	if(direction == CW){
		acount2++;
    1422:	90 91 68 01 	lds	r25, 0x0168
    1426:	9f 5f       	subi	r25, 0xFF	; 255
    1428:	90 93 68 01 	sts	0x0168, r25
    142c:	db cf       	rjmp	.-74     	; 0x13e4 <decode_spi_right_knob+0x26>
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
    142e:	89 83       	std	Y+1, r24	; 0x01
    1430:	0e 94 c2 09 	call	0x1384	; 0x1384 <right_dec>
    1434:	89 81       	ldd	r24, Y+1	; 0x01
		}
		//update_number();
		acount2 = 0;
    1436:	10 92 68 01 	sts	0x0168, r1
    143a:	ed cf       	rjmp	.-38     	; 0x1416 <decode_spi_right_knob+0x58>
	if(direction == CCW){
		acount2--;
	}
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
    143c:	89 83       	std	Y+1, r24	; 0x01
    143e:	0e 94 9b 09 	call	0x1336	; 0x1336 <right_inc>
    1442:	89 81       	ldd	r24, Y+1	; 0x01
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
		}
		//update_number();
		acount2 = 0;
    1444:	10 92 68 01 	sts	0x0168, r1
    1448:	e6 cf       	rjmp	.-52     	; 0x1416 <decode_spi_right_knob+0x58>

0000144a <left_inc>:
			break;
	}

}
void left_inc(){
	switch(mode){
    144a:	80 91 79 01 	lds	r24, 0x0179
    144e:	82 30       	cpi	r24, 0x02	; 2
    1450:	11 f1       	breq	.+68     	; 0x1496 <left_inc+0x4c>
    1452:	a8 f0       	brcs	.+42     	; 0x147e <left_inc+0x34>
    1454:	83 30       	cpi	r24, 0x03	; 3
    1456:	41 f0       	breq	.+16     	; 0x1468 <left_inc+0x1e>
    1458:	84 30       	cpi	r24, 0x04	; 4
    145a:	41 f5       	brne	.+80     	; 0x14ac <left_inc+0x62>
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			alarm_is_radio++;
    145c:	80 91 a1 01 	lds	r24, 0x01A1
    1460:	8f 5f       	subi	r24, 0xFF	; 255
    1462:	80 93 a1 01 	sts	0x01A1, r24
    1466:	08 95       	ret
			if(alarm_hour >= 24){
				alarm_hour = 0;
			}
			break;
		case 3:
			volume++;
    1468:	80 91 01 01 	lds	r24, 0x0101
    146c:	8f 5f       	subi	r24, 0xFF	; 255
    146e:	80 93 01 01 	sts	0x0101, r24
			OCR3A = volume;
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	90 93 87 00 	sts	0x0087, r25
    1478:	80 93 86 00 	sts	0x0086, r24
			break;
    147c:	08 95       	ret
			break;
	}

}
void left_inc(){
	switch(mode){
    147e:	81 30       	cpi	r24, 0x01	; 1
    1480:	a1 f4       	brne	.+40     	; 0x14aa <left_inc+0x60>
		case 0: 
			break;
		case 1:
			hour++;
    1482:	80 91 76 01 	lds	r24, 0x0176
    1486:	8f 5f       	subi	r24, 0xFF	; 255
    1488:	80 93 76 01 	sts	0x0176, r24
			if(hour >= 24){
    148c:	88 31       	cpi	r24, 0x18	; 24
    148e:	58 f3       	brcs	.-42     	; 0x1466 <left_inc+0x1c>
				hour = 0;	    
    1490:	10 92 76 01 	sts	0x0176, r1
    1494:	08 95       	ret
			}   
			break;
		case 2: 
			alarm_hour++;
    1496:	80 91 74 01 	lds	r24, 0x0174
    149a:	8f 5f       	subi	r24, 0xFF	; 255
    149c:	80 93 74 01 	sts	0x0174, r24
			if(alarm_hour >= 24){
    14a0:	88 31       	cpi	r24, 0x18	; 24
    14a2:	08 f3       	brcs	.-62     	; 0x1466 <left_inc+0x1c>
				alarm_hour = 0;
    14a4:	10 92 74 01 	sts	0x0174, r1
    14a8:	08 95       	ret
    14aa:	08 95       	ret
    14ac:	08 95       	ret

000014ae <left_dec>:
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    14ae:	80 91 79 01 	lds	r24, 0x0179
    14b2:	82 30       	cpi	r24, 0x02	; 2
    14b4:	19 f1       	breq	.+70     	; 0x14fc <left_dec+0x4e>
    14b6:	a8 f0       	brcs	.+42     	; 0x14e2 <left_dec+0x34>
    14b8:	83 30       	cpi	r24, 0x03	; 3
    14ba:	41 f0       	breq	.+16     	; 0x14cc <left_dec+0x1e>
    14bc:	84 30       	cpi	r24, 0x04	; 4
    14be:	51 f5       	brne	.+84     	; 0x1514 <left_dec+0x66>
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			alarm_is_radio++;
    14c0:	80 91 a1 01 	lds	r24, 0x01A1
    14c4:	8f 5f       	subi	r24, 0xFF	; 255
    14c6:	80 93 a1 01 	sts	0x01A1, r24
    14ca:	08 95       	ret
			if(alarm_hour >= 240){
				alarm_hour = 23;
			}
			break;
		case 3:
			volume--;
    14cc:	80 91 01 01 	lds	r24, 0x0101
    14d0:	81 50       	subi	r24, 0x01	; 1
    14d2:	80 93 01 01 	sts	0x0101, r24
			OCR3A = volume;
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	90 93 87 00 	sts	0x0087, r25
    14dc:	80 93 86 00 	sts	0x0086, r24
			break;
    14e0:	08 95       	ret
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    14e2:	81 30       	cpi	r24, 0x01	; 1
    14e4:	b1 f4       	brne	.+44     	; 0x1512 <left_dec+0x64>
		case 0: 
			break;
		case 1:
			hour--;    
    14e6:	80 91 76 01 	lds	r24, 0x0176
    14ea:	81 50       	subi	r24, 0x01	; 1
    14ec:	80 93 76 01 	sts	0x0176, r24
			if(hour >= 240){
    14f0:	80 3f       	cpi	r24, 0xF0	; 240
    14f2:	58 f3       	brcs	.-42     	; 0x14ca <left_dec+0x1c>
				hour = 23;	    
    14f4:	87 e1       	ldi	r24, 0x17	; 23
    14f6:	80 93 76 01 	sts	0x0176, r24
    14fa:	08 95       	ret
			}   
			break;
		case 2:
			alarm_hour--;
    14fc:	80 91 74 01 	lds	r24, 0x0174
    1500:	81 50       	subi	r24, 0x01	; 1
    1502:	80 93 74 01 	sts	0x0174, r24
			if(alarm_hour >= 240){
    1506:	80 3f       	cpi	r24, 0xF0	; 240
    1508:	00 f3       	brcs	.-64     	; 0x14ca <left_dec+0x1c>
				alarm_hour = 23;
    150a:	87 e1       	ldi	r24, 0x17	; 23
    150c:	80 93 74 01 	sts	0x0174, r24
    1510:	08 95       	ret
    1512:	08 95       	ret
    1514:	08 95       	ret

00001516 <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
	uint8_t sw_index = 0;
	//Counter for preventing unneccessary reset    
	static uint8_t acount1 = 0;
	static uint8_t previous_encoder1 = 0; //Initialize previous    
	uint8_t direction = 0;                    //Direction variable
	encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
    151a:	8c 70       	andi	r24, 0x0C	; 12
    151c:	c8 2f       	mov	r28, r24
    151e:	d0 e0       	ldi	r29, 0x00	; 0
    1520:	d5 95       	asr	r29
    1522:	c7 95       	ror	r28
    1524:	d5 95       	asr	r29
    1526:	c7 95       	ror	r28
    1528:	9c 2f       	mov	r25, r28
	sw_index = (previous_encoder1 << 2) | encoder1; 
    152a:	e0 91 6b 01 	lds	r30, 0x016B
    152e:	ee 0f       	add	r30, r30
    1530:	ee 0f       	add	r30, r30
    1532:	ec 2b       	or	r30, r28
	/*shift previous to the left use it as an index Since
	  we know the pattern of the knob when it is turning
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
    1534:	f0 e0       	ldi	r31, 0x00	; 0
    1536:	ec 5f       	subi	r30, 0xFC	; 252
    1538:	fe 4f       	sbci	r31, 0xFE	; 254
    153a:	80 81       	ld	r24, Z
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
    153c:	81 30       	cpi	r24, 0x01	; 1
    153e:	f9 f0       	breq	.+62     	; 0x157e <decode_spi_left_knob+0x68>
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
    1540:	82 30       	cpi	r24, 0x02	; 2
    1542:	39 f0       	breq	.+14     	; 0x1552 <decode_spi_left_knob+0x3c>
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    1544:	93 30       	cpi	r25, 0x03	; 3
    1546:	61 f0       	breq	.+24     	; 0x1560 <decode_spi_left_knob+0x4a>
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
	}
	previous_encoder1 = encoder1;
    1548:	c0 93 6b 01 	sts	0x016B, r28
}
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	08 95       	ret
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
    1552:	80 91 6a 01 	lds	r24, 0x016A
    1556:	81 50       	subi	r24, 0x01	; 1
    1558:	80 93 6a 01 	sts	0x016A, r24
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    155c:	93 30       	cpi	r25, 0x03	; 3
    155e:	a1 f7       	brne	.-24     	; 0x1548 <decode_spi_left_knob+0x32>
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
    1560:	80 91 6a 01 	lds	r24, 0x016A
    1564:	9e ef       	ldi	r25, 0xFE	; 254
    1566:	98 0f       	add	r25, r24
    1568:	98 30       	cpi	r25, 0x08	; 8
    156a:	a0 f0       	brcs	.+40     	; 0x1594 <decode_spi_left_knob+0x7e>
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
    156c:	81 3f       	cpi	r24, 0xF1	; 241
    156e:	68 f4       	brcc	.+26     	; 0x158a <decode_spi_left_knob+0x74>
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    1570:	10 92 6a 01 	sts	0x016A, r1
	}
	previous_encoder1 = encoder1;
    1574:	c0 93 6b 01 	sts	0x016B, r28
}
    1578:	df 91       	pop	r29
    157a:	cf 91       	pop	r28
    157c:	08 95       	ret
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
    157e:	80 91 6a 01 	lds	r24, 0x016A
    1582:	8f 5f       	subi	r24, 0xFF	; 255
    1584:	80 93 6a 01 	sts	0x016A, r24
    1588:	dd cf       	rjmp	.-70     	; 0x1544 <decode_spi_left_knob+0x2e>
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
    158a:	0e 94 57 0a 	call	0x14ae	; 0x14ae <left_dec>
		}
		acount1 = 0;                     //Reset counter
    158e:	10 92 6a 01 	sts	0x016A, r1
    1592:	f0 cf       	rjmp	.-32     	; 0x1574 <decode_spi_left_knob+0x5e>
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
    1594:	0e 94 25 0a 	call	0x144a	; 0x144a <left_inc>
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    1598:	10 92 6a 01 	sts	0x016A, r1
    159c:	eb cf       	rjmp	.-42     	; 0x1574 <decode_spi_left_knob+0x5e>

0000159e <check_knobs>:
	__asm__ __volatile__ ("nop");
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
	// Return incoming data from SPDR
	return(SPDR);  
}
void check_knobs(void){
    159e:	cf 93       	push	r28
	static uint8_t cnt = 0;
	static uint8_t encoder;
	cnt++;
    15a0:	c0 91 6e 01 	lds	r28, 0x016E
    15a4:	cf 5f       	subi	r28, 0xFF	; 255
    15a6:	c0 93 6e 01 	sts	0x016E, r28
	encoder = SPI_Receive();
    15aa:	0e 94 c6 08 	call	0x118c	; 0x118c <SPI_Receive>
    15ae:	80 93 6d 01 	sts	0x016D, r24
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
    15b2:	c0 ff       	sbrs	r28, 0
    15b4:	03 c0       	rjmp	.+6      	; 0x15bc <check_knobs+0x1e>
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
	}
}
    15b6:	cf 91       	pop	r28
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
    15b8:	0c 94 df 09 	jmp	0x13be	; 0x13be <decode_spi_right_knob>
	}
}
    15bc:	cf 91       	pop	r28
	static uint8_t encoder;
	cnt++;
	encoder = SPI_Receive();
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
    15be:	0c 94 8b 0a 	jmp	0x1516	; 0x1516 <decode_spi_left_knob>

000015c2 <get_remote_temp>:

//TOD
// Pull temp functions from temp directory
// Display temp

uint16_t get_remote_temp(uint8_t f_or_c){
    15c2:	cf 93       	push	r28
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(f_or_c == 1){
    15c4:	81 30       	cpi	r24, 0x01	; 1
    15c6:	79 f0       	breq	.+30     	; 0x15e6 <get_remote_temp+0x24>
		uart_putc(CELCIUS); //Ask atmega48 for celcius
	}
	else{
		uart_putc(FARENHEIT); //Ask for F
    15c8:	81 e0       	ldi	r24, 0x01	; 1
    15ca:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <uart_putc>
	}

	lo = uart_getc(); //Get low byte
    15ce:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <uart_getc>
    15d2:	c8 2f       	mov	r28, r24
	hi = uart_getc(); //Get high byte
    15d4:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <uart_getc>

	tmp = (hi<<8) | lo; //Concatinate
    15d8:	2c 2f       	mov	r18, r28
    15da:	30 e0       	ldi	r19, 0x00	; 0
	return tmp;	   //return tempearture
}
    15dc:	a9 01       	movw	r20, r18
    15de:	58 2b       	or	r21, r24
    15e0:	ca 01       	movw	r24, r20
    15e2:	cf 91       	pop	r28
    15e4:	08 95       	ret
uint16_t get_remote_temp(uint8_t f_or_c){
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(f_or_c == 1){
		uart_putc(CELCIUS); //Ask atmega48 for celcius
    15e6:	82 e0       	ldi	r24, 0x02	; 2
    15e8:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <uart_putc>
    15ec:	f0 cf       	rjmp	.-32     	; 0x15ce <get_remote_temp+0xc>

000015ee <generate_temp_str>:

	tmp = (hi<<8) | lo; //Concatinate
	return tmp;	   //return tempearture
}

void generate_temp_str(){
    15ee:	ef 92       	push	r14
    15f0:	ff 92       	push	r15
    15f2:	0f 93       	push	r16
    15f4:	1f 93       	push	r17
    15f6:	cf 93       	push	r28
    15f8:	df 93       	push	r29
    15fa:	00 d0       	rcall	.+0      	; 0x15fc <generate_temp_str+0xe>
    15fc:	00 d0       	rcall	.+0      	; 0x15fe <generate_temp_str+0x10>
    15fe:	00 d0       	rcall	.+0      	; 0x1600 <generate_temp_str+0x12>
    1600:	cd b7       	in	r28, 0x3d	; 61
    1602:	de b7       	in	r29, 0x3e	; 62
	uint16_t remote_temp, local_temp;
	char local_buf[3];
	char remote_buf[3];
	if(reset_temp == 0){
    1604:	80 91 62 01 	lds	r24, 0x0162
    1608:	88 23       	and	r24, r24
    160a:	e9 f1       	breq	.+122    	; 0x1686 <generate_temp_str+0x98>
		return;
	}
	//TODO

	if(temp_mode){
    160c:	80 91 4d 01 	lds	r24, 0x014D
    1610:	81 11       	cpse	r24, r1
    1612:	46 c0       	rjmp	.+140    	; 0x16a0 <generate_temp_str+0xb2>
		loc_temp_str[15] = 'C';
		rem_temp_str[15] = 'C';

	}
	else {
		local_temp = get_local_temp(2);
    1614:	82 e0       	ldi	r24, 0x02	; 2
    1616:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <get_local_temp>
    161a:	7c 01       	movw	r14, r24
		remote_temp = get_remote_temp(2);
    161c:	82 e0       	ldi	r24, 0x02	; 2
    161e:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <get_remote_temp>
    1622:	8c 01       	movw	r16, r24
		loc_temp_str[15] = 'F';
    1624:	e0 91 7e 01 	lds	r30, 0x017E
    1628:	f0 91 7f 01 	lds	r31, 0x017F
    162c:	86 e4       	ldi	r24, 0x46	; 70
    162e:	87 87       	std	Z+15, r24	; 0x0f
		rem_temp_str[15] = 'F';
    1630:	e0 91 7c 01 	lds	r30, 0x017C
    1634:	f0 91 7d 01 	lds	r31, 0x017D
    1638:	87 87       	std	Z+15, r24	; 0x0f
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    163a:	4a e0       	ldi	r20, 0x0A	; 10
    163c:	be 01       	movw	r22, r28
    163e:	6c 5f       	subi	r22, 0xFC	; 252
    1640:	7f 4f       	sbci	r23, 0xFF	; 255
    1642:	c7 01       	movw	r24, r14
    1644:	0e 94 c7 10 	call	0x218e	; 0x218e <__itoa_ncheck>
    1648:	4a e0       	ldi	r20, 0x0A	; 10
    164a:	be 01       	movw	r22, r28
    164c:	6f 5f       	subi	r22, 0xFF	; 255
    164e:	7f 4f       	sbci	r23, 0xFF	; 255
    1650:	c8 01       	movw	r24, r16
    1652:	0e 94 c7 10 	call	0x218e	; 0x218e <__itoa_ncheck>
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);

	if(local_buf[2] == '1'){
    1656:	8e 81       	ldd	r24, Y+6	; 0x06
		loc_temp_str[12] = local_buf[0];
    1658:	e0 91 7e 01 	lds	r30, 0x017E
    165c:	f0 91 7f 01 	lds	r31, 0x017F
		rem_temp_str[15] = 'F';
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);

	if(local_buf[2] == '1'){
    1660:	81 33       	cpi	r24, 0x31	; 49
    1662:	91 f1       	breq	.+100    	; 0x16c8 <generate_temp_str+0xda>
		loc_temp_str[12] = local_buf[0];
		loc_temp_str[13] = local_buf[1];
		loc_temp_str[14] = local_buf[2];
	}
	else{
		loc_temp_str[13] = local_buf[0];
    1664:	8c 81       	ldd	r24, Y+4	; 0x04
    1666:	85 87       	std	Z+13, r24	; 0x0d
		loc_temp_str[14] = local_buf[1];
    1668:	8d 81       	ldd	r24, Y+5	; 0x05
    166a:	86 87       	std	Z+14, r24	; 0x0e
	}
	if(remote_buf[2] == '1'){
    166c:	8b 81       	ldd	r24, Y+3	; 0x03
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    166e:	e0 91 7c 01 	lds	r30, 0x017C
    1672:	f0 91 7d 01 	lds	r31, 0x017D
	}
	else{
		loc_temp_str[13] = local_buf[0];
		loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    1676:	81 33       	cpi	r24, 0x31	; 49
    1678:	99 f1       	breq	.+102    	; 0x16e0 <generate_temp_str+0xf2>
		rem_temp_str[12] = remote_buf[0];
		rem_temp_str[13] = remote_buf[1];
		rem_temp_str[14] = remote_buf[2];
	}
	else{
		rem_temp_str[13] = remote_buf[0];
    167a:	89 81       	ldd	r24, Y+1	; 0x01
    167c:	85 87       	std	Z+13, r24	; 0x0d
		rem_temp_str[14] = remote_buf[1];
    167e:	8a 81       	ldd	r24, Y+2	; 0x02
    1680:	86 87       	std	Z+14, r24	; 0x0e
	}
	//l_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	reset_temp = 0;
    1682:	10 92 62 01 	sts	0x0162, r1
}
    1686:	26 96       	adiw	r28, 0x06	; 6
    1688:	0f b6       	in	r0, 0x3f	; 63
    168a:	f8 94       	cli
    168c:	de bf       	out	0x3e, r29	; 62
    168e:	0f be       	out	0x3f, r0	; 63
    1690:	cd bf       	out	0x3d, r28	; 61
    1692:	df 91       	pop	r29
    1694:	cf 91       	pop	r28
    1696:	1f 91       	pop	r17
    1698:	0f 91       	pop	r16
    169a:	ff 90       	pop	r15
    169c:	ef 90       	pop	r14
    169e:	08 95       	ret
		return;
	}
	//TODO

	if(temp_mode){
		remote_temp = get_remote_temp(1);
    16a0:	81 e0       	ldi	r24, 0x01	; 1
    16a2:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <get_remote_temp>
    16a6:	8c 01       	movw	r16, r24
		local_temp = get_local_temp(1);
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <get_local_temp>
    16ae:	7c 01       	movw	r14, r24
		loc_temp_str[15] = 'C';
    16b0:	e0 91 7e 01 	lds	r30, 0x017E
    16b4:	f0 91 7f 01 	lds	r31, 0x017F
    16b8:	83 e4       	ldi	r24, 0x43	; 67
    16ba:	87 87       	std	Z+15, r24	; 0x0f
		rem_temp_str[15] = 'C';
    16bc:	e0 91 7c 01 	lds	r30, 0x017C
    16c0:	f0 91 7d 01 	lds	r31, 0x017D
    16c4:	87 87       	std	Z+15, r24	; 0x0f
    16c6:	b9 cf       	rjmp	.-142    	; 0x163a <generate_temp_str+0x4c>
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);

	if(local_buf[2] == '1'){
		loc_temp_str[12] = local_buf[0];
    16c8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ca:	94 87       	std	Z+12, r25	; 0x0c
		loc_temp_str[13] = local_buf[1];
    16cc:	9d 81       	ldd	r25, Y+5	; 0x05
    16ce:	95 87       	std	Z+13, r25	; 0x0d
		loc_temp_str[14] = local_buf[2];
    16d0:	86 87       	std	Z+14, r24	; 0x0e
	}
	else{
		loc_temp_str[13] = local_buf[0];
		loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    16d2:	8b 81       	ldd	r24, Y+3	; 0x03
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    16d4:	e0 91 7c 01 	lds	r30, 0x017C
    16d8:	f0 91 7d 01 	lds	r31, 0x017D
	}
	else{
		loc_temp_str[13] = local_buf[0];
		loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    16dc:	81 33       	cpi	r24, 0x31	; 49
    16de:	69 f6       	brne	.-102    	; 0x167a <generate_temp_str+0x8c>
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    16e0:	99 81       	ldd	r25, Y+1	; 0x01
    16e2:	94 87       	std	Z+12, r25	; 0x0c
		rem_temp_str[13] = remote_buf[1];
    16e4:	9a 81       	ldd	r25, Y+2	; 0x02
    16e6:	95 87       	std	Z+13, r25	; 0x0d
		rem_temp_str[14] = remote_buf[2];
    16e8:	86 87       	std	Z+14, r24	; 0x0e
    16ea:	cb cf       	rjmp	.-106    	; 0x1682 <generate_temp_str+0x94>

000016ec <generate_alarm_string>:
	//loc_temp_str[12] = '2';
	reset_temp = 0;
}

void generate_alarm_string(){
	if(alarm_is_radio%2){
    16ec:	80 91 a1 01 	lds	r24, 0x01A1
		//strcpy(alrm_string, "ALARM RADIO");		
		alrm_str[7]  = 'R';
    16f0:	e0 91 7a 01 	lds	r30, 0x017A
    16f4:	f0 91 7b 01 	lds	r31, 0x017B
	//loc_temp_str[12] = '2';
	reset_temp = 0;
}

void generate_alarm_string(){
	if(alarm_is_radio%2){
    16f8:	80 fd       	sbrc	r24, 0
    16fa:	0b c0       	rjmp	.+22     	; 0x1712 <generate_alarm_string+0x26>
		alrm_str[10] = 'I';
		alrm_str[11] = 'O';
	}
	else{
		//strcpy(alrm_string, "ALARM MUSIC");		
		alrm_str[7]  = 'M';
    16fc:	8d e4       	ldi	r24, 0x4D	; 77
    16fe:	87 83       	std	Z+7, r24	; 0x07
		alrm_str[8]  = 'U';
    1700:	85 e5       	ldi	r24, 0x55	; 85
    1702:	80 87       	std	Z+8, r24	; 0x08
		alrm_str[9]  = 'S';
    1704:	83 e5       	ldi	r24, 0x53	; 83
    1706:	81 87       	std	Z+9, r24	; 0x09
		alrm_str[10] = 'I';
    1708:	89 e4       	ldi	r24, 0x49	; 73
    170a:	82 87       	std	Z+10, r24	; 0x0a
		alrm_str[11] = 'C';
    170c:	83 e4       	ldi	r24, 0x43	; 67
    170e:	83 87       	std	Z+11, r24	; 0x0b
    1710:	08 95       	ret
}

void generate_alarm_string(){
	if(alarm_is_radio%2){
		//strcpy(alrm_string, "ALARM RADIO");		
		alrm_str[7]  = 'R';
    1712:	82 e5       	ldi	r24, 0x52	; 82
    1714:	87 83       	std	Z+7, r24	; 0x07
		alrm_str[8]  = 'A';
    1716:	81 e4       	ldi	r24, 0x41	; 65
    1718:	80 87       	std	Z+8, r24	; 0x08
		alrm_str[9]  = 'D';
    171a:	84 e4       	ldi	r24, 0x44	; 68
    171c:	81 87       	std	Z+9, r24	; 0x09
		alrm_str[10] = 'I';
    171e:	89 e4       	ldi	r24, 0x49	; 73
    1720:	82 87       	std	Z+10, r24	; 0x0a
		alrm_str[11] = 'O';
    1722:	8f e4       	ldi	r24, 0x4F	; 79
    1724:	83 87       	std	Z+11, r24	; 0x0b
    1726:	08 95       	ret

00001728 <show_temperature>:

}

void show_temperature(){
	static uint8_t counter = 0;
	generate_temp_str();
    1728:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <generate_temp_str>
	if(counter <= 15){
    172c:	80 91 67 01 	lds	r24, 0x0167
    1730:	80 31       	cpi	r24, 0x10	; 16
    1732:	50 f0       	brcs	.+20     	; 0x1748 <show_temperature+0x20>
			//_delay_ms(1);
		}
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
    1734:	90 ef       	ldi	r25, 0xF0	; 240
    1736:	98 0f       	add	r25, r24
    1738:	90 31       	cpi	r25, 0x10	; 16
    173a:	f8 f0       	brcs	.+62     	; 0x177a <show_temperature+0x52>
		//if(counter == 31){
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
    173c:	8b 34       	cpi	r24, 0x4B	; 75
    173e:	b0 f4       	brcc	.+44     	; 0x176c <show_temperature+0x44>
		temp_is_up = 1;
		counter = 0;
		cursor_home();
	}
	else{
		counter++;
    1740:	8f 5f       	subi	r24, 0xFF	; 255
    1742:	80 93 67 01 	sts	0x0167, r24
    1746:	08 95       	ret

void show_temperature(){
	static uint8_t counter = 0;
	generate_temp_str();
	if(counter <= 15){
		char2lcd(loc_temp_str[counter]);
    1748:	e0 91 7e 01 	lds	r30, 0x017E
    174c:	f0 91 7f 01 	lds	r31, 0x017F
    1750:	e8 0f       	add	r30, r24
    1752:	f1 1d       	adc	r31, r1
    1754:	80 81       	ld	r24, Z
    1756:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <char2lcd>
		if(counter == 15){
    175a:	80 91 67 01 	lds	r24, 0x0167
    175e:	8f 30       	cpi	r24, 0x0F	; 15
    1760:	79 f7       	brne	.-34     	; 0x1740 <show_temperature+0x18>
			home_line2();
    1762:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <home_line2>
    1766:	80 91 67 01 	lds	r24, 0x0167
    176a:	ea cf       	rjmp	.-44     	; 0x1740 <show_temperature+0x18>
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
		temp_is_up = 1;
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	80 93 60 01 	sts	0x0160, r24
		counter = 0;
    1772:	10 92 67 01 	sts	0x0167, r1
		cursor_home();
    1776:	0c 94 b5 0d 	jmp	0x1b6a	; 0x1b6a <cursor_home>
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
		//minute++;
		char2lcd(rem_temp_str[counter-16]);
    177a:	e0 91 7c 01 	lds	r30, 0x017C
    177e:	f0 91 7d 01 	lds	r31, 0x017D
    1782:	e8 0f       	add	r30, r24
    1784:	f1 1d       	adc	r31, r1
    1786:	70 97       	sbiw	r30, 0x10	; 16
    1788:	80 81       	ld	r24, Z
    178a:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <char2lcd>
		counter++;
    178e:	80 91 67 01 	lds	r24, 0x0167
    1792:	8f 5f       	subi	r24, 0xFF	; 255
    1794:	80 93 67 01 	sts	0x0167, r24
    1798:	08 95       	ret

0000179a <show_alarm>:
		counter++;
	}
}
void show_alarm(){
	static uint8_t counter = 0;
	generate_alarm_string();
    179a:	0e 94 76 0b 	call	0x16ec	; 0x16ec <generate_alarm_string>
	if(counter <= 15){
    179e:	80 91 66 01 	lds	r24, 0x0166
    17a2:	80 31       	cpi	r24, 0x10	; 16
    17a4:	30 f0       	brcs	.+12     	; 0x17b2 <show_alarm+0x18>
		char2lcd(alrm_str[counter]);
		counter++;
	}
	else if (counter >= 45){
    17a6:	8d 32       	cpi	r24, 0x2D	; 45
    17a8:	98 f4       	brcc	.+38     	; 0x17d0 <show_alarm+0x36>
		counter = 0;
		cursor_home();
	}
	else{
		counter++;
    17aa:	8f 5f       	subi	r24, 0xFF	; 255
    17ac:	80 93 66 01 	sts	0x0166, r24
    17b0:	08 95       	ret
}
void show_alarm(){
	static uint8_t counter = 0;
	generate_alarm_string();
	if(counter <= 15){
		char2lcd(alrm_str[counter]);
    17b2:	e0 91 7a 01 	lds	r30, 0x017A
    17b6:	f0 91 7b 01 	lds	r31, 0x017B
    17ba:	e8 0f       	add	r30, r24
    17bc:	f1 1d       	adc	r31, r1
    17be:	80 81       	ld	r24, Z
    17c0:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <char2lcd>
		counter++;
    17c4:	80 91 66 01 	lds	r24, 0x0166
    17c8:	8f 5f       	subi	r24, 0xFF	; 255
    17ca:	80 93 66 01 	sts	0x0166, r24
    17ce:	08 95       	ret
	}
	else if (counter >= 45){
		counter = 0;
    17d0:	10 92 66 01 	sts	0x0166, r1
		cursor_home();
    17d4:	0c 94 b5 0d 	jmp	0x1b6a	; 0x1b6a <cursor_home>

000017d8 <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    17d8:	83 b7       	in	r24, 0x33	; 51
    17da:	81 60       	ori	r24, 0x01	; 1
    17dc:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    17de:	80 b7       	in	r24, 0x30	; 48
    17e0:	88 60       	ori	r24, 0x08	; 8
    17e2:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    17e4:	85 b5       	in	r24, 0x25	; 37
    17e6:	8a 67       	ori	r24, 0x7A	; 122
    17e8:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    17ea:	87 b7       	in	r24, 0x37	; 55
    17ec:	81 64       	ori	r24, 0x41	; 65
    17ee:	87 bf       	out	0x37, r24	; 55
    17f0:	08 95       	ret

000017f2 <ADC_init>:
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    17f2:	e1 e6       	ldi	r30, 0x61	; 97
    17f4:	f0 e0       	ldi	r31, 0x00	; 0
    17f6:	80 81       	ld	r24, Z
    17f8:	80 83       	st	Z, r24
	PORTF = 0x00;
    17fa:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    17fe:	87 b1       	in	r24, 0x07	; 7
    1800:	80 66       	ori	r24, 0x60	; 96
    1802:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1804:	86 b1       	in	r24, 0x06	; 6
    1806:	8f 6e       	ori	r24, 0xEF	; 239
    1808:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    180a:	8f ef       	ldi	r24, 0xFF	; 255
    180c:	83 bd       	out	0x23, r24	; 35
    180e:	08 95       	ret

00001810 <volume_control_init>:
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1810:	81 e8       	ldi	r24, 0x81	; 129
    1812:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    1816:	89 e0       	ldi	r24, 0x09	; 9
    1818:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    181c:	80 91 01 01 	lds	r24, 0x0101
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	90 93 87 00 	sts	0x0087, r25
    1826:	80 93 86 00 	sts	0x0086, r24
    182a:	08 95       	ret

0000182c <initialize_string>:
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    182c:	84 e1       	ldi	r24, 0x14	; 20
    182e:	91 e0       	ldi	r25, 0x01	; 1
    1830:	90 93 7f 01 	sts	0x017F, r25
    1834:	80 93 7e 01 	sts	0x017E, r24
	rem_temp_str = "Remote temp:   C";
    1838:	85 e2       	ldi	r24, 0x25	; 37
    183a:	91 e0       	ldi	r25, 0x01	; 1
    183c:	90 93 7d 01 	sts	0x017D, r25
    1840:	80 93 7c 01 	sts	0x017C, r24
	alrm_str     = "ALARM      *****";
    1844:	86 e3       	ldi	r24, 0x36	; 54
    1846:	91 e0       	ldi	r25, 0x01	; 1
    1848:	90 93 7b 01 	sts	0x017B, r25
    184c:	80 93 7a 01 	sts	0x017A, r24
    1850:	08 95       	ret

00001852 <encoder_init>:
}

void encoder_init(){
	DDRF &= 0xFC;
    1852:	e1 e6       	ldi	r30, 0x61	; 97
    1854:	f0 e0       	ldi	r31, 0x00	; 0
    1856:	80 81       	ld	r24, Z
    1858:	8c 7f       	andi	r24, 0xFC	; 252
    185a:	80 83       	st	Z, r24
	PORTF |= (1<<PF7);
    185c:	e2 e6       	ldi	r30, 0x62	; 98
    185e:	f0 e0       	ldi	r31, 0x00	; 0
    1860:	80 81       	ld	r24, Z
    1862:	80 68       	ori	r24, 0x80	; 128
    1864:	80 83       	st	Z, r24
    1866:	08 95       	ret

00001868 <LCD_handler>:
}

void LCD_handler(){
	if(LCD_mode==0){
    1868:	80 91 4c 01 	lds	r24, 0x014C
    186c:	88 23       	and	r24, r24
    186e:	29 f0       	breq	.+10     	; 0x187a <LCD_handler+0x12>
		//alarm_mode_change = 1;
		show_alarm();	
		//show words;
	}
	else if(LCD_mode==1){
    1870:	81 30       	cpi	r24, 0x01	; 1
    1872:	51 f0       	breq	.+20     	; 0x1888 <LCD_handler+0x20>
		//Mode 2 => show temp in F
		temp_mode = 0;	
		show_temperature();
	}
	else if(LCD_mode==2){
    1874:	82 30       	cpi	r24, 0x02	; 2
    1876:	19 f0       	breq	.+6      	; 0x187e <LCD_handler+0x16>
    1878:	08 95       	ret
}

void LCD_handler(){
	if(LCD_mode==0){
		//alarm_mode_change = 1;
		show_alarm();	
    187a:	0c 94 cd 0b 	jmp	0x179a	; 0x179a <show_alarm>
		temp_mode = 0;	
		show_temperature();
	}
	else if(LCD_mode==2){
		//Mode 3 => show temp in C
		temp_mode = 1;	
    187e:	81 e0       	ldi	r24, 0x01	; 1
    1880:	80 93 4d 01 	sts	0x014D, r24
		show_temperature();
    1884:	0c 94 94 0b 	jmp	0x1728	; 0x1728 <show_temperature>
		show_alarm();	
		//show words;
	}
	else if(LCD_mode==1){
		//Mode 2 => show temp in F
		temp_mode = 0;	
    1888:	10 92 4d 01 	sts	0x014D, r1
		show_temperature();
    188c:	0c 94 94 0b 	jmp	0x1728	; 0x1728 <show_temperature>

00001890 <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    1890:	1f 92       	push	r1
    1892:	0f 92       	push	r0
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	0f 92       	push	r0
    1898:	11 24       	eor	r1, r1
    189a:	0b b6       	in	r0, 0x3b	; 59
    189c:	0f 92       	push	r0
    189e:	2f 93       	push	r18
    18a0:	3f 93       	push	r19
    18a2:	8f 93       	push	r24
    18a4:	9f 93       	push	r25
    18a6:	af 93       	push	r26
    18a8:	bf 93       	push	r27
    18aa:	ef 93       	push	r30
    18ac:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    18ae:	80 91 71 00 	lds	r24, 0x0071
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	fc 01       	movw	r30, r24
    18b6:	38 97       	sbiw	r30, 0x08	; 8
    18b8:	e1 35       	cpi	r30, 0x51	; 81
    18ba:	f1 05       	cpc	r31, r1
    18bc:	b0 f0       	brcs	.+44     	; 0x18ea <__vector_33+0x5a>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    18be:	80 91 71 00 	lds	r24, 0x0071
    18c2:	80 93 a7 01 	sts	0x01A7, r24
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    18c6:	84 e0       	ldi	r24, 0x04	; 4
    18c8:	80 93 74 00 	sts	0x0074, r24
  }//switch
}//TWI_isr
    18cc:	ff 91       	pop	r31
    18ce:	ef 91       	pop	r30
    18d0:	bf 91       	pop	r27
    18d2:	af 91       	pop	r26
    18d4:	9f 91       	pop	r25
    18d6:	8f 91       	pop	r24
    18d8:	3f 91       	pop	r19
    18da:	2f 91       	pop	r18
    18dc:	0f 90       	pop	r0
    18de:	0b be       	out	0x3b, r0	; 59
    18e0:	0f 90       	pop	r0
    18e2:	0f be       	out	0x3f, r0	; 63
    18e4:	0f 90       	pop	r0
    18e6:	1f 90       	pop	r1
    18e8:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    18ea:	e5 52       	subi	r30, 0x25	; 37
    18ec:	ff 4f       	sbci	r31, 0xFF	; 255
    18ee:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    18f2:	80 91 80 01 	lds	r24, 0x0180
    18f6:	e0 91 a8 01 	lds	r30, 0x01A8
    18fa:	f0 91 a9 01 	lds	r31, 0x01A9
    18fe:	e8 0f       	add	r30, r24
    1900:	f1 1d       	adc	r31, r1
    1902:	80 91 73 00 	lds	r24, 0x0073
    1906:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    1908:	84 e9       	ldi	r24, 0x94	; 148
    190a:	80 93 74 00 	sts	0x0074, r24
      break;      
    190e:	de cf       	rjmp	.-68     	; 0x18cc <__vector_33+0x3c>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    1910:	80 91 aa 01 	lds	r24, 0x01AA
    1914:	80 93 73 00 	sts	0x0073, r24
      twi_buf_ptr = 0;      //initalize buffer pointer 
    1918:	10 92 80 01 	sts	0x0180, r1
      TWCR = TWCR_SEND;     //send SLA+RW
    191c:	85 e8       	ldi	r24, 0x85	; 133
    191e:	80 93 74 00 	sts	0x0074, r24
      break;
    1922:	d4 cf       	rjmp	.-88     	; 0x18cc <__vector_33+0x3c>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    1924:	80 91 80 01 	lds	r24, 0x0180
    1928:	90 91 ab 01 	lds	r25, 0x01AB
    192c:	89 17       	cp	r24, r25
    192e:	60 f7       	brcc	.-40     	; 0x1908 <__vector_33+0x78>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    1930:	e0 91 a8 01 	lds	r30, 0x01A8
    1934:	f0 91 a9 01 	lds	r31, 0x01A9
    1938:	91 e0       	ldi	r25, 0x01	; 1
    193a:	98 0f       	add	r25, r24
    193c:	90 93 80 01 	sts	0x0180, r25
    1940:	e8 0f       	add	r30, r24
    1942:	f1 1d       	adc	r31, r1
    1944:	80 81       	ld	r24, Z
    1946:	80 93 73 00 	sts	0x0073, r24
        TWCR = TWCR_SEND;               //send next byte 
    194a:	85 e8       	ldi	r24, 0x85	; 133
    194c:	80 93 74 00 	sts	0x0074, r24
    1950:	bd cf       	rjmp	.-134    	; 0x18cc <__vector_33+0x3c>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    1952:	85 ea       	ldi	r24, 0xA5	; 165
    1954:	80 93 74 00 	sts	0x0074, r24
      break;
    1958:	b9 cf       	rjmp	.-142    	; 0x18cc <__vector_33+0x3c>
    195a:	20 91 80 01 	lds	r18, 0x0180
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    195e:	80 91 ab 01 	lds	r24, 0x01AB
    1962:	30 e0       	ldi	r19, 0x00	; 0
    1964:	90 e0       	ldi	r25, 0x00	; 0
    1966:	01 97       	sbiw	r24, 0x01	; 1
    1968:	28 17       	cp	r18, r24
    196a:	39 07       	cpc	r19, r25
    196c:	dc f4       	brge	.+54     	; 0x19a4 <__vector_33+0x114>
    196e:	85 ec       	ldi	r24, 0xC5	; 197
    1970:	80 93 74 00 	sts	0x0074, r24
    1974:	ab cf       	rjmp	.-170    	; 0x18cc <__vector_33+0x3c>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    1976:	e0 91 a8 01 	lds	r30, 0x01A8
    197a:	f0 91 a9 01 	lds	r31, 0x01A9
    197e:	80 91 80 01 	lds	r24, 0x0180
    1982:	21 e0       	ldi	r18, 0x01	; 1
    1984:	28 0f       	add	r18, r24
    1986:	20 93 80 01 	sts	0x0180, r18
    198a:	e8 0f       	add	r30, r24
    198c:	f1 1d       	adc	r31, r1
    198e:	80 91 73 00 	lds	r24, 0x0073
    1992:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1994:	80 91 ab 01 	lds	r24, 0x01AB
    1998:	30 e0       	ldi	r19, 0x00	; 0
    199a:	90 e0       	ldi	r25, 0x00	; 0
    199c:	01 97       	sbiw	r24, 0x01	; 1
    199e:	28 17       	cp	r18, r24
    19a0:	39 07       	cpc	r19, r25
    19a2:	2c f3       	brlt	.-54     	; 0x196e <__vector_33+0xde>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    19a4:	85 e8       	ldi	r24, 0x85	; 133
    19a6:	80 93 74 00 	sts	0x0074, r24
    19aa:	90 cf       	rjmp	.-224    	; 0x18cc <__vector_33+0x3c>

000019ac <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    19ac:	80 91 74 00 	lds	r24, 0x0074
}
    19b0:	81 70       	andi	r24, 0x01	; 1
    19b2:	08 95       	ret

000019b4 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    19b4:	90 91 74 00 	lds	r25, 0x0074
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    19b8:	90 fd       	sbrc	r25, 0
    19ba:	fc cf       	rjmp	.-8      	; 0x19b4 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    19bc:	8e 7f       	andi	r24, 0xFE	; 254
    19be:	80 93 aa 01 	sts	0x01AA, r24
  twi_buf = twi_data;                   //load pointer to write buffer
    19c2:	70 93 a9 01 	sts	0x01A9, r23
    19c6:	60 93 a8 01 	sts	0x01A8, r22
  twi_msg_size = byte_cnt;              //load size of xfer 
    19ca:	40 93 ab 01 	sts	0x01AB, r20
  TWCR = TWCR_START;                    //initiate START
    19ce:	85 ea       	ldi	r24, 0xA5	; 165
    19d0:	80 93 74 00 	sts	0x0074, r24
    19d4:	08 95       	ret

000019d6 <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    19d6:	90 91 74 00 	lds	r25, 0x0074
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    19da:	90 fd       	sbrc	r25, 0
    19dc:	fc cf       	rjmp	.-8      	; 0x19d6 <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    19de:	81 60       	ori	r24, 0x01	; 1
    19e0:	80 93 aa 01 	sts	0x01AA, r24
  twi_buf = twi_data;                  //load pointer to write buffer
    19e4:	70 93 a9 01 	sts	0x01A9, r23
    19e8:	60 93 a8 01 	sts	0x01A8, r22
  twi_msg_size = byte_cnt;             //load size of xfer 
    19ec:	40 93 ab 01 	sts	0x01AB, r20
  TWCR = TWCR_START;                   //initiate START
    19f0:	85 ea       	ldi	r24, 0xA5	; 165
    19f2:	80 93 74 00 	sts	0x0074, r24
    19f6:	08 95       	ret

000019f8 <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    19f8:	8f ef       	ldi	r24, 0xFF	; 255
    19fa:	80 93 73 00 	sts	0x0073, r24
  TWSR = 0x00;     //prescaler value = 1
    19fe:	10 92 71 00 	sts	0x0071, r1
  TWBR = TWI_TWBR; //defined in twi_master.h 
    1a02:	8c e0       	ldi	r24, 0x0C	; 12
    1a04:	80 93 70 00 	sts	0x0070, r24
    1a08:	08 95       	ret

00001a0a <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1a0a:	5d 9b       	sbis	0x0b, 5	; 11
    1a0c:	fe cf       	rjmp	.-4      	; 0x1a0a <uart_putc>
    UDR0 = data;    // Send data byte
    1a0e:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1a10:	5d 9b       	sbis	0x0b, 5	; 11
    1a12:	fe cf       	rjmp	.-4      	; 0x1a10 <uart_putc+0x6>
}
    1a14:	08 95       	ret

00001a16 <uart_puts>:
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    1a16:	fc 01       	movw	r30, r24
    1a18:	20 81       	ld	r18, Z
    1a1a:	22 23       	and	r18, r18
    1a1c:	49 f0       	breq	.+18     	; 0x1a30 <uart_puts+0x1a>
    1a1e:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1a20:	5d 9b       	sbis	0x0b, 5	; 11
    1a22:	fe cf       	rjmp	.-4      	; 0x1a20 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    1a24:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1a26:	5d 9b       	sbis	0x0b, 5	; 11
    1a28:	fe cf       	rjmp	.-4      	; 0x1a26 <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    1a2a:	21 91       	ld	r18, Z+
    1a2c:	21 11       	cpse	r18, r1
    1a2e:	f8 cf       	rjmp	.-16     	; 0x1a20 <uart_puts+0xa>
    1a30:	08 95       	ret

00001a32 <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1a32:	9c 01       	movw	r18, r24
    1a34:	fc 01       	movw	r30, r24
    1a36:	44 91       	lpm	r20, Z
    1a38:	44 23       	and	r20, r20
    1a3a:	69 f0       	breq	.+26     	; 0x1a56 <uart_puts_p+0x24>
	uart_putc(pgm_read_byte(str++));
    1a3c:	01 96       	adiw	r24, 0x01	; 1
    1a3e:	f9 01       	movw	r30, r18
    1a40:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1a42:	5d 9b       	sbis	0x0b, 5	; 11
    1a44:	fe cf       	rjmp	.-4      	; 0x1a42 <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    1a46:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1a48:	5d 9b       	sbis	0x0b, 5	; 11
    1a4a:	fe cf       	rjmp	.-4      	; 0x1a48 <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1a4c:	9c 01       	movw	r18, r24
    1a4e:	fc 01       	movw	r30, r24
    1a50:	44 91       	lpm	r20, Z
    1a52:	41 11       	cpse	r20, r1
    1a54:	f3 cf       	rjmp	.-26     	; 0x1a3c <uart_puts_p+0xa>
	uart_putc(pgm_read_byte(str++));
    }
}
    1a56:	08 95       	ret

00001a58 <uart_init>:
//must be in place for the MAX232 chip to get data.

void uart_init(){
    //rx and tx enable, receive interrupt enabled, 8 bit characters
    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
    UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!
    1a58:	8a b1       	in	r24, 0x0a	; 10
    1a5a:	88 61       	ori	r24, 0x18	; 24
    1a5c:	8a b9       	out	0x0a, r24	; 10

    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
    //async operation, no parity,  one stop bit, 8-bit characters
    UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    1a5e:	e5 e9       	ldi	r30, 0x95	; 149
    1a60:	f0 e0       	ldi	r31, 0x00	; 0
    1a62:	80 81       	ld	r24, Z
    1a64:	86 60       	ori	r24, 0x06	; 6
    1a66:	80 83       	st	Z, r24
    UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    1a68:	10 92 90 00 	sts	0x0090, r1
    UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    1a6c:	87 e6       	ldi	r24, 0x67	; 103
    1a6e:	89 b9       	out	0x09, r24	; 9
    1a70:	08 95       	ret

00001a72 <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    1a72:	80 e8       	ldi	r24, 0x80	; 128
    1a74:	9e e3       	ldi	r25, 0x3E	; 62
    1a76:	03 c0       	rjmp	.+6      	; 0x1a7e <uart_getc+0xc>
    1a78:	01 97       	sbiw	r24, 0x01	; 1
	timer++;
	if(timer >= 16000){ return(0);}
    1a7a:	00 97       	sbiw	r24, 0x00	; 0
    1a7c:	21 f0       	breq	.+8      	; 0x1a86 <uart_getc+0x14>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    1a7e:	5f 9b       	sbis	0x0b, 7	; 11
    1a80:	fb cf       	rjmp	.-10     	; 0x1a78 <uart_getc+0x6>
	//what should we return if nothing comes in?
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
    1a82:	8c b1       	in	r24, 0x0c	; 12
    1a84:	08 95       	ret
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
	timer++;
	if(timer >= 16000){ return(0);}
    1a86:	80 e0       	ldi	r24, 0x00	; 0
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
}
    1a88:	08 95       	ret

00001a8a <lm73_temp_convert>:
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
    1a8a:	62 30       	cpi	r22, 0x02	; 2
    1a8c:	09 f0       	breq	.+2      	; 0x1a90 <lm73_temp_convert+0x6>
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    1a8e:	08 95       	ret
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
	lm73_temp = (lm73_temp*9/5)+32;
    1a90:	9c 01       	movw	r18, r24
    1a92:	22 0f       	add	r18, r18
    1a94:	33 1f       	adc	r19, r19
    1a96:	22 0f       	add	r18, r18
    1a98:	33 1f       	adc	r19, r19
    1a9a:	22 0f       	add	r18, r18
    1a9c:	33 1f       	adc	r19, r19
    1a9e:	28 0f       	add	r18, r24
    1aa0:	39 1f       	adc	r19, r25
    1aa2:	ad ec       	ldi	r26, 0xCD	; 205
    1aa4:	bc ec       	ldi	r27, 0xCC	; 204
    1aa6:	0e 94 b8 10 	call	0x2170	; 0x2170 <__umulhisi3>
    1aaa:	96 95       	lsr	r25
    1aac:	87 95       	ror	r24
    1aae:	96 95       	lsr	r25
    1ab0:	87 95       	ror	r24
    1ab2:	80 96       	adiw	r24, 0x20	; 32
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    1ab4:	08 95       	ret

00001ab6 <lm73_init>:
//******************************************************************************
void lm73_init(){
	lm73_wr_buf[0] = LM73_PTR_TEMP;
    1ab6:	10 92 fc 01 	sts	0x01FC, r1
	twi_start_wr(LM73_ADDRESS, lm73_wr_buf, 2);
    1aba:	42 e0       	ldi	r20, 0x02	; 2
    1abc:	6c ef       	ldi	r22, 0xFC	; 252
    1abe:	71 e0       	ldi	r23, 0x01	; 1
    1ac0:	80 e9       	ldi	r24, 0x90	; 144
    1ac2:	0c 94 da 0c 	jmp	0x19b4	; 0x19b4 <twi_start_wr>

00001ac6 <get_local_temp>:

}

uint16_t get_local_temp(uint8_t f_not_c){
    1ac6:	cf 93       	push	r28
    1ac8:	c8 2f       	mov	r28, r24
	uint16_t ret, lm73_temp;
	twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2);
    1aca:	42 e0       	ldi	r20, 0x02	; 2
    1acc:	6e ef       	ldi	r22, 0xFE	; 254
    1ace:	71 e0       	ldi	r23, 0x01	; 1
    1ad0:	80 e9       	ldi	r24, 0x90	; 144
    1ad2:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1ad6:	8f e3       	ldi	r24, 0x3F	; 63
    1ad8:	9f e1       	ldi	r25, 0x1F	; 31
    1ada:	01 97       	sbiw	r24, 0x01	; 1
    1adc:	f1 f7       	brne	.-4      	; 0x1ada <get_local_temp+0x14>
    1ade:	00 c0       	rjmp	.+0      	; 0x1ae0 <get_local_temp+0x1a>
    1ae0:	00 00       	nop
	_delay_ms(2);    //wait for it to finish
	//now assemble the two bytes read back into one 16-bit value
	//save high temperature byte into lm73_temp
	lm73_temp = lm73_rd_buf[0] << 8;
    1ae2:	20 91 fe 01 	lds	r18, 0x01FE
    1ae6:	30 e0       	ldi	r19, 0x00	; 0
    1ae8:	92 2f       	mov	r25, r18
    1aea:	88 27       	eor	r24, r24
	//shift it into upper byte 
	//"OR" in the low temp byte to lm73_temp 
	lm73_temp |= lm73_rd_buf[1];
    1aec:	20 91 ff 01 	lds	r18, 0x01FF
    1af0:	82 2b       	or	r24, r18
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
    1af2:	88 0f       	add	r24, r24
    1af4:	89 2f       	mov	r24, r25
    1af6:	88 1f       	adc	r24, r24
    1af8:	99 0b       	sbc	r25, r25
    1afa:	91 95       	neg	r25
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
    1afc:	c2 30       	cpi	r28, 0x02	; 2
    1afe:	91 f4       	brne	.+36     	; 0x1b24 <get_local_temp+0x5e>
	lm73_temp = (lm73_temp*9/5)+32;
    1b00:	9c 01       	movw	r18, r24
    1b02:	22 0f       	add	r18, r18
    1b04:	33 1f       	adc	r19, r19
    1b06:	22 0f       	add	r18, r18
    1b08:	33 1f       	adc	r19, r19
    1b0a:	22 0f       	add	r18, r18
    1b0c:	33 1f       	adc	r19, r19
    1b0e:	28 0f       	add	r18, r24
    1b10:	39 1f       	adc	r19, r25
    1b12:	ad ec       	ldi	r26, 0xCD	; 205
    1b14:	bc ec       	ldi	r27, 0xCC	; 204
    1b16:	0e 94 b8 10 	call	0x2170	; 0x2170 <__umulhisi3>
    1b1a:	96 95       	lsr	r25
    1b1c:	87 95       	ror	r24
    1b1e:	96 95       	lsr	r25
    1b20:	87 95       	ror	r24
    1b22:	80 96       	adiw	r24, 0x20	; 32
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
	ret = lm73_temp_convert(lm73_temp, f_not_c);

	return ret;
}
    1b24:	cf 91       	pop	r28
    1b26:	08 95       	ret

00001b28 <strobe_lcd>:

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1b28:	e2 e6       	ldi	r30, 0x62	; 98
    1b2a:	f0 e0       	ldi	r31, 0x00	; 0
    1b2c:	80 81       	ld	r24, Z
    1b2e:	88 60       	ori	r24, 0x08	; 8
    1b30:	80 83       	st	Z, r24
	PORTF &= ~0x08;
    1b32:	80 81       	ld	r24, Z
    1b34:	87 7f       	andi	r24, 0xF7	; 247
    1b36:	80 83       	st	Z, r24
    1b38:	08 95       	ret

00001b3a <clear_display>:
}          
 
void clear_display(void){
	SPDR = 0x00;    //command, not data
    1b3a:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b3c:	77 9b       	sbis	0x0e, 7	; 14
    1b3e:	fe cf       	rjmp	.-4      	; 0x1b3c <clear_display+0x2>
	SPDR = 0x01;    //clear display command
    1b40:	81 e0       	ldi	r24, 0x01	; 1
    1b42:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b44:	77 9b       	sbis	0x0e, 7	; 14
    1b46:	fe cf       	rjmp	.-4      	; 0x1b44 <clear_display+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1b48:	80 91 62 00 	lds	r24, 0x0062
    1b4c:	88 60       	ori	r24, 0x08	; 8
    1b4e:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1b52:	80 91 62 00 	lds	r24, 0x0062
    1b56:	87 7f       	andi	r24, 0xF7	; 247
    1b58:	80 93 62 00 	sts	0x0062, r24
    1b5c:	8f e3       	ldi	r24, 0x3F	; 63
    1b5e:	9f e1       	ldi	r25, 0x1F	; 31
    1b60:	01 97       	sbiw	r24, 0x01	; 1
    1b62:	f1 f7       	brne	.-4      	; 0x1b60 <clear_display+0x26>
    1b64:	00 c0       	rjmp	.+0      	; 0x1b66 <clear_display+0x2c>
    1b66:	00 00       	nop
    1b68:	08 95       	ret

00001b6a <cursor_home>:
	strobe_lcd();   //strobe the LCD enable pin
	_delay_ms(2);   //obligatory waiting for slow LCD
}         

void cursor_home(void){
	SPDR = 0x00;    //command, not data
    1b6a:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b6c:	77 9b       	sbis	0x0e, 7	; 14
    1b6e:	fe cf       	rjmp	.-4      	; 0x1b6c <cursor_home+0x2>
	SPDR = 0x02;   // cursor go home position
    1b70:	82 e0       	ldi	r24, 0x02	; 2
    1b72:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b74:	77 9b       	sbis	0x0e, 7	; 14
    1b76:	fe cf       	rjmp	.-4      	; 0x1b74 <cursor_home+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1b78:	80 91 62 00 	lds	r24, 0x0062
    1b7c:	88 60       	ori	r24, 0x08	; 8
    1b7e:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1b82:	80 91 62 00 	lds	r24, 0x0062
    1b86:	87 7f       	andi	r24, 0xF7	; 247
    1b88:	80 93 62 00 	sts	0x0062, r24
    1b8c:	08 95       	ret

00001b8e <home_line2>:
	strobe_lcd();
//	_delay_ms(1);  //not necessary with alarm_clock.c code
}         
  
void home_line2(void){
	SPDR = 0x00;    //command, not data
    1b8e:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b90:	77 9b       	sbis	0x0e, 7	; 14
    1b92:	fe cf       	rjmp	.-4      	; 0x1b90 <home_line2+0x2>
	SPDR = 0xC0;   // cursor go home on line 2
    1b94:	80 ec       	ldi	r24, 0xC0	; 192
    1b96:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b98:	77 9b       	sbis	0x0e, 7	; 14
    1b9a:	fe cf       	rjmp	.-4      	; 0x1b98 <home_line2+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1b9c:	80 91 62 00 	lds	r24, 0x0062
    1ba0:	88 60       	ori	r24, 0x08	; 8
    1ba2:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1ba6:	80 91 62 00 	lds	r24, 0x0062
    1baa:	87 7f       	andi	r24, 0xF7	; 247
    1bac:	80 93 62 00 	sts	0x0062, r24
    1bb0:	08 95       	ret

00001bb2 <fill_spaces>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd(); 
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
    1bb2:	80 e1       	ldi	r24, 0x10	; 16
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    1bb6:	41 e0       	ldi	r20, 0x01	; 1
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		SPDR = 0x20; 
    1bb8:	30 e2       	ldi	r19, 0x20	; 32
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    1bba:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1bbc:	77 9b       	sbis	0x0e, 7	; 14
    1bbe:	fe cf       	rjmp	.-4      	; 0x1bbc <fill_spaces+0xa>
		SPDR = 0x20; 
    1bc0:	3f b9       	out	0x0f, r19	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1bc2:	77 9b       	sbis	0x0e, 7	; 14
    1bc4:	fe cf       	rjmp	.-4      	; 0x1bc2 <fill_spaces+0x10>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1bc6:	20 91 62 00 	lds	r18, 0x0062
    1bca:	28 60       	ori	r18, 0x08	; 8
    1bcc:	20 93 62 00 	sts	0x0062, r18
	PORTF &= ~0x08;
    1bd0:	20 91 62 00 	lds	r18, 0x0062
    1bd4:	27 7f       	andi	r18, 0xF7	; 247
    1bd6:	20 93 62 00 	sts	0x0062, r18
    1bda:	ef e9       	ldi	r30, 0x9F	; 159
    1bdc:	ff e0       	ldi	r31, 0x0F	; 15
    1bde:	31 97       	sbiw	r30, 0x01	; 1
    1be0:	f1 f7       	brne	.-4      	; 0x1bde <fill_spaces+0x2c>
    1be2:	00 c0       	rjmp	.+0      	; 0x1be4 <fill_spaces+0x32>
    1be4:	00 00       	nop
    1be6:	01 97       	sbiw	r24, 0x01	; 1
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
    1be8:	00 97       	sbiw	r24, 0x00	; 0
    1bea:	39 f7       	brne	.-50     	; 0x1bba <fill_spaces+0x8>
		SPDR = 0x20; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_ms(1);
	}
}  
    1bec:	08 95       	ret

00001bee <char2lcd>:
   
void char2lcd(char a_char){
	//sends a char to the LCD
	//usage: char2lcd('H');  // send an H to the LCD
	SPDR = 0x01;   //set SR for data xfer with LSB=1
    1bee:	91 e0       	ldi	r25, 0x01	; 1
    1bf0:	9f b9       	out	0x0f, r25	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1bf2:	77 9b       	sbis	0x0e, 7	; 14
    1bf4:	fe cf       	rjmp	.-4      	; 0x1bf2 <char2lcd+0x4>
	SPDR = a_char; //send the char to the SPI port
    1bf6:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1bf8:	77 9b       	sbis	0x0e, 7	; 14
    1bfa:	fe cf       	rjmp	.-4      	; 0x1bf8 <char2lcd+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1bfc:	80 91 62 00 	lds	r24, 0x0062
    1c00:	88 60       	ori	r24, 0x08	; 8
    1c02:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1c06:	80 91 62 00 	lds	r24, 0x0062
    1c0a:	87 7f       	andi	r24, 0xF7	; 247
    1c0c:	80 93 62 00 	sts	0x0062, r24
    1c10:	8f e9       	ldi	r24, 0x9F	; 159
    1c12:	9f e0       	ldi	r25, 0x0F	; 15
    1c14:	01 97       	sbiw	r24, 0x01	; 1
    1c16:	f1 f7       	brne	.-4      	; 0x1c14 <char2lcd+0x26>
    1c18:	00 c0       	rjmp	.+0      	; 0x1c1a <char2lcd+0x2c>
    1c1a:	00 00       	nop
    1c1c:	08 95       	ret

00001c1e <cursor_off>:
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void cursor_off(void){
	//cuts cursor off 
	SPDR = 0x00;   //set SR for data xfer with LSB=1
    1c1e:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1c20:	77 9b       	sbis	0x0e, 7	; 14
    1c22:	fe cf       	rjmp	.-4      	; 0x1c20 <cursor_off+0x2>
	SPDR = 0x0C; //send the command to cut off cursor
    1c24:	8c e0       	ldi	r24, 0x0C	; 12
    1c26:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1c28:	77 9b       	sbis	0x0e, 7	; 14
    1c2a:	fe cf       	rjmp	.-4      	; 0x1c28 <cursor_off+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1c2c:	80 91 62 00 	lds	r24, 0x0062
    1c30:	88 60       	ori	r24, 0x08	; 8
    1c32:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1c36:	80 91 62 00 	lds	r24, 0x0062
    1c3a:	87 7f       	andi	r24, 0xF7	; 247
    1c3c:	80 93 62 00 	sts	0x0062, r24
    1c40:	8f e9       	ldi	r24, 0x9F	; 159
    1c42:	9f e0       	ldi	r25, 0x0F	; 15
    1c44:	01 97       	sbiw	r24, 0x01	; 1
    1c46:	f1 f7       	brne	.-4      	; 0x1c44 <cursor_off+0x26>
    1c48:	00 c0       	rjmp	.+0      	; 0x1c4a <cursor_off+0x2c>
    1c4a:	00 00       	nop
    1c4c:	08 95       	ret

00001c4e <string2lcd>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();  //toggle the enable bit
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void string2lcd(char *lcd_str){
    1c4e:	dc 01       	movw	r26, r24

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1c50:	80 e0       	ldi	r24, 0x00	; 0
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	20 e0       	ldi	r18, 0x00	; 0
    1c56:	30 e0       	ldi	r19, 0x00	; 0
		SPDR = 0x01; //set SR for data
    1c58:	41 e0       	ldi	r20, 0x01	; 1
    1c5a:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1c5c:	77 9b       	sbis	0x0e, 7	; 14
    1c5e:	fe cf       	rjmp	.-4      	; 0x1c5c <string2lcd+0xe>
		SPDR = lcd_str[count]; 
    1c60:	fd 01       	movw	r30, r26
    1c62:	e8 0f       	add	r30, r24
    1c64:	f9 1f       	adc	r31, r25
    1c66:	80 81       	ld	r24, Z
    1c68:	8f b9       	out	0x0f, r24	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1c6a:	77 9b       	sbis	0x0e, 7	; 14
    1c6c:	fe cf       	rjmp	.-4      	; 0x1c6a <string2lcd+0x1c>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1c6e:	80 91 62 00 	lds	r24, 0x0062
    1c72:	88 60       	ori	r24, 0x08	; 8
    1c74:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1c78:	80 91 62 00 	lds	r24, 0x0062
    1c7c:	87 7f       	andi	r24, 0xF7	; 247
    1c7e:	80 93 62 00 	sts	0x0062, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1c82:	8f e8       	ldi	r24, 0x8F	; 143
    1c84:	91 e0       	ldi	r25, 0x01	; 1
    1c86:	01 97       	sbiw	r24, 0x01	; 1
    1c88:	f1 f7       	brne	.-4      	; 0x1c86 <string2lcd+0x38>
    1c8a:	00 c0       	rjmp	.+0      	; 0x1c8c <string2lcd+0x3e>
    1c8c:	00 00       	nop
  
void string2lcd(char *lcd_str){

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1c8e:	2f 5f       	subi	r18, 0xFF	; 255
    1c90:	3f 4f       	sbci	r19, 0xFF	; 255
    1c92:	c9 01       	movw	r24, r18
    1c94:	fd 01       	movw	r30, r26
    1c96:	01 90       	ld	r0, Z+
    1c98:	00 20       	and	r0, r0
    1c9a:	e9 f7       	brne	.-6      	; 0x1c96 <string2lcd+0x48>
    1c9c:	ea 1b       	sub	r30, r26
    1c9e:	fb 0b       	sbc	r31, r27
    1ca0:	32 97       	sbiw	r30, 0x02	; 2
    1ca2:	e2 17       	cp	r30, r18
    1ca4:	f3 07       	cpc	r31, r19
    1ca6:	c8 f6       	brcc	.-78     	; 0x1c5a <string2lcd+0xc>
		SPDR = lcd_str[count]; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_us(100);
	}                  
} 
    1ca8:	08 95       	ret

00001caa <lcd_init>:

void lcd_init(void){
	int i;
	DDRF |= 0x08;  //port F bit 3 is the enable strobe for the LCD
    1caa:	80 91 61 00 	lds	r24, 0x0061
    1cae:	88 60       	ori	r24, 0x08	; 8
    1cb0:	80 93 61 00 	sts	0x0061, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1cb4:	8f e5       	ldi	r24, 0x5F	; 95
    1cb6:	9a ee       	ldi	r25, 0xEA	; 234
    1cb8:	01 97       	sbiw	r24, 0x01	; 1
    1cba:	f1 f7       	brne	.-4      	; 0x1cb8 <lcd_init+0xe>
    1cbc:	00 c0       	rjmp	.+0      	; 0x1cbe <lcd_init+0x14>
    1cbe:	00 00       	nop
    1cc0:	83 e0       	ldi	r24, 0x03	; 3
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
	//initalize the LCD to receive data
	_delay_ms(15);   
	for(i=0; i<=2; i++){ //do funky initalize sequence 3 times
		SPDR = 0x00;
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		SPDR = 0x30;
    1cc4:	30 e3       	ldi	r19, 0x30	; 48
	int i;
	DDRF |= 0x08;  //port F bit 3 is the enable strobe for the LCD
	//initalize the LCD to receive data
	_delay_ms(15);   
	for(i=0; i<=2; i++){ //do funky initalize sequence 3 times
		SPDR = 0x00;
    1cc6:	1f b8       	out	0x0f, r1	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1cc8:	77 9b       	sbis	0x0e, 7	; 14
    1cca:	fe cf       	rjmp	.-4      	; 0x1cc8 <lcd_init+0x1e>
		SPDR = 0x30;
    1ccc:	3f b9       	out	0x0f, r19	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1cce:	77 9b       	sbis	0x0e, 7	; 14
    1cd0:	fe cf       	rjmp	.-4      	; 0x1cce <lcd_init+0x24>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1cd2:	20 91 62 00 	lds	r18, 0x0062
    1cd6:	28 60       	ori	r18, 0x08	; 8
    1cd8:	20 93 62 00 	sts	0x0062, r18
	PORTF &= ~0x08;
    1cdc:	20 91 62 00 	lds	r18, 0x0062
    1ce0:	27 7f       	andi	r18, 0xF7	; 247
    1ce2:	20 93 62 00 	sts	0x0062, r18
    1ce6:	ef e5       	ldi	r30, 0x5F	; 95
    1ce8:	fd e6       	ldi	r31, 0x6D	; 109
    1cea:	31 97       	sbiw	r30, 0x01	; 1
    1cec:	f1 f7       	brne	.-4      	; 0x1cea <lcd_init+0x40>
    1cee:	00 c0       	rjmp	.+0      	; 0x1cf0 <lcd_init+0x46>
    1cf0:	00 00       	nop
    1cf2:	01 97       	sbiw	r24, 0x01	; 1
void lcd_init(void){
	int i;
	DDRF |= 0x08;  //port F bit 3 is the enable strobe for the LCD
	//initalize the LCD to receive data
	_delay_ms(15);   
	for(i=0; i<=2; i++){ //do funky initalize sequence 3 times
    1cf4:	00 97       	sbiw	r24, 0x00	; 0
    1cf6:	39 f7       	brne	.-50     	; 0x1cc6 <lcd_init+0x1c>
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_ms(7);
	}

	SPDR = 0x00;
    1cf8:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1cfa:	77 9b       	sbis	0x0e, 7	; 14
    1cfc:	fe cf       	rjmp	.-4      	; 0x1cfa <lcd_init+0x50>
	SPDR = 0x38;
    1cfe:	88 e3       	ldi	r24, 0x38	; 56
    1d00:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1d02:	77 9b       	sbis	0x0e, 7	; 14
    1d04:	fe cf       	rjmp	.-4      	; 0x1d02 <lcd_init+0x58>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1d06:	80 91 62 00 	lds	r24, 0x0062
    1d0a:	88 60       	ori	r24, 0x08	; 8
    1d0c:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1d10:	80 91 62 00 	lds	r24, 0x0062
    1d14:	87 7f       	andi	r24, 0xF7	; 247
    1d16:	80 93 62 00 	sts	0x0062, r24
    1d1a:	8f e1       	ldi	r24, 0x1F	; 31
    1d1c:	9e e4       	ldi	r25, 0x4E	; 78
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	f1 f7       	brne	.-4      	; 0x1d1e <lcd_init+0x74>
    1d22:	00 c0       	rjmp	.+0      	; 0x1d24 <lcd_init+0x7a>
    1d24:	00 00       	nop
	SPDR = 0x38;
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();
	_delay_ms(5);   

	SPDR = 0x00;
    1d26:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1d28:	77 9b       	sbis	0x0e, 7	; 14
    1d2a:	fe cf       	rjmp	.-4      	; 0x1d28 <lcd_init+0x7e>
	SPDR = 0x08;
    1d2c:	88 e0       	ldi	r24, 0x08	; 8
    1d2e:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1d30:	77 9b       	sbis	0x0e, 7	; 14
    1d32:	fe cf       	rjmp	.-4      	; 0x1d30 <lcd_init+0x86>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1d34:	80 91 62 00 	lds	r24, 0x0062
    1d38:	88 60       	ori	r24, 0x08	; 8
    1d3a:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1d3e:	80 91 62 00 	lds	r24, 0x0062
    1d42:	87 7f       	andi	r24, 0xF7	; 247
    1d44:	80 93 62 00 	sts	0x0062, r24
    1d48:	ef e1       	ldi	r30, 0x1F	; 31
    1d4a:	fe e4       	ldi	r31, 0x4E	; 78
    1d4c:	31 97       	sbiw	r30, 0x01	; 1
    1d4e:	f1 f7       	brne	.-4      	; 0x1d4c <lcd_init+0xa2>
    1d50:	00 c0       	rjmp	.+0      	; 0x1d52 <lcd_init+0xa8>
    1d52:	00 00       	nop
	SPDR = 0x08;
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();
	_delay_ms(5);

	SPDR = 0x00;
    1d54:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1d56:	77 9b       	sbis	0x0e, 7	; 14
    1d58:	fe cf       	rjmp	.-4      	; 0x1d56 <lcd_init+0xac>
	SPDR = 0x01;
    1d5a:	81 e0       	ldi	r24, 0x01	; 1
    1d5c:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1d5e:	77 9b       	sbis	0x0e, 7	; 14
    1d60:	fe cf       	rjmp	.-4      	; 0x1d5e <lcd_init+0xb4>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1d62:	80 91 62 00 	lds	r24, 0x0062
    1d66:	88 60       	ori	r24, 0x08	; 8
    1d68:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1d6c:	80 91 62 00 	lds	r24, 0x0062
    1d70:	87 7f       	andi	r24, 0xF7	; 247
    1d72:	80 93 62 00 	sts	0x0062, r24
    1d76:	8f e1       	ldi	r24, 0x1F	; 31
    1d78:	9e e4       	ldi	r25, 0x4E	; 78
    1d7a:	01 97       	sbiw	r24, 0x01	; 1
    1d7c:	f1 f7       	brne	.-4      	; 0x1d7a <lcd_init+0xd0>
    1d7e:	00 c0       	rjmp	.+0      	; 0x1d80 <lcd_init+0xd6>
    1d80:	00 00       	nop
	SPDR = 0x01;
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();
	_delay_ms(5);   

	SPDR = 0x00;
    1d82:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1d84:	77 9b       	sbis	0x0e, 7	; 14
    1d86:	fe cf       	rjmp	.-4      	; 0x1d84 <lcd_init+0xda>
	SPDR = 0x06;
    1d88:	86 e0       	ldi	r24, 0x06	; 6
    1d8a:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1d8c:	77 9b       	sbis	0x0e, 7	; 14
    1d8e:	fe cf       	rjmp	.-4      	; 0x1d8c <lcd_init+0xe2>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1d90:	80 91 62 00 	lds	r24, 0x0062
    1d94:	88 60       	ori	r24, 0x08	; 8
    1d96:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1d9a:	80 91 62 00 	lds	r24, 0x0062
    1d9e:	87 7f       	andi	r24, 0xF7	; 247
    1da0:	80 93 62 00 	sts	0x0062, r24
    1da4:	ef e1       	ldi	r30, 0x1F	; 31
    1da6:	fe e4       	ldi	r31, 0x4E	; 78
    1da8:	31 97       	sbiw	r30, 0x01	; 1
    1daa:	f1 f7       	brne	.-4      	; 0x1da8 <lcd_init+0xfe>
    1dac:	00 c0       	rjmp	.+0      	; 0x1dae <lcd_init+0x104>
    1dae:	00 00       	nop
	SPDR = 0x06;
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();
	_delay_ms(5);

	SPDR = 0x00;
    1db0:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1db2:	77 9b       	sbis	0x0e, 7	; 14
    1db4:	fe cf       	rjmp	.-4      	; 0x1db2 <lcd_init+0x108>
	SPDR = 0x0E;
    1db6:	8e e0       	ldi	r24, 0x0E	; 14
    1db8:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1dba:	77 9b       	sbis	0x0e, 7	; 14
    1dbc:	fe cf       	rjmp	.-4      	; 0x1dba <lcd_init+0x110>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1dbe:	80 91 62 00 	lds	r24, 0x0062
    1dc2:	88 60       	ori	r24, 0x08	; 8
    1dc4:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1dc8:	80 91 62 00 	lds	r24, 0x0062
    1dcc:	87 7f       	andi	r24, 0xF7	; 247
    1dce:	80 93 62 00 	sts	0x0062, r24
    1dd2:	8f e1       	ldi	r24, 0x1F	; 31
    1dd4:	9e e4       	ldi	r25, 0x4E	; 78
    1dd6:	01 97       	sbiw	r24, 0x01	; 1
    1dd8:	f1 f7       	brne	.-4      	; 0x1dd6 <lcd_init+0x12c>
    1dda:	00 c0       	rjmp	.+0      	; 0x1ddc <lcd_init+0x132>
    1ddc:	00 00       	nop
    1dde:	08 95       	ret

00001de0 <get_int_status>:
//
//TODO: update for interrupts
// 
uint8_t get_int_status(){

    si4734_wr_buf[0] = GET_INT_STATUS;              
    1de0:	84 e1       	ldi	r24, 0x14	; 20
    1de2:	80 93 10 02 	sts	0x0210, r24
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 1); //send get_int_status command
    1de6:	41 e0       	ldi	r20, 0x01	; 1
    1de8:	60 e1       	ldi	r22, 0x10	; 16
    1dea:	72 e0       	ldi	r23, 0x02	; 2
    1dec:	82 e2       	ldi	r24, 0x22	; 34
    1dee:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <twi_start_wr>
    while( twi_busy() ){}; //spin while previous TWI transaction finshes
    1df2:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1df6:	81 11       	cpse	r24, r1
    1df8:	fc cf       	rjmp	.-8      	; 0x1df2 <get_int_status+0x12>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1dfa:	84 e6       	ldi	r24, 0x64	; 100
    1dfc:	8a 95       	dec	r24
    1dfe:	f1 f7       	brne	.-4      	; 0x1dfc <get_int_status+0x1c>
    _delay_us(300);        //si4734 process delay
    twi_start_rd(SI4734_ADDRESS, si4734_rd_buf, 1); //get the interrupt status 
    1e00:	41 e0       	ldi	r20, 0x01	; 1
    1e02:	61 e3       	ldi	r22, 0x31	; 49
    1e04:	72 e0       	ldi	r23, 0x02	; 2
    1e06:	82 e2       	ldi	r24, 0x22	; 34
    1e08:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <twi_start_rd>
    while( twi_busy() ){}; //spin while previous TWI transaction finshes
    1e0c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1e10:	81 11       	cpse	r24, r1
    1e12:	fc cf       	rjmp	.-8      	; 0x1e0c <get_int_status+0x2c>
    return(si4734_rd_buf[0]);
}
    1e14:	80 91 31 02 	lds	r24, 0x0231
    1e18:	08 95       	ret

00001e1a <fm_tune_freq>:
//
//takes current_fm_freq and sends it to the radio chip
//

void fm_tune_freq(){
  si4734_wr_buf[0] = 0x20;  //fm tune command
    1e1a:	80 e2       	ldi	r24, 0x20	; 32
    1e1c:	80 93 10 02 	sts	0x0210, r24
  si4734_wr_buf[1] = 0x00;  //no FREEZE and no FAST tune
    1e20:	10 92 11 02 	sts	0x0211, r1
  current_fm_freq = 10630;
    1e24:	86 e8       	ldi	r24, 0x86	; 134
    1e26:	99 e2       	ldi	r25, 0x29	; 41
    1e28:	90 93 9b 01 	sts	0x019B, r25
    1e2c:	80 93 9a 01 	sts	0x019A, r24
  si4734_wr_buf[2] = (uint8_t)(current_fm_freq >> 8); //freq high byte
    1e30:	89 e2       	ldi	r24, 0x29	; 41
    1e32:	80 93 12 02 	sts	0x0212, r24
  si4734_wr_buf[3] = (uint8_t)(current_fm_freq);      //freq low byte
    1e36:	86 e8       	ldi	r24, 0x86	; 134
    1e38:	80 93 13 02 	sts	0x0213, r24
  si4734_wr_buf[4] = 0x00;  //antenna tuning capactior
    1e3c:	10 92 14 02 	sts	0x0214, r1
  //send fm tune command
  STC_interrupt = FALSE;
    1e40:	10 92 9c 01 	sts	0x019C, r1
 // set_property(GPO_IEN, GPO_IEN_STCIEN); //seek_tune complete interrupt
  twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 5);
    1e44:	45 e0       	ldi	r20, 0x05	; 5
    1e46:	60 e1       	ldi	r22, 0x10	; 16
    1e48:	72 e0       	ldi	r23, 0x02	; 2
    1e4a:	82 e2       	ldi	r24, 0x22	; 34
    1e4c:	0c 94 da 0c 	jmp	0x19b4	; 0x19b4 <twi_start_wr>

00001e50 <radio_pwr_dwn>:
//

void radio_pwr_dwn(){

	//save current frequency to EEPROM
	switch(current_radio_band){
    1e50:	80 91 48 01 	lds	r24, 0x0148
    1e54:	90 91 49 01 	lds	r25, 0x0149
	}//switch      

	//eeprom_write_byte(&eeprom_volume, current_volume); //save current volume level

	//send fm power down command
	si4734_wr_buf[0] = 0x11;
    1e58:	81 e1       	ldi	r24, 0x11	; 17
    1e5a:	80 93 10 02 	sts	0x0210, r24
	twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 1);
    1e5e:	41 e0       	ldi	r20, 0x01	; 1
    1e60:	60 e1       	ldi	r22, 0x10	; 16
    1e62:	72 e0       	ldi	r23, 0x02	; 2
    1e64:	82 e2       	ldi	r24, 0x22	; 34
    1e66:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <twi_start_wr>
    1e6a:	87 e6       	ldi	r24, 0x67	; 103
    1e6c:	8a 95       	dec	r24
    1e6e:	f1 f7       	brne	.-4      	; 0x1e6c <radio_pwr_dwn+0x1c>
    1e70:	00 00       	nop
    1e72:	08 95       	ret

00001e74 <fm_rsq_status>:
//inside the chip. 
//TODO: Dang, thats a big delay, could cause problems, best check out.
//
void fm_rsq_status(){

	si4734_wr_buf[0] = FM_RSQ_STATUS;            //fm_rsq_status command
    1e74:	83 e2       	ldi	r24, 0x23	; 35
    1e76:	80 93 10 02 	sts	0x0210, r24
	si4734_wr_buf[1] = FM_RSQ_STATUS_IN_INTACK;  //clear STCINT bit if set
    1e7a:	81 e0       	ldi	r24, 0x01	; 1
    1e7c:	80 93 11 02 	sts	0x0211, r24
	twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 2);
    1e80:	42 e0       	ldi	r20, 0x02	; 2
    1e82:	60 e1       	ldi	r22, 0x10	; 16
    1e84:	72 e0       	ldi	r23, 0x02	; 2
    1e86:	82 e2       	ldi	r24, 0x22	; 34
    1e88:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <twi_start_wr>
	while(twi_busy()){}; //spin while previous TWI transaction finshes
    1e8c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1e90:	81 11       	cpse	r24, r1
    1e92:	fc cf       	rjmp	.-8      	; 0x1e8c <fm_rsq_status+0x18>
    1e94:	84 e6       	ldi	r24, 0x64	; 100
    1e96:	8a 95       	dec	r24
    1e98:	f1 f7       	brne	.-4      	; 0x1e96 <fm_rsq_status+0x22>
	_delay_us(300);      //delay for si4734 to process
	//This is a blind wait. Waiting for CTS interrupt here would tell you 
	//when the command is received and has been processed.
	//get the fm tune status 
	twi_start_rd(SI4734_ADDRESS, si4734_tune_status_buf, 8);
    1e9a:	48 e0       	ldi	r20, 0x08	; 8
    1e9c:	69 e1       	ldi	r22, 0x19	; 25
    1e9e:	72 e0       	ldi	r23, 0x02	; 2
    1ea0:	82 e2       	ldi	r24, 0x22	; 34
    1ea2:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <twi_start_rd>
	while(twi_busy()){}; //spin while previous TWI transaction finshes
    1ea6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1eaa:	81 11       	cpse	r24, r1
    1eac:	fc cf       	rjmp	.-8      	; 0x1ea6 <fm_rsq_status+0x32>
}
    1eae:	08 95       	ret

00001eb0 <fm_tune_status>:
//is cleared.
//TODO: Dang, thats a big delay, could cause problems, best check out.
//
void fm_tune_status(){

	si4734_wr_buf[0] = FM_TUNE_STATUS;            //fm_tune_status command
    1eb0:	82 e2       	ldi	r24, 0x22	; 34
    1eb2:	80 93 10 02 	sts	0x0210, r24
	si4734_wr_buf[1] = FM_TUNE_STATUS_IN_INTACK;  //clear STCINT bit if set
    1eb6:	81 e0       	ldi	r24, 0x01	; 1
    1eb8:	80 93 11 02 	sts	0x0211, r24
	twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 2);
    1ebc:	42 e0       	ldi	r20, 0x02	; 2
    1ebe:	60 e1       	ldi	r22, 0x10	; 16
    1ec0:	72 e0       	ldi	r23, 0x02	; 2
    1ec2:	82 e2       	ldi	r24, 0x22	; 34
    1ec4:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <twi_start_wr>
	while(twi_busy()){}; //spin while previous TWI transaction finshes
    1ec8:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1ecc:	81 11       	cpse	r24, r1
    1ece:	fc cf       	rjmp	.-8      	; 0x1ec8 <fm_tune_status+0x18>
    1ed0:	84 e6       	ldi	r24, 0x64	; 100
    1ed2:	8a 95       	dec	r24
    1ed4:	f1 f7       	brne	.-4      	; 0x1ed2 <fm_tune_status+0x22>
	_delay_us(300);        //delay for si4734 to process
	//get the fm tune status 
	twi_start_rd(SI4734_ADDRESS, si4734_tune_status_buf, 8);
    1ed6:	48 e0       	ldi	r20, 0x08	; 8
    1ed8:	69 e1       	ldi	r22, 0x19	; 25
    1eda:	72 e0       	ldi	r23, 0x02	; 2
    1edc:	82 e2       	ldi	r24, 0x22	; 34
    1ede:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <twi_start_rd>
	while( twi_busy() ){}; //spin till TWI read transaction finshes
    1ee2:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1ee6:	81 11       	cpse	r24, r1
    1ee8:	fc cf       	rjmp	.-8      	; 0x1ee2 <fm_tune_status+0x32>
}
    1eea:	08 95       	ret

00001eec <set_property>:
//The set property command does not have a indication that it has completed. This
//command is guarnteed by design to finish in 10ms. 
//
void set_property(uint16_t property, uint16_t property_value){

	si4734_wr_buf[0] = SET_PROPERTY;                   //set property command
    1eec:	22 e1       	ldi	r18, 0x12	; 18
    1eee:	20 93 10 02 	sts	0x0210, r18
	si4734_wr_buf[1] = 0x00;                           //all zeros
    1ef2:	10 92 11 02 	sts	0x0211, r1
	si4734_wr_buf[2] = (uint8_t)(property >> 8);       //property high byte
    1ef6:	90 93 12 02 	sts	0x0212, r25
	si4734_wr_buf[3] = (uint8_t)(property);            //property low byte
    1efa:	80 93 13 02 	sts	0x0213, r24
	si4734_wr_buf[4] = (uint8_t)(property_value >> 8); //property value high byte
    1efe:	70 93 14 02 	sts	0x0214, r23
	si4734_wr_buf[5] = (uint8_t)(property_value);      //property value low byte
    1f02:	60 93 15 02 	sts	0x0215, r22
	twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 6);
    1f06:	46 e0       	ldi	r20, 0x06	; 6
    1f08:	60 e1       	ldi	r22, 0x10	; 16
    1f0a:	72 e0       	ldi	r23, 0x02	; 2
    1f0c:	82 e2       	ldi	r24, 0x22	; 34
    1f0e:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1f12:	83 ec       	ldi	r24, 0xC3	; 195
    1f14:	99 e0       	ldi	r25, 0x09	; 9
    1f16:	01 97       	sbiw	r24, 0x01	; 1
    1f18:	f1 f7       	brne	.-4      	; 0x1f16 <set_property+0x2a>
    1f1a:	00 c0       	rjmp	.+0      	; 0x1f1c <set_property+0x30>
    1f1c:	00 00       	nop
    1f1e:	08 95       	ret

00001f20 <fm_pwr_up>:
	//restore the previous fm frequency  
	//current_fm_freq = eeprom_read_word(&eeprom_fm_freq); //TODO: only this one does not work 
	//current_volume  = eeprom_read_byte(&eeprom_volume); //TODO: only this one does not work 

	//send fm power up command
	si4734_wr_buf[0] = FM_PWR_UP; //powerup command byte
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	80 93 10 02 	sts	0x0210, r24
	si4734_wr_buf[1] = 0x50;      //GPO2O enabled, STCINT enabled, use ext. 32khz osc.
    1f26:	80 e5       	ldi	r24, 0x50	; 80
    1f28:	80 93 11 02 	sts	0x0211, r24
	si4734_wr_buf[2] = 0x05;      //OPMODE = 0x05; analog audio output
    1f2c:	85 e0       	ldi	r24, 0x05	; 5
    1f2e:	80 93 12 02 	sts	0x0212, r24
	twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 3);
    1f32:	43 e0       	ldi	r20, 0x03	; 3
    1f34:	60 e1       	ldi	r22, 0x10	; 16
    1f36:	72 e0       	ldi	r23, 0x02	; 2
    1f38:	82 e2       	ldi	r24, 0x22	; 34
    1f3a:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <twi_start_wr>
    1f3e:	8f e2       	ldi	r24, 0x2F	; 47
    1f40:	95 e7       	ldi	r25, 0x75	; 117
    1f42:	01 97       	sbiw	r24, 0x01	; 1
    1f44:	f1 f7       	brne	.-4      	; 0x1f42 <fm_pwr_up+0x22>
    1f46:	00 c0       	rjmp	.+0      	; 0x1f48 <fm_pwr_up+0x28>
    1f48:	00 00       	nop
	_delay_ms(120);               //startup delay as specified 
	//The seek/tune interrupt is enabled here. If the STCINT bit is set, a 1.5us
	//low pulse will be output from GPIO2/INT when tune or seek is completed.
	set_property(GPO_IEN, GPO_IEN_STCIEN); //seek_tune complete interrupt
    1f4a:	61 e0       	ldi	r22, 0x01	; 1
    1f4c:	70 e0       	ldi	r23, 0x00	; 0
    1f4e:	81 e0       	ldi	r24, 0x01	; 1
    1f50:	90 e0       	ldi	r25, 0x00	; 0
    1f52:	0c 94 76 0f 	jmp	0x1eec	; 0x1eec <set_property>

00001f56 <radio_init>:
//   (^ edge int from radio) bit 7--| | | | | | | |--bit 0 USART0 RX
//(shift/load_n for 74HC165) bit 6----| | | | | |----bit 1 USART0 TX
//                           bit 5------| | | |------bit 2 (new radio reset, active high)
//                  (unused) bit 4--------| |--------bit 3 (TCNT3 PWM output for volume control)
void radio_init(void){
	DDRE  |= 0x04; //Port E bit 2 is active high reset for radio
    1f56:	12 9a       	sbi	0x02, 2	; 2
	DDRE  |= 0x40; //Port E bit 6 is shift/load_n for encoder 74HC165
    1f58:	16 9a       	sbi	0x02, 6	; 2
	DDRE  |= 0x08; //Port E bit 3 is TCNT3 PWM output for volume
    1f5a:	13 9a       	sbi	0x02, 3	; 2
	PORTE |= 0x04; //radio reset is on at powerup (active high)
    1f5c:	1a 9a       	sbi	0x03, 2	; 3
	PORTE |= 0x40; //pulse low to load switch values, else its in shift mode
    1f5e:	1e 9a       	sbi	0x03, 6	; 3
    1f60:	08 95       	ret

00001f62 <radio_reset>:
	//PORTE = (1<<PE7);
}
//Given the hardware setup reflected above, here is the radio reset sequence.
//hardware reset of Si4734
void radio_reset(void){
	PORTE &= ~(1<<PE7); //int2 initially low to sense TWI mode
    1f62:	1f 98       	cbi	0x03, 7	; 3
	DDRE  |= 0x80;      //turn on Port E bit 7 to drive it low
    1f64:	17 9a       	sbi	0x02, 7	; 2
	PORTE |=  (1<<PE2); //hardware reset Si4734
    1f66:	1a 9a       	sbi	0x03, 2	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1f68:	82 e4       	ldi	r24, 0x42	; 66
    1f6a:	8a 95       	dec	r24
    1f6c:	f1 f7       	brne	.-4      	; 0x1f6a <radio_reset+0x8>
    1f6e:	00 c0       	rjmp	.+0      	; 0x1f70 <radio_reset+0xe>
	_delay_us(200);     //hold for 200us, 100us by spec
	PORTE &= ~(1<<PE2); //release reset
    1f70:	1a 98       	cbi	0x03, 2	; 3
    1f72:	8a e0       	ldi	r24, 0x0A	; 10
    1f74:	8a 95       	dec	r24
    1f76:	f1 f7       	brne	.-4      	; 0x1f74 <radio_reset+0x12>
	_delay_us(30);      //5us required because of my slow I2C translators I suspect
	//Si code in "low" has 30us delay...no explaination in documentation
	DDRE  &= ~(0x80);   //now Port E bit 7 becomes input from the radio interrupt
    1f78:	17 98       	cbi	0x02, 7	; 2
    1f7a:	08 95       	ret

00001f7c <radio_powerUp>:
}
//Once its setup, you can tune the radio and get the received signal strength.
void radio_powerUp(void){
	while(twi_busy()){} //spin while TWI is busy
    1f7c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1f80:	81 11       	cpse	r24, r1
    1f82:	fc cf       	rjmp	.-8      	; 0x1f7c <radio_powerUp>
	fm_pwr_up();        //power up radio
    1f84:	0c 94 90 0f 	jmp	0x1f20	; 0x1f20 <fm_pwr_up>

00001f88 <radio_tune_freq>:
}
void radio_tune_freq(){
	while(twi_busy()){
    1f88:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1f8c:	81 11       	cpse	r24, r1
    1f8e:	fc cf       	rjmp	.-8      	; 0x1f88 <radio_tune_freq>
		//minute++;	
	} //spin while TWI is busy
	fm_tune_freq();     //tune to frequency
    1f90:	0c 94 0d 0f 	jmp	0x1e1a	; 0x1e1a <fm_tune_freq>

00001f94 <radio_get_strengh>:
}
//retrive the receive strength and display on the bargraph display
void radio_get_strengh(){
	while(twi_busy()){}                //spin while TWI is busy
    1f94:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <twi_busy>
    1f98:	81 11       	cpse	r24, r1
    1f9a:	fc cf       	rjmp	.-8      	; 0x1f94 <radio_get_strengh>
	fm_rsq_status();                   //get status of radio tuning operation
    1f9c:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <fm_rsq_status>
	rssi =  si4734_tune_status_buf[4]; //get tune status
    1fa0:	80 91 1d 02 	lds	r24, 0x021D
    1fa4:	80 93 44 02 	sts	0x0244, r24
    1fa8:	08 95       	ret

00001faa <redefine_rssi>:
}
//redefine rssi to be a bar graph
void redefine_rssi(){
	if(rssi<= 8) {rssi = 0x00;} 
    1faa:	80 91 44 02 	lds	r24, 0x0244
    1fae:	89 30       	cpi	r24, 0x09	; 9
    1fb0:	b0 f0       	brcs	.+44     	; 0x1fde <redefine_rssi+0x34>
	else if(rssi<=16) {rssi = 0x01;} 
    1fb2:	81 31       	cpi	r24, 0x11	; 17
    1fb4:	80 f0       	brcs	.+32     	; 0x1fd6 <redefine_rssi+0x2c>
	else if(rssi<=24) {rssi = 0x03;} 
    1fb6:	89 31       	cpi	r24, 0x19	; 25
    1fb8:	c8 f0       	brcs	.+50     	; 0x1fec <redefine_rssi+0x42>
	else if(rssi<=32) {rssi = 0x07;} 
    1fba:	81 32       	cpi	r24, 0x21	; 33
    1fbc:	98 f0       	brcs	.+38     	; 0x1fe4 <redefine_rssi+0x3a>
	else if(rssi<=40) {rssi = 0x0F;} 
    1fbe:	89 32       	cpi	r24, 0x29	; 41
    1fc0:	c8 f0       	brcs	.+50     	; 0x1ff4 <redefine_rssi+0x4a>
	else if(rssi<=48) {rssi = 0x1F;} 
    1fc2:	81 33       	cpi	r24, 0x31	; 49
    1fc4:	f8 f0       	brcs	.+62     	; 0x2004 <redefine_rssi+0x5a>
	else if(rssi<=56) {rssi = 0x3F;} 
    1fc6:	89 33       	cpi	r24, 0x39	; 57
    1fc8:	c8 f0       	brcs	.+50     	; 0x1ffc <redefine_rssi+0x52>
	else if(rssi<=64) {rssi = 0x7F;}
    1fca:	81 34       	cpi	r24, 0x41	; 65
    1fcc:	f8 f0       	brcs	.+62     	; 0x200c <redefine_rssi+0x62>
	else if(rssi>=64) {rssi = 0xFF;}
    1fce:	8f ef       	ldi	r24, 0xFF	; 255
    1fd0:	80 93 44 02 	sts	0x0244, r24
    1fd4:	08 95       	ret
	rssi =  si4734_tune_status_buf[4]; //get tune status
}
//redefine rssi to be a bar graph
void redefine_rssi(){
	if(rssi<= 8) {rssi = 0x00;} 
	else if(rssi<=16) {rssi = 0x01;} 
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	80 93 44 02 	sts	0x0244, r24
    1fdc:	08 95       	ret
	fm_rsq_status();                   //get status of radio tuning operation
	rssi =  si4734_tune_status_buf[4]; //get tune status
}
//redefine rssi to be a bar graph
void redefine_rssi(){
	if(rssi<= 8) {rssi = 0x00;} 
    1fde:	10 92 44 02 	sts	0x0244, r1
    1fe2:	08 95       	ret
	else if(rssi<=16) {rssi = 0x01;} 
	else if(rssi<=24) {rssi = 0x03;} 
	else if(rssi<=32) {rssi = 0x07;} 
    1fe4:	87 e0       	ldi	r24, 0x07	; 7
    1fe6:	80 93 44 02 	sts	0x0244, r24
    1fea:	08 95       	ret
}
//redefine rssi to be a bar graph
void redefine_rssi(){
	if(rssi<= 8) {rssi = 0x00;} 
	else if(rssi<=16) {rssi = 0x01;} 
	else if(rssi<=24) {rssi = 0x03;} 
    1fec:	83 e0       	ldi	r24, 0x03	; 3
    1fee:	80 93 44 02 	sts	0x0244, r24
    1ff2:	08 95       	ret
	else if(rssi<=32) {rssi = 0x07;} 
	else if(rssi<=40) {rssi = 0x0F;} 
    1ff4:	8f e0       	ldi	r24, 0x0F	; 15
    1ff6:	80 93 44 02 	sts	0x0244, r24
    1ffa:	08 95       	ret
	else if(rssi<=48) {rssi = 0x1F;} 
	else if(rssi<=56) {rssi = 0x3F;} 
    1ffc:	8f e3       	ldi	r24, 0x3F	; 63
    1ffe:	80 93 44 02 	sts	0x0244, r24
    2002:	08 95       	ret
	if(rssi<= 8) {rssi = 0x00;} 
	else if(rssi<=16) {rssi = 0x01;} 
	else if(rssi<=24) {rssi = 0x03;} 
	else if(rssi<=32) {rssi = 0x07;} 
	else if(rssi<=40) {rssi = 0x0F;} 
	else if(rssi<=48) {rssi = 0x1F;} 
    2004:	8f e1       	ldi	r24, 0x1F	; 31
    2006:	80 93 44 02 	sts	0x0244, r24
    200a:	08 95       	ret
	else if(rssi<=56) {rssi = 0x3F;} 
	else if(rssi<=64) {rssi = 0x7F;}
    200c:	8f e7       	ldi	r24, 0x7F	; 127
    200e:	80 93 44 02 	sts	0x0244, r24
    2012:	08 95       	ret

00002014 <radio_interrupt_init>:
    2014:	8a b7       	in	r24, 0x3a	; 58
    2016:	80 68       	ori	r24, 0x80	; 128
    2018:	8a bf       	out	0x3a, r24	; 58
    201a:	89 b7       	in	r24, 0x39	; 57
    201c:	80 68       	ori	r24, 0x80	; 128
    201e:	89 bf       	out	0x39, r24	; 57
    2020:	08 95       	ret

00002022 <main>:
{
	//set port bits 4-7 B as outputs
	//uint8_t c = 0;
	//DDRE = 0xFF;
	//PORTE &= 0x7F;
	DDRB = 0xF7;
    2022:	87 ef       	ldi	r24, 0xF7	; 247
    2024:	87 bb       	out	0x17, r24	; 23
	DDRD |= (1 << PB2);
    2026:	8a 9a       	sbi	0x11, 2	; 17

	volume = 100;
    2028:	84 e6       	ldi	r24, 0x64	; 100
    202a:	80 93 01 01 	sts	0x0101, r24
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    202e:	83 b7       	in	r24, 0x33	; 51
    2030:	81 60       	ori	r24, 0x01	; 1
    2032:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    2034:	80 b7       	in	r24, 0x30	; 48
    2036:	88 60       	ori	r24, 0x08	; 8
    2038:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    203a:	85 b5       	in	r24, 0x25	; 37
    203c:	8a 67       	ori	r24, 0x7A	; 122
    203e:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    2040:	87 b7       	in	r24, 0x37	; 55
    2042:	81 64       	ori	r24, 0x41	; 65
    2044:	87 bf       	out	0x37, r24	; 55
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    2046:	80 91 61 00 	lds	r24, 0x0061
    204a:	80 93 61 00 	sts	0x0061, r24
	PORTF = 0x00;
    204e:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    2052:	87 b1       	in	r24, 0x07	; 7
    2054:	80 66       	ori	r24, 0x60	; 96
    2056:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    2058:	86 b1       	in	r24, 0x06	; 6
    205a:	8f 6e       	ori	r24, 0xEF	; 239
    205c:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    205e:	8f ef       	ldi	r24, 0xFF	; 255
    2060:	83 bd       	out	0x23, r24	; 35

	volume = 100;
	timer_init();
	ADC_init();
	//encoder_init();
	music_init();   
    2062:	0e 94 61 05 	call	0xac2	; 0xac2 <music_init>
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    2066:	80 e5       	ldi	r24, 0x50	; 80
    2068:	8d b9       	out	0x0d, r24	; 13
	timer_init();
	ADC_init();
	//encoder_init();
	music_init();   
	SPI_init();
	lcd_init();
    206a:	0e 94 55 0e 	call	0x1caa	; 0x1caa <lcd_init>
	init_twi();
    206e:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <init_twi>
	uart_init();
    2072:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <uart_init>
	OCR2 = 0xFF;
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    2076:	81 e8       	ldi	r24, 0x81	; 129
    2078:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    207c:	89 e0       	ldi	r24, 0x09	; 9
    207e:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    2082:	80 91 01 01 	lds	r24, 0x0101
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	90 93 87 00 	sts	0x0087, r25
    208c:	80 93 86 00 	sts	0x0086, r24
	SPI_init();
	lcd_init();
	init_twi();
	uart_init();
	volume_control_init();
	lm73_init();
    2090:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <lm73_init>
	cursor_off();
    2094:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <cursor_off>
	TCCR3B = (1<<WGM32) | (1<<CS30);
	OCR3A = volume;
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    2098:	84 e1       	ldi	r24, 0x14	; 20
    209a:	91 e0       	ldi	r25, 0x01	; 1
    209c:	90 93 7f 01 	sts	0x017F, r25
    20a0:	80 93 7e 01 	sts	0x017E, r24
	rem_temp_str = "Remote temp:   C";
    20a4:	85 e2       	ldi	r24, 0x25	; 37
    20a6:	91 e0       	ldi	r25, 0x01	; 1
    20a8:	90 93 7d 01 	sts	0x017D, r25
    20ac:	80 93 7c 01 	sts	0x017C, r24
	alrm_str     = "ALARM      *****";
    20b0:	86 e3       	ldi	r24, 0x36	; 54
    20b2:	91 e0       	ldi	r25, 0x01	; 1
    20b4:	90 93 7b 01 	sts	0x017B, r25
    20b8:	80 93 7a 01 	sts	0x017A, r24
	lm73_init();
	cursor_off();
	initialize_string();
	//Test radio
	//_delay_ms(1000);
	radio_interrupt_init();
    20bc:	0e 94 0a 10 	call	0x2014	; 0x2014 <radio_interrupt_init>
	radio_init();
    20c0:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <radio_init>
	current_fm_freq = 10630;
    20c4:	86 e8       	ldi	r24, 0x86	; 134
    20c6:	99 e2       	ldi	r25, 0x29	; 41
    20c8:	90 93 9b 01 	sts	0x019B, r25
    20cc:	80 93 9a 01 	sts	0x019A, r24

	//EIMSK |= (1<<INT7);
	//EICRB |= (1<<ISC71);
	sei();
    20d0:	78 94       	sei
    20d2:	10 c0       	rjmp	.+32     	; 0x20f4 <main+0xd2>
		update_time();
		if(encode_flag){
			check_knobs();
			encode_flag = 0;
		}
		if(bar_graph_flag){
    20d4:	80 91 61 01 	lds	r24, 0x0161
    20d8:	81 11       	cpse	r24, r1
    20da:	1a c0       	rjmp	.+52     	; 0x2110 <main+0xee>
			bar_graph();
			bar_graph_flag = 0;
		}
		if(update_LCD){
    20dc:	80 91 63 01 	lds	r24, 0x0163
    20e0:	81 11       	cpse	r24, r1
    20e2:	1e c0       	rjmp	.+60     	; 0x2120 <main+0xfe>
			//show_temperature();
			LCD_handler();
			update_LCD = 0;
		}

		if(clear_LCD){
    20e4:	80 91 96 01 	lds	r24, 0x0196
    20e8:	81 11       	cpse	r24, r1
    20ea:	22 c0       	rjmp	.+68     	; 0x2130 <main+0x10e>
			clear_display();
			clear_LCD = 0;
		}
		
		if(turn_radio_on){
    20ec:	80 91 4a 01 	lds	r24, 0x014A
    20f0:	81 11       	cpse	r24, r1
    20f2:	26 c0       	rjmp	.+76     	; 0x2140 <main+0x11e>
	//*******************************************
	//strcpy(loc_temp_str, "Local  temp:   C");
	//string2lcd("hello");
	while(1){

		update_time();
    20f4:	0e 94 49 08 	call	0x1092	; 0x1092 <update_time>
		if(encode_flag){
    20f8:	80 91 65 01 	lds	r24, 0x0165
    20fc:	88 23       	and	r24, r24
    20fe:	51 f3       	breq	.-44     	; 0x20d4 <main+0xb2>
			check_knobs();
    2100:	0e 94 cf 0a 	call	0x159e	; 0x159e <check_knobs>
			encode_flag = 0;
    2104:	10 92 65 01 	sts	0x0165, r1
		}
		if(bar_graph_flag){
    2108:	80 91 61 01 	lds	r24, 0x0161
    210c:	88 23       	and	r24, r24
    210e:	31 f3       	breq	.-52     	; 0x20dc <main+0xba>
			bar_graph();
    2110:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <bar_graph>
			bar_graph_flag = 0;
    2114:	10 92 61 01 	sts	0x0161, r1
		}
		if(update_LCD){
    2118:	80 91 63 01 	lds	r24, 0x0163
    211c:	88 23       	and	r24, r24
    211e:	11 f3       	breq	.-60     	; 0x20e4 <main+0xc2>
			//show_temperature();
			LCD_handler();
    2120:	0e 94 34 0c 	call	0x1868	; 0x1868 <LCD_handler>
			update_LCD = 0;
    2124:	10 92 63 01 	sts	0x0163, r1
		}

		if(clear_LCD){
    2128:	80 91 96 01 	lds	r24, 0x0196
    212c:	88 23       	and	r24, r24
    212e:	f1 f2       	breq	.-68     	; 0x20ec <main+0xca>
			clear_display();
    2130:	0e 94 9d 0d 	call	0x1b3a	; 0x1b3a <clear_display>
			clear_LCD = 0;
    2134:	10 92 96 01 	sts	0x0196, r1
		}
		
		if(turn_radio_on){
    2138:	80 91 4a 01 	lds	r24, 0x014A
    213c:	88 23       	and	r24, r24
    213e:	d1 f2       	breq	.-76     	; 0x20f4 <main+0xd2>
			radio_reset();
    2140:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <radio_reset>
			radio_powerUp();
    2144:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <radio_powerUp>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2148:	2f ef       	ldi	r18, 0xFF	; 255
    214a:	83 ed       	ldi	r24, 0xD3	; 211
    214c:	90 e3       	ldi	r25, 0x30	; 48
    214e:	21 50       	subi	r18, 0x01	; 1
    2150:	80 40       	sbci	r24, 0x00	; 0
    2152:	90 40       	sbci	r25, 0x00	; 0
    2154:	e1 f7       	brne	.-8      	; 0x214e <main+0x12c>
    2156:	00 c0       	rjmp	.+0      	; 0x2158 <main+0x136>
    2158:	00 00       	nop
			_delay_ms(1000);
			radio_tune_freq();
    215a:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <radio_tune_freq>
			//fm_tune_status();
			turn_radio_on = 0;
    215e:	10 92 4a 01 	sts	0x014A, r1
    2162:	c8 cf       	rjmp	.-112    	; 0x20f4 <main+0xd2>

00002164 <__tablejump2__>:
    2164:	ee 0f       	add	r30, r30
    2166:	ff 1f       	adc	r31, r31

00002168 <__tablejump__>:
    2168:	05 90       	lpm	r0, Z+
    216a:	f4 91       	lpm	r31, Z
    216c:	e0 2d       	mov	r30, r0
    216e:	09 94       	ijmp

00002170 <__umulhisi3>:
    2170:	a2 9f       	mul	r26, r18
    2172:	b0 01       	movw	r22, r0
    2174:	b3 9f       	mul	r27, r19
    2176:	c0 01       	movw	r24, r0
    2178:	a3 9f       	mul	r26, r19
    217a:	70 0d       	add	r23, r0
    217c:	81 1d       	adc	r24, r1
    217e:	11 24       	eor	r1, r1
    2180:	91 1d       	adc	r25, r1
    2182:	b2 9f       	mul	r27, r18
    2184:	70 0d       	add	r23, r0
    2186:	81 1d       	adc	r24, r1
    2188:	11 24       	eor	r1, r1
    218a:	91 1d       	adc	r25, r1
    218c:	08 95       	ret

0000218e <__itoa_ncheck>:
    218e:	bb 27       	eor	r27, r27
    2190:	4a 30       	cpi	r20, 0x0A	; 10
    2192:	31 f4       	brne	.+12     	; 0x21a0 <__itoa_ncheck+0x12>
    2194:	99 23       	and	r25, r25
    2196:	22 f4       	brpl	.+8      	; 0x21a0 <__itoa_ncheck+0x12>
    2198:	bd e2       	ldi	r27, 0x2D	; 45
    219a:	90 95       	com	r25
    219c:	81 95       	neg	r24
    219e:	9f 4f       	sbci	r25, 0xFF	; 255
    21a0:	0c 94 d3 10 	jmp	0x21a6	; 0x21a6 <__utoa_common>

000021a4 <__utoa_ncheck>:
    21a4:	bb 27       	eor	r27, r27

000021a6 <__utoa_common>:
    21a6:	fb 01       	movw	r30, r22
    21a8:	55 27       	eor	r21, r21
    21aa:	aa 27       	eor	r26, r26
    21ac:	88 0f       	add	r24, r24
    21ae:	99 1f       	adc	r25, r25
    21b0:	aa 1f       	adc	r26, r26
    21b2:	a4 17       	cp	r26, r20
    21b4:	10 f0       	brcs	.+4      	; 0x21ba <__utoa_common+0x14>
    21b6:	a4 1b       	sub	r26, r20
    21b8:	83 95       	inc	r24
    21ba:	50 51       	subi	r21, 0x10	; 16
    21bc:	b9 f7       	brne	.-18     	; 0x21ac <__utoa_common+0x6>
    21be:	a0 5d       	subi	r26, 0xD0	; 208
    21c0:	aa 33       	cpi	r26, 0x3A	; 58
    21c2:	08 f0       	brcs	.+2      	; 0x21c6 <__utoa_common+0x20>
    21c4:	a9 5d       	subi	r26, 0xD9	; 217
    21c6:	a1 93       	st	Z+, r26
    21c8:	00 97       	sbiw	r24, 0x00	; 0
    21ca:	79 f7       	brne	.-34     	; 0x21aa <__utoa_common+0x4>
    21cc:	b1 11       	cpse	r27, r1
    21ce:	b1 93       	st	Z+, r27
    21d0:	11 92       	st	Z+, r1
    21d2:	cb 01       	movw	r24, r22
    21d4:	0c 94 ec 10 	jmp	0x21d8	; 0x21d8 <strrev>

000021d8 <strrev>:
    21d8:	dc 01       	movw	r26, r24
    21da:	fc 01       	movw	r30, r24
    21dc:	67 2f       	mov	r22, r23
    21de:	71 91       	ld	r23, Z+
    21e0:	77 23       	and	r23, r23
    21e2:	e1 f7       	brne	.-8      	; 0x21dc <strrev+0x4>
    21e4:	32 97       	sbiw	r30, 0x02	; 2
    21e6:	04 c0       	rjmp	.+8      	; 0x21f0 <strrev+0x18>
    21e8:	7c 91       	ld	r23, X
    21ea:	6d 93       	st	X+, r22
    21ec:	70 83       	st	Z, r23
    21ee:	62 91       	ld	r22, -Z
    21f0:	ae 17       	cp	r26, r30
    21f2:	bf 07       	cpc	r27, r31
    21f4:	c8 f3       	brcs	.-14     	; 0x21e8 <strrev+0x10>
    21f6:	08 95       	ret

000021f8 <_exit>:
    21f8:	f8 94       	cli

000021fa <__stop_program>:
    21fa:	ff cf       	rjmp	.-2      	; 0x21fa <__stop_program>
