
lab6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  00001e4c  00001ee0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e4c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b7  00800136  00800136  00001f16  2**0
                  ALLOC
  3 .stab         00004ec0  00000000  00000000  00001f18  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001966  00000000  00000000  00006dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000873e  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      1c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 13 09 	jmp	0x1226	; 0x1226 <__vector_10>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 9e 07 	jmp	0xf3c	; 0xf3c <__vector_12>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 1a 07 	jmp	0xe34	; 0xe34 <__vector_16>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__vector_21>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__vector_33>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	87 01       	movw	r16, r14
      8e:	8f 01       	movw	r16, r30
      90:	97 01       	movw	r18, r14
      92:	9f 01       	movw	r18, r30
      94:	a7 01       	movw	r20, r14
      96:	b0 01       	movw	r22, r0
      98:	b9 01       	movw	r22, r18
      9a:	77 01       	movw	r14, r14
      9c:	7f 01       	movw	r14, r30
      9e:	0d 03       	fmul	r16, r21
      a0:	05 03       	mulsu	r16, r21
      a2:	00 03       	mulsu	r16, r16
      a4:	2a 03       	fmul	r18, r18
      a6:	1d 03       	fmul	r17, r21
      a8:	25 03       	mulsu	r18, r21
      aa:	15 03       	mulsu	r17, r21
      ac:	de 02       	muls	r29, r30
      ae:	d6 02       	muls	r29, r22
      b0:	d1 02       	muls	r29, r17
      b2:	c9 02       	muls	r28, r25
      b4:	32 03       	mulsu	r19, r18
      b6:	e6 02       	muls	r30, r22
      b8:	bc 02       	muls	r27, r28
      ba:	a4 02       	muls	r26, r20
      bc:	52 03       	mulsu	r21, r18
      be:	fb 02       	muls	r31, r27
      c0:	f3 02       	muls	r31, r19
      c2:	eb 02       	muls	r30, r27
      c4:	72 03       	mulsu	r23, r18
      c6:	ac 02       	muls	r26, r28
      c8:	62 03       	mulsu	r22, r18
      ca:	b4 02       	muls	r27, r20
      cc:	7f 03       	fmul	r23, r23
      ce:	4a 03       	fmul	r20, r18
      d0:	6a 03       	fmul	r22, r18
      d2:	c4 02       	muls	r28, r20
      d4:	42 03       	mulsu	r20, r18
      d6:	3a 03       	fmul	r19, r18
      d8:	5a 03       	fmul	r21, r18
      da:	9f 02       	muls	r25, r31
      dc:	6d 02       	muls	r22, r29
      de:	65 02       	muls	r22, r21
      e0:	75 02       	muls	r23, r21
      e2:	77 03       	mulsu	r23, r23
      e4:	58 02       	muls	r21, r24
      e6:	50 02       	muls	r21, r16
      e8:	7a 02       	muls	r23, r26
      ea:	33 02       	muls	r19, r19
      ec:	97 02       	muls	r25, r23
      ee:	60 02       	muls	r22, r16
      f0:	43 02       	muls	r20, r19
      f2:	3b 02       	muls	r19, r27
      f4:	87 02       	muls	r24, r23
      f6:	4b 02       	muls	r20, r27
      f8:	7f 02       	muls	r23, r31
      fa:	2b 02       	muls	r18, r27
      fc:	11 02       	muls	r17, r17
      fe:	8f 02       	muls	r24, r31
     100:	01 02       	muls	r16, r17
     102:	f9 01       	movw	r30, r18
     104:	1e 02       	muls	r17, r30
     106:	16 02       	muls	r17, r22
     108:	23 02       	muls	r18, r19
     10a:	f4 01       	movw	r30, r8
     10c:	09 02       	muls	r16, r25
     10e:	dc 01       	movw	r26, r24
     110:	ec 01       	movw	r28, r24
     112:	d7 01       	movw	r26, r14
     114:	cf 01       	movw	r24, r30
     116:	c7 01       	movw	r24, r14
     118:	c2 01       	movw	r24, r4
     11a:	e4 01       	movw	r28, r8
     11c:	89 04       	cpc	r8, r9
     11e:	a7 04       	cpc	r10, r7
     120:	83 04       	cpc	r8, r3
     122:	95 04       	cpc	r9, r5
     124:	77 04       	cpc	r7, r7
     126:	7d 04       	cpc	r7, r13
     128:	77 04       	cpc	r7, r7
     12a:	7d 04       	cpc	r7, r13
     12c:	ad 04       	cpc	r10, r13
     12e:	89 04       	cpc	r8, r9
     130:	a7 04       	cpc	r10, r7
     132:	83 04       	cpc	r8, r3
     134:	95 04       	cpc	r9, r5
     136:	8f 04       	cpc	r8, r15
     138:	71 04       	cpc	r7, r1
     13a:	8f 04       	cpc	r8, r15
     13c:	71 04       	cpc	r7, r1
     13e:	d7 04       	cpc	r13, r7
     140:	13 05       	cpc	r17, r3
     142:	cb 04       	cpc	r12, r11
     144:	43 05       	cpc	r20, r3
     146:	cb 04       	cpc	r12, r11
     148:	07 05       	cpc	r16, r7
     14a:	01 05       	cpc	r16, r1
     14c:	71 04       	cpc	r7, r1
     14e:	dd 04       	cpc	r13, r13
     150:	71 04       	cpc	r7, r1
     152:	ef 04       	cpc	r14, r15
     154:	9b 04       	cpc	r9, r11
     156:	31 05       	cpc	r19, r1
     158:	77 04       	cpc	r7, r7
     15a:	25 05       	cpc	r18, r5
     15c:	b3 04       	cpc	r11, r3
     15e:	2b 05       	cpc	r18, r11
     160:	b9 04       	cpc	r11, r9
     162:	37 05       	cpc	r19, r7
     164:	fb 04       	cpc	r15, r11
     166:	a1 04       	cpc	r10, r1
     168:	9b 04       	cpc	r9, r11
     16a:	e3 04       	cpc	r14, r3
     16c:	bf 04       	cpc	r11, r15
     16e:	89 04       	cpc	r8, r9
     170:	a7 04       	cpc	r10, r7
     172:	83 04       	cpc	r8, r3
     174:	95 04       	cpc	r9, r5
     176:	77 04       	cpc	r7, r7
     178:	7d 04       	cpc	r7, r13
     17a:	77 04       	cpc	r7, r7
     17c:	7d 04       	cpc	r7, r13
     17e:	ad 04       	cpc	r10, r13
     180:	89 04       	cpc	r8, r9
     182:	0d 05       	cpc	r16, r13
     184:	a1 04       	cpc	r10, r1
     186:	83 04       	cpc	r8, r3
     188:	8f 04       	cpc	r8, r15
     18a:	71 04       	cpc	r7, r1
     18c:	8f 04       	cpc	r8, r15
     18e:	71 04       	cpc	r7, r1
     190:	d7 04       	cpc	r13, r7
     192:	19 05       	cpc	r17, r9
     194:	e9 04       	cpc	r14, r9
     196:	ad 04       	cpc	r10, r13
     198:	1f 05       	cpc	r17, r15
     19a:	dd 04       	cpc	r13, r13
     19c:	b3 04       	cpc	r11, r3
     19e:	b9 04       	cpc	r11, r9
     1a0:	9b 04       	cpc	r9, r11
     1a2:	a1 04       	cpc	r10, r1
     1a4:	3d 05       	cpc	r19, r13
     1a6:	bf 04       	cpc	r11, r15
     1a8:	e7 06       	cpc	r14, r23
     1aa:	e0 06       	cpc	r14, r16
     1ac:	d9 06       	cpc	r13, r25
     1ae:	d1 06       	cpc	r13, r17
     1b0:	c9 06       	cpc	r12, r25
     1b2:	ee 06       	cpc	r14, r30
     1b4:	fe 06       	cpc	r15, r30
     1b6:	01 0c       	add	r0, r1
     1b8:	d8 0b       	sbc	r29, r24
     1ba:	d8 0b       	sbc	r29, r24
     1bc:	d8 0b       	sbc	r29, r24
     1be:	d8 0b       	sbc	r29, r24
     1c0:	d8 0b       	sbc	r29, r24
     1c2:	d8 0b       	sbc	r29, r24
     1c4:	d8 0b       	sbc	r29, r24
     1c6:	01 0c       	add	r0, r1
     1c8:	d8 0b       	sbc	r29, r24
     1ca:	d8 0b       	sbc	r29, r24
     1cc:	d8 0b       	sbc	r29, r24
     1ce:	d8 0b       	sbc	r29, r24
     1d0:	d8 0b       	sbc	r29, r24
     1d2:	d8 0b       	sbc	r29, r24
     1d4:	d8 0b       	sbc	r29, r24
     1d6:	0b 0c       	add	r0, r11
     1d8:	d8 0b       	sbc	r29, r24
     1da:	d8 0b       	sbc	r29, r24
     1dc:	d8 0b       	sbc	r29, r24
     1de:	d8 0b       	sbc	r29, r24
     1e0:	d8 0b       	sbc	r29, r24
     1e2:	d8 0b       	sbc	r29, r24
     1e4:	d8 0b       	sbc	r29, r24
     1e6:	d8 0b       	sbc	r29, r24
     1e8:	d8 0b       	sbc	r29, r24
     1ea:	d8 0b       	sbc	r29, r24
     1ec:	d8 0b       	sbc	r29, r24
     1ee:	d8 0b       	sbc	r29, r24
     1f0:	d8 0b       	sbc	r29, r24
     1f2:	d8 0b       	sbc	r29, r24
     1f4:	d8 0b       	sbc	r29, r24
     1f6:	0b 0c       	add	r0, r11
     1f8:	d8 0b       	sbc	r29, r24
     1fa:	d8 0b       	sbc	r29, r24
     1fc:	d8 0b       	sbc	r29, r24
     1fe:	d8 0b       	sbc	r29, r24
     200:	d8 0b       	sbc	r29, r24
     202:	d8 0b       	sbc	r29, r24
     204:	d8 0b       	sbc	r29, r24
     206:	d8 0b       	sbc	r29, r24
     208:	d8 0b       	sbc	r29, r24
     20a:	d8 0b       	sbc	r29, r24
     20c:	d8 0b       	sbc	r29, r24
     20e:	d8 0b       	sbc	r29, r24
     210:	d8 0b       	sbc	r29, r24
     212:	d8 0b       	sbc	r29, r24
     214:	d8 0b       	sbc	r29, r24
     216:	22 0c       	add	r2, r2
     218:	d8 0b       	sbc	r29, r24
     21a:	d8 0b       	sbc	r29, r24
     21c:	d8 0b       	sbc	r29, r24
     21e:	d8 0b       	sbc	r29, r24
     220:	d8 0b       	sbc	r29, r24
     222:	d8 0b       	sbc	r29, r24
     224:	d8 0b       	sbc	r29, r24
     226:	26 0c       	add	r2, r6
     228:	d8 0b       	sbc	r29, r24
     22a:	d8 0b       	sbc	r29, r24
     22c:	d8 0b       	sbc	r29, r24
     22e:	d8 0b       	sbc	r29, r24
     230:	d8 0b       	sbc	r29, r24
     232:	d8 0b       	sbc	r29, r24
     234:	d8 0b       	sbc	r29, r24
     236:	d8 0b       	sbc	r29, r24
     238:	d8 0b       	sbc	r29, r24
     23a:	d8 0b       	sbc	r29, r24
     23c:	d8 0b       	sbc	r29, r24
     23e:	d8 0b       	sbc	r29, r24
     240:	d8 0b       	sbc	r29, r24
     242:	d8 0b       	sbc	r29, r24
     244:	d8 0b       	sbc	r29, r24
     246:	34 0c       	add	r3, r4
     248:	d8 0b       	sbc	r29, r24
     24a:	d8 0b       	sbc	r29, r24
     24c:	d8 0b       	sbc	r29, r24
     24e:	d8 0b       	sbc	r29, r24
     250:	d8 0b       	sbc	r29, r24
     252:	d8 0b       	sbc	r29, r24
     254:	d8 0b       	sbc	r29, r24
     256:	f2 0b       	sbc	r31, r18

00000258 <__ctors_end>:
     258:	11 24       	eor	r1, r1
     25a:	1f be       	out	0x3f, r1	; 63
     25c:	cf ef       	ldi	r28, 0xFF	; 255
     25e:	d0 e1       	ldi	r29, 0x10	; 16
     260:	de bf       	out	0x3e, r29	; 62
     262:	cd bf       	out	0x3d, r28	; 61

00000264 <__do_copy_data>:
     264:	11 e0       	ldi	r17, 0x01	; 1
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b1 e0       	ldi	r27, 0x01	; 1
     26a:	ec e4       	ldi	r30, 0x4C	; 76
     26c:	fe e1       	ldi	r31, 0x1E	; 30
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	a6 33       	cpi	r26, 0x36	; 54
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	21 e0       	ldi	r18, 0x01	; 1
     280:	a6 e3       	ldi	r26, 0x36	; 54
     282:	b1 e0       	ldi	r27, 0x01	; 1
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	ad 3e       	cpi	r26, 0xED	; 237
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 6c 0e 	call	0x1cd8	; 0x1cd8 <main>
     292:	0c 94 24 0f 	jmp	0x1e48	; 0x1e48 <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <play_rest>:
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     29a:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     29c:	10 92 79 01 	sts	0x0179, r1
     2a0:	10 92 78 01 	sts	0x0178, r1
  max_beat = duration;
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	90 93 77 01 	sts	0x0177, r25
     2aa:	80 93 76 01 	sts	0x0176, r24
     2ae:	08 95       	ret

000002b0 <play_note>:
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
     2b0:	cf 93       	push	r28
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
     2b2:	92 98       	cbi	0x12, 2	; 18
  beat = 0;             //reset the beat counter
     2b4:	10 92 79 01 	sts	0x0179, r1
     2b8:	10 92 78 01 	sts	0x0178, r1
  max_beat = duration;  //set the max beat
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	30 93 77 01 	sts	0x0177, r19
     2c2:	20 93 76 01 	sts	0x0176, r18
  switch (octave) {
     2c6:	50 e0       	ldi	r21, 0x00	; 0
     2c8:	49 30       	cpi	r20, 0x09	; 9
     2ca:	51 05       	cpc	r21, r1
     2cc:	20 f0       	brcs	.+8      	; 0x2d6 <play_note+0x26>
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
     2ce:	1b bc       	out	0x2b, r1	; 43
     2d0:	1a bc       	out	0x2a, r1	; 42
  }
}
     2d2:	cf 91       	pop	r28
     2d4:	08 95       	ret
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2d6:	4a 5b       	subi	r20, 0xBA	; 186
     2d8:	5f 4f       	sbci	r21, 0xFF	; 255
     2da:	fa 01       	movw	r30, r20
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2dc:	99 27       	eor	r25, r25
     2de:	87 fd       	sbrc	r24, 7
     2e0:	90 95       	com	r25
     2e2:	a9 2f       	mov	r26, r25
     2e4:	b9 2f       	mov	r27, r25
     2e6:	81 54       	subi	r24, 0x41	; 65
     2e8:	91 09       	sbc	r25, r1
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2ea:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
     2ee:	87 30       	cpi	r24, 0x07	; 7
     2f0:	91 05       	cpc	r25, r1
     2f2:	78 f7       	brcc	.-34     	; 0x2d2 <play_note+0x22>
     2f4:	81 5b       	subi	r24, 0xB1	; 177
     2f6:	9f 4f       	sbci	r25, 0xFF	; 255
     2f8:	fc 01       	movw	r30, r24
     2fa:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2fe:	87 30       	cpi	r24, 0x07	; 7
     300:	91 05       	cpc	r25, r1
     302:	38 f7       	brcc	.-50     	; 0x2d2 <play_note+0x22>
     304:	8a 5a       	subi	r24, 0xAA	; 170
     306:	9f 4f       	sbci	r25, 0xFF	; 255
     308:	fc 01       	movw	r30, r24
     30a:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
     30e:	87 30       	cpi	r24, 0x07	; 7
     310:	91 05       	cpc	r25, r1
     312:	f8 f6       	brcc	.-66     	; 0x2d2 <play_note+0x22>
     314:	83 5a       	subi	r24, 0xA3	; 163
     316:	9f 4f       	sbci	r25, 0xFF	; 255
     318:	fc 01       	movw	r30, r24
     31a:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
     31e:	87 30       	cpi	r24, 0x07	; 7
     320:	91 05       	cpc	r25, r1
     322:	b8 f6       	brcc	.-82     	; 0x2d2 <play_note+0x22>
     324:	8c 59       	subi	r24, 0x9C	; 156
     326:	9f 4f       	sbci	r25, 0xFF	; 255
     328:	fc 01       	movw	r30, r24
     32a:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
     32e:	87 30       	cpi	r24, 0x07	; 7
     330:	91 05       	cpc	r25, r1
     332:	78 f6       	brcc	.-98     	; 0x2d2 <play_note+0x22>
     334:	85 59       	subi	r24, 0x95	; 149
     336:	9f 4f       	sbci	r25, 0xFF	; 255
     338:	fc 01       	movw	r30, r24
     33a:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
     33e:	87 30       	cpi	r24, 0x07	; 7
     340:	91 05       	cpc	r25, r1
     342:	38 f6       	brcc	.-114    	; 0x2d2 <play_note+0x22>
     344:	8e 58       	subi	r24, 0x8E	; 142
     346:	9f 4f       	sbci	r25, 0xFF	; 255
     348:	fc 01       	movw	r30, r24
     34a:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
     34e:	87 30       	cpi	r24, 0x07	; 7
     350:	91 05       	cpc	r25, r1
     352:	08 f0       	brcs	.+2      	; 0x356 <play_note+0xa6>
     354:	be cf       	rjmp	.-132    	; 0x2d2 <play_note+0x22>
     356:	87 58       	subi	r24, 0x87	; 135
     358:	9f 4f       	sbci	r25, 0xFF	; 255
     35a:	fc 01       	movw	r30, r24
     35c:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
     360:	87 30       	cpi	r24, 0x07	; 7
     362:	91 05       	cpc	r25, r1
     364:	08 f0       	brcs	.+2      	; 0x368 <play_note+0xb8>
     366:	b5 cf       	rjmp	.-150    	; 0x2d2 <play_note+0x22>
     368:	80 58       	subi	r24, 0x80	; 128
     36a:	9f 4f       	sbci	r25, 0xFF	; 255
     36c:	fc 01       	movw	r30, r24
     36e:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
     372:	87 30       	cpi	r24, 0x07	; 7
     374:	91 05       	cpc	r25, r1
     376:	08 f0       	brcs	.+2      	; 0x37a <play_note+0xca>
     378:	ac cf       	rjmp	.-168    	; 0x2d2 <play_note+0x22>
     37a:	89 57       	subi	r24, 0x79	; 121
     37c:	9f 4f       	sbci	r25, 0xFF	; 255
     37e:	fc 01       	movw	r30, r24
     380:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
     384:	88 e5       	ldi	r24, 0x58	; 88
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	9b bd       	out	0x2b, r25	; 43
     38a:	8a bd       	out	0x2a, r24	; 42
	break;
     38c:	a2 cf       	rjmp	.-188    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
     38e:	66 23       	and	r22, r22
     390:	09 f4       	brne	.+2      	; 0x394 <play_note+0xe4>
     392:	0f c2       	rjmp	.+1054   	; 0x7b2 <play_note+0x502>
     394:	83 e6       	ldi	r24, 0x63	; 99
     396:	90 e0       	ldi	r25, 0x00	; 0
     398:	9b bd       	out	0x2b, r25	; 43
     39a:	8a bd       	out	0x2a, r24	; 42
     39c:	9a cf       	rjmp	.-204    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
     39e:	66 23       	and	r22, r22
     3a0:	09 f4       	brne	.+2      	; 0x3a4 <play_note+0xf4>
     3a2:	11 c2       	rjmp	.+1058   	; 0x7c6 <play_note+0x516>
     3a4:	8f e6       	ldi	r24, 0x6F	; 111
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	9b bd       	out	0x2b, r25	; 43
     3aa:	8a bd       	out	0x2a, r24	; 42
     3ac:	92 cf       	rjmp	.-220    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
     3ae:	86 e7       	ldi	r24, 0x76	; 118
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	9b bd       	out	0x2b, r25	; 43
     3b4:	8a bd       	out	0x2a, r24	; 42
	break;
     3b6:	8d cf       	rjmp	.-230    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
     3b8:	66 23       	and	r22, r22
     3ba:	09 f4       	brne	.+2      	; 0x3be <play_note+0x10e>
     3bc:	ff c1       	rjmp	.+1022   	; 0x7bc <play_note+0x50c>
     3be:	8a e4       	ldi	r24, 0x4A	; 74
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	9b bd       	out	0x2b, r25	; 43
     3c4:	8a bd       	out	0x2a, r24	; 42
     3c6:	85 cf       	rjmp	.-246    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
     3c8:	66 23       	and	r22, r22
     3ca:	09 f4       	brne	.+2      	; 0x3ce <play_note+0x11e>
     3cc:	01 c2       	rjmp	.+1026   	; 0x7d0 <play_note+0x520>
     3ce:	83 e5       	ldi	r24, 0x53	; 83
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	9b bd       	out	0x2b, r25	; 43
     3d4:	8a bd       	out	0x2a, r24	; 42
     3d6:	7d cf       	rjmp	.-262    	; 0x2d2 <play_note+0x22>
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
     3d8:	66 23       	and	r22, r22
     3da:	09 f4       	brne	.+2      	; 0x3de <play_note+0x12e>
     3dc:	b8 c1       	rjmp	.+880    	; 0x74e <play_note+0x49e>
     3de:	82 e4       	ldi	r24, 0x42	; 66
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	9b bd       	out	0x2b, r25	; 43
     3e4:	8a bd       	out	0x2a, r24	; 42
     3e6:	75 cf       	rjmp	.-278    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
     3e8:	81 eb       	ldi	r24, 0xB1	; 177
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	9b bd       	out	0x2b, r25	; 43
     3ee:	8a bd       	out	0x2a, r24	; 42
	break;
     3f0:	70 cf       	rjmp	.-288    	; 0x2d2 <play_note+0x22>
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
     3f2:	66 23       	and	r22, r22
     3f4:	09 f4       	brne	.+2      	; 0x3f8 <play_note+0x148>
     3f6:	d3 c1       	rjmp	.+934    	; 0x79e <play_note+0x4ee>
     3f8:	85 e8       	ldi	r24, 0x85	; 133
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	9b bd       	out	0x2b, r25	; 43
     3fe:	8a bd       	out	0x2a, r24	; 42
     400:	68 cf       	rjmp	.-304    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
     402:	66 23       	and	r22, r22
     404:	09 f4       	brne	.+2      	; 0x408 <play_note+0x158>
     406:	c1 c1       	rjmp	.+898    	; 0x78a <play_note+0x4da>
     408:	85 e9       	ldi	r24, 0x95	; 149
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	9b bd       	out	0x2b, r25	; 43
     40e:	8a bd       	out	0x2a, r24	; 42
     410:	60 cf       	rjmp	.-320    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
     412:	66 23       	and	r22, r22
     414:	09 f4       	brne	.+2      	; 0x418 <play_note+0x168>
     416:	be c1       	rjmp	.+892    	; 0x794 <play_note+0x4e4>
     418:	87 ea       	ldi	r24, 0xA7	; 167
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9b bd       	out	0x2b, r25	; 43
     41e:	8a bd       	out	0x2a, r24	; 42
     420:	58 cf       	rjmp	.-336    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
     422:	84 e6       	ldi	r24, 0x64	; 100
     424:	91 e0       	ldi	r25, 0x01	; 1
     426:	9b bd       	out	0x2b, r25	; 43
     428:	8a bd       	out	0x2a, r24	; 42
	break;
     42a:	53 cf       	rjmp	.-346    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
     42c:	66 23       	and	r22, r22
     42e:	09 f4       	brne	.+2      	; 0x432 <play_note+0x182>
     430:	bb c1       	rjmp	.+886    	; 0x7a8 <play_note+0x4f8>
     432:	80 ee       	ldi	r24, 0xE0	; 224
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	9b bd       	out	0x2b, r25	; 43
     438:	8a bd       	out	0x2a, r24	; 42
     43a:	4b cf       	rjmp	.-362    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
     43c:	8d ee       	ldi	r24, 0xED	; 237
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	9b bd       	out	0x2b, r25	; 43
     442:	8a bd       	out	0x2a, r24	; 42
	break;
     444:	46 cf       	rjmp	.-372    	; 0x2d2 <play_note+0x22>
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
     446:	66 23       	and	r22, r22
     448:	09 f4       	brne	.+2      	; 0x44c <play_note+0x19c>
     44a:	8b c1       	rjmp	.+790    	; 0x762 <play_note+0x4b2>
     44c:	87 ec       	ldi	r24, 0xC7	; 199
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	9b bd       	out	0x2b, r25	; 43
     452:	8a bd       	out	0x2a, r24	; 42
     454:	3e cf       	rjmp	.-388    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
     456:	66 23       	and	r22, r22
     458:	09 f4       	brne	.+2      	; 0x45c <play_note+0x1ac>
     45a:	74 c1       	rjmp	.+744    	; 0x744 <play_note+0x494>
     45c:	80 e9       	ldi	r24, 0x90	; 144
     45e:	91 e0       	ldi	r25, 0x01	; 1
     460:	9b bd       	out	0x2b, r25	; 43
     462:	8a bd       	out	0x2a, r24	; 42
     464:	36 cf       	rjmp	.-404    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
     466:	66 23       	and	r22, r22
     468:	09 f4       	brne	.+2      	; 0x46c <play_note+0x1bc>
     46a:	cb c1       	rjmp	.+918    	; 0x802 <play_note+0x552>
     46c:	84 e8       	ldi	r24, 0x84	; 132
     46e:	93 e0       	ldi	r25, 0x03	; 3
     470:	9b bd       	out	0x2b, r25	; 43
     472:	8a bd       	out	0x2a, r24	; 42
     474:	2e cf       	rjmp	.-420    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
     476:	66 23       	and	r22, r22
     478:	09 f4       	brne	.+2      	; 0x47c <play_note+0x1cc>
     47a:	af c1       	rjmp	.+862    	; 0x7da <play_note+0x52a>
     47c:	8b e2       	ldi	r24, 0x2B	; 43
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	9b bd       	out	0x2b, r25	; 43
     482:	8a bd       	out	0x2a, r24	; 42
     484:	26 cf       	rjmp	.-436    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
     486:	66 23       	and	r22, r22
     488:	09 f4       	brne	.+2      	; 0x48c <play_note+0x1dc>
     48a:	b1 c1       	rjmp	.+866    	; 0x7ee <play_note+0x53e>
     48c:	82 ea       	ldi	r24, 0xA2	; 162
     48e:	92 e0       	ldi	r25, 0x02	; 2
     490:	9b bd       	out	0x2b, r25	; 43
     492:	8a bd       	out	0x2a, r24	; 42
     494:	1e cf       	rjmp	.-452    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
     496:	8c ed       	ldi	r24, 0xDC	; 220
     498:	91 e0       	ldi	r25, 0x01	; 1
     49a:	9b bd       	out	0x2b, r25	; 43
     49c:	8a bd       	out	0x2a, r24	; 42
	break;
     49e:	19 cf       	rjmp	.-462    	; 0x2d2 <play_note+0x22>
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
     4a0:	66 23       	and	r22, r22
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <play_note+0x1f6>
     4a4:	59 c1       	rjmp	.+690    	; 0x758 <play_note+0x4a8>
     4a6:	87 e1       	ldi	r24, 0x17	; 23
     4a8:	92 e0       	ldi	r25, 0x02	; 2
     4aa:	9b bd       	out	0x2b, r25	; 43
     4ac:	8a bd       	out	0x2a, r24	; 42
     4ae:	11 cf       	rjmp	.-478    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
     4b0:	66 23       	and	r22, r22
     4b2:	09 f4       	brne	.+2      	; 0x4b6 <play_note+0x206>
     4b4:	b0 c1       	rjmp	.+864    	; 0x816 <play_note+0x566>
     4b6:	88 e5       	ldi	r24, 0x58	; 88
     4b8:	92 e0       	ldi	r25, 0x02	; 2
     4ba:	9b bd       	out	0x2b, r25	; 43
     4bc:	8a bd       	out	0x2a, r24	; 42
     4be:	09 cf       	rjmp	.-494    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
     4c0:	8a ec       	ldi	r24, 0xCA	; 202
     4c2:	92 e0       	ldi	r25, 0x02	; 2
     4c4:	9b bd       	out	0x2b, r25	; 43
     4c6:	8a bd       	out	0x2a, r24	; 42
	break;
     4c8:	04 cf       	rjmp	.-504    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
     4ca:	66 23       	and	r22, r22
     4cc:	09 f4       	brne	.+2      	; 0x4d0 <play_note+0x220>
     4ce:	35 c1       	rjmp	.+618    	; 0x73a <play_note+0x48a>
     4d0:	86 e4       	ldi	r24, 0x46	; 70
     4d2:	96 e0       	ldi	r25, 0x06	; 6
     4d4:	9b bd       	out	0x2b, r25	; 43
     4d6:	8a bd       	out	0x2a, r24	; 42
     4d8:	fc ce       	rjmp	.-520    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
     4da:	66 23       	and	r22, r22
     4dc:	09 f4       	brne	.+2      	; 0x4e0 <play_note+0x230>
     4de:	82 c1       	rjmp	.+772    	; 0x7e4 <play_note+0x534>
     4e0:	8a e0       	ldi	r24, 0x0A	; 10
     4e2:	97 e0       	ldi	r25, 0x07	; 7
     4e4:	9b bd       	out	0x2b, r25	; 43
     4e6:	8a bd       	out	0x2a, r24	; 42
     4e8:	f4 ce       	rjmp	.-536    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
     4ea:	86 e9       	ldi	r24, 0x96	; 150
     4ec:	95 e0       	ldi	r25, 0x05	; 5
     4ee:	9b bd       	out	0x2b, r25	; 43
     4f0:	8a bd       	out	0x2a, r24	; 42
	break;
     4f2:	ef ce       	rjmp	.-546    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
     4f4:	8a eb       	ldi	r24, 0xBA	; 186
     4f6:	93 e0       	ldi	r25, 0x03	; 3
     4f8:	9b bd       	out	0x2b, r25	; 43
     4fa:	8a bd       	out	0x2a, r24	; 42
	break;
     4fc:	ea ce       	rjmp	.-556    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
     4fe:	66 23       	and	r22, r22
     500:	09 f4       	brne	.+2      	; 0x504 <play_note+0x254>
     502:	7a c1       	rjmp	.+756    	; 0x7f8 <play_note+0x548>
     504:	81 ec       	ldi	r24, 0xC1	; 193
     506:	91 e0       	ldi	r25, 0x01	; 1
     508:	9b bd       	out	0x2b, r25	; 43
     50a:	8a bd       	out	0x2a, r24	; 42
     50c:	e2 ce       	rjmp	.-572    	; 0x2d2 <play_note+0x22>
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
     50e:	66 23       	and	r22, r22
     510:	09 f4       	brne	.+2      	; 0x514 <play_note+0x264>
     512:	7c c1       	rjmp	.+760    	; 0x80c <play_note+0x55c>
     514:	8b e0       	ldi	r24, 0x0B	; 11
     516:	91 e0       	ldi	r25, 0x01	; 1
     518:	9b bd       	out	0x2b, r25	; 43
     51a:	8a bd       	out	0x2a, r24	; 42
     51c:	da ce       	rjmp	.-588    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
     51e:	66 23       	and	r22, r22
     520:	09 f4       	brne	.+2      	; 0x524 <play_note+0x274>
     522:	7e c1       	rjmp	.+764    	; 0x820 <play_note+0x570>
     524:	80 e5       	ldi	r24, 0x50	; 80
     526:	91 e0       	ldi	r25, 0x01	; 1
     528:	9b bd       	out	0x2b, r25	; 43
     52a:	8a bd       	out	0x2a, r24	; 42
     52c:	d2 ce       	rjmp	.-604    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
     52e:	66 23       	and	r22, r22
     530:	09 f4       	brne	.+2      	; 0x534 <play_note+0x284>
     532:	ad c1       	rjmp	.+858    	; 0x88e <play_note+0x5de>
     534:	82 e2       	ldi	r24, 0x22	; 34
     536:	93 e0       	ldi	r25, 0x03	; 3
     538:	9b bd       	out	0x2b, r25	; 43
     53a:	8a bd       	out	0x2a, r24	; 42
     53c:	ca ce       	rjmp	.-620    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
     53e:	86 e7       	ldi	r24, 0x76	; 118
     540:	97 e0       	ldi	r25, 0x07	; 7
     542:	9b bd       	out	0x2b, r25	; 43
     544:	8a bd       	out	0x2a, r24	; 42
	break;
     546:	c5 ce       	rjmp	.-630    	; 0x2d2 <play_note+0x22>
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
     548:	66 23       	and	r22, r22
     54a:	09 f4       	brne	.+2      	; 0x54e <play_note+0x29e>
     54c:	0f c1       	rjmp	.+542    	; 0x76c <play_note+0x4bc>
     54e:	8e ec       	ldi	r24, 0xCE	; 206
     550:	92 e1       	ldi	r25, 0x12	; 18
     552:	9b bd       	out	0x2b, r25	; 43
     554:	8a bd       	out	0x2a, r24	; 42
     556:	bd ce       	rjmp	.-646    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
     558:	66 23       	and	r22, r22
     55a:	09 f4       	brne	.+2      	; 0x55e <play_note+0x2ae>
     55c:	7a c1       	rjmp	.+756    	; 0x852 <play_note+0x5a2>
     55e:	8d e1       	ldi	r24, 0x1D	; 29
     560:	95 e1       	ldi	r25, 0x15	; 21
     562:	9b bd       	out	0x2b, r25	; 43
     564:	8a bd       	out	0x2a, r24	; 42
     566:	b5 ce       	rjmp	.-662    	; 0x2d2 <play_note+0x22>
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
     568:	66 23       	and	r22, r22
     56a:	09 f4       	brne	.+2      	; 0x56e <play_note+0x2be>
     56c:	dc c0       	rjmp	.+440    	; 0x726 <play_note+0x476>
     56e:	80 e6       	ldi	r24, 0x60	; 96
     570:	98 e0       	ldi	r25, 0x08	; 8
     572:	9b bd       	out	0x2b, r25	; 43
     574:	8a bd       	out	0x2a, r24	; 42
     576:	ad ce       	rjmp	.-678    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
     578:	66 23       	and	r22, r22
     57a:	09 f4       	brne	.+2      	; 0x57e <play_note+0x2ce>
     57c:	92 c1       	rjmp	.+804    	; 0x8a2 <play_note+0x5f2>
     57e:	80 e1       	ldi	r24, 0x10	; 16
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	9b bd       	out	0x2b, r25	; 43
     584:	8a bd       	out	0x2a, r24	; 42
     586:	a5 ce       	rjmp	.-694    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
     588:	8e e2       	ldi	r24, 0x2E	; 46
     58a:	9b e0       	ldi	r25, 0x0B	; 11
     58c:	9b bd       	out	0x2b, r25	; 43
     58e:	8a bd       	out	0x2a, r24	; 42
	break;
     590:	a0 ce       	rjmp	.-704    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
     592:	66 23       	and	r22, r22
     594:	09 f4       	brne	.+2      	; 0x598 <play_note+0x2e8>
     596:	49 c1       	rjmp	.+658    	; 0x82a <play_note+0x57a>
     598:	8b e1       	ldi	r24, 0x1B	; 27
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	9b bd       	out	0x2b, r25	; 43
     59e:	8a bd       	out	0x2a, r24	; 42
     5a0:	98 ce       	rjmp	.-720    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
     5a2:	8c e1       	ldi	r24, 0x1C	; 28
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	9b bd       	out	0x2b, r25	; 43
     5a8:	8a bd       	out	0x2a, r24	; 42
	break;
     5aa:	93 ce       	rjmp	.-730    	; 0x2d2 <play_note+0x22>
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
     5ac:	66 23       	and	r22, r22
     5ae:	09 f4       	brne	.+2      	; 0x5b2 <play_note+0x302>
     5b0:	41 c1       	rjmp	.+642    	; 0x834 <play_note+0x584>
     5b2:	87 e0       	ldi	r24, 0x07	; 7
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	9b bd       	out	0x2b, r25	; 43
     5b8:	8a bd       	out	0x2a, r24	; 42
     5ba:	8b ce       	rjmp	.-746    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
     5bc:	66 23       	and	r22, r22
     5be:	09 f4       	brne	.+2      	; 0x5c2 <play_note+0x312>
     5c0:	da c0       	rjmp	.+436    	; 0x776 <play_note+0x4c6>
     5c2:	8b e0       	ldi	r24, 0x0B	; 11
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	9b bd       	out	0x2b, r25	; 43
     5c8:	8a bd       	out	0x2a, r24	; 42
     5ca:	83 ce       	rjmp	.-762    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
     5cc:	82 e1       	ldi	r24, 0x12	; 18
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	9b bd       	out	0x2b, r25	; 43
     5d2:	8a bd       	out	0x2a, r24	; 42
	break;
     5d4:	7e ce       	rjmp	.-772    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
     5d6:	66 23       	and	r22, r22
     5d8:	09 f4       	brne	.+2      	; 0x5dc <play_note+0x32c>
     5da:	9b c0       	rjmp	.+310    	; 0x712 <play_note+0x462>
     5dc:	89 e1       	ldi	r24, 0x19	; 25
     5de:	99 e1       	ldi	r25, 0x19	; 25
     5e0:	9b bd       	out	0x2b, r25	; 43
     5e2:	8a bd       	out	0x2a, r24	; 42
     5e4:	76 ce       	rjmp	.-788    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
     5e6:	66 23       	and	r22, r22
     5e8:	09 f4       	brne	.+2      	; 0x5ec <play_note+0x33c>
     5ea:	29 c1       	rjmp	.+594    	; 0x83e <play_note+0x58e>
     5ec:	80 e3       	ldi	r24, 0x30	; 48
     5ee:	9c e1       	ldi	r25, 0x1C	; 28
     5f0:	9b bd       	out	0x2b, r25	; 43
     5f2:	8a bd       	out	0x2a, r24	; 42
     5f4:	6e ce       	rjmp	.-804    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
     5f6:	8c ed       	ldi	r24, 0xDC	; 220
     5f8:	9d e1       	ldi	r25, 0x1D	; 29
     5fa:	9b bd       	out	0x2b, r25	; 43
     5fc:	8a bd       	out	0x2a, r24	; 42
	break;
     5fe:	69 ce       	rjmp	.-814    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
     600:	8a e3       	ldi	r24, 0x3A	; 58
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	9b bd       	out	0x2b, r25	; 43
     606:	8a bd       	out	0x2a, r24	; 42
	break;
     608:	64 ce       	rjmp	.-824    	; 0x2d2 <play_note+0x22>
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
     60a:	66 23       	and	r22, r22
     60c:	09 f4       	brne	.+2      	; 0x610 <play_note+0x360>
     60e:	35 c1       	rjmp	.+618    	; 0x87a <play_note+0x5ca>
     610:	80 e2       	ldi	r24, 0x20	; 32
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	9b bd       	out	0x2b, r25	; 43
     616:	8a bd       	out	0x2a, r24	; 42
     618:	5c ce       	rjmp	.-840    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
     61a:	66 23       	and	r22, r22
     61c:	09 f4       	brne	.+2      	; 0x620 <play_note+0x370>
     61e:	32 c1       	rjmp	.+612    	; 0x884 <play_note+0x5d4>
     620:	84 e2       	ldi	r24, 0x24	; 36
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	9b bd       	out	0x2b, r25	; 43
     626:	8a bd       	out	0x2a, r24	; 42
     628:	54 ce       	rjmp	.-856    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
     62a:	66 23       	and	r22, r22
     62c:	09 f4       	brne	.+2      	; 0x630 <play_note+0x380>
     62e:	76 c0       	rjmp	.+236    	; 0x71c <play_note+0x46c>
     630:	89 e2       	ldi	r24, 0x29	; 41
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	9b bd       	out	0x2b, r25	; 43
     636:	8a bd       	out	0x2a, r24	; 42
     638:	4c ce       	rjmp	.-872    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
     63a:	66 23       	and	r22, r22
     63c:	09 f4       	brne	.+2      	; 0x640 <play_note+0x390>
     63e:	78 c0       	rjmp	.+240    	; 0x730 <play_note+0x480>
     640:	81 e3       	ldi	r24, 0x31	; 49
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	9b bd       	out	0x2b, r25	; 43
     646:	8a bd       	out	0x2a, r24	; 42
     648:	44 ce       	rjmp	.-888    	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
     64a:	8b e2       	ldi	r24, 0x2B	; 43
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	9b bd       	out	0x2b, r25	; 43
     650:	8a bd       	out	0x2a, r24	; 42
	break;
     652:	3f ce       	rjmp	.-898    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
     654:	66 23       	and	r22, r22
     656:	09 f4       	brne	.+2      	; 0x65a <play_note+0x3aa>
     658:	93 c0       	rjmp	.+294    	; 0x780 <play_note+0x4d0>
     65a:	87 e3       	ldi	r24, 0x37	; 55
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	9b bd       	out	0x2b, r25	; 43
     660:	8a bd       	out	0x2a, r24	; 42
     662:	37 ce       	rjmp	.-914    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
     664:	66 23       	and	r22, r22
     666:	09 f4       	brne	.+2      	; 0x66a <play_note+0x3ba>
     668:	4f c0       	rjmp	.+158    	; 0x708 <play_note+0x458>
     66a:	88 e1       	ldi	r24, 0x18	; 24
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	9b bd       	out	0x2b, r25	; 43
     670:	8a bd       	out	0x2a, r24	; 42
     672:	2f ce       	rjmp	.-930    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
     674:	66 23       	and	r22, r22
     676:	09 f4       	brne	.+2      	; 0x67a <play_note+0x3ca>
     678:	f6 c0       	rjmp	.+492    	; 0x866 <play_note+0x5b6>
     67a:	82 eb       	ldi	r24, 0xB2	; 178
     67c:	94 e0       	ldi	r25, 0x04	; 4
     67e:	9b bd       	out	0x2b, r25	; 43
     680:	8a bd       	out	0x2a, r24	; 42
     682:	27 ce       	rjmp	.-946    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
     684:	66 23       	and	r22, r22
     686:	09 f4       	brne	.+2      	; 0x68a <play_note+0x3da>
     688:	16 c1       	rjmp	.+556    	; 0x8b6 <play_note+0x606>
     68a:	8d e8       	ldi	r24, 0x8D	; 141
     68c:	9a e0       	ldi	r25, 0x0A	; 10
     68e:	9b bd       	out	0x2b, r25	; 43
     690:	8a bd       	out	0x2a, r24	; 42
     692:	1f ce       	rjmp	.-962    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
     694:	66 23       	and	r22, r22
     696:	09 f4       	brne	.+2      	; 0x69a <play_note+0x3ea>
     698:	d7 c0       	rjmp	.+430    	; 0x848 <play_note+0x598>
     69a:	86 e1       	ldi	r24, 0x16	; 22
     69c:	9e e0       	ldi	r25, 0x0E	; 14
     69e:	9b bd       	out	0x2b, r25	; 43
     6a0:	8a bd       	out	0x2a, r24	; 42
     6a2:	17 ce       	rjmp	.-978    	; 0x2d2 <play_note+0x22>
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
     6a4:	66 23       	and	r22, r22
     6a6:	09 f4       	brne	.+2      	; 0x6aa <play_note+0x3fa>
     6a8:	f7 c0       	rjmp	.+494    	; 0x898 <play_note+0x5e8>
     6aa:	80 ec       	ldi	r24, 0xC0	; 192
     6ac:	90 e1       	ldi	r25, 0x10	; 16
     6ae:	9b bd       	out	0x2b, r25	; 43
     6b0:	8a bd       	out	0x2a, r24	; 42
     6b2:	0f ce       	rjmp	.-994    	; 0x2d2 <play_note+0x22>
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
     6b4:	66 23       	and	r22, r22
     6b6:	09 f4       	brne	.+2      	; 0x6ba <play_note+0x40a>
     6b8:	d1 c0       	rjmp	.+418    	; 0x85c <play_note+0x5ac>
     6ba:	8f e2       	ldi	r24, 0x2F	; 47
     6bc:	94 e0       	ldi	r25, 0x04	; 4
     6be:	9b bd       	out	0x2b, r25	; 43
     6c0:	8a bd       	out	0x2a, r24	; 42
     6c2:	07 ce       	rjmp	.-1010   	; 0x2d2 <play_note+0x22>
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
     6c4:	66 23       	and	r22, r22
     6c6:	09 f4       	brne	.+2      	; 0x6ca <play_note+0x41a>
     6c8:	f1 c0       	rjmp	.+482    	; 0x8ac <play_note+0x5fc>
     6ca:	87 e6       	ldi	r24, 0x67	; 103
     6cc:	99 e0       	ldi	r25, 0x09	; 9
     6ce:	9b bd       	out	0x2b, r25	; 43
     6d0:	8a bd       	out	0x2a, r24	; 42
     6d2:	ff cd       	rjmp	.-1026   	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
     6d4:	66 23       	and	r22, r22
     6d6:	09 f4       	brne	.+2      	; 0x6da <play_note+0x42a>
     6d8:	cb c0       	rjmp	.+406    	; 0x870 <play_note+0x5c0>
     6da:	8d e8       	ldi	r24, 0x8D	; 141
     6dc:	9c e0       	ldi	r25, 0x0C	; 12
     6de:	9b bd       	out	0x2b, r25	; 43
     6e0:	8a bd       	out	0x2a, r24	; 42
     6e2:	f7 cd       	rjmp	.-1042   	; 0x2d2 <play_note+0x22>
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
     6e4:	8d e5       	ldi	r24, 0x5D	; 93
     6e6:	96 e1       	ldi	r25, 0x16	; 22
     6e8:	9b bd       	out	0x2b, r25	; 43
     6ea:	8a bd       	out	0x2a, r24	; 42
	break;
     6ec:	f2 cd       	rjmp	.-1052   	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
     6ee:	66 23       	and	r22, r22
     6f0:	09 f4       	brne	.+2      	; 0x6f4 <play_note+0x444>
     6f2:	e6 c0       	rjmp	.+460    	; 0x8c0 <play_note+0x610>
     6f4:	86 e4       	ldi	r24, 0x46	; 70
     6f6:	95 e0       	ldi	r25, 0x05	; 5
     6f8:	9b bd       	out	0x2b, r25	; 43
     6fa:	8a bd       	out	0x2a, r24	; 42
     6fc:	ea cd       	rjmp	.-1068   	; 0x2d2 <play_note+0x22>
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
     6fe:	8d ee       	ldi	r24, 0xED	; 237
     700:	9e e0       	ldi	r25, 0x0E	; 14
     702:	9b bd       	out	0x2b, r25	; 43
     704:	8a bd       	out	0x2a, r24	; 42
	break;
     706:	e5 cd       	rjmp	.-1078   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
     708:	85 e1       	ldi	r24, 0x15	; 21
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	9b bd       	out	0x2b, r25	; 43
     70e:	8a bd       	out	0x2a, r24	; 42
     710:	e0 cd       	rjmp	.-1088   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
     712:	82 eb       	ldi	r24, 0xB2	; 178
     714:	97 e1       	ldi	r25, 0x17	; 23
     716:	9b bd       	out	0x2b, r25	; 43
     718:	8a bd       	out	0x2a, r24	; 42
     71a:	db cd       	rjmp	.-1098   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
     71c:	86 e2       	ldi	r24, 0x26	; 38
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	9b bd       	out	0x2b, r25	; 43
     722:	8a bd       	out	0x2a, r24	; 42
     724:	d6 cd       	rjmp	.-1108   	; 0x2d2 <play_note+0x22>
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
     726:	87 ee       	ldi	r24, 0xE7	; 231
     728:	97 e0       	ldi	r25, 0x07	; 7
     72a:	9b bd       	out	0x2b, r25	; 43
     72c:	8a bd       	out	0x2a, r24	; 42
     72e:	d1 cd       	rjmp	.-1118   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
     730:	8e e2       	ldi	r24, 0x2E	; 46
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9b bd       	out	0x2b, r25	; 43
     736:	8a bd       	out	0x2a, r24	; 42
     738:	cc cd       	rjmp	.-1128   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
     73a:	8b ee       	ldi	r24, 0xEB	; 235
     73c:	95 e0       	ldi	r25, 0x05	; 5
     73e:	9b bd       	out	0x2b, r25	; 43
     740:	8a bd       	out	0x2a, r24	; 42
     742:	c7 cd       	rjmp	.-1138   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
     744:	8a e7       	ldi	r24, 0x7A	; 122
     746:	91 e0       	ldi	r25, 0x01	; 1
     748:	9b bd       	out	0x2b, r25	; 43
     74a:	8a bd       	out	0x2a, r24	; 42
     74c:	c2 cd       	rjmp	.-1148   	; 0x2d2 <play_note+0x22>
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
     74e:	8e e3       	ldi	r24, 0x3E	; 62
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	9b bd       	out	0x2b, r25	; 43
     754:	8a bd       	out	0x2a, r24	; 42
     756:	bd cd       	rjmp	.-1158   	; 0x2d2 <play_note+0x22>
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
     758:	89 ef       	ldi	r24, 0xF9	; 249
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	9b bd       	out	0x2b, r25	; 43
     75e:	8a bd       	out	0x2a, r24	; 42
     760:	b8 cd       	rjmp	.-1168   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
     762:	8c eb       	ldi	r24, 0xBC	; 188
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	9b bd       	out	0x2b, r25	; 43
     768:	8a bd       	out	0x2a, r24	; 42
     76a:	b3 cd       	rjmp	.-1178   	; 0x2d2 <play_note+0x22>
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
     76c:	80 ec       	ldi	r24, 0xC0	; 192
     76e:	91 e1       	ldi	r25, 0x11	; 17
     770:	9b bd       	out	0x2b, r25	; 43
     772:	8a bd       	out	0x2a, r24	; 42
     774:	ae cd       	rjmp	.-1188   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
     776:	89 e0       	ldi	r24, 0x09	; 9
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	9b bd       	out	0x2b, r25	; 43
     77c:	8a bd       	out	0x2a, r24	; 42
     77e:	a9 cd       	rjmp	.-1198   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
     780:	84 e3       	ldi	r24, 0x34	; 52
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	9b bd       	out	0x2b, r25	; 43
     786:	8a bd       	out	0x2a, r24	; 42
     788:	a4 cd       	rjmp	.-1208   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
     78a:	8d e8       	ldi	r24, 0x8D	; 141
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	9b bd       	out	0x2b, r25	; 43
     790:	8a bd       	out	0x2a, r24	; 42
     792:	9f cd       	rjmp	.-1218   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
     794:	8e e9       	ldi	r24, 0x9E	; 158
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	9b bd       	out	0x2b, r25	; 43
     79a:	8a bd       	out	0x2a, r24	; 42
     79c:	9a cd       	rjmp	.-1228   	; 0x2d2 <play_note+0x22>
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
     79e:	8d e7       	ldi	r24, 0x7D	; 125
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	9b bd       	out	0x2b, r25	; 43
     7a4:	8a bd       	out	0x2a, r24	; 42
     7a6:	95 cd       	rjmp	.-1238   	; 0x2d2 <play_note+0x22>
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
     7a8:	83 ed       	ldi	r24, 0xD3	; 211
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	9b bd       	out	0x2b, r25	; 43
     7ae:	8a bd       	out	0x2a, r24	; 42
     7b0:	90 cd       	rjmp	.-1248   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
     7b2:	8d e5       	ldi	r24, 0x5D	; 93
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	9b bd       	out	0x2b, r25	; 43
     7b8:	8a bd       	out	0x2a, r24	; 42
     7ba:	8b cd       	rjmp	.-1258   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
     7bc:	86 e4       	ldi	r24, 0x46	; 70
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	9b bd       	out	0x2b, r25	; 43
     7c2:	8a bd       	out	0x2a, r24	; 42
     7c4:	86 cd       	rjmp	.-1268   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
     7c6:	89 e6       	ldi	r24, 0x69	; 105
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	9b bd       	out	0x2b, r25	; 43
     7cc:	8a bd       	out	0x2a, r24	; 42
     7ce:	81 cd       	rjmp	.-1278   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
     7d0:	8e e4       	ldi	r24, 0x4E	; 78
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	9b bd       	out	0x2b, r25	; 43
     7d6:	8a bd       	out	0x2a, r24	; 42
     7d8:	7c cd       	rjmp	.-1288   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
     7da:	8b e1       	ldi	r24, 0x1B	; 27
     7dc:	91 e0       	ldi	r25, 0x01	; 1
     7de:	9b bd       	out	0x2b, r25	; 43
     7e0:	8a bd       	out	0x2a, r24	; 42
     7e2:	77 cd       	rjmp	.-1298   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
     7e4:	85 ea       	ldi	r24, 0xA5	; 165
     7e6:	96 e0       	ldi	r25, 0x06	; 6
     7e8:	9b bd       	out	0x2b, r25	; 43
     7ea:	8a bd       	out	0x2a, r24	; 42
     7ec:	72 cd       	rjmp	.-1308   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
     7ee:	8c e7       	ldi	r24, 0x7C	; 124
     7f0:	92 e0       	ldi	r25, 0x02	; 2
     7f2:	9b bd       	out	0x2b, r25	; 43
     7f4:	8a bd       	out	0x2a, r24	; 42
     7f6:	6d cd       	rjmp	.-1318   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
     7f8:	88 ea       	ldi	r24, 0xA8	; 168
     7fa:	91 e0       	ldi	r25, 0x01	; 1
     7fc:	9b bd       	out	0x2b, r25	; 43
     7fe:	8a bd       	out	0x2a, r24	; 42
     800:	68 cd       	rjmp	.-1328   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
     802:	82 e5       	ldi	r24, 0x52	; 82
     804:	93 e0       	ldi	r25, 0x03	; 3
     806:	9b bd       	out	0x2b, r25	; 43
     808:	8a bd       	out	0x2a, r24	; 42
     80a:	63 cd       	rjmp	.-1338   	; 0x2d2 <play_note+0x22>
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
     80c:	8c ef       	ldi	r24, 0xFC	; 252
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	9b bd       	out	0x2b, r25	; 43
     812:	8a bd       	out	0x2a, r24	; 42
     814:	5e cd       	rjmp	.-1348   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
     816:	87 e3       	ldi	r24, 0x37	; 55
     818:	92 e0       	ldi	r25, 0x02	; 2
     81a:	9b bd       	out	0x2b, r25	; 43
     81c:	8a bd       	out	0x2a, r24	; 42
     81e:	59 cd       	rjmp	.-1358   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
     820:	8d e3       	ldi	r24, 0x3D	; 61
     822:	91 e0       	ldi	r25, 0x01	; 1
     824:	9b bd       	out	0x2b, r25	; 43
     826:	8a bd       	out	0x2a, r24	; 42
     828:	54 cd       	rjmp	.-1368   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
     82a:	89 e1       	ldi	r24, 0x19	; 25
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	9b bd       	out	0x2b, r25	; 43
     830:	8a bd       	out	0x2a, r24	; 42
     832:	4f cd       	rjmp	.-1378   	; 0x2d2 <play_note+0x22>
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
     834:	85 e0       	ldi	r24, 0x05	; 5
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	9b bd       	out	0x2b, r25	; 43
     83a:	8a bd       	out	0x2a, r24	; 42
     83c:	4a cd       	rjmp	.-1388   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
     83e:	8a e9       	ldi	r24, 0x9A	; 154
     840:	9a e1       	ldi	r25, 0x1A	; 26
     842:	9b bd       	out	0x2b, r25	; 43
     844:	8a bd       	out	0x2a, r24	; 42
     846:	45 cd       	rjmp	.-1398   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
     848:	8c e4       	ldi	r24, 0x4C	; 76
     84a:	9d e0       	ldi	r25, 0x0D	; 13
     84c:	9b bd       	out	0x2b, r25	; 43
     84e:	8a bd       	out	0x2a, r24	; 42
     850:	40 cd       	rjmp	.-1408   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
     852:	8d ee       	ldi	r24, 0xED	; 237
     854:	93 e1       	ldi	r25, 0x13	; 19
     856:	9b bd       	out	0x2b, r25	; 43
     858:	8a bd       	out	0x2a, r24	; 42
     85a:	3b cd       	rjmp	.-1418   	; 0x2d2 <play_note+0x22>
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
     85c:	83 ef       	ldi	r24, 0xF3	; 243
     85e:	93 e0       	ldi	r25, 0x03	; 3
     860:	9b bd       	out	0x2b, r25	; 43
     862:	8a bd       	out	0x2a, r24	; 42
     864:	36 cd       	rjmp	.-1428   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
     866:	8f e6       	ldi	r24, 0x6F	; 111
     868:	94 e0       	ldi	r25, 0x04	; 4
     86a:	9b bd       	out	0x2b, r25	; 43
     86c:	8a bd       	out	0x2a, r24	; 42
     86e:	31 cd       	rjmp	.-1438   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
     870:	88 ed       	ldi	r24, 0xD8	; 216
     872:	9b e0       	ldi	r25, 0x0B	; 11
     874:	9b bd       	out	0x2b, r25	; 43
     876:	8a bd       	out	0x2a, r24	; 42
     878:	2c cd       	rjmp	.-1448   	; 0x2d2 <play_note+0x22>
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
     87a:	8e e1       	ldi	r24, 0x1E	; 30
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	9b bd       	out	0x2b, r25	; 43
     880:	8a bd       	out	0x2a, r24	; 42
     882:	27 cd       	rjmp	.-1458   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
     884:	82 e2       	ldi	r24, 0x22	; 34
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	9b bd       	out	0x2b, r25	; 43
     88a:	8a bd       	out	0x2a, r24	; 42
     88c:	22 cd       	rjmp	.-1468   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
     88e:	85 ef       	ldi	r24, 0xF5	; 245
     890:	92 e0       	ldi	r25, 0x02	; 2
     892:	9b bd       	out	0x2b, r25	; 43
     894:	8a bd       	out	0x2a, r24	; 42
     896:	1d cd       	rjmp	.-1478   	; 0x2d2 <play_note+0x22>
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
     898:	80 ed       	ldi	r24, 0xD0	; 208
     89a:	9f e0       	ldi	r25, 0x0F	; 15
     89c:	9b bd       	out	0x2b, r25	; 43
     89e:	8a bd       	out	0x2a, r24	; 42
     8a0:	18 cd       	rjmp	.-1488   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
     8a2:	8d e0       	ldi	r24, 0x0D	; 13
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	9b bd       	out	0x2b, r25	; 43
     8a8:	8a bd       	out	0x2a, r24	; 42
     8aa:	13 cd       	rjmp	.-1498   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
     8ac:	8f ed       	ldi	r24, 0xDF	; 223
     8ae:	98 e0       	ldi	r25, 0x08	; 8
     8b0:	9b bd       	out	0x2b, r25	; 43
     8b2:	8a bd       	out	0x2a, r24	; 42
     8b4:	0e cd       	rjmp	.-1508   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
     8b6:	86 ef       	ldi	r24, 0xF6	; 246
     8b8:	99 e0       	ldi	r25, 0x09	; 9
     8ba:	9b bd       	out	0x2b, r25	; 43
     8bc:	8a bd       	out	0x2a, r24	; 42
     8be:	09 cd       	rjmp	.-1518   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
     8c0:	8a ef       	ldi	r24, 0xFA	; 250
     8c2:	94 e0       	ldi	r25, 0x04	; 4
     8c4:	9b bd       	out	0x2b, r25	; 43
     8c6:	8a bd       	out	0x2a, r24	; 42
     8c8:	04 cd       	rjmp	.-1528   	; 0x2d2 <play_note+0x22>

000008ca <song0>:
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8ca:	86 34       	cpi	r24, 0x46	; 70
     8cc:	91 05       	cpc	r25, r1
     8ce:	20 f0       	brcs	.+8      	; 0x8d8 <song0+0xe>
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	80 93 68 01 	sts	0x0168, r24
     8d6:	08 95       	ret
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8d8:	fc 01       	movw	r30, r24
     8da:	e2 57       	subi	r30, 0x72	; 114
     8dc:	ff 4f       	sbci	r31, 0xFF	; 255
     8de:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
     8e2:	22 e0       	ldi	r18, 0x02	; 2
     8e4:	44 e0       	ldi	r20, 0x04	; 4
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	81 e4       	ldi	r24, 0x41	; 65
     8ea:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
     8ee:	26 e0       	ldi	r18, 0x06	; 6
     8f0:	44 e0       	ldi	r20, 0x04	; 4
     8f2:	60 e0       	ldi	r22, 0x00	; 0
     8f4:	81 e4       	ldi	r24, 0x41	; 65
     8f6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
     8fa:	22 e0       	ldi	r18, 0x02	; 2
     8fc:	44 e0       	ldi	r20, 0x04	; 4
     8fe:	61 e0       	ldi	r22, 0x01	; 1
     900:	81 e4       	ldi	r24, 0x41	; 65
     902:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
     906:	28 e0       	ldi	r18, 0x08	; 8
     908:	44 e0       	ldi	r20, 0x04	; 4
     90a:	60 e0       	ldi	r22, 0x00	; 0
     90c:	84 e4       	ldi	r24, 0x44	; 68
     90e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
     912:	28 e0       	ldi	r18, 0x08	; 8
     914:	44 e0       	ldi	r20, 0x04	; 4
     916:	60 e0       	ldi	r22, 0x00	; 0
     918:	86 e4       	ldi	r24, 0x46	; 70
     91a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
     91e:	26 e0       	ldi	r18, 0x06	; 6
     920:	44 e0       	ldi	r20, 0x04	; 4
     922:	61 e0       	ldi	r22, 0x01	; 1
     924:	82 e4       	ldi	r24, 0x42	; 66
     926:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
     92a:	28 e0       	ldi	r18, 0x08	; 8
     92c:	44 e0       	ldi	r20, 0x04	; 4
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	83 e4       	ldi	r24, 0x43	; 67
     932:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
     936:	28 e0       	ldi	r18, 0x08	; 8
     938:	44 e0       	ldi	r20, 0x04	; 4
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	81 e4       	ldi	r24, 0x41	; 65
     93e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 67: play_note('G', 0, 4, 8);
     942:	28 e0       	ldi	r18, 0x08	; 8
     944:	44 e0       	ldi	r20, 0x04	; 4
     946:	60 e0       	ldi	r22, 0x00	; 0
     948:	87 e4       	ldi	r24, 0x47	; 71
     94a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
     94e:	28 e0       	ldi	r18, 0x08	; 8
     950:	44 e0       	ldi	r20, 0x04	; 4
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	85 e4       	ldi	r24, 0x45	; 69
     956:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
     95a:	20 e1       	ldi	r18, 0x10	; 16
     95c:	44 e0       	ldi	r20, 0x04	; 4
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	81 e4       	ldi	r24, 0x41	; 65
     962:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
     966:	24 e0       	ldi	r18, 0x04	; 4
     968:	45 e0       	ldi	r20, 0x05	; 5
     96a:	60 e0       	ldi	r22, 0x00	; 0
     96c:	83 e4       	ldi	r24, 0x43	; 67
     96e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 65: play_note('D', 0, 5, 4);
     972:	24 e0       	ldi	r18, 0x04	; 4
     974:	45 e0       	ldi	r20, 0x05	; 5
     976:	60 e0       	ldi	r22, 0x00	; 0
     978:	84 e4       	ldi	r24, 0x44	; 68
     97a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     97e:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     980:	10 92 79 01 	sts	0x0179, r1
     984:	10 92 78 01 	sts	0x0178, r1
  max_beat = duration;
     988:	88 e0       	ldi	r24, 0x08	; 8
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	90 93 77 01 	sts	0x0177, r25
     990:	80 93 76 01 	sts	0x0176, r24
     994:	08 95       	ret
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     996:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     998:	10 92 79 01 	sts	0x0179, r1
     99c:	10 92 78 01 	sts	0x0178, r1
  max_beat = duration;
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	90 93 77 01 	sts	0x0177, r25
     9a8:	80 93 76 01 	sts	0x0176, r24
     9ac:	08 95       	ret
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
     9ae:	20 e1       	ldi	r18, 0x10	; 16
     9b0:	44 e0       	ldi	r20, 0x04	; 4
     9b2:	61 e0       	ldi	r22, 0x01	; 1
     9b4:	82 e4       	ldi	r24, 0x42	; 66
     9b6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
     9ba:	28 e0       	ldi	r18, 0x08	; 8
     9bc:	44 e0       	ldi	r20, 0x04	; 4
     9be:	61 e0       	ldi	r22, 0x01	; 1
     9c0:	82 e4       	ldi	r24, 0x42	; 66
     9c2:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
     9c6:	28 e1       	ldi	r18, 0x18	; 24
     9c8:	44 e0       	ldi	r20, 0x04	; 4
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	87 e4       	ldi	r24, 0x47	; 71
     9ce:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
     9d2:	20 e1       	ldi	r18, 0x10	; 16
     9d4:	45 e0       	ldi	r20, 0x05	; 5
     9d6:	60 e0       	ldi	r22, 0x00	; 0
     9d8:	84 e4       	ldi	r24, 0x44	; 68
     9da:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     9de:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     9e0:	10 92 79 01 	sts	0x0179, r1
     9e4:	10 92 78 01 	sts	0x0178, r1
  max_beat = duration;
     9e8:	82 e0       	ldi	r24, 0x02	; 2
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	90 93 77 01 	sts	0x0177, r25
     9f0:	80 93 76 01 	sts	0x0176, r24
     9f4:	08 95       	ret
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
     9f6:	24 e0       	ldi	r18, 0x04	; 4
     9f8:	44 e0       	ldi	r20, 0x04	; 4
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	81 e4       	ldi	r24, 0x41	; 65
     9fe:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
     a02:	26 e0       	ldi	r18, 0x06	; 6
     a04:	44 e0       	ldi	r20, 0x04	; 4
     a06:	60 e0       	ldi	r22, 0x00	; 0
     a08:	87 e4       	ldi	r24, 0x47	; 71
     a0a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
     a0e:	24 e0       	ldi	r18, 0x04	; 4
     a10:	44 e0       	ldi	r20, 0x04	; 4
     a12:	61 e0       	ldi	r22, 0x01	; 1
     a14:	87 e4       	ldi	r24, 0x47	; 71
     a16:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
     a1a:	28 e0       	ldi	r18, 0x08	; 8
     a1c:	44 e0       	ldi	r20, 0x04	; 4
     a1e:	61 e0       	ldi	r22, 0x01	; 1
     a20:	87 e4       	ldi	r24, 0x47	; 71
     a22:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
     a26:	23 e0       	ldi	r18, 0x03	; 3
     a28:	44 e0       	ldi	r20, 0x04	; 4
     a2a:	60 e0       	ldi	r22, 0x00	; 0
     a2c:	87 e4       	ldi	r24, 0x47	; 71
     a2e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
     a32:	20 e1       	ldi	r18, 0x10	; 16
     a34:	44 e0       	ldi	r20, 0x04	; 4
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	84 e4       	ldi	r24, 0x44	; 68
     a3a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
     a3e:	20 e1       	ldi	r18, 0x10	; 16
     a40:	45 e0       	ldi	r20, 0x05	; 5
     a42:	60 e0       	ldi	r22, 0x00	; 0
     a44:	83 e4       	ldi	r24, 0x43	; 67
     a46:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
     a4a:	22 e0       	ldi	r18, 0x02	; 2
     a4c:	44 e0       	ldi	r20, 0x04	; 4
     a4e:	61 e0       	ldi	r22, 0x01	; 1
     a50:	82 e4       	ldi	r24, 0x42	; 66
     a52:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
     a56:	24 e0       	ldi	r18, 0x04	; 4
     a58:	45 e0       	ldi	r20, 0x05	; 5
     a5a:	61 e0       	ldi	r22, 0x01	; 1
     a5c:	84 e4       	ldi	r24, 0x44	; 68
     a5e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
     a62:	24 e0       	ldi	r18, 0x04	; 4
     a64:	44 e0       	ldi	r20, 0x04	; 4
     a66:	61 e0       	ldi	r22, 0x01	; 1
     a68:	81 e4       	ldi	r24, 0x41	; 65
     a6a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
     a6e:	28 e0       	ldi	r18, 0x08	; 8
     a70:	44 e0       	ldi	r20, 0x04	; 4
     a72:	60 e0       	ldi	r22, 0x00	; 0
     a74:	82 e4       	ldi	r24, 0x42	; 66
     a76:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
     a7a:	28 e1       	ldi	r18, 0x18	; 24
     a7c:	44 e0       	ldi	r20, 0x04	; 4
     a7e:	60 e0       	ldi	r22, 0x00	; 0
     a80:	86 e4       	ldi	r24, 0x46	; 70
     a82:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
     a86:	27 e0       	ldi	r18, 0x07	; 7
     a88:	44 e0       	ldi	r20, 0x04	; 4
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	87 e4       	ldi	r24, 0x47	; 71
     a8e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>

00000a92 <play_song>:
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     a92:	86 2f       	mov	r24, r22
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000a9a <music_off>:
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     a9a:	10 92 68 01 	sts	0x0168, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     a9e:	8e b5       	in	r24, 0x2e	; 46
     aa0:	8c 7f       	andi	r24, 0xFC	; 252
     aa2:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     aa4:	92 9a       	sbi	0x12, 2	; 18
     aa6:	08 95       	ret

00000aa8 <music_on>:
}

void music_on(void) {
  //this starts the alarm timer running
  notes=0;
     aa8:	10 92 68 01 	sts	0x0168, r1
  TCCR1B |= (1<<CS11)|(1<<CS10);
     aac:	8e b5       	in	r24, 0x2e	; 46
     aae:	83 60       	ori	r24, 0x03	; 3
     ab0:	8e bd       	out	0x2e, r24	; 46
  //unmutes the output
  PORTD &= unmute;
     ab2:	92 98       	cbi	0x12, 2	; 18
  //and starts the selected song
  play_song(song, notes);
     ab4:	80 91 68 01 	lds	r24, 0x0168
     ab8:	90 91 75 01 	lds	r25, 0x0175
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000ac2 <music_init>:
  play_song(song, notes);
}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  DDRD |= (1<<PD7);
     ac2:	8f 9a       	sbi	0x11, 7	; 17
  TIMSK |= (1<<OCIE1A) | (1<<TOIE0);  //enable timer interrupt 1 on compare
     ac4:	87 b7       	in	r24, 0x37	; 55
     ac6:	81 61       	ori	r24, 0x11	; 17
     ac8:	87 bf       	out	0x37, r24	; 55
  TCCR1A = 0x00;         //TCNT1, normal port operation
     aca:	1f bc       	out	0x2f, r1	; 47
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
     acc:	8e b5       	in	r24, 0x2e	; 46
     ace:	88 60       	ori	r24, 0x08	; 8
     ad0:	8e bd       	out	0x2e, r24	; 46
  TCCR1C = 0x00;         //no forced compare
     ad2:	10 92 7a 00 	sts	0x007A, r1
  OCR1A = 0x0033;        //(use to vary alarm frequency)
     ad6:	83 e3       	ldi	r24, 0x33	; 51
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	9b bd       	out	0x2b, r25	; 43
     adc:	8a bd       	out	0x2a, r24	; 42
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     ade:	10 92 68 01 	sts	0x0168, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     ae2:	8e b5       	in	r24, 0x2e	; 46
     ae4:	8c 7f       	andi	r24, 0xFC	; 252
     ae6:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     ae8:	92 9a       	sbi	0x12, 2	; 18
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0033;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
     aea:	10 92 79 01 	sts	0x0179, r1
     aee:	10 92 78 01 	sts	0x0178, r1
  max_beat = 0;
     af2:	10 92 77 01 	sts	0x0177, r1
     af6:	10 92 76 01 	sts	0x0176, r1
  notes = 0;
     afa:	10 92 68 01 	sts	0x0168, r1
  song = 0;              //beaver fight song
     afe:	10 92 75 01 	sts	0x0175, r1
     b02:	08 95       	ret

00000b04 <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b04:	20 91 59 01 	lds	r18, 0x0159
     b08:	30 91 5a 01 	lds	r19, 0x015A
     b0c:	22 0f       	add	r18, r18
     b0e:	33 1f       	adc	r19, r19
     b10:	49 b3       	in	r20, 0x19	; 25
     b12:	50 e0       	ldi	r21, 0x00	; 0
     b14:	02 c0       	rjmp	.+4      	; 0xb1a <chk_buttons+0x16>
     b16:	55 95       	asr	r21
     b18:	47 95       	ror	r20
     b1a:	8a 95       	dec	r24
     b1c:	e2 f7       	brpl	.-8      	; 0xb16 <chk_buttons+0x12>
     b1e:	40 fd       	sbrc	r20, 0
     b20:	0e c0       	rjmp	.+28     	; 0xb3e <chk_buttons+0x3a>
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	90 ee       	ldi	r25, 0xE0	; 224
     b26:	28 2b       	or	r18, r24
     b28:	39 2b       	or	r19, r25
     b2a:	30 93 5a 01 	sts	0x015A, r19
     b2e:	20 93 59 01 	sts	0x0159, r18
	if (state == 0xF000){
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	21 15       	cp	r18, r1
     b36:	30 4f       	sbci	r19, 0xF0	; 240
     b38:	09 f0       	breq	.+2      	; 0xb3c <chk_buttons+0x38>
     b3a:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}
	return 0;
}
     b3c:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	90 ee       	ldi	r25, 0xE0	; 224
     b42:	f1 cf       	rjmp	.-30     	; 0xb26 <chk_buttons+0x22>

00000b44 <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
     b44:	81 11       	cpse	r24, r1
     b46:	02 c0       	rjmp	.+4      	; 0xb4c <int2seg+0x8>
		return ZERO;
     b48:	80 ec       	ldi	r24, 0xC0	; 192
     b4a:	08 95       	ret
	}
	else if(number == 1 ){
     b4c:	81 30       	cpi	r24, 0x01	; 1
     b4e:	91 f0       	breq	.+36     	; 0xb74 <int2seg+0x30>
		return ONE;
	}
	else if(number == 2 ){
     b50:	82 30       	cpi	r24, 0x02	; 2
     b52:	91 f0       	breq	.+36     	; 0xb78 <int2seg+0x34>
		return TWO;
	}
	else if(number == 3 ){
     b54:	83 30       	cpi	r24, 0x03	; 3
     b56:	a1 f0       	breq	.+40     	; 0xb80 <int2seg+0x3c>
		return THREE;
	}
	else if(number == 4 ){
     b58:	84 30       	cpi	r24, 0x04	; 4
     b5a:	81 f0       	breq	.+32     	; 0xb7c <int2seg+0x38>
		return FOUR;
	}
	else if(number == 5 ){
     b5c:	85 30       	cpi	r24, 0x05	; 5
     b5e:	91 f0       	breq	.+36     	; 0xb84 <int2seg+0x40>
		return FIVE;
	}
	else if(number == 6 ){
     b60:	86 30       	cpi	r24, 0x06	; 6
     b62:	91 f0       	breq	.+36     	; 0xb88 <int2seg+0x44>
		return  SIX;
	}
	else if(number == 7 ){
     b64:	87 30       	cpi	r24, 0x07	; 7
     b66:	91 f0       	breq	.+36     	; 0xb8c <int2seg+0x48>
		return SEVEN;
	}
	else if(number == 8 ){
     b68:	88 30       	cpi	r24, 0x08	; 8
     b6a:	91 f0       	breq	.+36     	; 0xb90 <int2seg+0x4c>
		return EIGHT;
	}
	else if(number == 9 ){
     b6c:	89 30       	cpi	r24, 0x09	; 9
     b6e:	91 f0       	breq	.+36     	; 0xb94 <int2seg+0x50>
		return NINE;
	}
	else{ 
		return 0;
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	08 95       	ret
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
		return ZERO;
	}
	else if(number == 1 ){
		return ONE;
     b74:	89 ef       	ldi	r24, 0xF9	; 249
     b76:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
     b78:	84 ea       	ldi	r24, 0xA4	; 164
     b7a:	08 95       	ret
	}
	else if(number == 3 ){
		return THREE;
	}
	else if(number == 4 ){
		return FOUR;
     b7c:	89 e9       	ldi	r24, 0x99	; 153
     b7e:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
	}
	else if(number == 3 ){
		return THREE;
     b80:	80 eb       	ldi	r24, 0xB0	; 176
     b82:	08 95       	ret
	}
	else if(number == 4 ){
		return FOUR;
	}
	else if(number == 5 ){
		return FIVE;
     b84:	82 e9       	ldi	r24, 0x92	; 146
     b86:	08 95       	ret
	}
	else if(number == 6 ){
		return  SIX;
     b88:	82 e8       	ldi	r24, 0x82	; 130
     b8a:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
     b8c:	88 ef       	ldi	r24, 0xF8	; 248
		return NINE;
	}
	else{ 
		return 0;
	}
}
     b8e:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
	}
	else if(number == 8 ){
		return EIGHT;
     b90:	80 e8       	ldi	r24, 0x80	; 128
     b92:	08 95       	ret
	}
	else if(number == 9 ){
		return NINE;
     b94:	80 e9       	ldi	r24, 0x90	; 144
     b96:	08 95       	ret

00000b98 <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
     b98:	ff 92       	push	r15
     b9a:	0f 93       	push	r16
     b9c:	1f 93       	push	r17
     b9e:	cf 93       	push	r28
     ba0:	df 93       	push	r29
     ba2:	ec 01       	movw	r28, r24
	//determine how many digits there are 
	//int digit;
	// Break down the digits

	if(ticker%2 == 1){
     ba4:	80 91 5b 01 	lds	r24, 0x015B
     ba8:	80 ff       	sbrs	r24, 0
     baa:	82 c0       	rjmp	.+260    	; 0xcb0 <segsum+0x118>
		segment_data[2] = 0xFC;
     bac:	8c ef       	ldi	r24, 0xFC	; 252
     bae:	80 93 81 01 	sts	0x0181, r24
		segment_data[2] = 0xFF;
	} 
	//When setting alarm is on)
	//break up decimal sum into 4 digit-segments

	segment_data[0] = int2seg(sum % 10); //ones
     bb2:	9e 01       	movw	r18, r28
     bb4:	ad ec       	ldi	r26, 0xCD	; 205
     bb6:	bc ec       	ldi	r27, 0xCC	; 204
     bb8:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <__umulhisi3>
     bbc:	96 95       	lsr	r25
     bbe:	87 95       	ror	r24
     bc0:	96 95       	lsr	r25
     bc2:	87 95       	ror	r24
     bc4:	96 95       	lsr	r25
     bc6:	87 95       	ror	r24
     bc8:	3c 2f       	mov	r19, r28
     bca:	2a e0       	ldi	r18, 0x0A	; 10
     bcc:	82 9f       	mul	r24, r18
     bce:	30 19       	sub	r19, r0
     bd0:	11 24       	eor	r1, r1
     bd2:	83 2f       	mov	r24, r19
     bd4:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     bd8:	f8 2e       	mov	r15, r24
	segment_data[1] = int2seg((sum % 100)/10); //tens
     bda:	9e 01       	movw	r18, r28
     bdc:	36 95       	lsr	r19
     bde:	27 95       	ror	r18
     be0:	36 95       	lsr	r19
     be2:	27 95       	ror	r18
     be4:	ab e7       	ldi	r26, 0x7B	; 123
     be6:	b4 e1       	ldi	r27, 0x14	; 20
     be8:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <__umulhisi3>
     bec:	96 95       	lsr	r25
     bee:	87 95       	ror	r24
     bf0:	44 e6       	ldi	r20, 0x64	; 100
     bf2:	48 9f       	mul	r20, r24
     bf4:	90 01       	movw	r18, r0
     bf6:	49 9f       	mul	r20, r25
     bf8:	30 0d       	add	r19, r0
     bfa:	11 24       	eor	r1, r1
     bfc:	ce 01       	movw	r24, r28
     bfe:	82 1b       	sub	r24, r18
     c00:	93 0b       	sbc	r25, r19
     c02:	9c 01       	movw	r18, r24
     c04:	ad ec       	ldi	r26, 0xCD	; 205
     c06:	bc ec       	ldi	r27, 0xCC	; 204
     c08:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <__umulhisi3>
     c0c:	96 95       	lsr	r25
     c0e:	87 95       	ror	r24
     c10:	96 95       	lsr	r25
     c12:	87 95       	ror	r24
     c14:	96 95       	lsr	r25
     c16:	87 95       	ror	r24
     c18:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c1c:	80 93 80 01 	sts	0x0180, r24
	//segment_data[2] = 1; //decimal
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
     c20:	9e 01       	movw	r18, r28
     c22:	36 95       	lsr	r19
     c24:	27 95       	ror	r18
     c26:	36 95       	lsr	r19
     c28:	27 95       	ror	r18
     c2a:	36 95       	lsr	r19
     c2c:	27 95       	ror	r18
     c2e:	a5 ec       	ldi	r26, 0xC5	; 197
     c30:	b0 e2       	ldi	r27, 0x20	; 32
     c32:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <__umulhisi3>
     c36:	8c 01       	movw	r16, r24
     c38:	12 95       	swap	r17
     c3a:	02 95       	swap	r16
     c3c:	0f 70       	andi	r16, 0x0F	; 15
     c3e:	01 27       	eor	r16, r17
     c40:	1f 70       	andi	r17, 0x0F	; 15
     c42:	01 27       	eor	r16, r17
     c44:	48 ee       	ldi	r20, 0xE8	; 232
     c46:	53 e0       	ldi	r21, 0x03	; 3
     c48:	04 9f       	mul	r16, r20
     c4a:	90 01       	movw	r18, r0
     c4c:	05 9f       	mul	r16, r21
     c4e:	30 0d       	add	r19, r0
     c50:	14 9f       	mul	r17, r20
     c52:	30 0d       	add	r19, r0
     c54:	11 24       	eor	r1, r1
     c56:	ce 01       	movw	r24, r28
     c58:	82 1b       	sub	r24, r18
     c5a:	93 0b       	sbc	r25, r19
     c5c:	9c 01       	movw	r18, r24
     c5e:	36 95       	lsr	r19
     c60:	27 95       	ror	r18
     c62:	36 95       	lsr	r19
     c64:	27 95       	ror	r18
     c66:	ab e7       	ldi	r26, 0x7B	; 123
     c68:	b4 e1       	ldi	r27, 0x14	; 20
     c6a:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <__umulhisi3>
     c6e:	96 95       	lsr	r25
     c70:	87 95       	ror	r24
     c72:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c76:	80 93 82 01 	sts	0x0182, r24
	segment_data[4] = int2seg(sum/1000); //thousands
     c7a:	80 2f       	mov	r24, r16
     c7c:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c80:	80 93 83 01 	sts	0x0183, r24
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
     c84:	80 91 40 01 	lds	r24, 0x0140
     c88:	88 23       	and	r24, r24
     c8a:	21 f0       	breq	.+8      	; 0xc94 <segsum+0xfc>
     c8c:	80 91 67 01 	lds	r24, 0x0167
     c90:	81 11       	cpse	r24, r1
     c92:	12 c0       	rjmp	.+36     	; 0xcb8 <segsum+0x120>
		segment_data[0] &= 0x7F;
	}
	else{
		segment_data[0] |= 0b10000000;
     c94:	8f 2d       	mov	r24, r15
     c96:	80 68       	ori	r24, 0x80	; 128
     c98:	80 93 7f 01 	sts	0x017F, r24
	}
	if(mode == 1 && blink){
     c9c:	80 91 61 01 	lds	r24, 0x0161
     ca0:	81 30       	cpi	r24, 0x01	; 1
     ca2:	91 f0       	breq	.+36     	; 0xcc8 <segsum+0x130>
		segment_data[4] = 0xFF;
		segment_data[3] = 0xFF;
		segment_data[1] = 0xFF;
		segment_data[0] = 0xFF;
	}
}//segment_sum
     ca4:	df 91       	pop	r29
     ca6:	cf 91       	pop	r28
     ca8:	1f 91       	pop	r17
     caa:	0f 91       	pop	r16
     cac:	ff 90       	pop	r15
     cae:	08 95       	ret

	if(ticker%2 == 1){
		segment_data[2] = 0xFC;
	}
	else{
		segment_data[2] = 0xFF;
     cb0:	8f ef       	ldi	r24, 0xFF	; 255
     cb2:	80 93 81 01 	sts	0x0181, r24
     cb6:	7d cf       	rjmp	.-262    	; 0xbb2 <segsum+0x1a>
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
	segment_data[4] = int2seg(sum/1000); //thousands
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
		segment_data[0] &= 0x7F;
     cb8:	8f 2d       	mov	r24, r15
     cba:	8f 77       	andi	r24, 0x7F	; 127
     cbc:	80 93 7f 01 	sts	0x017F, r24
	}
	else{
		segment_data[0] |= 0b10000000;
	}
	if(mode == 1 && blink){
     cc0:	80 91 61 01 	lds	r24, 0x0161
     cc4:	81 30       	cpi	r24, 0x01	; 1
     cc6:	71 f7       	brne	.-36     	; 0xca4 <segsum+0x10c>
     cc8:	80 91 37 01 	lds	r24, 0x0137
     ccc:	88 23       	and	r24, r24
     cce:	51 f3       	breq	.-44     	; 0xca4 <segsum+0x10c>
		segment_data[4] = 0xFF;
     cd0:	8f ef       	ldi	r24, 0xFF	; 255
     cd2:	80 93 83 01 	sts	0x0183, r24
		segment_data[3] = 0xFF;
     cd6:	80 93 82 01 	sts	0x0182, r24
		segment_data[1] = 0xFF;
     cda:	80 93 80 01 	sts	0x0180, r24
		segment_data[0] = 0xFF;
     cde:	80 93 7f 01 	sts	0x017F, r24
	}
}//segment_sum
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	08 95       	ret

00000cee <button_routine>:
//***********************************************************************************
void button_routine(){
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
	// L -> R
	// 3 2 1 0 7 6 5 4
	uint8_t button = 0;
	//static int previous_mode;   
	DDRA  = 0x00; // PORTA input mode
     cf4:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0xFF; //Pull ups
     cf6:	8f ef       	ldi	r24, 0xFF	; 255
     cf8:	8b bb       	out	0x1b, r24	; 27
	__asm__ __volatile__ ("nop");
     cfa:	00 00       	nop
	__asm__ __volatile__ ("nop");
     cfc:	00 00       	nop
	//enable tristate buffer for pushbutton switches
	PORTB |= 0x70; //Set S2,S1,S0 to 111
     cfe:	88 b3       	in	r24, 0x18	; 24
     d00:	80 67       	ori	r24, 0x70	; 112
     d02:	88 bb       	out	0x18, r24	; 24
	__asm__ __volatile__ ("nop");
     d04:	00 00       	nop
	__asm__ __volatile__ ("nop");
     d06:	00 00       	nop
     d08:	20 e0       	ldi	r18, 0x00	; 0
     d0a:	30 e0       	ldi	r19, 0x00	; 0
				case 7:
					if(alarm_on && music_status){
						music_off();
						music_status = 0;
					}
					alarm_on = !alarm_on;
     d0c:	d1 e0       	ldi	r29, 0x01	; 1
				case 3:
					if(mode == 3){
						mode = 0;			
					}
					else{
						mode = 3;
     d0e:	c3 e0       	ldi	r28, 0x03	; 3
				case 2:
					if(mode == 2){
						mode = 0;	
					}
					else{
						mode = 2;
     d10:	12 e0       	ldi	r17, 0x02	; 2
     d12:	10 c0       	rjmp	.+32     	; 0xd34 <button_routine+0x46>
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d14:	61 e0       	ldi	r22, 0x01	; 1
     d16:	70 ee       	ldi	r23, 0xE0	; 224
     d18:	46 2b       	or	r20, r22
     d1a:	57 2b       	or	r21, r23
     d1c:	50 93 5a 01 	sts	0x015A, r21
     d20:	40 93 59 01 	sts	0x0159, r20
	if (state == 0xF000){
     d24:	41 15       	cp	r20, r1
     d26:	50 4f       	sbci	r21, 0xF0	; 240
     d28:	c9 f0       	breq	.+50     	; 0xd5c <button_routine+0x6e>
     d2a:	2f 5f       	subi	r18, 0xFF	; 255
     d2c:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d2e:	28 30       	cpi	r18, 0x08	; 8
     d30:	31 05       	cpc	r19, r1
     d32:	11 f1       	breq	.+68     	; 0xd78 <button_routine+0x8a>
     d34:	82 2f       	mov	r24, r18
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d36:	40 91 59 01 	lds	r20, 0x0159
     d3a:	50 91 5a 01 	lds	r21, 0x015A
     d3e:	44 0f       	add	r20, r20
     d40:	55 1f       	adc	r21, r21
     d42:	69 b3       	in	r22, 0x19	; 25
     d44:	70 e0       	ldi	r23, 0x00	; 0
     d46:	02 2e       	mov	r0, r18
     d48:	02 c0       	rjmp	.+4      	; 0xd4e <button_routine+0x60>
     d4a:	75 95       	asr	r23
     d4c:	67 95       	ror	r22
     d4e:	0a 94       	dec	r0
     d50:	e2 f7       	brpl	.-8      	; 0xd4a <button_routine+0x5c>
     d52:	60 ff       	sbrs	r22, 0
     d54:	df cf       	rjmp	.-66     	; 0xd14 <button_routine+0x26>
     d56:	60 e0       	ldi	r22, 0x00	; 0
     d58:	70 ee       	ldi	r23, 0xE0	; 224
     d5a:	de cf       	rjmp	.-68     	; 0xd18 <button_routine+0x2a>
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	87 30       	cpi	r24, 0x07	; 7
     d62:	91 05       	cpc	r25, r1
     d64:	88 f0       	brcs	.+34     	; 0xd88 <button_routine+0x9a>
				case 0:  
					mode = 0;
					break;
				case 1:
					if(mode == 1){
						mode = 0;	
     d66:	10 92 61 01 	sts	0x0161, r1
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     d6a:	d0 93 49 01 	sts	0x0149, r29
     d6e:	2f 5f       	subi	r18, 0xFF	; 255
     d70:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d72:	28 30       	cpi	r18, 0x08	; 8
     d74:	31 05       	cpc	r19, r1
     d76:	f1 f6       	brne	.-68     	; 0xd34 <button_routine+0x46>
					break;
			}
			bar_graph_flag = 1;	
		}
	}
	DDRA = 0xFF;  //switch PORTA to output
     d78:	8f ef       	ldi	r24, 0xFF	; 255
     d7a:	8a bb       	out	0x1a, r24	; 26
	__asm__ __volatile__ ("nop"); //Buffer
     d7c:	00 00       	nop
	__asm__ __volatile__ ("nop"); //Buffer 
     d7e:	00 00       	nop

}
     d80:	df 91       	pop	r29
     d82:	cf 91       	pop	r28
     d84:	1f 91       	pop	r17
     d86:	08 95       	ret
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
     d88:	8c 52       	subi	r24, 0x2C	; 44
     d8a:	9f 4f       	sbci	r25, 0xFF	; 255
     d8c:	fc 01       	movw	r30, r24
     d8e:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
					break;
				case 4:
					temp_mode = !temp_mode;
					break;
				case 5:
					show_ampm = !show_ampm;
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	90 91 67 01 	lds	r25, 0x0167
     d98:	91 11       	cpse	r25, r1
     d9a:	80 e0       	ldi	r24, 0x00	; 0
     d9c:	80 93 67 01 	sts	0x0167, r24
					//show_temp = !show_temp;
					break;
     da0:	e4 cf       	rjmp	.-56     	; 0xd6a <button_routine+0x7c>
					else{
						mode = 3;
					}
					break;
				case 4:
					temp_mode = !temp_mode;
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	90 91 36 01 	lds	r25, 0x0136
     da8:	91 11       	cpse	r25, r1
     daa:	80 e0       	ldi	r24, 0x00	; 0
     dac:	80 93 36 01 	sts	0x0136, r24
					break;
     db0:	dc cf       	rjmp	.-72     	; 0xd6a <button_routine+0x7c>
					else{
						mode = 2;
					}
					break;
				case 3:
					if(mode == 3){
     db2:	80 91 61 01 	lds	r24, 0x0161
     db6:	83 30       	cpi	r24, 0x03	; 3
     db8:	b1 f2       	breq	.-84     	; 0xd66 <button_routine+0x78>
						mode = 0;			
					}
					else{
						mode = 3;
     dba:	c0 93 61 01 	sts	0x0161, r28
     dbe:	d5 cf       	rjmp	.-86     	; 0xd6a <button_routine+0x7c>
					else{
						mode = 1;
					}
					break;
				case 2:
					if(mode == 2){
     dc0:	80 91 61 01 	lds	r24, 0x0161
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	79 f2       	breq	.-98     	; 0xd66 <button_routine+0x78>
						mode = 0;	
					}
					else{
						mode = 2;
     dc8:	10 93 61 01 	sts	0x0161, r17
     dcc:	ce cf       	rjmp	.-100    	; 0xd6a <button_routine+0x7c>
			switch(button){
				case 0:  
					mode = 0;
					break;
				case 1:
					if(mode == 1){
     dce:	80 91 61 01 	lds	r24, 0x0161
     dd2:	81 30       	cpi	r24, 0x01	; 1
     dd4:	41 f2       	breq	.-112    	; 0xd66 <button_routine+0x78>
						mode = 0;	
					}
					else{
						mode = 1;
     dd6:	d0 93 61 01 	sts	0x0161, r29
     dda:	c7 cf       	rjmp	.-114    	; 0xd6a <button_routine+0x7c>
				case 5:
					show_ampm = !show_ampm;
					//show_temp = !show_temp;
					break;
				case 6:
					if(music_status){
     ddc:	80 91 38 01 	lds	r24, 0x0138
     de0:	88 23       	and	r24, r24
     de2:	09 f4       	brne	.+2      	; 0xde6 <button_routine+0xf8>
     de4:	c2 cf       	rjmp	.-124    	; 0xd6a <button_routine+0x7c>
						snooze_flag = 1;
     de6:	d0 93 3a 01 	sts	0x013A, r29
						music_status = 0;
     dea:	10 92 38 01 	sts	0x0138, r1
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     dee:	10 92 68 01 	sts	0x0168, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     df2:	8e b5       	in	r24, 0x2e	; 46
     df4:	8c 7f       	andi	r24, 0xFC	; 252
     df6:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     df8:	92 9a       	sbi	0x12, 2	; 18
     dfa:	b7 cf       	rjmp	.-146    	; 0xd6a <button_routine+0x7c>
						music_off();
					}
					break;
				case 7:
					if(alarm_on && music_status){
     dfc:	80 91 39 01 	lds	r24, 0x0139
     e00:	88 23       	and	r24, r24
     e02:	79 f0       	breq	.+30     	; 0xe22 <button_routine+0x134>
     e04:	90 91 38 01 	lds	r25, 0x0138
     e08:	99 23       	and	r25, r25
     e0a:	91 f0       	breq	.+36     	; 0xe30 <button_routine+0x142>
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     e0c:	10 92 68 01 	sts	0x0168, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     e10:	8e b5       	in	r24, 0x2e	; 46
     e12:	8c 7f       	andi	r24, 0xFC	; 252
     e14:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     e16:	92 9a       	sbi	0x12, 2	; 18
						music_off();
						music_status = 0;
     e18:	10 92 38 01 	sts	0x0138, r1
     e1c:	90 91 39 01 	lds	r25, 0x0139
     e20:	01 c0       	rjmp	.+2      	; 0xe24 <button_routine+0x136>
     e22:	90 e0       	ldi	r25, 0x00	; 0
					}
					alarm_on = !alarm_on;
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	91 11       	cpse	r25, r1
     e28:	80 e0       	ldi	r24, 0x00	; 0
     e2a:	80 93 39 01 	sts	0x0139, r24
					//alarm_change = 1; 
					break;
     e2e:	9d cf       	rjmp	.-198    	; 0xd6a <button_routine+0x7c>
     e30:	98 2f       	mov	r25, r24
     e32:	f8 cf       	rjmp	.-16     	; 0xe24 <button_routine+0x136>

00000e34 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
     e34:	1f 92       	push	r1
     e36:	0f 92       	push	r0
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	0f 92       	push	r0
     e3c:	11 24       	eor	r1, r1
     e3e:	0b b6       	in	r0, 0x3b	; 59
     e40:	0f 92       	push	r0
     e42:	2f 93       	push	r18
     e44:	3f 93       	push	r19
     e46:	4f 93       	push	r20
     e48:	5f 93       	push	r21
     e4a:	6f 93       	push	r22
     e4c:	7f 93       	push	r23
     e4e:	8f 93       	push	r24
     e50:	9f 93       	push	r25
     e52:	af 93       	push	r26
     e54:	bf 93       	push	r27
     e56:	cf 93       	push	r28
     e58:	ef 93       	push	r30
     e5a:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
     e5c:	20 91 58 01 	lds	r18, 0x0158
     e60:	2f 5f       	subi	r18, 0xFF	; 255
     e62:	20 93 58 01 	sts	0x0158, r18
	//update_time();
	if(count%2 == 0){
     e66:	20 fd       	sbrc	r18, 0
     e68:	03 c0       	rjmp	.+6      	; 0xe70 <__vector_16+0x3c>
		update_LCD = 1;
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	80 93 4b 01 	sts	0x014B, r24

	}
	if(count%8 == 0){
     e70:	82 2f       	mov	r24, r18
     e72:	87 70       	andi	r24, 0x07	; 7
     e74:	81 f4       	brne	.+32     	; 0xe96 <__vector_16+0x62>
		//	update_LCD = 1;
		beat++;
     e76:	80 91 78 01 	lds	r24, 0x0178
     e7a:	90 91 79 01 	lds	r25, 0x0179
     e7e:	01 96       	adiw	r24, 0x01	; 1
     e80:	90 93 79 01 	sts	0x0179, r25
     e84:	80 93 78 01 	sts	0x0178, r24
		blink = !blink;
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	90 91 37 01 	lds	r25, 0x0137
     e8e:	91 11       	cpse	r25, r1
     e90:	3f c0       	rjmp	.+126    	; 0xf10 <__vector_16+0xdc>
     e92:	80 93 37 01 	sts	0x0137, r24
	}
	if((count%128)==0){
     e96:	2f 77       	andi	r18, 0x7F	; 127
     e98:	39 f5       	brne	.+78     	; 0xee8 <__vector_16+0xb4>
		ticker++;     
     e9a:	80 91 5b 01 	lds	r24, 0x015B
     e9e:	8f 5f       	subi	r24, 0xFF	; 255
     ea0:	80 93 5b 01 	sts	0x015B, r24
		second++; 
     ea4:	80 91 60 01 	lds	r24, 0x0160
     ea8:	8f 5f       	subi	r24, 0xFF	; 255
     eaa:	80 93 60 01 	sts	0x0160, r24
		reset_temp = 1;   
     eae:	c1 e0       	ldi	r28, 0x01	; 1
     eb0:	c0 93 4a 01 	sts	0x014A, r28
		if(alarm_on){
     eb4:	80 91 39 01 	lds	r24, 0x0139
     eb8:	88 23       	and	r24, r24
     eba:	b1 f0       	breq	.+44     	; 0xee8 <__vector_16+0xb4>
			if ((alarm_time == time) && !snooze_flag && !music_status){
     ebc:	20 91 44 01 	lds	r18, 0x0144
     ec0:	30 91 45 01 	lds	r19, 0x0145
     ec4:	80 91 46 01 	lds	r24, 0x0146
     ec8:	90 91 47 01 	lds	r25, 0x0147
     ecc:	28 17       	cp	r18, r24
     ece:	39 07       	cpc	r19, r25
     ed0:	41 f1       	breq	.+80     	; 0xf22 <__vector_16+0xee>
				//play music
				music_on();
				music_status = 1;
			}
			else if(snooze_flag){
     ed2:	80 91 3a 01 	lds	r24, 0x013A
     ed6:	88 23       	and	r24, r24
     ed8:	39 f0       	breq	.+14     	; 0xee8 <__vector_16+0xb4>
				snooze_second++;
     eda:	80 91 3b 01 	lds	r24, 0x013B
     ede:	8f 5f       	subi	r24, 0xFF	; 255
     ee0:	80 93 3b 01 	sts	0x013B, r24
				if(snooze_second >= 10){
     ee4:	8a 30       	cpi	r24, 0x0A	; 10
     ee6:	b0 f4       	brcc	.+44     	; 0xf14 <__vector_16+0xe0>
					snooze_second = 0;
				}	
			}
		}
	}
}
     ee8:	ff 91       	pop	r31
     eea:	ef 91       	pop	r30
     eec:	cf 91       	pop	r28
     eee:	bf 91       	pop	r27
     ef0:	af 91       	pop	r26
     ef2:	9f 91       	pop	r25
     ef4:	8f 91       	pop	r24
     ef6:	7f 91       	pop	r23
     ef8:	6f 91       	pop	r22
     efa:	5f 91       	pop	r21
     efc:	4f 91       	pop	r20
     efe:	3f 91       	pop	r19
     f00:	2f 91       	pop	r18
     f02:	0f 90       	pop	r0
     f04:	0b be       	out	0x3b, r0	; 59
     f06:	0f 90       	pop	r0
     f08:	0f be       	out	0x3f, r0	; 63
     f0a:	0f 90       	pop	r0
     f0c:	1f 90       	pop	r1
     f0e:	18 95       	reti

	}
	if(count%8 == 0){
		//	update_LCD = 1;
		beat++;
		blink = !blink;
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	bf cf       	rjmp	.-130    	; 0xe92 <__vector_16+0x5e>
				music_status = 1;
			}
			else if(snooze_flag){
				snooze_second++;
				if(snooze_second >= 10){
					snooze_flag = 0;
     f14:	10 92 3a 01 	sts	0x013A, r1
					music_on();
     f18:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
					snooze_second = 0;
     f1c:	10 92 3b 01 	sts	0x013B, r1
     f20:	e3 cf       	rjmp	.-58     	; 0xee8 <__vector_16+0xb4>
	if((count%128)==0){
		ticker++;     
		second++; 
		reset_temp = 1;   
		if(alarm_on){
			if ((alarm_time == time) && !snooze_flag && !music_status){
     f22:	80 91 3a 01 	lds	r24, 0x013A
     f26:	81 11       	cpse	r24, r1
     f28:	d8 cf       	rjmp	.-80     	; 0xeda <__vector_16+0xa6>
     f2a:	80 91 38 01 	lds	r24, 0x0138
     f2e:	81 11       	cpse	r24, r1
     f30:	db cf       	rjmp	.-74     	; 0xee8 <__vector_16+0xb4>
				//play music
				music_on();
     f32:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
				music_status = 1;
     f36:	c0 93 38 01 	sts	0x0138, r28
     f3a:	d6 cf       	rjmp	.-84     	; 0xee8 <__vector_16+0xb4>

00000f3c <__vector_12>:
			}
		}
	}
}

ISR(TIMER1_COMPA_vect){
     f3c:	1f 92       	push	r1
     f3e:	0f 92       	push	r0
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	0f 92       	push	r0
     f44:	11 24       	eor	r1, r1
     f46:	0b b6       	in	r0, 0x3b	; 59
     f48:	0f 92       	push	r0
     f4a:	2f 93       	push	r18
     f4c:	3f 93       	push	r19
     f4e:	4f 93       	push	r20
     f50:	5f 93       	push	r21
     f52:	6f 93       	push	r22
     f54:	7f 93       	push	r23
     f56:	8f 93       	push	r24
     f58:	9f 93       	push	r25
     f5a:	af 93       	push	r26
     f5c:	bf 93       	push	r27
     f5e:	ef 93       	push	r30
     f60:	ff 93       	push	r31
	PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
     f62:	82 b3       	in	r24, 0x12	; 18
     f64:	80 58       	subi	r24, 0x80	; 128
     f66:	82 bb       	out	0x12, r24	; 18
	PORTB |= (1<<PB0);
     f68:	c0 9a       	sbi	0x18, 0	; 24
	if(beat >= max_beat) {   //if we've played the note long enough
     f6a:	20 91 78 01 	lds	r18, 0x0178
     f6e:	30 91 79 01 	lds	r19, 0x0179
     f72:	80 91 76 01 	lds	r24, 0x0176
     f76:	90 91 77 01 	lds	r25, 0x0177
     f7a:	28 17       	cp	r18, r24
     f7c:	39 07       	cpc	r19, r25
     f7e:	60 f0       	brcs	.+24     	; 0xf98 <__vector_12+0x5c>
		notes++;               //move on to the next note
     f80:	80 91 68 01 	lds	r24, 0x0168
     f84:	8f 5f       	subi	r24, 0xFF	; 255
     f86:	80 93 68 01 	sts	0x0168, r24
		play_song(song, notes);//and play it
     f8a:	80 91 68 01 	lds	r24, 0x0168
     f8e:	90 91 75 01 	lds	r25, 0x0175
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	0e 94 65 04 	call	0x8ca	; 0x8ca <song0>
	}
}
     f98:	ff 91       	pop	r31
     f9a:	ef 91       	pop	r30
     f9c:	bf 91       	pop	r27
     f9e:	af 91       	pop	r26
     fa0:	9f 91       	pop	r25
     fa2:	8f 91       	pop	r24
     fa4:	7f 91       	pop	r23
     fa6:	6f 91       	pop	r22
     fa8:	5f 91       	pop	r21
     faa:	4f 91       	pop	r20
     fac:	3f 91       	pop	r19
     fae:	2f 91       	pop	r18
     fb0:	0f 90       	pop	r0
     fb2:	0b be       	out	0x3b, r0	; 59
     fb4:	0f 90       	pop	r0
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	0f 90       	pop	r0
     fba:	1f 90       	pop	r1
     fbc:	18 95       	reti

00000fbe <__vector_21>:
		default:
			break;
	}    
} 

ISR(ADC_vect){
     fbe:	1f 92       	push	r1
     fc0:	0f 92       	push	r0
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	0f 92       	push	r0
     fc6:	11 24       	eor	r1, r1
     fc8:	8f 93       	push	r24
     fca:	9f 93       	push	r25

	if(ADCH < 100){
     fcc:	85 b1       	in	r24, 0x05	; 5
     fce:	84 36       	cpi	r24, 0x64	; 100
     fd0:	48 f0       	brcs	.+18     	; 0xfe4 <__vector_21+0x26>
		OCR2 = 100-ADCH;
	}  
	else{
		OCR2 = 1;// brightness_level;
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	83 bd       	out	0x23, r24	; 35
	}
}
     fd6:	9f 91       	pop	r25
     fd8:	8f 91       	pop	r24
     fda:	0f 90       	pop	r0
     fdc:	0f be       	out	0x3f, r0	; 63
     fde:	0f 90       	pop	r0
     fe0:	1f 90       	pop	r1
     fe2:	18 95       	reti
} 

ISR(ADC_vect){

	if(ADCH < 100){
		OCR2 = 100-ADCH;
     fe4:	95 b1       	in	r25, 0x05	; 5
     fe6:	84 e6       	ldi	r24, 0x64	; 100
     fe8:	89 1b       	sub	r24, r25
     fea:	83 bd       	out	0x23, r24	; 35
	}  
	else{
		OCR2 = 1;// brightness_level;
	}
}
     fec:	9f 91       	pop	r25
     fee:	8f 91       	pop	r24
     ff0:	0f 90       	pop	r0
     ff2:	0f be       	out	0x3f, r0	; 63
     ff4:	0f 90       	pop	r0
     ff6:	1f 90       	pop	r1
     ff8:	18 95       	reti

00000ffa <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
     ffa:	80 91 60 01 	lds	r24, 0x0160
		minute++;
     ffe:	20 91 5f 01 	lds	r18, 0x015F
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
    1002:	8c 33       	cpi	r24, 0x3C	; 60
    1004:	28 f0       	brcs	.+10     	; 0x1010 <update_time+0x16>
		minute++;
    1006:	2f 5f       	subi	r18, 0xFF	; 255
    1008:	20 93 5f 01 	sts	0x015F, r18
		second = 0;
    100c:	10 92 60 01 	sts	0x0160, r1
	}             
	if(minute >=60){
		hour++;
    1010:	e0 91 5e 01 	lds	r30, 0x015E
	// static int minute_change = 0;
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
    1014:	2c 33       	cpi	r18, 0x3C	; 60
    1016:	c0 f5       	brcc	.+112    	; 0x1088 <update_time+0x8e>
    1018:	30 e0       	ldi	r19, 0x00	; 0
		hour++;
		minute = 0;
	}
	if(hour >= 24){
    101a:	e8 31       	cpi	r30, 0x18	; 24
    101c:	f0 f5       	brcc	.+124    	; 0x109a <update_time+0xa0>
    101e:	6e 2f       	mov	r22, r30
    1020:	70 e0       	ldi	r23, 0x00	; 0
    1022:	84 e6       	ldi	r24, 0x64	; 100
    1024:	e8 9f       	mul	r30, r24
    1026:	a0 01       	movw	r20, r0
    1028:	11 24       	eor	r1, r1
		hour = 0;
	} 

	alarm_time = (alarm_hour * 100) + alarm_minute;
    102a:	f0 91 5c 01 	lds	r31, 0x015C
    102e:	80 91 5d 01 	lds	r24, 0x015D
    1032:	90 e0       	ldi	r25, 0x00	; 0
    1034:	a4 e6       	ldi	r26, 0x64	; 100
    1036:	fa 9f       	mul	r31, r26
    1038:	80 0d       	add	r24, r0
    103a:	91 1d       	adc	r25, r1
    103c:	11 24       	eor	r1, r1
    103e:	90 93 45 01 	sts	0x0145, r25
    1042:	80 93 44 01 	sts	0x0144, r24
	// if(minute_change){
	time = (hour * 100) + minute;
    1046:	c9 01       	movw	r24, r18
    1048:	84 0f       	add	r24, r20
    104a:	95 1f       	adc	r25, r21
    104c:	90 93 47 01 	sts	0x0147, r25
    1050:	80 93 46 01 	sts	0x0146, r24
	// minute_change = 0;

	if(show_ampm){
    1054:	40 91 67 01 	lds	r20, 0x0167
    1058:	44 23       	and	r20, r20
    105a:	39 f1       	breq	.+78     	; 0x10aa <update_time+0xb0>
		if(hour>=12){
    105c:	ec 30       	cpi	r30, 0x0C	; 12
    105e:	50 f1       	brcs	.+84     	; 0x10b4 <update_time+0xba>
			if(hour == 12){
    1060:	ec 30       	cpi	r30, 0x0C	; 12
    1062:	d1 f1       	breq	.+116    	; 0x10d8 <update_time+0xde>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour-12)*100 + minute;
    1064:	6c 50       	subi	r22, 0x0C	; 12
    1066:	71 09       	sbc	r23, r1
    1068:	44 e6       	ldi	r20, 0x64	; 100
    106a:	46 9f       	mul	r20, r22
    106c:	c0 01       	movw	r24, r0
    106e:	47 9f       	mul	r20, r23
    1070:	90 0d       	add	r25, r0
    1072:	11 24       	eor	r1, r1
    1074:	82 0f       	add	r24, r18
    1076:	93 1f       	adc	r25, r19
    1078:	90 93 43 01 	sts	0x0143, r25
    107c:	80 93 42 01 	sts	0x0142, r24
				am_pm = 1;
    1080:	81 e0       	ldi	r24, 0x01	; 1
    1082:	80 93 40 01 	sts	0x0140, r24
    1086:	08 95       	ret
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
		hour++;
    1088:	ef 5f       	subi	r30, 0xFF	; 255
    108a:	e0 93 5e 01 	sts	0x015E, r30
		minute = 0;
    108e:	10 92 5f 01 	sts	0x015F, r1
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	30 e0       	ldi	r19, 0x00	; 0
	}
	if(hour >= 24){
    1096:	e8 31       	cpi	r30, 0x18	; 24
    1098:	10 f2       	brcs	.-124    	; 0x101e <update_time+0x24>
		hour = 0;
    109a:	10 92 5e 01 	sts	0x015E, r1
    109e:	40 e0       	ldi	r20, 0x00	; 0
    10a0:	50 e0       	ldi	r21, 0x00	; 0
    10a2:	60 e0       	ldi	r22, 0x00	; 0
    10a4:	70 e0       	ldi	r23, 0x00	; 0
    10a6:	e0 e0       	ldi	r30, 0x00	; 0
    10a8:	c0 cf       	rjmp	.-128    	; 0x102a <update_time+0x30>
			}
			am_pm = 0;
		}
	}
	else{
		show_time = (hour * 100) + minute;
    10aa:	90 93 43 01 	sts	0x0143, r25
    10ae:	80 93 42 01 	sts	0x0142, r24
    10b2:	08 95       	ret
				show_time = (hour-12)*100 + minute;
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
    10b4:	ee 23       	and	r30, r30
    10b6:	39 f0       	breq	.+14     	; 0x10c6 <update_time+0xcc>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour)*100 + minute;
    10b8:	90 93 43 01 	sts	0x0143, r25
    10bc:	80 93 42 01 	sts	0x0142, r24
			}
			am_pm = 0;
    10c0:	10 92 40 01 	sts	0x0140, r1
    10c4:	08 95       	ret
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
				show_time = 1200 + minute;
    10c6:	20 55       	subi	r18, 0x50	; 80
    10c8:	3b 4f       	sbci	r19, 0xFB	; 251
    10ca:	30 93 43 01 	sts	0x0143, r19
    10ce:	20 93 42 01 	sts	0x0142, r18
			}
			else{
				show_time = (hour)*100 + minute;
			}
			am_pm = 0;
    10d2:	10 92 40 01 	sts	0x0140, r1
    10d6:	08 95       	ret
	// minute_change = 0;

	if(show_ampm){
		if(hour>=12){
			if(hour == 12){
				show_time = 1200 + minute;
    10d8:	20 55       	subi	r18, 0x50	; 80
    10da:	3b 4f       	sbci	r19, 0xFB	; 251
    10dc:	30 93 43 01 	sts	0x0143, r19
    10e0:	20 93 42 01 	sts	0x0142, r18
    10e4:	08 95       	ret

000010e6 <SPI_init>:
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    10e6:	80 e5       	ldi	r24, 0x50	; 80
    10e8:	8d b9       	out	0x0d, r24	; 13
    10ea:	08 95       	ret

000010ec <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    10ec:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    10ee:	77 9b       	sbis	0x0e, 7	; 14
    10f0:	fe cf       	rjmp	.-4      	; 0x10ee <SPI_Transmit+0x2>
}
    10f2:	08 95       	ret

000010f4 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
	PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
    10f4:	83 b1       	in	r24, 0x03	; 3
    10f6:	13 b8       	out	0x03, r1	; 3
	__asm__ __volatile__ ("nop");
    10f8:	00 00       	nop
	__asm__ __volatile__ ("nop");
    10fa:	00 00       	nop
	// Wait until 8 clock cycles are done 
	SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
    10fc:	1f b8       	out	0x0f, r1	; 15
	PORTE |= (1 << PE6);  
    10fe:	1e 9a       	sbi	0x03, 6	; 3
	__asm__ __volatile__ ("nop");
    1100:	00 00       	nop
	__asm__ __volatile__ ("nop");
    1102:	00 00       	nop
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    1104:	77 9b       	sbis	0x0e, 7	; 14
    1106:	fe cf       	rjmp	.-4      	; 0x1104 <__stack+0x5>
	// Return incoming data from SPDR
	return(SPDR);  
    1108:	8f b1       	in	r24, 0x0f	; 15
}
    110a:	08 95       	ret

0000110c <bar_graph>:
 *void bar_graph()
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
    110c:	80 91 61 01 	lds	r24, 0x0161
    1110:	88 23       	and	r24, r24
    1112:	b9 f0       	breq	.+46     	; 0x1142 <bar_graph+0x36>
		write = 0x00;
	}
	else{
		write = 1<<(mode-1);
    1114:	9f ef       	ldi	r25, 0xFF	; 255
    1116:	98 0f       	add	r25, r24
    1118:	81 e0       	ldi	r24, 0x01	; 1
    111a:	01 c0       	rjmp	.+2      	; 0x111e <bar_graph+0x12>
    111c:	88 0f       	add	r24, r24
    111e:	9a 95       	dec	r25
    1120:	ea f7       	brpl	.-6      	; 0x111c <bar_graph+0x10>
	}

	if(alarm_on != 0){
    1122:	90 91 39 01 	lds	r25, 0x0139
    1126:	91 11       	cpse	r25, r1
		write = 0xFF;
    1128:	8f ef       	ldi	r24, 0xFF	; 255

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    112a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    112c:	77 9b       	sbis	0x0e, 7	; 14
    112e:	fe cf       	rjmp	.-4      	; 0x112c <bar_graph+0x20>

	if(alarm_on != 0){
		write = 0xFF;
	}
	SPI_Transmit(write);
	PORTD = (1 << PD2);  //Push data out of SPI
    1130:	84 e0       	ldi	r24, 0x04	; 4
    1132:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop"); //Buffer
    1134:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    1136:	00 00       	nop


	PORTD = (2 << PD2);  // Push data out of SPI
    1138:	88 e0       	ldi	r24, 0x08	; 8
    113a:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop");  //Buffer
    113c:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    113e:	00 00       	nop
    1140:	08 95       	ret
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
		write = 0x00;
    1142:	80 e0       	ldi	r24, 0x00	; 0
    1144:	ee cf       	rjmp	.-36     	; 0x1122 <bar_graph+0x16>

00001146 <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
	uint8_t display_segment = 0;
	static uint8_t rotate_7seg = 0;
	switch(mode){
    1146:	80 91 61 01 	lds	r24, 0x0161
    114a:	83 30       	cpi	r24, 0x03	; 3
    114c:	09 f4       	brne	.+2      	; 0x1150 <display_update+0xa>
    114e:	41 c0       	rjmp	.+130    	; 0x11d2 <display_update+0x8c>
    1150:	84 30       	cpi	r24, 0x04	; 4
    1152:	41 f0       	breq	.+16     	; 0x1164 <display_update+0x1e>
    1154:	82 30       	cpi	r24, 0x02	; 2
    1156:	a1 f1       	breq	.+104    	; 0x11c0 <display_update+0x7a>
			segment_data[2] = 0xFF; //decimal
			break;
		case 4:
			break;
		default:
			segsum(show_time);
    1158:	80 91 42 01 	lds	r24, 0x0142
    115c:	90 91 43 01 	lds	r25, 0x0143
    1160:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
	   PORTA = segment_data[display_segment];
	   _delay_us(80);
	   PORTA = OFF;
	   }
	 */
	switch(rotate_7seg%5){
    1164:	20 91 54 01 	lds	r18, 0x0154
    1168:	8d ec       	ldi	r24, 0xCD	; 205
    116a:	28 9f       	mul	r18, r24
    116c:	81 2d       	mov	r24, r1
    116e:	11 24       	eor	r1, r1
    1170:	86 95       	lsr	r24
    1172:	86 95       	lsr	r24
    1174:	98 2f       	mov	r25, r24
    1176:	99 0f       	add	r25, r25
    1178:	99 0f       	add	r25, r25
    117a:	98 0f       	add	r25, r24
    117c:	82 2f       	mov	r24, r18
    117e:	89 1b       	sub	r24, r25
    1180:	82 30       	cpi	r24, 0x02	; 2
    1182:	09 f4       	brne	.+2      	; 0x1186 <display_update+0x40>
    1184:	45 c0       	rjmp	.+138    	; 0x1210 <display_update+0xca>
    1186:	78 f0       	brcs	.+30     	; 0x11a6 <display_update+0x60>
    1188:	83 30       	cpi	r24, 0x03	; 3
    118a:	b9 f1       	breq	.+110    	; 0x11fa <display_update+0xb4>
    118c:	84 30       	cpi	r24, 0x04	; 4
    118e:	59 f5       	brne	.+86     	; 0x11e6 <display_update+0xa0>
		case 3:
			PORTB = 3 << 4;
			PORTA = segment_data[3];
			break;
		case 4:
			PORTB = 4 << 4;
    1190:	80 e4       	ldi	r24, 0x40	; 64
    1192:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[4];
    1194:	80 91 83 01 	lds	r24, 0x0183
    1198:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    119a:	80 91 54 01 	lds	r24, 0x0154
    119e:	8f 5f       	subi	r24, 0xFF	; 255
    11a0:	80 93 54 01 	sts	0x0154, r24
    11a4:	08 95       	ret
	   PORTA = segment_data[display_segment];
	   _delay_us(80);
	   PORTA = OFF;
	   }
	 */
	switch(rotate_7seg%5){
    11a6:	81 30       	cpi	r24, 0x01	; 1
    11a8:	f1 f4       	brne	.+60     	; 0x11e6 <display_update+0xa0>
			PORTB = 0 << 4;
			PORTA = segment_data[0];
			break;

		case 1:
			PORTB = 1 << 4;
    11aa:	80 e1       	ldi	r24, 0x10	; 16
    11ac:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[1];
    11ae:	80 91 80 01 	lds	r24, 0x0180
    11b2:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    11b4:	80 91 54 01 	lds	r24, 0x0154
    11b8:	8f 5f       	subi	r24, 0xFF	; 255
    11ba:	80 93 54 01 	sts	0x0154, r24
    11be:	08 95       	ret
void display_update(){
	uint8_t display_segment = 0;
	static uint8_t rotate_7seg = 0;
	switch(mode){
		case 2:
			segsum(alarm_time);
    11c0:	80 91 44 01 	lds	r24, 0x0144
    11c4:	90 91 45 01 	lds	r25, 0x0145
    11c8:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0x00;
    11cc:	10 92 81 01 	sts	0x0181, r1
			break;
    11d0:	c9 cf       	rjmp	.-110    	; 0x1164 <display_update+0x1e>
		case 3:
			segsum(OCR3A);
    11d2:	80 91 86 00 	lds	r24, 0x0086
    11d6:	90 91 87 00 	lds	r25, 0x0087
    11da:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0xFF; //decimal
    11de:	8f ef       	ldi	r24, 0xFF	; 255
    11e0:	80 93 81 01 	sts	0x0181, r24
			break;
    11e4:	bf cf       	rjmp	.-130    	; 0x1164 <display_update+0x1e>
	   PORTA = OFF;
	   }
	 */
	switch(rotate_7seg%5){
		case 0:
			PORTB = 0 << 4;
    11e6:	18 ba       	out	0x18, r1	; 24
			PORTA = segment_data[0];
    11e8:	80 91 7f 01 	lds	r24, 0x017F
    11ec:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    11ee:	80 91 54 01 	lds	r24, 0x0154
    11f2:	8f 5f       	subi	r24, 0xFF	; 255
    11f4:	80 93 54 01 	sts	0x0154, r24
    11f8:	08 95       	ret
		case 2:
			PORTB = 2 << 4;
			PORTA = segment_data[2];
			break;
		case 3:
			PORTB = 3 << 4;
    11fa:	80 e3       	ldi	r24, 0x30	; 48
    11fc:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[3];
    11fe:	80 91 82 01 	lds	r24, 0x0182
    1202:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    1204:	80 91 54 01 	lds	r24, 0x0154
    1208:	8f 5f       	subi	r24, 0xFF	; 255
    120a:	80 93 54 01 	sts	0x0154, r24
    120e:	08 95       	ret
		case 1:
			PORTB = 1 << 4;
			PORTA = segment_data[1];
			break;
		case 2:
			PORTB = 2 << 4;
    1210:	80 e2       	ldi	r24, 0x20	; 32
    1212:	88 bb       	out	0x18, r24	; 24
			PORTA = segment_data[2];
    1214:	80 91 81 01 	lds	r24, 0x0181
    1218:	8b bb       	out	0x1b, r24	; 27
			break;
		default:
			break;

	}
	rotate_7seg++;
    121a:	80 91 54 01 	lds	r24, 0x0154
    121e:	8f 5f       	subi	r24, 0xFF	; 255
    1220:	80 93 54 01 	sts	0x0154, r24
    1224:	08 95       	ret

00001226 <__vector_10>:
		notes++;               //move on to the next note
		play_song(song, notes);//and play it
	}
}

ISR(TIMER2_OVF_vect){
    1226:	1f 92       	push	r1
    1228:	0f 92       	push	r0
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	0f 92       	push	r0
    122e:	11 24       	eor	r1, r1
    1230:	0b b6       	in	r0, 0x3b	; 59
    1232:	0f 92       	push	r0
    1234:	2f 93       	push	r18
    1236:	3f 93       	push	r19
    1238:	4f 93       	push	r20
    123a:	5f 93       	push	r21
    123c:	6f 93       	push	r22
    123e:	7f 93       	push	r23
    1240:	8f 93       	push	r24
    1242:	9f 93       	push	r25
    1244:	af 93       	push	r26
    1246:	bf 93       	push	r27
    1248:	cf 93       	push	r28
    124a:	ef 93       	push	r30
    124c:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
    124e:	c0 91 57 01 	lds	r28, 0x0157
    1252:	cf 5f       	subi	r28, 0xFF	; 255
    1254:	c0 93 57 01 	sts	0x0157, r28
	//display_update();

	if(count%64 == 0){
    1258:	8c 2f       	mov	r24, r28
    125a:	8f 73       	andi	r24, 0x3F	; 63
    125c:	f1 f0       	breq	.+60     	; 0x129a <__vector_10+0x74>
		button_routine();
	}

	switch(count%8){
    125e:	c7 70       	andi	r28, 0x07	; 7
    1260:	c1 f0       	breq	.+48     	; 0x1292 <__vector_10+0x6c>
    1262:	c1 30       	cpi	r28, 0x01	; 1
    1264:	11 f4       	brne	.+4      	; 0x126a <__vector_10+0x44>
			//TODO
			encode_flag = 1;
			//check_knobs();
			break;
		case 1:
			display_update();
    1266:	0e 94 a3 08 	call	0x1146	; 0x1146 <display_update>
			break;
		default:
			break;
	}    
} 
    126a:	ff 91       	pop	r31
    126c:	ef 91       	pop	r30
    126e:	cf 91       	pop	r28
    1270:	bf 91       	pop	r27
    1272:	af 91       	pop	r26
    1274:	9f 91       	pop	r25
    1276:	8f 91       	pop	r24
    1278:	7f 91       	pop	r23
    127a:	6f 91       	pop	r22
    127c:	5f 91       	pop	r21
    127e:	4f 91       	pop	r20
    1280:	3f 91       	pop	r19
    1282:	2f 91       	pop	r18
    1284:	0f 90       	pop	r0
    1286:	0b be       	out	0x3b, r0	; 59
    1288:	0f 90       	pop	r0
    128a:	0f be       	out	0x3f, r0	; 63
    128c:	0f 90       	pop	r0
    128e:	1f 90       	pop	r1
    1290:	18 95       	reti
	}

	switch(count%8){
		case 0:
			//TODO
			encode_flag = 1;
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	80 93 4d 01 	sts	0x014D, r24
			//check_knobs();
			break;
    1298:	e8 cf       	rjmp	.-48     	; 0x126a <__vector_10+0x44>
	static uint8_t count = 0;
	count++;
	//display_update();

	if(count%64 == 0){
		button_routine();
    129a:	0e 94 77 06 	call	0xcee	; 0xcee <button_routine>
    129e:	df cf       	rjmp	.-66     	; 0x125e <__vector_10+0x38>

000012a0 <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
	switch(mode){
    12a0:	80 91 61 01 	lds	r24, 0x0161
    12a4:	81 30       	cpi	r24, 0x01	; 1
    12a6:	59 f0       	breq	.+22     	; 0x12be <right_inc+0x1e>
    12a8:	82 30       	cpi	r24, 0x02	; 2
    12aa:	41 f4       	brne	.+16     	; 0x12bc <right_inc+0x1c>
				minute = 0;	    
			}     
			second++;
			break;
		case 2: 
			alarm_minute++;
    12ac:	80 91 5d 01 	lds	r24, 0x015D
    12b0:	8f 5f       	subi	r24, 0xFF	; 255
			if(alarm_minute >= 60){
    12b2:	8c 33       	cpi	r24, 0x3C	; 60
    12b4:	88 f0       	brcs	.+34     	; 0x12d8 <right_inc+0x38>
				alarm_minute = 0;	
    12b6:	10 92 5d 01 	sts	0x015D, r1
    12ba:	08 95       	ret
    12bc:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    12be:	80 91 5f 01 	lds	r24, 0x015F
    12c2:	8f 5f       	subi	r24, 0xFF	; 255
			if(minute >= 60){
    12c4:	8c 33       	cpi	r24, 0x3C	; 60
    12c6:	58 f0       	brcs	.+22     	; 0x12de <right_inc+0x3e>
				minute = 0;	    
    12c8:	10 92 5f 01 	sts	0x015F, r1
			}     
			second++;
    12cc:	80 91 60 01 	lds	r24, 0x0160
    12d0:	8f 5f       	subi	r24, 0xFF	; 255
    12d2:	80 93 60 01 	sts	0x0160, r24
			break;
    12d6:	08 95       	ret
		case 2: 
			alarm_minute++;
    12d8:	80 93 5d 01 	sts	0x015D, r24
    12dc:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    12de:	80 93 5f 01 	sts	0x015F, r24
			if(minute >= 60){
				minute = 0;	    
			}     
			second++;
    12e2:	80 91 60 01 	lds	r24, 0x0160
    12e6:	8f 5f       	subi	r24, 0xFF	; 255
    12e8:	80 93 60 01 	sts	0x0160, r24
			break;
    12ec:	08 95       	ret

000012ee <right_dec>:
		default:
			break;             
	}
}
void right_dec(){
	switch(mode){
    12ee:	80 91 61 01 	lds	r24, 0x0161
    12f2:	81 30       	cpi	r24, 0x01	; 1
    12f4:	71 f0       	breq	.+28     	; 0x1312 <right_dec+0x24>
    12f6:	82 30       	cpi	r24, 0x02	; 2
    12f8:	59 f4       	brne	.+22     	; 0x1310 <right_dec+0x22>
			if(minute >= 240){
				minute = 59;	    
			}   
			break;
		case 2: 
			alarm_minute--;
    12fa:	80 91 5d 01 	lds	r24, 0x015D
    12fe:	81 50       	subi	r24, 0x01	; 1
    1300:	80 93 5d 01 	sts	0x015D, r24
			if(alarm_minute >= 240){
    1304:	80 3f       	cpi	r24, 0xF0	; 240
    1306:	18 f0       	brcs	.+6      	; 0x130e <right_dec+0x20>
				alarm_minute = 59;	
    1308:	8b e3       	ldi	r24, 0x3B	; 59
    130a:	80 93 5d 01 	sts	0x015D, r24
    130e:	08 95       	ret
    1310:	08 95       	ret
void right_dec(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute--;
    1312:	80 91 5f 01 	lds	r24, 0x015F
    1316:	81 50       	subi	r24, 0x01	; 1
    1318:	80 93 5f 01 	sts	0x015F, r24
			if(minute >= 240){
    131c:	80 3f       	cpi	r24, 0xF0	; 240
    131e:	b8 f3       	brcs	.-18     	; 0x130e <right_dec+0x20>
				minute = 59;	    
    1320:	8b e3       	ldi	r24, 0x3B	; 59
    1322:	80 93 5f 01 	sts	0x015F, r24
    1326:	08 95       	ret

00001328 <decode_spi_right_knob>:
	previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
    1328:	cf 93       	push	r28
    132a:	df 93       	push	r29
    132c:	1f 92       	push	r1
    132e:	cd b7       	in	r28, 0x3d	; 61
    1330:	de b7       	in	r29, 0x3e	; 62
	uint8_t sw_index = 0;
	static uint8_t acount2 = 0;
	static uint8_t previous_encoder2 = 0;
	uint8_t direction = 0;
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    1332:	83 70       	andi	r24, 0x03	; 3
	sw_index = (previous_encoder2 << 2) | encoder2;
    1334:	e0 91 51 01 	lds	r30, 0x0151
    1338:	ee 0f       	add	r30, r30
    133a:	ee 0f       	add	r30, r30
    133c:	e8 2b       	or	r30, r24
	direction = sw_table[sw_index];
    133e:	f0 e0       	ldi	r31, 0x00	; 0
    1340:	ed 5f       	subi	r30, 0xFD	; 253
    1342:	fe 4f       	sbci	r31, 0xFE	; 254
    1344:	90 81       	ld	r25, Z
	//value = modeA;
	if(direction == CW){
    1346:	91 30       	cpi	r25, 0x01	; 1
    1348:	09 f1       	breq	.+66     	; 0x138c <decode_spi_right_knob+0x64>
		acount2++;
	}	
	if(direction == CCW){
    134a:	92 30       	cpi	r25, 0x02	; 2
    134c:	41 f0       	breq	.+16     	; 0x135e <decode_spi_right_knob+0x36>
		acount2--;
	}
	if(encoder2 == 3){
    134e:	83 30       	cpi	r24, 0x03	; 3
    1350:	69 f0       	breq	.+26     	; 0x136c <decode_spi_right_knob+0x44>
			right_dec();
		}
		//update_number();
		acount2 = 0;
	}
	previous_encoder2 = encoder2;
    1352:	80 93 51 01 	sts	0x0151, r24
}
    1356:	0f 90       	pop	r0
    1358:	df 91       	pop	r29
    135a:	cf 91       	pop	r28
    135c:	08 95       	ret
	//value = modeA;
	if(direction == CW){
		acount2++;
	}	
	if(direction == CCW){
		acount2--;
    135e:	90 91 50 01 	lds	r25, 0x0150
    1362:	91 50       	subi	r25, 0x01	; 1
    1364:	90 93 50 01 	sts	0x0150, r25
	}
	if(encoder2 == 3){
    1368:	83 30       	cpi	r24, 0x03	; 3
    136a:	99 f7       	brne	.-26     	; 0x1352 <decode_spi_right_knob+0x2a>
		if((acount2 > 1) && (acount2 < 10)){
    136c:	90 91 50 01 	lds	r25, 0x0150
    1370:	2e ef       	ldi	r18, 0xFE	; 254
    1372:	29 0f       	add	r18, r25
    1374:	28 30       	cpi	r18, 0x08	; 8
    1376:	b8 f0       	brcs	.+46     	; 0x13a6 <decode_spi_right_knob+0x7e>
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
    1378:	91 3f       	cpi	r25, 0xF1	; 241
    137a:	70 f4       	brcc	.+28     	; 0x1398 <decode_spi_right_knob+0x70>
			right_dec();
		}
		//update_number();
		acount2 = 0;
    137c:	10 92 50 01 	sts	0x0150, r1
	}
	previous_encoder2 = encoder2;
    1380:	80 93 51 01 	sts	0x0151, r24
}
    1384:	0f 90       	pop	r0
    1386:	df 91       	pop	r29
    1388:	cf 91       	pop	r28
    138a:	08 95       	ret
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
	sw_index = (previous_encoder2 << 2) | encoder2;
	direction = sw_table[sw_index];
	//value = modeA;
	if(direction == CW){
		acount2++;
    138c:	90 91 50 01 	lds	r25, 0x0150
    1390:	9f 5f       	subi	r25, 0xFF	; 255
    1392:	90 93 50 01 	sts	0x0150, r25
    1396:	db cf       	rjmp	.-74     	; 0x134e <decode_spi_right_knob+0x26>
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
    1398:	89 83       	std	Y+1, r24	; 0x01
    139a:	0e 94 77 09 	call	0x12ee	; 0x12ee <right_dec>
    139e:	89 81       	ldd	r24, Y+1	; 0x01
		}
		//update_number();
		acount2 = 0;
    13a0:	10 92 50 01 	sts	0x0150, r1
    13a4:	ed cf       	rjmp	.-38     	; 0x1380 <decode_spi_right_knob+0x58>
	if(direction == CCW){
		acount2--;
	}
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
    13a6:	89 83       	std	Y+1, r24	; 0x01
    13a8:	0e 94 50 09 	call	0x12a0	; 0x12a0 <right_inc>
    13ac:	89 81       	ldd	r24, Y+1	; 0x01
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
		}
		//update_number();
		acount2 = 0;
    13ae:	10 92 50 01 	sts	0x0150, r1
    13b2:	e6 cf       	rjmp	.-52     	; 0x1380 <decode_spi_right_knob+0x58>

000013b4 <left_inc>:
			break;
	}

}
void left_inc(){
	switch(mode){
    13b4:	80 91 61 01 	lds	r24, 0x0161
    13b8:	82 30       	cpi	r24, 0x02	; 2
    13ba:	21 f1       	breq	.+72     	; 0x1404 <left_inc+0x50>
    13bc:	b8 f0       	brcs	.+46     	; 0x13ec <left_inc+0x38>
    13be:	83 30       	cpi	r24, 0x03	; 3
    13c0:	51 f0       	breq	.+20     	; 0x13d6 <left_inc+0x22>
    13c2:	84 30       	cpi	r24, 0x04	; 4
    13c4:	71 f5       	brne	.+92     	; 0x1422 <left_inc+0x6e>
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	90 91 36 01 	lds	r25, 0x0136
    13cc:	91 11       	cpse	r25, r1
    13ce:	24 c0       	rjmp	.+72     	; 0x1418 <left_inc+0x64>
    13d0:	80 93 36 01 	sts	0x0136, r24
    13d4:	08 95       	ret
			if(alarm_hour >= 24){
				alarm_hour = 0;
			}
			break;
		case 3:
			volume++;
    13d6:	80 91 00 01 	lds	r24, 0x0100
    13da:	8f 5f       	subi	r24, 0xFF	; 255
    13dc:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	90 93 87 00 	sts	0x0087, r25
    13e6:	80 93 86 00 	sts	0x0086, r24
			break;
    13ea:	08 95       	ret
			break;
	}

}
void left_inc(){
	switch(mode){
    13ec:	81 30       	cpi	r24, 0x01	; 1
    13ee:	c1 f4       	brne	.+48     	; 0x1420 <left_inc+0x6c>
		case 0: 
			break;
		case 1:
			hour++;
    13f0:	80 91 5e 01 	lds	r24, 0x015E
    13f4:	8f 5f       	subi	r24, 0xFF	; 255
    13f6:	80 93 5e 01 	sts	0x015E, r24
			if(hour >= 24){
    13fa:	88 31       	cpi	r24, 0x18	; 24
    13fc:	58 f3       	brcs	.-42     	; 0x13d4 <left_inc+0x20>
				hour = 0;	    
    13fe:	10 92 5e 01 	sts	0x015E, r1
    1402:	08 95       	ret
			}   
			break;
		case 2: 
			alarm_hour++;
    1404:	80 91 5c 01 	lds	r24, 0x015C
    1408:	8f 5f       	subi	r24, 0xFF	; 255
    140a:	80 93 5c 01 	sts	0x015C, r24
			if(alarm_hour >= 24){
    140e:	88 31       	cpi	r24, 0x18	; 24
    1410:	08 f3       	brcs	.-62     	; 0x13d4 <left_inc+0x20>
				alarm_hour = 0;
    1412:	10 92 5c 01 	sts	0x015C, r1
    1416:	08 95       	ret
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    1418:	80 e0       	ldi	r24, 0x00	; 0
    141a:	80 93 36 01 	sts	0x0136, r24
    141e:	da cf       	rjmp	.-76     	; 0x13d4 <left_inc+0x20>
    1420:	08 95       	ret
    1422:	08 95       	ret

00001424 <left_dec>:
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    1424:	80 91 61 01 	lds	r24, 0x0161
    1428:	82 30       	cpi	r24, 0x02	; 2
    142a:	29 f1       	breq	.+74     	; 0x1476 <left_dec+0x52>
    142c:	b8 f0       	brcs	.+46     	; 0x145c <left_dec+0x38>
    142e:	83 30       	cpi	r24, 0x03	; 3
    1430:	51 f0       	breq	.+20     	; 0x1446 <left_dec+0x22>
    1432:	84 30       	cpi	r24, 0x04	; 4
    1434:	81 f5       	brne	.+96     	; 0x1496 <left_dec+0x72>
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    1436:	81 e0       	ldi	r24, 0x01	; 1
    1438:	90 91 36 01 	lds	r25, 0x0136
    143c:	91 11       	cpse	r25, r1
    143e:	26 c0       	rjmp	.+76     	; 0x148c <left_dec+0x68>
    1440:	80 93 36 01 	sts	0x0136, r24
    1444:	08 95       	ret
			if(alarm_hour >= 240){
				alarm_hour = 23;
			}
			break;
		case 3:
			volume--;
    1446:	80 91 00 01 	lds	r24, 0x0100
    144a:	81 50       	subi	r24, 0x01	; 1
    144c:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    1450:	90 e0       	ldi	r25, 0x00	; 0
    1452:	90 93 87 00 	sts	0x0087, r25
    1456:	80 93 86 00 	sts	0x0086, r24
			break;
    145a:	08 95       	ret
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    145c:	81 30       	cpi	r24, 0x01	; 1
    145e:	d1 f4       	brne	.+52     	; 0x1494 <left_dec+0x70>
		case 0: 
			break;
		case 1:
			hour--;    
    1460:	80 91 5e 01 	lds	r24, 0x015E
    1464:	81 50       	subi	r24, 0x01	; 1
    1466:	80 93 5e 01 	sts	0x015E, r24
			if(hour >= 240){
    146a:	80 3f       	cpi	r24, 0xF0	; 240
    146c:	58 f3       	brcs	.-42     	; 0x1444 <left_dec+0x20>
				hour = 23;	    
    146e:	87 e1       	ldi	r24, 0x17	; 23
    1470:	80 93 5e 01 	sts	0x015E, r24
    1474:	08 95       	ret
			}   
			break;
		case 2:
			alarm_hour--;
    1476:	80 91 5c 01 	lds	r24, 0x015C
    147a:	81 50       	subi	r24, 0x01	; 1
    147c:	80 93 5c 01 	sts	0x015C, r24
			if(alarm_hour >= 240){
    1480:	80 3f       	cpi	r24, 0xF0	; 240
    1482:	00 f3       	brcs	.-64     	; 0x1444 <left_dec+0x20>
				alarm_hour = 23;
    1484:	87 e1       	ldi	r24, 0x17	; 23
    1486:	80 93 5c 01 	sts	0x015C, r24
    148a:	08 95       	ret
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    148c:	80 e0       	ldi	r24, 0x00	; 0
    148e:	80 93 36 01 	sts	0x0136, r24
    1492:	d8 cf       	rjmp	.-80     	; 0x1444 <left_dec+0x20>
    1494:	08 95       	ret
    1496:	08 95       	ret

00001498 <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
    1498:	cf 93       	push	r28
    149a:	df 93       	push	r29
	uint8_t sw_index = 0;
	//Counter for preventing unneccessary reset    
	static uint8_t acount1 = 0;
	static uint8_t previous_encoder1 = 0; //Initialize previous    
	uint8_t direction = 0;                    //Direction variable
	encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
    149c:	8c 70       	andi	r24, 0x0C	; 12
    149e:	c8 2f       	mov	r28, r24
    14a0:	d0 e0       	ldi	r29, 0x00	; 0
    14a2:	d5 95       	asr	r29
    14a4:	c7 95       	ror	r28
    14a6:	d5 95       	asr	r29
    14a8:	c7 95       	ror	r28
    14aa:	9c 2f       	mov	r25, r28
	sw_index = (previous_encoder1 << 2) | encoder1; 
    14ac:	e0 91 53 01 	lds	r30, 0x0153
    14b0:	ee 0f       	add	r30, r30
    14b2:	ee 0f       	add	r30, r30
    14b4:	ec 2b       	or	r30, r28
	/*shift previous to the left use it as an index Since
	  we know the pattern of the knob when it is turning
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
    14b6:	f0 e0       	ldi	r31, 0x00	; 0
    14b8:	ed 5f       	subi	r30, 0xFD	; 253
    14ba:	fe 4f       	sbci	r31, 0xFE	; 254
    14bc:	80 81       	ld	r24, Z
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
    14be:	81 30       	cpi	r24, 0x01	; 1
    14c0:	f9 f0       	breq	.+62     	; 0x1500 <decode_spi_left_knob+0x68>
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
    14c2:	82 30       	cpi	r24, 0x02	; 2
    14c4:	39 f0       	breq	.+14     	; 0x14d4 <decode_spi_left_knob+0x3c>
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    14c6:	93 30       	cpi	r25, 0x03	; 3
    14c8:	61 f0       	breq	.+24     	; 0x14e2 <decode_spi_left_knob+0x4a>
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
	}
	previous_encoder1 = encoder1;
    14ca:	c0 93 53 01 	sts	0x0153, r28
}
    14ce:	df 91       	pop	r29
    14d0:	cf 91       	pop	r28
    14d2:	08 95       	ret
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
    14d4:	80 91 52 01 	lds	r24, 0x0152
    14d8:	81 50       	subi	r24, 0x01	; 1
    14da:	80 93 52 01 	sts	0x0152, r24
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    14de:	93 30       	cpi	r25, 0x03	; 3
    14e0:	a1 f7       	brne	.-24     	; 0x14ca <decode_spi_left_knob+0x32>
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
    14e2:	80 91 52 01 	lds	r24, 0x0152
    14e6:	9e ef       	ldi	r25, 0xFE	; 254
    14e8:	98 0f       	add	r25, r24
    14ea:	98 30       	cpi	r25, 0x08	; 8
    14ec:	a0 f0       	brcs	.+40     	; 0x1516 <decode_spi_left_knob+0x7e>
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
    14ee:	81 3f       	cpi	r24, 0xF1	; 241
    14f0:	68 f4       	brcc	.+26     	; 0x150c <decode_spi_left_knob+0x74>
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    14f2:	10 92 52 01 	sts	0x0152, r1
	}
	previous_encoder1 = encoder1;
    14f6:	c0 93 53 01 	sts	0x0153, r28
}
    14fa:	df 91       	pop	r29
    14fc:	cf 91       	pop	r28
    14fe:	08 95       	ret
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
    1500:	80 91 52 01 	lds	r24, 0x0152
    1504:	8f 5f       	subi	r24, 0xFF	; 255
    1506:	80 93 52 01 	sts	0x0152, r24
    150a:	dd cf       	rjmp	.-70     	; 0x14c6 <decode_spi_left_knob+0x2e>
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
    150c:	0e 94 12 0a 	call	0x1424	; 0x1424 <left_dec>
		}
		acount1 = 0;                     //Reset counter
    1510:	10 92 52 01 	sts	0x0152, r1
    1514:	f0 cf       	rjmp	.-32     	; 0x14f6 <decode_spi_left_knob+0x5e>
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
    1516:	0e 94 da 09 	call	0x13b4	; 0x13b4 <left_inc>
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    151a:	10 92 52 01 	sts	0x0152, r1
    151e:	eb cf       	rjmp	.-42     	; 0x14f6 <decode_spi_left_knob+0x5e>

00001520 <check_knobs>:
	__asm__ __volatile__ ("nop");
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
	// Return incoming data from SPDR
	return(SPDR);  
}
void check_knobs(void){
    1520:	cf 93       	push	r28
	static uint8_t cnt = 0;
	static uint8_t encoder;
	cnt++;
    1522:	c0 91 56 01 	lds	r28, 0x0156
    1526:	cf 5f       	subi	r28, 0xFF	; 255
    1528:	c0 93 56 01 	sts	0x0156, r28
	encoder = SPI_Receive();
    152c:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <SPI_Receive>
    1530:	80 93 55 01 	sts	0x0155, r24
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
    1534:	c0 ff       	sbrs	r28, 0
    1536:	03 c0       	rjmp	.+6      	; 0x153e <check_knobs+0x1e>
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
	}
}
    1538:	cf 91       	pop	r28
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
    153a:	0c 94 94 09 	jmp	0x1328	; 0x1328 <decode_spi_right_knob>
	}
}
    153e:	cf 91       	pop	r28
	static uint8_t encoder;
	cnt++;
	encoder = SPI_Receive();
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
    1540:	0c 94 4c 0a 	jmp	0x1498	; 0x1498 <decode_spi_left_knob>

00001544 <get_remote_temp>:

//TOD
// Pull temp functions from temp directory
// Display temp

uint16_t get_remote_temp(uint8_t f_or_c){
    1544:	cf 93       	push	r28
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(f_or_c == 1){
    1546:	81 30       	cpi	r24, 0x01	; 1
    1548:	79 f0       	breq	.+30     	; 0x1568 <get_remote_temp+0x24>
		uart_putc(CELCIUS); //Ask atmega48 for celcius
	}
	else{
		uart_putc(FARENHEIT); //Ask for F
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	0e 94 81 0c 	call	0x1902	; 0x1902 <uart_putc>
	}

	lo = uart_getc(); //Get low byte
    1550:	0e 94 b5 0c 	call	0x196a	; 0x196a <uart_getc>
    1554:	c8 2f       	mov	r28, r24
	hi = uart_getc(); //Get high byte
    1556:	0e 94 b5 0c 	call	0x196a	; 0x196a <uart_getc>

	tmp = (hi<<8) | lo; //Concatinate
    155a:	2c 2f       	mov	r18, r28
    155c:	30 e0       	ldi	r19, 0x00	; 0
	return tmp;	   //return tempearture
}
    155e:	a9 01       	movw	r20, r18
    1560:	58 2b       	or	r21, r24
    1562:	ca 01       	movw	r24, r20
    1564:	cf 91       	pop	r28
    1566:	08 95       	ret
uint16_t get_remote_temp(uint8_t f_or_c){
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(f_or_c == 1){
		uart_putc(CELCIUS); //Ask atmega48 for celcius
    1568:	82 e0       	ldi	r24, 0x02	; 2
    156a:	0e 94 81 0c 	call	0x1902	; 0x1902 <uart_putc>
    156e:	f0 cf       	rjmp	.-32     	; 0x1550 <get_remote_temp+0xc>

00001570 <generate_temp_str>:

	tmp = (hi<<8) | lo; //Concatinate
	return tmp;	   //return tempearture
}

void generate_temp_str(){
    1570:	ef 92       	push	r14
    1572:	ff 92       	push	r15
    1574:	0f 93       	push	r16
    1576:	1f 93       	push	r17
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	00 d0       	rcall	.+0      	; 0x157e <generate_temp_str+0xe>
    157e:	00 d0       	rcall	.+0      	; 0x1580 <generate_temp_str+0x10>
    1580:	00 d0       	rcall	.+0      	; 0x1582 <generate_temp_str+0x12>
    1582:	cd b7       	in	r28, 0x3d	; 61
    1584:	de b7       	in	r29, 0x3e	; 62
	uint16_t remote_temp, local_temp;
	char local_buf[3];
	char remote_buf[3];
	if(reset_temp == 0){
    1586:	80 91 4a 01 	lds	r24, 0x014A
    158a:	88 23       	and	r24, r24
    158c:	e9 f1       	breq	.+122    	; 0x1608 <generate_temp_str+0x98>
		return;
	}
	//TODO

	if(temp_mode){
    158e:	80 91 36 01 	lds	r24, 0x0136
    1592:	81 11       	cpse	r24, r1
    1594:	46 c0       	rjmp	.+140    	; 0x1622 <generate_temp_str+0xb2>
		loc_temp_str[15] = 'C';
		rem_temp_str[15] = 'C';

	}
	else {
		local_temp = get_local_temp(2);
    1596:	82 e0       	ldi	r24, 0x02	; 2
    1598:	0e 94 df 0c 	call	0x19be	; 0x19be <get_local_temp>
    159c:	7c 01       	movw	r14, r24
		remote_temp = get_remote_temp(2);
    159e:	82 e0       	ldi	r24, 0x02	; 2
    15a0:	0e 94 a2 0a 	call	0x1544	; 0x1544 <get_remote_temp>
    15a4:	8c 01       	movw	r16, r24
		loc_temp_str[15] = 'F';
    15a6:	e0 91 64 01 	lds	r30, 0x0164
    15aa:	f0 91 65 01 	lds	r31, 0x0165
    15ae:	86 e4       	ldi	r24, 0x46	; 70
    15b0:	87 87       	std	Z+15, r24	; 0x0f
		rem_temp_str[15] = 'F';
    15b2:	e0 91 62 01 	lds	r30, 0x0162
    15b6:	f0 91 63 01 	lds	r31, 0x0163
    15ba:	87 87       	std	Z+15, r24	; 0x0f
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    15bc:	4a e0       	ldi	r20, 0x0A	; 10
    15be:	be 01       	movw	r22, r28
    15c0:	6c 5f       	subi	r22, 0xFC	; 252
    15c2:	7f 4f       	sbci	r23, 0xFF	; 255
    15c4:	c7 01       	movw	r24, r14
    15c6:	0e 94 ef 0e 	call	0x1dde	; 0x1dde <__itoa_ncheck>
    15ca:	4a e0       	ldi	r20, 0x0A	; 10
    15cc:	be 01       	movw	r22, r28
    15ce:	6f 5f       	subi	r22, 0xFF	; 255
    15d0:	7f 4f       	sbci	r23, 0xFF	; 255
    15d2:	c8 01       	movw	r24, r16
    15d4:	0e 94 ef 0e 	call	0x1dde	; 0x1dde <__itoa_ncheck>
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);

	if(local_buf[2] == '1'){
    15d8:	8e 81       	ldd	r24, Y+6	; 0x06
		loc_temp_str[12] = local_buf[0];
    15da:	e0 91 64 01 	lds	r30, 0x0164
    15de:	f0 91 65 01 	lds	r31, 0x0165
		rem_temp_str[15] = 'F';
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);

	if(local_buf[2] == '1'){
    15e2:	81 33       	cpi	r24, 0x31	; 49
    15e4:	91 f1       	breq	.+100    	; 0x164a <generate_temp_str+0xda>
		loc_temp_str[12] = local_buf[0];
		loc_temp_str[13] = local_buf[1];
		loc_temp_str[14] = local_buf[2];
	}
	else{
		loc_temp_str[13] = local_buf[0];
    15e6:	8c 81       	ldd	r24, Y+4	; 0x04
    15e8:	85 87       	std	Z+13, r24	; 0x0d
		loc_temp_str[14] = local_buf[1];
    15ea:	8d 81       	ldd	r24, Y+5	; 0x05
    15ec:	86 87       	std	Z+14, r24	; 0x0e
	}
	if(remote_buf[2] == '1'){
    15ee:	8b 81       	ldd	r24, Y+3	; 0x03
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    15f0:	e0 91 62 01 	lds	r30, 0x0162
    15f4:	f0 91 63 01 	lds	r31, 0x0163
	}
	else{
		loc_temp_str[13] = local_buf[0];
		loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    15f8:	81 33       	cpi	r24, 0x31	; 49
    15fa:	99 f1       	breq	.+102    	; 0x1662 <generate_temp_str+0xf2>
		rem_temp_str[12] = remote_buf[0];
		rem_temp_str[13] = remote_buf[1];
		rem_temp_str[14] = remote_buf[2];
	}
	else{
		rem_temp_str[13] = remote_buf[0];
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
    15fe:	85 87       	std	Z+13, r24	; 0x0d
		rem_temp_str[14] = remote_buf[1];
    1600:	8a 81       	ldd	r24, Y+2	; 0x02
    1602:	86 87       	std	Z+14, r24	; 0x0e
	}
	//l_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	reset_temp = 0;
    1604:	10 92 4a 01 	sts	0x014A, r1
}
    1608:	26 96       	adiw	r28, 0x06	; 6
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	de bf       	out	0x3e, r29	; 62
    1610:	0f be       	out	0x3f, r0	; 63
    1612:	cd bf       	out	0x3d, r28	; 61
    1614:	df 91       	pop	r29
    1616:	cf 91       	pop	r28
    1618:	1f 91       	pop	r17
    161a:	0f 91       	pop	r16
    161c:	ff 90       	pop	r15
    161e:	ef 90       	pop	r14
    1620:	08 95       	ret
		return;
	}
	//TODO

	if(temp_mode){
		remote_temp = get_remote_temp(1);
    1622:	81 e0       	ldi	r24, 0x01	; 1
    1624:	0e 94 a2 0a 	call	0x1544	; 0x1544 <get_remote_temp>
    1628:	8c 01       	movw	r16, r24
		local_temp = get_local_temp(1);
    162a:	81 e0       	ldi	r24, 0x01	; 1
    162c:	0e 94 df 0c 	call	0x19be	; 0x19be <get_local_temp>
    1630:	7c 01       	movw	r14, r24
		loc_temp_str[15] = 'C';
    1632:	e0 91 64 01 	lds	r30, 0x0164
    1636:	f0 91 65 01 	lds	r31, 0x0165
    163a:	83 e4       	ldi	r24, 0x43	; 67
    163c:	87 87       	std	Z+15, r24	; 0x0f
		rem_temp_str[15] = 'C';
    163e:	e0 91 62 01 	lds	r30, 0x0162
    1642:	f0 91 63 01 	lds	r31, 0x0163
    1646:	87 87       	std	Z+15, r24	; 0x0f
    1648:	b9 cf       	rjmp	.-142    	; 0x15bc <generate_temp_str+0x4c>
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);

	if(local_buf[2] == '1'){
		loc_temp_str[12] = local_buf[0];
    164a:	9c 81       	ldd	r25, Y+4	; 0x04
    164c:	94 87       	std	Z+12, r25	; 0x0c
		loc_temp_str[13] = local_buf[1];
    164e:	9d 81       	ldd	r25, Y+5	; 0x05
    1650:	95 87       	std	Z+13, r25	; 0x0d
		loc_temp_str[14] = local_buf[2];
    1652:	86 87       	std	Z+14, r24	; 0x0e
	}
	else{
		loc_temp_str[13] = local_buf[0];
		loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    1654:	8b 81       	ldd	r24, Y+3	; 0x03
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    1656:	e0 91 62 01 	lds	r30, 0x0162
    165a:	f0 91 63 01 	lds	r31, 0x0163
	}
	else{
		loc_temp_str[13] = local_buf[0];
		loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    165e:	81 33       	cpi	r24, 0x31	; 49
    1660:	69 f6       	brne	.-102    	; 0x15fc <generate_temp_str+0x8c>
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    1662:	99 81       	ldd	r25, Y+1	; 0x01
    1664:	94 87       	std	Z+12, r25	; 0x0c
		rem_temp_str[13] = remote_buf[1];
    1666:	9a 81       	ldd	r25, Y+2	; 0x02
    1668:	95 87       	std	Z+13, r25	; 0x0d
		rem_temp_str[14] = remote_buf[2];
    166a:	86 87       	std	Z+14, r24	; 0x0e
    166c:	cb cf       	rjmp	.-106    	; 0x1604 <generate_temp_str+0x94>

0000166e <show_temperature>:
	static uint8_t counter = 0;
	//loc_temp_str = "Local  temp:   C";
	//rem_temp_str = "Remote temp:   C";
	//loc_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	generate_temp_str();
    166e:	0e 94 b8 0a 	call	0x1570	; 0x1570 <generate_temp_str>
	//If temp string is not already displayed, diisplay it
	if(counter <= 15){
    1672:	80 91 4f 01 	lds	r24, 0x014F
    1676:	80 31       	cpi	r24, 0x10	; 16
    1678:	50 f0       	brcs	.+20     	; 0x168e <show_temperature+0x20>
			//_delay_ms(1);
		}
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
    167a:	90 ef       	ldi	r25, 0xF0	; 240
    167c:	98 0f       	add	r25, r24
    167e:	90 31       	cpi	r25, 0x10	; 16
    1680:	f8 f0       	brcs	.+62     	; 0x16c0 <show_temperature+0x52>
		//if(counter == 31){
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
    1682:	8b 34       	cpi	r24, 0x4B	; 75
    1684:	b0 f4       	brcc	.+44     	; 0x16b2 <show_temperature+0x44>
		temp_is_up = 1;
		counter = 0;
		cursor_home();
	}
	else{
		counter++;
    1686:	8f 5f       	subi	r24, 0xFF	; 255
    1688:	80 93 4f 01 	sts	0x014F, r24
    168c:	08 95       	ret
	//loc_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	generate_temp_str();
	//If temp string is not already displayed, diisplay it
	if(counter <= 15){
		char2lcd(loc_temp_str[counter]);
    168e:	e0 91 64 01 	lds	r30, 0x0164
    1692:	f0 91 65 01 	lds	r31, 0x0165
    1696:	e8 0f       	add	r30, r24
    1698:	f1 1d       	adc	r31, r1
    169a:	80 81       	ld	r24, Z
    169c:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <char2lcd>
		if(counter == 15){
    16a0:	80 91 4f 01 	lds	r24, 0x014F
    16a4:	8f 30       	cpi	r24, 0x0F	; 15
    16a6:	79 f7       	brne	.-34     	; 0x1686 <show_temperature+0x18>
			home_line2();
    16a8:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <home_line2>
    16ac:	80 91 4f 01 	lds	r24, 0x014F
    16b0:	ea cf       	rjmp	.-44     	; 0x1686 <show_temperature+0x18>
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
		temp_is_up = 1;
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	80 93 48 01 	sts	0x0148, r24
		counter = 0;
    16b8:	10 92 4f 01 	sts	0x014F, r1
		cursor_home();
    16bc:	0c 94 31 0d 	jmp	0x1a62	; 0x1a62 <cursor_home>
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
		//minute++;
		char2lcd(rem_temp_str[counter-16]);
    16c0:	e0 91 62 01 	lds	r30, 0x0162
    16c4:	f0 91 63 01 	lds	r31, 0x0163
    16c8:	e8 0f       	add	r30, r24
    16ca:	f1 1d       	adc	r31, r1
    16cc:	70 97       	sbiw	r30, 0x10	; 16
    16ce:	80 81       	ld	r24, Z
    16d0:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <char2lcd>
		counter++;
    16d4:	80 91 4f 01 	lds	r24, 0x014F
    16d8:	8f 5f       	subi	r24, 0xFF	; 255
    16da:	80 93 4f 01 	sts	0x014F, r24
    16de:	08 95       	ret

000016e0 <LCD_Display>:


void LCD_Display(){
	static uint8_t counter = 0;

	if(counter <= 15){
    16e0:	80 91 4e 01 	lds	r24, 0x014E
    16e4:	80 31       	cpi	r24, 0x10	; 16
    16e6:	30 f4       	brcc	.+12     	; 0x16f4 <LCD_Display+0x14>
		//	char2lcd(rem_temp_str[counter]);
		if(counter == 15){
    16e8:	8f 30       	cpi	r24, 0x0F	; 15
    16ea:	79 f0       	breq	.+30     	; 0x170a <LCD_Display+0x2a>
	}
	else if(counter >=100){
		counter = 0;
	}
	else{
		counter++;
    16ec:	8f 5f       	subi	r24, 0xFF	; 255
    16ee:	80 93 4e 01 	sts	0x014E, r24
    16f2:	08 95       	ret
			//_delay_ms(1);
		}
		counter++;
		//	return;
	}
	else if (counter >=16 && counter <= 31){
    16f4:	90 ef       	ldi	r25, 0xF0	; 240
    16f6:	98 0f       	add	r25, r24
    16f8:	90 31       	cpi	r25, 0x10	; 16
    16fa:	c0 f3       	brcs	.-16     	; 0x16ec <LCD_Display+0xc>
		//	//minute++;
		//	char2lcd(loc_temp_str[counter-16]);
		counter++;
		//return;
	}
	else if(counter >= 75){ 
    16fc:	8b 34       	cpi	r24, 0x4B	; 75
    16fe:	b0 f3       	brcs	.-20     	; 0x16ec <LCD_Display+0xc>
		//counter = 0;
		//loc_temp_str = "";
		//rem_temp_str = "";
		//loc_temp_str = "Local  temp:   C";
		//rem_temp_str = "Remote temp:   C";
		counter++;
    1700:	8f 5f       	subi	r24, 0xFF	; 255
    1702:	80 93 4e 01 	sts	0x014E, r24
		cursor_home();
    1706:	0c 94 31 0d 	jmp	0x1a62	; 0x1a62 <cursor_home>
	static uint8_t counter = 0;

	if(counter <= 15){
		//	char2lcd(rem_temp_str[counter]);
		if(counter == 15){
			home_line2();
    170a:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <home_line2>
    170e:	80 91 4e 01 	lds	r24, 0x014E
    1712:	ec cf       	rjmp	.-40     	; 0x16ec <LCD_Display+0xc>

00001714 <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1714:	83 b7       	in	r24, 0x33	; 51
    1716:	81 60       	ori	r24, 0x01	; 1
    1718:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    171a:	80 b7       	in	r24, 0x30	; 48
    171c:	88 60       	ori	r24, 0x08	; 8
    171e:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1720:	85 b5       	in	r24, 0x25	; 37
    1722:	8a 67       	ori	r24, 0x7A	; 122
    1724:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1726:	87 b7       	in	r24, 0x37	; 55
    1728:	81 64       	ori	r24, 0x41	; 65
    172a:	87 bf       	out	0x37, r24	; 55
    172c:	08 95       	ret

0000172e <ADC_init>:
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    172e:	e1 e6       	ldi	r30, 0x61	; 97
    1730:	f0 e0       	ldi	r31, 0x00	; 0
    1732:	80 81       	ld	r24, Z
    1734:	80 83       	st	Z, r24
	PORTF = 0x00;
    1736:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    173a:	87 b1       	in	r24, 0x07	; 7
    173c:	80 66       	ori	r24, 0x60	; 96
    173e:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1740:	86 b1       	in	r24, 0x06	; 6
    1742:	8f 6e       	ori	r24, 0xEF	; 239
    1744:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    1746:	8f ef       	ldi	r24, 0xFF	; 255
    1748:	83 bd       	out	0x23, r24	; 35
    174a:	08 95       	ret

0000174c <volume_control_init>:
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    174c:	81 e8       	ldi	r24, 0x81	; 129
    174e:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    1752:	89 e0       	ldi	r24, 0x09	; 9
    1754:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    1758:	80 91 00 01 	lds	r24, 0x0100
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	90 93 87 00 	sts	0x0087, r25
    1762:	80 93 86 00 	sts	0x0086, r24
    1766:	08 95       	ret

00001768 <initialize_string>:
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    1768:	83 e1       	ldi	r24, 0x13	; 19
    176a:	91 e0       	ldi	r25, 0x01	; 1
    176c:	90 93 65 01 	sts	0x0165, r25
    1770:	80 93 64 01 	sts	0x0164, r24
	rem_temp_str = "Remote temp:   C";
    1774:	84 e2       	ldi	r24, 0x24	; 36
    1776:	91 e0       	ldi	r25, 0x01	; 1
    1778:	90 93 63 01 	sts	0x0163, r25
    177c:	80 93 62 01 	sts	0x0162, r24
    1780:	08 95       	ret

00001782 <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    1782:	1f 92       	push	r1
    1784:	0f 92       	push	r0
    1786:	0f b6       	in	r0, 0x3f	; 63
    1788:	0f 92       	push	r0
    178a:	11 24       	eor	r1, r1
    178c:	0b b6       	in	r0, 0x3b	; 59
    178e:	0f 92       	push	r0
    1790:	2f 93       	push	r18
    1792:	3f 93       	push	r19
    1794:	8f 93       	push	r24
    1796:	9f 93       	push	r25
    1798:	af 93       	push	r26
    179a:	bf 93       	push	r27
    179c:	ef 93       	push	r30
    179e:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    17a0:	80 91 71 00 	lds	r24, 0x0071
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	fc 01       	movw	r30, r24
    17a8:	38 97       	sbiw	r30, 0x08	; 8
    17aa:	e1 35       	cpi	r30, 0x51	; 81
    17ac:	f1 05       	cpc	r31, r1
    17ae:	b0 f0       	brcs	.+44     	; 0x17dc <__vector_33+0x5a>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    17b0:	80 91 71 00 	lds	r24, 0x0071
    17b4:	80 93 84 01 	sts	0x0184, r24
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    17b8:	84 e0       	ldi	r24, 0x04	; 4
    17ba:	80 93 74 00 	sts	0x0074, r24
  }//switch
}//TWI_isr
    17be:	ff 91       	pop	r31
    17c0:	ef 91       	pop	r30
    17c2:	bf 91       	pop	r27
    17c4:	af 91       	pop	r26
    17c6:	9f 91       	pop	r25
    17c8:	8f 91       	pop	r24
    17ca:	3f 91       	pop	r19
    17cc:	2f 91       	pop	r18
    17ce:	0f 90       	pop	r0
    17d0:	0b be       	out	0x3b, r0	; 59
    17d2:	0f 90       	pop	r0
    17d4:	0f be       	out	0x3f, r0	; 63
    17d6:	0f 90       	pop	r0
    17d8:	1f 90       	pop	r1
    17da:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    17dc:	e5 52       	subi	r30, 0x25	; 37
    17de:	ff 4f       	sbci	r31, 0xFF	; 255
    17e0:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    17e4:	80 91 66 01 	lds	r24, 0x0166
    17e8:	e0 91 85 01 	lds	r30, 0x0185
    17ec:	f0 91 86 01 	lds	r31, 0x0186
    17f0:	e8 0f       	add	r30, r24
    17f2:	f1 1d       	adc	r31, r1
    17f4:	80 91 73 00 	lds	r24, 0x0073
    17f8:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    17fa:	84 e9       	ldi	r24, 0x94	; 148
    17fc:	80 93 74 00 	sts	0x0074, r24
      break;      
    1800:	de cf       	rjmp	.-68     	; 0x17be <__vector_33+0x3c>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    1802:	80 91 87 01 	lds	r24, 0x0187
    1806:	80 93 73 00 	sts	0x0073, r24
      twi_buf_ptr = 0;      //initalize buffer pointer 
    180a:	10 92 66 01 	sts	0x0166, r1
      TWCR = TWCR_SEND;     //send SLA+RW
    180e:	85 e8       	ldi	r24, 0x85	; 133
    1810:	80 93 74 00 	sts	0x0074, r24
      break;
    1814:	d4 cf       	rjmp	.-88     	; 0x17be <__vector_33+0x3c>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    1816:	80 91 66 01 	lds	r24, 0x0166
    181a:	90 91 88 01 	lds	r25, 0x0188
    181e:	89 17       	cp	r24, r25
    1820:	60 f7       	brcc	.-40     	; 0x17fa <__vector_33+0x78>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    1822:	e0 91 85 01 	lds	r30, 0x0185
    1826:	f0 91 86 01 	lds	r31, 0x0186
    182a:	91 e0       	ldi	r25, 0x01	; 1
    182c:	98 0f       	add	r25, r24
    182e:	90 93 66 01 	sts	0x0166, r25
    1832:	e8 0f       	add	r30, r24
    1834:	f1 1d       	adc	r31, r1
    1836:	80 81       	ld	r24, Z
    1838:	80 93 73 00 	sts	0x0073, r24
        TWCR = TWCR_SEND;               //send next byte 
    183c:	85 e8       	ldi	r24, 0x85	; 133
    183e:	80 93 74 00 	sts	0x0074, r24
    1842:	bd cf       	rjmp	.-134    	; 0x17be <__vector_33+0x3c>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    1844:	85 ea       	ldi	r24, 0xA5	; 165
    1846:	80 93 74 00 	sts	0x0074, r24
      break;
    184a:	b9 cf       	rjmp	.-142    	; 0x17be <__vector_33+0x3c>
    184c:	20 91 66 01 	lds	r18, 0x0166
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1850:	80 91 88 01 	lds	r24, 0x0188
    1854:	30 e0       	ldi	r19, 0x00	; 0
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	01 97       	sbiw	r24, 0x01	; 1
    185a:	28 17       	cp	r18, r24
    185c:	39 07       	cpc	r19, r25
    185e:	dc f4       	brge	.+54     	; 0x1896 <__vector_33+0x114>
    1860:	85 ec       	ldi	r24, 0xC5	; 197
    1862:	80 93 74 00 	sts	0x0074, r24
    1866:	ab cf       	rjmp	.-170    	; 0x17be <__vector_33+0x3c>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    1868:	e0 91 85 01 	lds	r30, 0x0185
    186c:	f0 91 86 01 	lds	r31, 0x0186
    1870:	80 91 66 01 	lds	r24, 0x0166
    1874:	21 e0       	ldi	r18, 0x01	; 1
    1876:	28 0f       	add	r18, r24
    1878:	20 93 66 01 	sts	0x0166, r18
    187c:	e8 0f       	add	r30, r24
    187e:	f1 1d       	adc	r31, r1
    1880:	80 91 73 00 	lds	r24, 0x0073
    1884:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1886:	80 91 88 01 	lds	r24, 0x0188
    188a:	30 e0       	ldi	r19, 0x00	; 0
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	01 97       	sbiw	r24, 0x01	; 1
    1890:	28 17       	cp	r18, r24
    1892:	39 07       	cpc	r19, r25
    1894:	2c f3       	brlt	.-54     	; 0x1860 <__vector_33+0xde>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    1896:	85 e8       	ldi	r24, 0x85	; 133
    1898:	80 93 74 00 	sts	0x0074, r24
    189c:	90 cf       	rjmp	.-224    	; 0x17be <__vector_33+0x3c>

0000189e <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    189e:	80 91 74 00 	lds	r24, 0x0074
}
    18a2:	81 70       	andi	r24, 0x01	; 1
    18a4:	08 95       	ret

000018a6 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    18a6:	90 91 74 00 	lds	r25, 0x0074
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    18aa:	90 fd       	sbrc	r25, 0
    18ac:	fc cf       	rjmp	.-8      	; 0x18a6 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    18ae:	8e 7f       	andi	r24, 0xFE	; 254
    18b0:	80 93 87 01 	sts	0x0187, r24
  twi_buf = twi_data;                   //load pointer to write buffer
    18b4:	70 93 86 01 	sts	0x0186, r23
    18b8:	60 93 85 01 	sts	0x0185, r22
  twi_msg_size = byte_cnt;              //load size of xfer 
    18bc:	40 93 88 01 	sts	0x0188, r20
  TWCR = TWCR_START;                    //initiate START
    18c0:	85 ea       	ldi	r24, 0xA5	; 165
    18c2:	80 93 74 00 	sts	0x0074, r24
    18c6:	08 95       	ret

000018c8 <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    18c8:	90 91 74 00 	lds	r25, 0x0074
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    18cc:	90 fd       	sbrc	r25, 0
    18ce:	fc cf       	rjmp	.-8      	; 0x18c8 <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    18d0:	81 60       	ori	r24, 0x01	; 1
    18d2:	80 93 87 01 	sts	0x0187, r24
  twi_buf = twi_data;                  //load pointer to write buffer
    18d6:	70 93 86 01 	sts	0x0186, r23
    18da:	60 93 85 01 	sts	0x0185, r22
  twi_msg_size = byte_cnt;             //load size of xfer 
    18de:	40 93 88 01 	sts	0x0188, r20
  TWCR = TWCR_START;                   //initiate START
    18e2:	85 ea       	ldi	r24, 0xA5	; 165
    18e4:	80 93 74 00 	sts	0x0074, r24
    18e8:	08 95       	ret

000018ea <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    18ea:	8f ef       	ldi	r24, 0xFF	; 255
    18ec:	80 93 73 00 	sts	0x0073, r24
  TWSR = 0x00;     //prescaler value = 1
    18f0:	10 92 71 00 	sts	0x0071, r1
  TWBR = TWI_TWBR; //defined in twi_master.h 
    18f4:	8c e0       	ldi	r24, 0x0C	; 12
    18f6:	80 93 70 00 	sts	0x0070, r24
  PORTD |= (1 << PD0) | (1 << PD1); 
    18fa:	82 b3       	in	r24, 0x12	; 18
    18fc:	83 60       	ori	r24, 0x03	; 3
    18fe:	82 bb       	out	0x12, r24	; 18
    1900:	08 95       	ret

00001902 <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1902:	5d 9b       	sbis	0x0b, 5	; 11
    1904:	fe cf       	rjmp	.-4      	; 0x1902 <uart_putc>
    UDR0 = data;    // Send data byte
    1906:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1908:	5d 9b       	sbis	0x0b, 5	; 11
    190a:	fe cf       	rjmp	.-4      	; 0x1908 <uart_putc+0x6>
}
    190c:	08 95       	ret

0000190e <uart_puts>:
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    190e:	fc 01       	movw	r30, r24
    1910:	20 81       	ld	r18, Z
    1912:	22 23       	and	r18, r18
    1914:	49 f0       	breq	.+18     	; 0x1928 <uart_puts+0x1a>
    1916:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1918:	5d 9b       	sbis	0x0b, 5	; 11
    191a:	fe cf       	rjmp	.-4      	; 0x1918 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    191c:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    191e:	5d 9b       	sbis	0x0b, 5	; 11
    1920:	fe cf       	rjmp	.-4      	; 0x191e <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    1922:	21 91       	ld	r18, Z+
    1924:	21 11       	cpse	r18, r1
    1926:	f8 cf       	rjmp	.-16     	; 0x1918 <uart_puts+0xa>
    1928:	08 95       	ret

0000192a <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    192a:	9c 01       	movw	r18, r24
    192c:	fc 01       	movw	r30, r24
    192e:	44 91       	lpm	r20, Z
    1930:	44 23       	and	r20, r20
    1932:	69 f0       	breq	.+26     	; 0x194e <uart_puts_p+0x24>
	uart_putc(pgm_read_byte(str++));
    1934:	01 96       	adiw	r24, 0x01	; 1
    1936:	f9 01       	movw	r30, r18
    1938:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    193a:	5d 9b       	sbis	0x0b, 5	; 11
    193c:	fe cf       	rjmp	.-4      	; 0x193a <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    193e:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1940:	5d 9b       	sbis	0x0b, 5	; 11
    1942:	fe cf       	rjmp	.-4      	; 0x1940 <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1944:	9c 01       	movw	r18, r24
    1946:	fc 01       	movw	r30, r24
    1948:	44 91       	lpm	r20, Z
    194a:	41 11       	cpse	r20, r1
    194c:	f3 cf       	rjmp	.-26     	; 0x1934 <uart_puts_p+0xa>
	uart_putc(pgm_read_byte(str++));
    }
}
    194e:	08 95       	ret

00001950 <uart_init>:
//must be in place for the MAX232 chip to get data.

void uart_init(){
    //rx and tx enable, receive interrupt enabled, 8 bit characters
    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
    UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!
    1950:	8a b1       	in	r24, 0x0a	; 10
    1952:	88 61       	ori	r24, 0x18	; 24
    1954:	8a b9       	out	0x0a, r24	; 10

    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
    //async operation, no parity,  one stop bit, 8-bit characters
    UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    1956:	e5 e9       	ldi	r30, 0x95	; 149
    1958:	f0 e0       	ldi	r31, 0x00	; 0
    195a:	80 81       	ld	r24, Z
    195c:	86 60       	ori	r24, 0x06	; 6
    195e:	80 83       	st	Z, r24
    UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    1960:	10 92 90 00 	sts	0x0090, r1
    UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    1964:	87 e6       	ldi	r24, 0x67	; 103
    1966:	89 b9       	out	0x09, r24	; 9
    1968:	08 95       	ret

0000196a <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    196a:	80 e8       	ldi	r24, 0x80	; 128
    196c:	9e e3       	ldi	r25, 0x3E	; 62
    196e:	03 c0       	rjmp	.+6      	; 0x1976 <uart_getc+0xc>
    1970:	01 97       	sbiw	r24, 0x01	; 1
	timer++;
	if(timer >= 16000){ return(0);}
    1972:	00 97       	sbiw	r24, 0x00	; 0
    1974:	21 f0       	breq	.+8      	; 0x197e <uart_getc+0x14>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    1976:	5f 9b       	sbis	0x0b, 7	; 11
    1978:	fb cf       	rjmp	.-10     	; 0x1970 <uart_getc+0x6>
	//what should we return if nothing comes in?
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
    197a:	8c b1       	in	r24, 0x0c	; 12
    197c:	08 95       	ret
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
	timer++;
	if(timer >= 16000){ return(0);}
    197e:	80 e0       	ldi	r24, 0x00	; 0
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
}
    1980:	08 95       	ret

00001982 <lm73_temp_convert>:
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
    1982:	62 30       	cpi	r22, 0x02	; 2
    1984:	09 f0       	breq	.+2      	; 0x1988 <lm73_temp_convert+0x6>
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    1986:	08 95       	ret
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
	lm73_temp = (lm73_temp*9/5)+32;
    1988:	9c 01       	movw	r18, r24
    198a:	22 0f       	add	r18, r18
    198c:	33 1f       	adc	r19, r19
    198e:	22 0f       	add	r18, r18
    1990:	33 1f       	adc	r19, r19
    1992:	22 0f       	add	r18, r18
    1994:	33 1f       	adc	r19, r19
    1996:	28 0f       	add	r18, r24
    1998:	39 1f       	adc	r19, r25
    199a:	ad ec       	ldi	r26, 0xCD	; 205
    199c:	bc ec       	ldi	r27, 0xCC	; 204
    199e:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <__umulhisi3>
    19a2:	96 95       	lsr	r25
    19a4:	87 95       	ror	r24
    19a6:	96 95       	lsr	r25
    19a8:	87 95       	ror	r24
    19aa:	80 96       	adiw	r24, 0x20	; 32
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    19ac:	08 95       	ret

000019ae <lm73_init>:
//******************************************************************************
void lm73_init(){
	lm73_wr_buf[0] = LM73_PTR_TEMP;
    19ae:	10 92 d9 01 	sts	0x01D9, r1
	twi_start_wr(LM73_ADDRESS, lm73_wr_buf, 2);
    19b2:	42 e0       	ldi	r20, 0x02	; 2
    19b4:	69 ed       	ldi	r22, 0xD9	; 217
    19b6:	71 e0       	ldi	r23, 0x01	; 1
    19b8:	80 e9       	ldi	r24, 0x90	; 144
    19ba:	0c 94 53 0c 	jmp	0x18a6	; 0x18a6 <twi_start_wr>

000019be <get_local_temp>:

}

uint16_t get_local_temp(uint8_t f_not_c){
    19be:	cf 93       	push	r28
    19c0:	c8 2f       	mov	r28, r24
	uint16_t ret, lm73_temp;
	twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2);
    19c2:	42 e0       	ldi	r20, 0x02	; 2
    19c4:	6b ed       	ldi	r22, 0xDB	; 219
    19c6:	71 e0       	ldi	r23, 0x01	; 1
    19c8:	80 e9       	ldi	r24, 0x90	; 144
    19ca:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    19ce:	8f e3       	ldi	r24, 0x3F	; 63
    19d0:	9f e1       	ldi	r25, 0x1F	; 31
    19d2:	01 97       	sbiw	r24, 0x01	; 1
    19d4:	f1 f7       	brne	.-4      	; 0x19d2 <get_local_temp+0x14>
    19d6:	00 c0       	rjmp	.+0      	; 0x19d8 <get_local_temp+0x1a>
    19d8:	00 00       	nop
	_delay_ms(2);    //wait for it to finish
	//now assemble the two bytes read back into one 16-bit value
	//save high temperature byte into lm73_temp
	lm73_temp = lm73_rd_buf[0] << 8;
    19da:	20 91 db 01 	lds	r18, 0x01DB
    19de:	30 e0       	ldi	r19, 0x00	; 0
    19e0:	92 2f       	mov	r25, r18
    19e2:	88 27       	eor	r24, r24
	//shift it into upper byte 
	//"OR" in the low temp byte to lm73_temp 
	lm73_temp |= lm73_rd_buf[1];
    19e4:	20 91 dc 01 	lds	r18, 0x01DC
    19e8:	82 2b       	or	r24, r18
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
    19ea:	88 0f       	add	r24, r24
    19ec:	89 2f       	mov	r24, r25
    19ee:	88 1f       	adc	r24, r24
    19f0:	99 0b       	sbc	r25, r25
    19f2:	91 95       	neg	r25
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
    19f4:	c2 30       	cpi	r28, 0x02	; 2
    19f6:	91 f4       	brne	.+36     	; 0x1a1c <get_local_temp+0x5e>
	lm73_temp = (lm73_temp*9/5)+32;
    19f8:	9c 01       	movw	r18, r24
    19fa:	22 0f       	add	r18, r18
    19fc:	33 1f       	adc	r19, r19
    19fe:	22 0f       	add	r18, r18
    1a00:	33 1f       	adc	r19, r19
    1a02:	22 0f       	add	r18, r18
    1a04:	33 1f       	adc	r19, r19
    1a06:	28 0f       	add	r18, r24
    1a08:	39 1f       	adc	r19, r25
    1a0a:	ad ec       	ldi	r26, 0xCD	; 205
    1a0c:	bc ec       	ldi	r27, 0xCC	; 204
    1a0e:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <__umulhisi3>
    1a12:	96 95       	lsr	r25
    1a14:	87 95       	ror	r24
    1a16:	96 95       	lsr	r25
    1a18:	87 95       	ror	r24
    1a1a:	80 96       	adiw	r24, 0x20	; 32
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
	ret = lm73_temp_convert(lm73_temp, f_not_c);

	return ret;
}
    1a1c:	cf 91       	pop	r28
    1a1e:	08 95       	ret

00001a20 <strobe_lcd>:

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a20:	e2 e6       	ldi	r30, 0x62	; 98
    1a22:	f0 e0       	ldi	r31, 0x00	; 0
    1a24:	80 81       	ld	r24, Z
    1a26:	88 60       	ori	r24, 0x08	; 8
    1a28:	80 83       	st	Z, r24
	PORTF &= ~0x08;
    1a2a:	80 81       	ld	r24, Z
    1a2c:	87 7f       	andi	r24, 0xF7	; 247
    1a2e:	80 83       	st	Z, r24
    1a30:	08 95       	ret

00001a32 <clear_display>:
}          
 
void clear_display(void){
	SPDR = 0x00;    //command, not data
    1a32:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a34:	77 9b       	sbis	0x0e, 7	; 14
    1a36:	fe cf       	rjmp	.-4      	; 0x1a34 <clear_display+0x2>
	SPDR = 0x01;    //clear display command
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a3c:	77 9b       	sbis	0x0e, 7	; 14
    1a3e:	fe cf       	rjmp	.-4      	; 0x1a3c <clear_display+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a40:	80 91 62 00 	lds	r24, 0x0062
    1a44:	88 60       	ori	r24, 0x08	; 8
    1a46:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a4a:	80 91 62 00 	lds	r24, 0x0062
    1a4e:	87 7f       	andi	r24, 0xF7	; 247
    1a50:	80 93 62 00 	sts	0x0062, r24
    1a54:	8f e3       	ldi	r24, 0x3F	; 63
    1a56:	9f e1       	ldi	r25, 0x1F	; 31
    1a58:	01 97       	sbiw	r24, 0x01	; 1
    1a5a:	f1 f7       	brne	.-4      	; 0x1a58 <clear_display+0x26>
    1a5c:	00 c0       	rjmp	.+0      	; 0x1a5e <clear_display+0x2c>
    1a5e:	00 00       	nop
    1a60:	08 95       	ret

00001a62 <cursor_home>:
	strobe_lcd();   //strobe the LCD enable pin
	_delay_ms(2);   //obligatory waiting for slow LCD
}         

void cursor_home(void){
	SPDR = 0x00;    //command, not data
    1a62:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a64:	77 9b       	sbis	0x0e, 7	; 14
    1a66:	fe cf       	rjmp	.-4      	; 0x1a64 <cursor_home+0x2>
	SPDR = 0x02;   // cursor go home position
    1a68:	82 e0       	ldi	r24, 0x02	; 2
    1a6a:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a6c:	77 9b       	sbis	0x0e, 7	; 14
    1a6e:	fe cf       	rjmp	.-4      	; 0x1a6c <cursor_home+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a70:	80 91 62 00 	lds	r24, 0x0062
    1a74:	88 60       	ori	r24, 0x08	; 8
    1a76:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a7a:	80 91 62 00 	lds	r24, 0x0062
    1a7e:	87 7f       	andi	r24, 0xF7	; 247
    1a80:	80 93 62 00 	sts	0x0062, r24
    1a84:	08 95       	ret

00001a86 <home_line2>:
	strobe_lcd();
//	_delay_ms(1);  //not necessary with alarm_clock.c code
}         
  
void home_line2(void){
	SPDR = 0x00;    //command, not data
    1a86:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a88:	77 9b       	sbis	0x0e, 7	; 14
    1a8a:	fe cf       	rjmp	.-4      	; 0x1a88 <home_line2+0x2>
	SPDR = 0xC0;   // cursor go home on line 2
    1a8c:	80 ec       	ldi	r24, 0xC0	; 192
    1a8e:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a90:	77 9b       	sbis	0x0e, 7	; 14
    1a92:	fe cf       	rjmp	.-4      	; 0x1a90 <home_line2+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a94:	80 91 62 00 	lds	r24, 0x0062
    1a98:	88 60       	ori	r24, 0x08	; 8
    1a9a:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a9e:	80 91 62 00 	lds	r24, 0x0062
    1aa2:	87 7f       	andi	r24, 0xF7	; 247
    1aa4:	80 93 62 00 	sts	0x0062, r24
    1aa8:	08 95       	ret

00001aaa <fill_spaces>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd(); 
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
    1aaa:	80 e1       	ldi	r24, 0x10	; 16
    1aac:	90 e0       	ldi	r25, 0x00	; 0
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    1aae:	41 e0       	ldi	r20, 0x01	; 1
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		SPDR = 0x20; 
    1ab0:	30 e2       	ldi	r19, 0x20	; 32
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    1ab2:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1ab4:	77 9b       	sbis	0x0e, 7	; 14
    1ab6:	fe cf       	rjmp	.-4      	; 0x1ab4 <fill_spaces+0xa>
		SPDR = 0x20; 
    1ab8:	3f b9       	out	0x0f, r19	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1aba:	77 9b       	sbis	0x0e, 7	; 14
    1abc:	fe cf       	rjmp	.-4      	; 0x1aba <fill_spaces+0x10>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1abe:	20 91 62 00 	lds	r18, 0x0062
    1ac2:	28 60       	ori	r18, 0x08	; 8
    1ac4:	20 93 62 00 	sts	0x0062, r18
	PORTF &= ~0x08;
    1ac8:	20 91 62 00 	lds	r18, 0x0062
    1acc:	27 7f       	andi	r18, 0xF7	; 247
    1ace:	20 93 62 00 	sts	0x0062, r18
    1ad2:	ef e9       	ldi	r30, 0x9F	; 159
    1ad4:	ff e0       	ldi	r31, 0x0F	; 15
    1ad6:	31 97       	sbiw	r30, 0x01	; 1
    1ad8:	f1 f7       	brne	.-4      	; 0x1ad6 <fill_spaces+0x2c>
    1ada:	00 c0       	rjmp	.+0      	; 0x1adc <fill_spaces+0x32>
    1adc:	00 00       	nop
    1ade:	01 97       	sbiw	r24, 0x01	; 1
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
    1ae0:	00 97       	sbiw	r24, 0x00	; 0
    1ae2:	39 f7       	brne	.-50     	; 0x1ab2 <fill_spaces+0x8>
		SPDR = 0x20; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_ms(1);
	}
}  
    1ae4:	08 95       	ret

00001ae6 <char2lcd>:
   
void char2lcd(char a_char){
	//sends a char to the LCD
	//usage: char2lcd('H');  // send an H to the LCD
	SPDR = 0x01;   //set SR for data xfer with LSB=1
    1ae6:	91 e0       	ldi	r25, 0x01	; 1
    1ae8:	9f b9       	out	0x0f, r25	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1aea:	77 9b       	sbis	0x0e, 7	; 14
    1aec:	fe cf       	rjmp	.-4      	; 0x1aea <char2lcd+0x4>
	SPDR = a_char; //send the char to the SPI port
    1aee:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1af0:	77 9b       	sbis	0x0e, 7	; 14
    1af2:	fe cf       	rjmp	.-4      	; 0x1af0 <char2lcd+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1af4:	80 91 62 00 	lds	r24, 0x0062
    1af8:	88 60       	ori	r24, 0x08	; 8
    1afa:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1afe:	80 91 62 00 	lds	r24, 0x0062
    1b02:	87 7f       	andi	r24, 0xF7	; 247
    1b04:	80 93 62 00 	sts	0x0062, r24
    1b08:	8f e9       	ldi	r24, 0x9F	; 159
    1b0a:	9f e0       	ldi	r25, 0x0F	; 15
    1b0c:	01 97       	sbiw	r24, 0x01	; 1
    1b0e:	f1 f7       	brne	.-4      	; 0x1b0c <char2lcd+0x26>
    1b10:	00 c0       	rjmp	.+0      	; 0x1b12 <char2lcd+0x2c>
    1b12:	00 00       	nop
    1b14:	08 95       	ret

00001b16 <cursor_off>:
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void cursor_off(void){
	//cuts cursor off 
	SPDR = 0x00;   //set SR for data xfer with LSB=1
    1b16:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b18:	77 9b       	sbis	0x0e, 7	; 14
    1b1a:	fe cf       	rjmp	.-4      	; 0x1b18 <cursor_off+0x2>
	SPDR = 0x0C; //send the command to cut off cursor
    1b1c:	8c e0       	ldi	r24, 0x0C	; 12
    1b1e:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b20:	77 9b       	sbis	0x0e, 7	; 14
    1b22:	fe cf       	rjmp	.-4      	; 0x1b20 <cursor_off+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1b24:	80 91 62 00 	lds	r24, 0x0062
    1b28:	88 60       	ori	r24, 0x08	; 8
    1b2a:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1b2e:	80 91 62 00 	lds	r24, 0x0062
    1b32:	87 7f       	andi	r24, 0xF7	; 247
    1b34:	80 93 62 00 	sts	0x0062, r24
    1b38:	8f e9       	ldi	r24, 0x9F	; 159
    1b3a:	9f e0       	ldi	r25, 0x0F	; 15
    1b3c:	01 97       	sbiw	r24, 0x01	; 1
    1b3e:	f1 f7       	brne	.-4      	; 0x1b3c <cursor_off+0x26>
    1b40:	00 c0       	rjmp	.+0      	; 0x1b42 <cursor_off+0x2c>
    1b42:	00 00       	nop
    1b44:	08 95       	ret

00001b46 <string2lcd>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();  //toggle the enable bit
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void string2lcd(char *lcd_str){
    1b46:	dc 01       	movw	r26, r24

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1b48:	80 e0       	ldi	r24, 0x00	; 0
    1b4a:	90 e0       	ldi	r25, 0x00	; 0
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
		SPDR = 0x01; //set SR for data
    1b50:	41 e0       	ldi	r20, 0x01	; 1
    1b52:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b54:	77 9b       	sbis	0x0e, 7	; 14
    1b56:	fe cf       	rjmp	.-4      	; 0x1b54 <string2lcd+0xe>
		SPDR = lcd_str[count]; 
    1b58:	fd 01       	movw	r30, r26
    1b5a:	e8 0f       	add	r30, r24
    1b5c:	f9 1f       	adc	r31, r25
    1b5e:	80 81       	ld	r24, Z
    1b60:	8f b9       	out	0x0f, r24	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1b62:	77 9b       	sbis	0x0e, 7	; 14
    1b64:	fe cf       	rjmp	.-4      	; 0x1b62 <string2lcd+0x1c>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1b66:	80 91 62 00 	lds	r24, 0x0062
    1b6a:	88 60       	ori	r24, 0x08	; 8
    1b6c:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1b70:	80 91 62 00 	lds	r24, 0x0062
    1b74:	87 7f       	andi	r24, 0xF7	; 247
    1b76:	80 93 62 00 	sts	0x0062, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1b7a:	8f e8       	ldi	r24, 0x8F	; 143
    1b7c:	91 e0       	ldi	r25, 0x01	; 1
    1b7e:	01 97       	sbiw	r24, 0x01	; 1
    1b80:	f1 f7       	brne	.-4      	; 0x1b7e <string2lcd+0x38>
    1b82:	00 c0       	rjmp	.+0      	; 0x1b84 <string2lcd+0x3e>
    1b84:	00 00       	nop
  
void string2lcd(char *lcd_str){

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1b86:	2f 5f       	subi	r18, 0xFF	; 255
    1b88:	3f 4f       	sbci	r19, 0xFF	; 255
    1b8a:	c9 01       	movw	r24, r18
    1b8c:	fd 01       	movw	r30, r26
    1b8e:	01 90       	ld	r0, Z+
    1b90:	00 20       	and	r0, r0
    1b92:	e9 f7       	brne	.-6      	; 0x1b8e <string2lcd+0x48>
    1b94:	ea 1b       	sub	r30, r26
    1b96:	fb 0b       	sbc	r31, r27
    1b98:	32 97       	sbiw	r30, 0x02	; 2
    1b9a:	e2 17       	cp	r30, r18
    1b9c:	f3 07       	cpc	r31, r19
    1b9e:	c8 f6       	brcc	.-78     	; 0x1b52 <string2lcd+0xc>
		SPDR = lcd_str[count]; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_us(100);
	}                  
} 
    1ba0:	08 95       	ret

00001ba2 <lcd_init>:
    1ba2:	80 91 61 00 	lds	r24, 0x0061
    1ba6:	88 60       	ori	r24, 0x08	; 8
    1ba8:	80 93 61 00 	sts	0x0061, r24
    1bac:	8f e5       	ldi	r24, 0x5F	; 95
    1bae:	9a ee       	ldi	r25, 0xEA	; 234
    1bb0:	01 97       	sbiw	r24, 0x01	; 1
    1bb2:	f1 f7       	brne	.-4      	; 0x1bb0 <lcd_init+0xe>
    1bb4:	00 c0       	rjmp	.+0      	; 0x1bb6 <lcd_init+0x14>
    1bb6:	00 00       	nop
    1bb8:	83 e0       	ldi	r24, 0x03	; 3
    1bba:	90 e0       	ldi	r25, 0x00	; 0
    1bbc:	30 e3       	ldi	r19, 0x30	; 48
    1bbe:	1f b8       	out	0x0f, r1	; 15
    1bc0:	77 9b       	sbis	0x0e, 7	; 14
    1bc2:	fe cf       	rjmp	.-4      	; 0x1bc0 <lcd_init+0x1e>
    1bc4:	3f b9       	out	0x0f, r19	; 15
    1bc6:	77 9b       	sbis	0x0e, 7	; 14
    1bc8:	fe cf       	rjmp	.-4      	; 0x1bc6 <lcd_init+0x24>
    1bca:	20 91 62 00 	lds	r18, 0x0062
    1bce:	28 60       	ori	r18, 0x08	; 8
    1bd0:	20 93 62 00 	sts	0x0062, r18
    1bd4:	20 91 62 00 	lds	r18, 0x0062
    1bd8:	27 7f       	andi	r18, 0xF7	; 247
    1bda:	20 93 62 00 	sts	0x0062, r18
    1bde:	ef e5       	ldi	r30, 0x5F	; 95
    1be0:	fd e6       	ldi	r31, 0x6D	; 109
    1be2:	31 97       	sbiw	r30, 0x01	; 1
    1be4:	f1 f7       	brne	.-4      	; 0x1be2 <lcd_init+0x40>
    1be6:	00 c0       	rjmp	.+0      	; 0x1be8 <lcd_init+0x46>
    1be8:	00 00       	nop
    1bea:	01 97       	sbiw	r24, 0x01	; 1
    1bec:	00 97       	sbiw	r24, 0x00	; 0
    1bee:	39 f7       	brne	.-50     	; 0x1bbe <lcd_init+0x1c>
    1bf0:	1f b8       	out	0x0f, r1	; 15
    1bf2:	77 9b       	sbis	0x0e, 7	; 14
    1bf4:	fe cf       	rjmp	.-4      	; 0x1bf2 <lcd_init+0x50>
    1bf6:	88 e3       	ldi	r24, 0x38	; 56
    1bf8:	8f b9       	out	0x0f, r24	; 15
    1bfa:	77 9b       	sbis	0x0e, 7	; 14
    1bfc:	fe cf       	rjmp	.-4      	; 0x1bfa <lcd_init+0x58>
    1bfe:	80 91 62 00 	lds	r24, 0x0062
    1c02:	88 60       	ori	r24, 0x08	; 8
    1c04:	80 93 62 00 	sts	0x0062, r24
    1c08:	80 91 62 00 	lds	r24, 0x0062
    1c0c:	87 7f       	andi	r24, 0xF7	; 247
    1c0e:	80 93 62 00 	sts	0x0062, r24
    1c12:	8f e1       	ldi	r24, 0x1F	; 31
    1c14:	9e e4       	ldi	r25, 0x4E	; 78
    1c16:	01 97       	sbiw	r24, 0x01	; 1
    1c18:	f1 f7       	brne	.-4      	; 0x1c16 <lcd_init+0x74>
    1c1a:	00 c0       	rjmp	.+0      	; 0x1c1c <lcd_init+0x7a>
    1c1c:	00 00       	nop
    1c1e:	1f b8       	out	0x0f, r1	; 15
    1c20:	77 9b       	sbis	0x0e, 7	; 14
    1c22:	fe cf       	rjmp	.-4      	; 0x1c20 <lcd_init+0x7e>
    1c24:	88 e0       	ldi	r24, 0x08	; 8
    1c26:	8f b9       	out	0x0f, r24	; 15
    1c28:	77 9b       	sbis	0x0e, 7	; 14
    1c2a:	fe cf       	rjmp	.-4      	; 0x1c28 <lcd_init+0x86>
    1c2c:	80 91 62 00 	lds	r24, 0x0062
    1c30:	88 60       	ori	r24, 0x08	; 8
    1c32:	80 93 62 00 	sts	0x0062, r24
    1c36:	80 91 62 00 	lds	r24, 0x0062
    1c3a:	87 7f       	andi	r24, 0xF7	; 247
    1c3c:	80 93 62 00 	sts	0x0062, r24
    1c40:	ef e1       	ldi	r30, 0x1F	; 31
    1c42:	fe e4       	ldi	r31, 0x4E	; 78
    1c44:	31 97       	sbiw	r30, 0x01	; 1
    1c46:	f1 f7       	brne	.-4      	; 0x1c44 <lcd_init+0xa2>
    1c48:	00 c0       	rjmp	.+0      	; 0x1c4a <lcd_init+0xa8>
    1c4a:	00 00       	nop
    1c4c:	1f b8       	out	0x0f, r1	; 15
    1c4e:	77 9b       	sbis	0x0e, 7	; 14
    1c50:	fe cf       	rjmp	.-4      	; 0x1c4e <lcd_init+0xac>
    1c52:	81 e0       	ldi	r24, 0x01	; 1
    1c54:	8f b9       	out	0x0f, r24	; 15
    1c56:	77 9b       	sbis	0x0e, 7	; 14
    1c58:	fe cf       	rjmp	.-4      	; 0x1c56 <lcd_init+0xb4>
    1c5a:	80 91 62 00 	lds	r24, 0x0062
    1c5e:	88 60       	ori	r24, 0x08	; 8
    1c60:	80 93 62 00 	sts	0x0062, r24
    1c64:	80 91 62 00 	lds	r24, 0x0062
    1c68:	87 7f       	andi	r24, 0xF7	; 247
    1c6a:	80 93 62 00 	sts	0x0062, r24
    1c6e:	8f e1       	ldi	r24, 0x1F	; 31
    1c70:	9e e4       	ldi	r25, 0x4E	; 78
    1c72:	01 97       	sbiw	r24, 0x01	; 1
    1c74:	f1 f7       	brne	.-4      	; 0x1c72 <lcd_init+0xd0>
    1c76:	00 c0       	rjmp	.+0      	; 0x1c78 <lcd_init+0xd6>
    1c78:	00 00       	nop
    1c7a:	1f b8       	out	0x0f, r1	; 15
    1c7c:	77 9b       	sbis	0x0e, 7	; 14
    1c7e:	fe cf       	rjmp	.-4      	; 0x1c7c <lcd_init+0xda>
    1c80:	86 e0       	ldi	r24, 0x06	; 6
    1c82:	8f b9       	out	0x0f, r24	; 15
    1c84:	77 9b       	sbis	0x0e, 7	; 14
    1c86:	fe cf       	rjmp	.-4      	; 0x1c84 <lcd_init+0xe2>
    1c88:	80 91 62 00 	lds	r24, 0x0062
    1c8c:	88 60       	ori	r24, 0x08	; 8
    1c8e:	80 93 62 00 	sts	0x0062, r24
    1c92:	80 91 62 00 	lds	r24, 0x0062
    1c96:	87 7f       	andi	r24, 0xF7	; 247
    1c98:	80 93 62 00 	sts	0x0062, r24
    1c9c:	ef e1       	ldi	r30, 0x1F	; 31
    1c9e:	fe e4       	ldi	r31, 0x4E	; 78
    1ca0:	31 97       	sbiw	r30, 0x01	; 1
    1ca2:	f1 f7       	brne	.-4      	; 0x1ca0 <lcd_init+0xfe>
    1ca4:	00 c0       	rjmp	.+0      	; 0x1ca6 <lcd_init+0x104>
    1ca6:	00 00       	nop
    1ca8:	1f b8       	out	0x0f, r1	; 15
    1caa:	77 9b       	sbis	0x0e, 7	; 14
    1cac:	fe cf       	rjmp	.-4      	; 0x1caa <lcd_init+0x108>
    1cae:	8e e0       	ldi	r24, 0x0E	; 14
    1cb0:	8f b9       	out	0x0f, r24	; 15
    1cb2:	77 9b       	sbis	0x0e, 7	; 14
    1cb4:	fe cf       	rjmp	.-4      	; 0x1cb2 <lcd_init+0x110>
    1cb6:	80 91 62 00 	lds	r24, 0x0062
    1cba:	88 60       	ori	r24, 0x08	; 8
    1cbc:	80 93 62 00 	sts	0x0062, r24
    1cc0:	80 91 62 00 	lds	r24, 0x0062
    1cc4:	87 7f       	andi	r24, 0xF7	; 247
    1cc6:	80 93 62 00 	sts	0x0062, r24
    1cca:	8f e1       	ldi	r24, 0x1F	; 31
    1ccc:	9e e4       	ldi	r25, 0x4E	; 78
    1cce:	01 97       	sbiw	r24, 0x01	; 1
    1cd0:	f1 f7       	brne	.-4      	; 0x1cce <lcd_init+0x12c>
    1cd2:	00 c0       	rjmp	.+0      	; 0x1cd4 <lcd_init+0x132>
    1cd4:	00 00       	nop
    1cd6:	08 95       	ret

00001cd8 <main>:

int main()
{
	//set port bits 4-7 B as outputs
	//uint8_t c = 0;
	DDRE = 0xFF;
    1cd8:	9f ef       	ldi	r25, 0xFF	; 255
    1cda:	92 b9       	out	0x02, r25	; 2
	PORTE &= 0x7F;
    1cdc:	1f 98       	cbi	0x03, 7	; 3
	DDRB = 0xF7;
    1cde:	87 ef       	ldi	r24, 0xF7	; 247
    1ce0:	87 bb       	out	0x17, r24	; 23
	DDRD |= (1 << PB2);
    1ce2:	8a 9a       	sbi	0x11, 2	; 17

	volume = 100;
    1ce4:	84 e6       	ldi	r24, 0x64	; 100
    1ce6:	80 93 00 01 	sts	0x0100, r24
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1cea:	83 b7       	in	r24, 0x33	; 51
    1cec:	81 60       	ori	r24, 0x01	; 1
    1cee:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    1cf0:	80 b7       	in	r24, 0x30	; 48
    1cf2:	88 60       	ori	r24, 0x08	; 8
    1cf4:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1cf6:	85 b5       	in	r24, 0x25	; 37
    1cf8:	8a 67       	ori	r24, 0x7A	; 122
    1cfa:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1cfc:	87 b7       	in	r24, 0x37	; 55
    1cfe:	81 64       	ori	r24, 0x41	; 65
    1d00:	87 bf       	out	0x37, r24	; 55
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    1d02:	80 91 61 00 	lds	r24, 0x0061
    1d06:	80 93 61 00 	sts	0x0061, r24
	PORTF = 0x00;
    1d0a:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1d0e:	87 b1       	in	r24, 0x07	; 7
    1d10:	80 66       	ori	r24, 0x60	; 96
    1d12:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1d14:	86 b1       	in	r24, 0x06	; 6
    1d16:	8f 6e       	ori	r24, 0xEF	; 239
    1d18:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    1d1a:	93 bd       	out	0x23, r25	; 35
	DDRD |= (1 << PB2);

	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
    1d1c:	0e 94 61 05 	call	0xac2	; 0xac2 <music_init>
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    1d20:	80 e5       	ldi	r24, 0x50	; 80
    1d22:	8d b9       	out	0x0d, r24	; 13
	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
	SPI_init();
	lcd_init();
    1d24:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <lcd_init>
	init_twi();
    1d28:	0e 94 75 0c 	call	0x18ea	; 0x18ea <init_twi>
	uart_init();
    1d2c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <uart_init>
	OCR2 = 0xFF;
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1d30:	81 e8       	ldi	r24, 0x81	; 129
    1d32:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    1d36:	89 e0       	ldi	r24, 0x09	; 9
    1d38:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    1d3c:	80 91 00 01 	lds	r24, 0x0100
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	90 93 87 00 	sts	0x0087, r25
    1d46:	80 93 86 00 	sts	0x0086, r24
	SPI_init();
	lcd_init();
	init_twi();
	uart_init();
	volume_control_init();
	lm73_init();
    1d4a:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <lm73_init>
	cursor_off();
    1d4e:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <cursor_off>
	TCCR3B = (1<<WGM32) | (1<<CS30);
	OCR3A = volume;
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    1d52:	83 e1       	ldi	r24, 0x13	; 19
    1d54:	91 e0       	ldi	r25, 0x01	; 1
    1d56:	90 93 65 01 	sts	0x0165, r25
    1d5a:	80 93 64 01 	sts	0x0164, r24
	rem_temp_str = "Remote temp:   C";
    1d5e:	84 e2       	ldi	r24, 0x24	; 36
    1d60:	91 e0       	ldi	r25, 0x01	; 1
    1d62:	90 93 63 01 	sts	0x0163, r25
    1d66:	80 93 62 01 	sts	0x0162, r24
	volume_control_init();
	lm73_init();
	cursor_off();
	initialize_string();
	//strcpy(loc_temp_str, "Local  temp:   C");
	sei();
    1d6a:	78 94       	sei
    1d6c:	08 c0       	rjmp	.+16     	; 0x1d7e <main+0xa6>
		  }*/
		if(encode_flag){
			check_knobs();
			encode_flag = 0;
		}
		if(bar_graph_flag){
    1d6e:	80 91 49 01 	lds	r24, 0x0149
    1d72:	81 11       	cpse	r24, r1
    1d74:	12 c0       	rjmp	.+36     	; 0x1d9a <main+0xc2>
			bar_graph();
			bar_graph_flag = 0;
		}
		if(update_LCD){
    1d76:	80 91 4b 01 	lds	r24, 0x014B
    1d7a:	81 11       	cpse	r24, r1
    1d7c:	16 c0       	rjmp	.+44     	; 0x1daa <main+0xd2>
	//string2lcd("hello");
	while(1){
		//_delay_ms(100);
		//clear_display();
		//display_update();
		update_time();
    1d7e:	0e 94 fd 07 	call	0xffa	; 0xffa <update_time>
		//}
		/*if(reset_temp){
		  generate_temp_str();
		  reset_temp = 0;
		  }*/
		if(encode_flag){
    1d82:	80 91 4d 01 	lds	r24, 0x014D
    1d86:	88 23       	and	r24, r24
    1d88:	91 f3       	breq	.-28     	; 0x1d6e <main+0x96>
			check_knobs();
    1d8a:	0e 94 90 0a 	call	0x1520	; 0x1520 <check_knobs>
			encode_flag = 0;
    1d8e:	10 92 4d 01 	sts	0x014D, r1
		}
		if(bar_graph_flag){
    1d92:	80 91 49 01 	lds	r24, 0x0149
    1d96:	88 23       	and	r24, r24
    1d98:	71 f3       	breq	.-36     	; 0x1d76 <main+0x9e>
			bar_graph();
    1d9a:	0e 94 86 08 	call	0x110c	; 0x110c <bar_graph>
			bar_graph_flag = 0;
    1d9e:	10 92 49 01 	sts	0x0149, r1
		}
		if(update_LCD){
    1da2:	80 91 4b 01 	lds	r24, 0x014B
    1da6:	88 23       	and	r24, r24
    1da8:	51 f3       	breq	.-44     	; 0x1d7e <main+0xa6>

			show_temperature();
    1daa:	0e 94 37 0b 	call	0x166e	; 0x166e <show_temperature>
			update_LCD = 0;
    1dae:	10 92 4b 01 	sts	0x014B, r1
    1db2:	e5 cf       	rjmp	.-54     	; 0x1d7e <main+0xa6>

00001db4 <__tablejump2__>:
    1db4:	ee 0f       	add	r30, r30
    1db6:	ff 1f       	adc	r31, r31

00001db8 <__tablejump__>:
    1db8:	05 90       	lpm	r0, Z+
    1dba:	f4 91       	lpm	r31, Z
    1dbc:	e0 2d       	mov	r30, r0
    1dbe:	09 94       	ijmp

00001dc0 <__umulhisi3>:
    1dc0:	a2 9f       	mul	r26, r18
    1dc2:	b0 01       	movw	r22, r0
    1dc4:	b3 9f       	mul	r27, r19
    1dc6:	c0 01       	movw	r24, r0
    1dc8:	a3 9f       	mul	r26, r19
    1dca:	70 0d       	add	r23, r0
    1dcc:	81 1d       	adc	r24, r1
    1dce:	11 24       	eor	r1, r1
    1dd0:	91 1d       	adc	r25, r1
    1dd2:	b2 9f       	mul	r27, r18
    1dd4:	70 0d       	add	r23, r0
    1dd6:	81 1d       	adc	r24, r1
    1dd8:	11 24       	eor	r1, r1
    1dda:	91 1d       	adc	r25, r1
    1ddc:	08 95       	ret

00001dde <__itoa_ncheck>:
    1dde:	bb 27       	eor	r27, r27
    1de0:	4a 30       	cpi	r20, 0x0A	; 10
    1de2:	31 f4       	brne	.+12     	; 0x1df0 <__itoa_ncheck+0x12>
    1de4:	99 23       	and	r25, r25
    1de6:	22 f4       	brpl	.+8      	; 0x1df0 <__itoa_ncheck+0x12>
    1de8:	bd e2       	ldi	r27, 0x2D	; 45
    1dea:	90 95       	com	r25
    1dec:	81 95       	neg	r24
    1dee:	9f 4f       	sbci	r25, 0xFF	; 255
    1df0:	0c 94 fb 0e 	jmp	0x1df6	; 0x1df6 <__utoa_common>

00001df4 <__utoa_ncheck>:
    1df4:	bb 27       	eor	r27, r27

00001df6 <__utoa_common>:
    1df6:	fb 01       	movw	r30, r22
    1df8:	55 27       	eor	r21, r21
    1dfa:	aa 27       	eor	r26, r26
    1dfc:	88 0f       	add	r24, r24
    1dfe:	99 1f       	adc	r25, r25
    1e00:	aa 1f       	adc	r26, r26
    1e02:	a4 17       	cp	r26, r20
    1e04:	10 f0       	brcs	.+4      	; 0x1e0a <__utoa_common+0x14>
    1e06:	a4 1b       	sub	r26, r20
    1e08:	83 95       	inc	r24
    1e0a:	50 51       	subi	r21, 0x10	; 16
    1e0c:	b9 f7       	brne	.-18     	; 0x1dfc <__utoa_common+0x6>
    1e0e:	a0 5d       	subi	r26, 0xD0	; 208
    1e10:	aa 33       	cpi	r26, 0x3A	; 58
    1e12:	08 f0       	brcs	.+2      	; 0x1e16 <__utoa_common+0x20>
    1e14:	a9 5d       	subi	r26, 0xD9	; 217
    1e16:	a1 93       	st	Z+, r26
    1e18:	00 97       	sbiw	r24, 0x00	; 0
    1e1a:	79 f7       	brne	.-34     	; 0x1dfa <__utoa_common+0x4>
    1e1c:	b1 11       	cpse	r27, r1
    1e1e:	b1 93       	st	Z+, r27
    1e20:	11 92       	st	Z+, r1
    1e22:	cb 01       	movw	r24, r22
    1e24:	0c 94 14 0f 	jmp	0x1e28	; 0x1e28 <strrev>

00001e28 <strrev>:
    1e28:	dc 01       	movw	r26, r24
    1e2a:	fc 01       	movw	r30, r24
    1e2c:	67 2f       	mov	r22, r23
    1e2e:	71 91       	ld	r23, Z+
    1e30:	77 23       	and	r23, r23
    1e32:	e1 f7       	brne	.-8      	; 0x1e2c <strrev+0x4>
    1e34:	32 97       	sbiw	r30, 0x02	; 2
    1e36:	04 c0       	rjmp	.+8      	; 0x1e40 <strrev+0x18>
    1e38:	7c 91       	ld	r23, X
    1e3a:	6d 93       	st	X+, r22
    1e3c:	70 83       	st	Z, r23
    1e3e:	62 91       	ld	r22, -Z
    1e40:	ae 17       	cp	r26, r30
    1e42:	bf 07       	cpc	r27, r31
    1e44:	c8 f3       	brcs	.-14     	; 0x1e38 <strrev+0x10>
    1e46:	08 95       	ret

00001e48 <_exit>:
    1e48:	f8 94       	cli

00001e4a <__stop_program>:
    1e4a:	ff cf       	rjmp	.-2      	; 0x1e4a <__stop_program>
