
lab3_skel.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  0000065c  000006f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000065c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001e  00800112  00800112  00000702  2**0
                  ALLOC
  3 .stab         000011d0  00000000  00000000  00000704  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ed9  00000000  00000000  000018d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000027ad  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 bc 02 	jmp	0x578	; 0x578 <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ec e5       	ldi	r30, 0x5C	; 92
  a0:	f6 e0       	ldi	r31, 0x06	; 6
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 31       	cpi	r26, 0x12	; 18
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a2 e1       	ldi	r26, 0x12	; 18
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a0 33       	cpi	r26, 0x30	; 48
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 06 03 	call	0x60c	; 0x60c <main>
  c6:	0c 94 2c 03 	jmp	0x658	; 0x658 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <chk_buttons>:



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
  ce:	20 91 1b 01 	lds	r18, 0x011B
  d2:	30 91 1c 01 	lds	r19, 0x011C
  d6:	22 0f       	add	r18, r18
  d8:	33 1f       	adc	r19, r19
  da:	49 b3       	in	r20, 0x19	; 25
  dc:	50 e0       	ldi	r21, 0x00	; 0
  de:	02 c0       	rjmp	.+4      	; 0xe4 <chk_buttons+0x16>
  e0:	55 95       	asr	r21
  e2:	47 95       	ror	r20
  e4:	8a 95       	dec	r24
  e6:	e2 f7       	brpl	.-8      	; 0xe0 <chk_buttons+0x12>
  e8:	40 fd       	sbrc	r20, 0
  ea:	0e c0       	rjmp	.+28     	; 0x108 <chk_buttons+0x3a>
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	90 ee       	ldi	r25, 0xE0	; 224
  f0:	28 2b       	or	r18, r24
  f2:	39 2b       	or	r19, r25
  f4:	30 93 1c 01 	sts	0x011C, r19
  f8:	20 93 1b 01 	sts	0x011B, r18
    if (state == 0xF000){
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	21 15       	cp	r18, r1
 100:	30 4f       	sbci	r19, 0xF0	; 240
 102:	09 f0       	breq	.+2      	; 0x106 <chk_buttons+0x38>
 104:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
    }
    return 0;

}
 106:	08 95       	ret



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	90 ee       	ldi	r25, 0xE0	; 224
 10c:	f1 cf       	rjmp	.-30     	; 0xf0 <chk_buttons+0x22>

0000010e <int2seg>:
}
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
 10e:	81 11       	cpse	r24, r1
 110:	02 c0       	rjmp	.+4      	; 0x116 <int2seg+0x8>
	return ZERO;
 112:	80 ec       	ldi	r24, 0xC0	; 192
 114:	08 95       	ret
    }
    else if(number == 1 ){
 116:	81 30       	cpi	r24, 0x01	; 1
 118:	91 f0       	breq	.+36     	; 0x13e <int2seg+0x30>
	return ONE;
    }
    else if(number == 2 ){
 11a:	82 30       	cpi	r24, 0x02	; 2
 11c:	91 f0       	breq	.+36     	; 0x142 <int2seg+0x34>
	return TWO;
    }
    else if(number == 3 ){
 11e:	83 30       	cpi	r24, 0x03	; 3
 120:	a1 f0       	breq	.+40     	; 0x14a <int2seg+0x3c>
	return THREE;
    }
    else if(number == 4 ){
 122:	84 30       	cpi	r24, 0x04	; 4
 124:	81 f0       	breq	.+32     	; 0x146 <int2seg+0x38>
	return FOUR;
    }
    else if(number == 5 ){
 126:	85 30       	cpi	r24, 0x05	; 5
 128:	91 f0       	breq	.+36     	; 0x14e <int2seg+0x40>
	return FIVE;
    }
    else if(number == 6 ){
 12a:	86 30       	cpi	r24, 0x06	; 6
 12c:	91 f0       	breq	.+36     	; 0x152 <int2seg+0x44>
	return  SIX;
    }
    else if(number == 7 ){
 12e:	87 30       	cpi	r24, 0x07	; 7
 130:	91 f0       	breq	.+36     	; 0x156 <int2seg+0x48>
	return SEVEN;
    }
    else if(number == 8 ){
 132:	88 30       	cpi	r24, 0x08	; 8
 134:	91 f0       	breq	.+36     	; 0x15a <int2seg+0x4c>
	return EIGHT;
    }
    else if(number == 9 ){
 136:	89 30       	cpi	r24, 0x09	; 9
 138:	91 f0       	breq	.+36     	; 0x15e <int2seg+0x50>
	return NINE;
    }
    else{ 
	return 0;
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	08 95       	ret
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
	return ZERO;
    }
    else if(number == 1 ){
	return ONE;
 13e:	89 ef       	ldi	r24, 0xF9	; 249
 140:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
 142:	84 ea       	ldi	r24, 0xA4	; 164
 144:	08 95       	ret
    }
    else if(number == 3 ){
	return THREE;
    }
    else if(number == 4 ){
	return FOUR;
 146:	89 e9       	ldi	r24, 0x99	; 153
 148:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
    }
    else if(number == 3 ){
	return THREE;
 14a:	80 eb       	ldi	r24, 0xB0	; 176
 14c:	08 95       	ret
    }
    else if(number == 4 ){
	return FOUR;
    }
    else if(number == 5 ){
	return FIVE;
 14e:	82 e9       	ldi	r24, 0x92	; 146
 150:	08 95       	ret
    }
    else if(number == 6 ){
	return  SIX;
 152:	82 e8       	ldi	r24, 0x82	; 130
 154:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
 156:	88 ef       	ldi	r24, 0xF8	; 248
	return NINE;
    }
    else{ 
	return 0;
    }
}
 158:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
    }
    else if(number == 8 ){
	return EIGHT;
 15a:	80 e8       	ldi	r24, 0x80	; 128
 15c:	08 95       	ret
    }
    else if(number == 9 ){
	return NINE;
 15e:	80 e9       	ldi	r24, 0x90	; 144
 160:	08 95       	ret

00000162 <segsum>:
//                                   segment_sum                                    
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|

void segsum(uint16_t sum) {
 162:	ef 92       	push	r14
 164:	ff 92       	push	r15
 166:	0f 93       	push	r16
 168:	1f 93       	push	r17
 16a:	cf 93       	push	r28
 16c:	df 93       	push	r29
 16e:	ec 01       	movw	r28, r24
    //determine how many digits there are 
    int digit;
    // Break down the digits
    if(sum >= 1000){
 170:	88 3e       	cpi	r24, 0xE8	; 232
 172:	23 e0       	ldi	r18, 0x03	; 3
 174:	92 07       	cpc	r25, r18
 176:	50 f4       	brcc	.+20     	; 0x18c <segsum+0x2a>
	digit = 4;
    }
    else if (sum >= 100 && sum < 1000){
 178:	84 56       	subi	r24, 0x64	; 100
 17a:	91 09       	sbc	r25, r1
 17c:	84 38       	cpi	r24, 0x84	; 132
 17e:	33 e0       	ldi	r19, 0x03	; 3
 180:	93 07       	cpc	r25, r19
 182:	08 f0       	brcs	.+2      	; 0x186 <segsum+0x24>
 184:	7f c0       	rjmp	.+254    	; 0x284 <segsum+0x122>
	digit = 3;
 186:	03 e0       	ldi	r16, 0x03	; 3
 188:	10 e0       	ldi	r17, 0x00	; 0
 18a:	02 c0       	rjmp	.+4      	; 0x190 <segsum+0x2e>
void segsum(uint16_t sum) {
    //determine how many digits there are 
    int digit;
    // Break down the digits
    if(sum >= 1000){
	digit = 4;
 18c:	04 e0       	ldi	r16, 0x04	; 4
 18e:	10 e0       	ldi	r17, 0x00	; 0
    }
    else if (sum <10){
	digit = 1;
    }
    //break up decimal sum into 4 digit-segments
    segment_data[0] = int2seg(sum % 10); //ones
 190:	9e 01       	movw	r18, r28
 192:	ad ec       	ldi	r26, 0xCD	; 205
 194:	bc ec       	ldi	r27, 0xCC	; 204
 196:	0e 94 1d 03 	call	0x63a	; 0x63a <__umulhisi3>
 19a:	96 95       	lsr	r25
 19c:	87 95       	ror	r24
 19e:	96 95       	lsr	r25
 1a0:	87 95       	ror	r24
 1a2:	96 95       	lsr	r25
 1a4:	87 95       	ror	r24
 1a6:	3c 2f       	mov	r19, r28
 1a8:	2a e0       	ldi	r18, 0x0A	; 10
 1aa:	82 9f       	mul	r24, r18
 1ac:	30 19       	sub	r19, r0
 1ae:	11 24       	eor	r1, r1
 1b0:	83 2f       	mov	r24, r19
 1b2:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 1b6:	80 93 2b 01 	sts	0x012B, r24
    segment_data[1] = int2seg((sum % 100)/10); //tens
 1ba:	9e 01       	movw	r18, r28
 1bc:	36 95       	lsr	r19
 1be:	27 95       	ror	r18
 1c0:	36 95       	lsr	r19
 1c2:	27 95       	ror	r18
 1c4:	ab e7       	ldi	r26, 0x7B	; 123
 1c6:	b4 e1       	ldi	r27, 0x14	; 20
 1c8:	0e 94 1d 03 	call	0x63a	; 0x63a <__umulhisi3>
 1cc:	96 95       	lsr	r25
 1ce:	87 95       	ror	r24
 1d0:	44 e6       	ldi	r20, 0x64	; 100
 1d2:	48 9f       	mul	r20, r24
 1d4:	90 01       	movw	r18, r0
 1d6:	49 9f       	mul	r20, r25
 1d8:	30 0d       	add	r19, r0
 1da:	11 24       	eor	r1, r1
 1dc:	ce 01       	movw	r24, r28
 1de:	82 1b       	sub	r24, r18
 1e0:	93 0b       	sbc	r25, r19
 1e2:	9c 01       	movw	r18, r24
 1e4:	ad ec       	ldi	r26, 0xCD	; 205
 1e6:	bc ec       	ldi	r27, 0xCC	; 204
 1e8:	0e 94 1d 03 	call	0x63a	; 0x63a <__umulhisi3>
 1ec:	96 95       	lsr	r25
 1ee:	87 95       	ror	r24
 1f0:	96 95       	lsr	r25
 1f2:	87 95       	ror	r24
 1f4:	96 95       	lsr	r25
 1f6:	87 95       	ror	r24
 1f8:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 1fc:	80 93 2c 01 	sts	0x012C, r24
    //segment_data[2] = 1; //decimal
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
 200:	9e 01       	movw	r18, r28
 202:	36 95       	lsr	r19
 204:	27 95       	ror	r18
 206:	36 95       	lsr	r19
 208:	27 95       	ror	r18
 20a:	36 95       	lsr	r19
 20c:	27 95       	ror	r18
 20e:	a5 ec       	ldi	r26, 0xC5	; 197
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	0e 94 1d 03 	call	0x63a	; 0x63a <__umulhisi3>
 216:	7c 01       	movw	r14, r24
 218:	f2 94       	swap	r15
 21a:	e2 94       	swap	r14
 21c:	ef e0       	ldi	r30, 0x0F	; 15
 21e:	ee 22       	and	r14, r30
 220:	ef 24       	eor	r14, r15
 222:	fe 22       	and	r15, r30
 224:	ef 24       	eor	r14, r15
 226:	28 ee       	ldi	r18, 0xE8	; 232
 228:	33 e0       	ldi	r19, 0x03	; 3
 22a:	e2 9e       	mul	r14, r18
 22c:	c0 01       	movw	r24, r0
 22e:	e3 9e       	mul	r14, r19
 230:	90 0d       	add	r25, r0
 232:	f2 9e       	mul	r15, r18
 234:	90 0d       	add	r25, r0
 236:	11 24       	eor	r1, r1
 238:	9e 01       	movw	r18, r28
 23a:	28 1b       	sub	r18, r24
 23c:	39 0b       	sbc	r19, r25
 23e:	36 95       	lsr	r19
 240:	27 95       	ror	r18
 242:	36 95       	lsr	r19
 244:	27 95       	ror	r18
 246:	ab e7       	ldi	r26, 0x7B	; 123
 248:	b4 e1       	ldi	r27, 0x14	; 20
 24a:	0e 94 1d 03 	call	0x63a	; 0x63a <__umulhisi3>
 24e:	96 95       	lsr	r25
 250:	87 95       	ror	r24
 252:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 256:	80 93 2e 01 	sts	0x012E, r24
    segment_data[4] = int2seg(sum/1000); //thousands
 25a:	8e 2d       	mov	r24, r14
 25c:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
    //blank out leading zero digits 
    switch (digit){
 260:	02 30       	cpi	r16, 0x02	; 2
 262:	11 05       	cpc	r17, r1
 264:	39 f1       	breq	.+78     	; 0x2b4 <segsum+0x152>
 266:	03 30       	cpi	r16, 0x03	; 3
 268:	11 05       	cpc	r17, r1
 26a:	11 f1       	breq	.+68     	; 0x2b0 <segsum+0x14e>
 26c:	01 30       	cpi	r16, 0x01	; 1
 26e:	11 05       	cpc	r17, r1
 270:	89 f0       	breq	.+34     	; 0x294 <segsum+0x132>
	case 3:
	    segment_data[4] = OFF;
 272:	80 93 2f 01 	sts	0x012F, r24
	    break;
	default:
	    break;
    }
    //now move data to right place for misplaced colon position
}//segment_sum
 276:	df 91       	pop	r29
 278:	cf 91       	pop	r28
 27a:	1f 91       	pop	r17
 27c:	0f 91       	pop	r16
 27e:	ff 90       	pop	r15
 280:	ef 90       	pop	r14
 282:	08 95       	ret
	digit = 4;
    }
    else if (sum >= 100 && sum < 1000){
	digit = 3;
    }
    else if (sum >= 10 && sum < 100){
 284:	86 5a       	subi	r24, 0xA6	; 166
 286:	9f 4f       	sbci	r25, 0xFF	; 255
 288:	8a 35       	cpi	r24, 0x5A	; 90
 28a:	91 05       	cpc	r25, r1
 28c:	f8 f4       	brcc	.+62     	; 0x2cc <segsum+0x16a>
	digit = 2;
 28e:	02 e0       	ldi	r16, 0x02	; 2
 290:	10 e0       	ldi	r17, 0x00	; 0
 292:	7e cf       	rjmp	.-260    	; 0x190 <segsum+0x2e>
	case 2:
	    segment_data[4] = OFF;  	
	    segment_data[3] = OFF;  	
	    break;
	case 1:
	    segment_data[4] = OFF;  	
 294:	8f ef       	ldi	r24, 0xFF	; 255
 296:	80 93 2f 01 	sts	0x012F, r24
	    segment_data[3] = OFF;  	
 29a:	80 93 2e 01 	sts	0x012E, r24
	    segment_data[1] = OFF;  	
 29e:	80 93 2c 01 	sts	0x012C, r24
	    break;
	default:
	    break;
    }
    //now move data to right place for misplaced colon position
}//segment_sum
 2a2:	df 91       	pop	r29
 2a4:	cf 91       	pop	r28
 2a6:	1f 91       	pop	r17
 2a8:	0f 91       	pop	r16
 2aa:	ff 90       	pop	r15
 2ac:	ef 90       	pop	r14
 2ae:	08 95       	ret
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
    segment_data[4] = int2seg(sum/1000); //thousands
    //blank out leading zero digits 
    switch (digit){
	case 3:
	    segment_data[4] = OFF;
 2b0:	8f ef       	ldi	r24, 0xFF	; 255
 2b2:	df cf       	rjmp	.-66     	; 0x272 <segsum+0x110>
	    break;
	case 2:
	    segment_data[4] = OFF;  	
 2b4:	8f ef       	ldi	r24, 0xFF	; 255
 2b6:	80 93 2f 01 	sts	0x012F, r24
	    segment_data[3] = OFF;  	
 2ba:	80 93 2e 01 	sts	0x012E, r24
	    break;
	default:
	    break;
    }
    //now move data to right place for misplaced colon position
}//segment_sum
 2be:	df 91       	pop	r29
 2c0:	cf 91       	pop	r28
 2c2:	1f 91       	pop	r17
 2c4:	0f 91       	pop	r16
 2c6:	ff 90       	pop	r15
 2c8:	ef 90       	pop	r14
 2ca:	08 95       	ret
    }
    else if (sum >= 10 && sum < 100){
	digit = 2;
    }
    else if (sum <10){
	digit = 1;
 2cc:	01 e0       	ldi	r16, 0x01	; 1
 2ce:	10 e0       	ldi	r17, 0x00	; 0
 2d0:	5f cf       	rjmp	.-322    	; 0x190 <segsum+0x2e>

000002d2 <button_routine>:
    //now move data to right place for misplaced colon position
}//segment_sum
//***********************************************************************************
void button_routine(){
    uint8_t button;
    DDRA  = 0x00; // PORTA input mode
 2d2:	1a ba       	out	0x1a, r1	; 26
    PORTA = 0xFF; //Pull ups
 2d4:	8f ef       	ldi	r24, 0xFF	; 255
 2d6:	8b bb       	out	0x1b, r24	; 27
    __asm__ __volatile__ ("nop");
 2d8:	00 00       	nop
    __asm__ __volatile__ ("nop");
 2da:	00 00       	nop
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
 2dc:	88 b3       	in	r24, 0x18	; 24
 2de:	80 67       	ori	r24, 0x70	; 112
 2e0:	88 bb       	out	0x18, r24	; 24
    __asm__ __volatile__ ("nop");
 2e2:	00 00       	nop
    __asm__ __volatile__ ("nop");
 2e4:	00 00       	nop
 2e6:	20 91 1b 01 	lds	r18, 0x011B
 2ea:	30 91 1c 01 	lds	r19, 0x011C
 2ee:	80 e0       	ldi	r24, 0x00	; 0
 2f0:	90 e0       	ldi	r25, 0x00	; 0
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
	    }
	    else {               //both off add 1
		dif = 1;
 2f2:	61 e0       	ldi	r22, 0x01	; 1
		// value = 4;
		dif =  2;
	    }
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
 2f4:	e4 e0       	ldi	r30, 0x04	; 4
		dif = 0;
	    }
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
 2f6:	72 e0       	ldi	r23, 0x02	; 2



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 2f8:	a9 01       	movw	r20, r18
 2fa:	44 0f       	add	r20, r20
 2fc:	55 1f       	adc	r21, r21
 2fe:	29 b3       	in	r18, 0x19	; 25
 300:	30 e0       	ldi	r19, 0x00	; 0
 302:	08 2e       	mov	r0, r24
 304:	02 c0       	rjmp	.+4      	; 0x30a <button_routine+0x38>
 306:	35 95       	asr	r19
 308:	27 95       	ror	r18
 30a:	0a 94       	dec	r0
 30c:	e2 f7       	brpl	.-8      	; 0x306 <button_routine+0x34>
 30e:	20 fd       	sbrc	r18, 0
 310:	11 c0       	rjmp	.+34     	; 0x334 <button_routine+0x62>
 312:	21 e0       	ldi	r18, 0x01	; 1
 314:	30 ee       	ldi	r19, 0xE0	; 224
 316:	24 2b       	or	r18, r20
 318:	35 2b       	or	r19, r21
 31a:	30 93 1c 01 	sts	0x011C, r19
 31e:	20 93 1b 01 	sts	0x011B, r18
    if (state == 0xF000){
 322:	21 15       	cp	r18, r1
 324:	40 ef       	ldi	r20, 0xF0	; 240
 326:	34 07       	cpc	r19, r20
 328:	41 f0       	breq	.+16     	; 0x33a <button_routine+0x68>
 32a:	01 96       	adiw	r24, 0x01	; 1
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
 32c:	83 30       	cpi	r24, 0x03	; 3
 32e:	91 05       	cpc	r25, r1
 330:	19 f7       	brne	.-58     	; 0x2f8 <button_routine+0x26>
 332:	08 95       	ret



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 334:	20 e0       	ldi	r18, 0x00	; 0
 336:	30 ee       	ldi	r19, 0xE0	; 224
 338:	ee cf       	rjmp	.-36     	; 0x316 <button_routine+0x44>
 33a:	48 2f       	mov	r20, r24
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    if(button == 0){
 33c:	88 23       	and	r24, r24
 33e:	09 f1       	breq	.+66     	; 0x382 <button_routine+0xb0>
		modeA = !modeA;   //Inverse everytime button0 is pressed
		//value = 1;
	    }
	    else if( button == 1){  //Inverse everytime button1 is pressed  
 340:	41 30       	cpi	r20, 0x01	; 1
 342:	c1 f0       	breq	.+48     	; 0x374 <button_routine+0xa2>
		modeB = !modeB;
		//value = 2;
	    } 
	    //value = value + 100;
	    if (modeA && modeB){    //If both modes are on, add 0
 344:	40 91 1e 01 	lds	r20, 0x011E
 348:	41 11       	cpse	r20, r1
 34a:	07 c0       	rjmp	.+14     	; 0x35a <button_routine+0x88>
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
	    }
	    else if (modeB && !modeA){ //1-off 2-on add 4
 34c:	40 91 1d 01 	lds	r20, 0x011D
 350:	44 23       	and	r20, r20
 352:	69 f0       	breq	.+26     	; 0x36e <button_routine+0x9c>
		//value = modeB;
		dif =  4;
 354:	e0 93 00 01 	sts	0x0100, r30
 358:	e8 cf       	rjmp	.-48     	; 0x32a <button_routine+0x58>
	    else if( button == 1){  //Inverse everytime button1 is pressed  
		modeB = !modeB;
		//value = 2;
	    } 
	    //value = value + 100;
	    if (modeA && modeB){    //If both modes are on, add 0
 35a:	40 91 1d 01 	lds	r20, 0x011D
 35e:	44 23       	and	r20, r20
 360:	19 f0       	breq	.+6      	; 0x368 <button_routine+0x96>
		//value = 4;
		dif = 0;
 362:	10 92 00 01 	sts	0x0100, r1
 366:	e1 cf       	rjmp	.-62     	; 0x32a <button_routine+0x58>
	    }
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
 368:	70 93 00 01 	sts	0x0100, r23
 36c:	de cf       	rjmp	.-68     	; 0x32a <button_routine+0x58>
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
	    }
	    else {               //both off add 1
		dif = 1;
 36e:	60 93 00 01 	sts	0x0100, r22
 372:	db cf       	rjmp	.-74     	; 0x32a <button_routine+0x58>
	    if(button == 0){
		modeA = !modeA;   //Inverse everytime button0 is pressed
		//value = 1;
	    }
	    else if( button == 1){  //Inverse everytime button1 is pressed  
		modeB = !modeB;
 374:	50 91 1d 01 	lds	r21, 0x011D
 378:	51 11       	cpse	r21, r1
 37a:	40 e0       	ldi	r20, 0x00	; 0
 37c:	40 93 1d 01 	sts	0x011D, r20
 380:	e1 cf       	rjmp	.-62     	; 0x344 <button_routine+0x72>
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
	    //Check the state of buttons
	    if(button == 0){
		modeA = !modeA;   //Inverse everytime button0 is pressed
 382:	41 e0       	ldi	r20, 0x01	; 1
 384:	50 91 1e 01 	lds	r21, 0x011E
 388:	51 11       	cpse	r21, r1
 38a:	40 e0       	ldi	r20, 0x00	; 0
 38c:	40 93 1e 01 	sts	0x011E, r20
 390:	d9 cf       	rjmp	.-78     	; 0x344 <button_routine+0x72>

00000392 <SPI_init>:
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 392:	81 e5       	ldi	r24, 0x51	; 81
 394:	8d b9       	out	0x0d, r24	; 13
 396:	08 95       	ret

00000398 <SPI_Transmit>:
/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){

    SPDR = data;    //Write data to SPDR
 398:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 39a:	77 9b       	sbis	0x0e, 7	; 14
 39c:	fe cf       	rjmp	.-4      	; 0x39a <SPI_Transmit+0x2>
}
 39e:	08 95       	ret

000003a0 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
    PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
 3a0:	83 b1       	in	r24, 0x03	; 3
 3a2:	13 b8       	out	0x03, r1	; 3
    __asm__ __volatile__ ("nop");
 3a4:	00 00       	nop
    __asm__ __volatile__ ("nop");
 3a6:	00 00       	nop
    // Wait until 8 clock cycles are done 
    SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
 3a8:	1f b8       	out	0x0f, r1	; 15
    PORTE |= (1 << PE6);  
 3aa:	1e 9a       	sbi	0x03, 6	; 3
    __asm__ __volatile__ ("nop");
 3ac:	00 00       	nop
    __asm__ __volatile__ ("nop");
 3ae:	00 00       	nop
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
 3b0:	77 9b       	sbis	0x0e, 7	; 14
 3b2:	fe cf       	rjmp	.-4      	; 0x3b0 <SPI_Receive+0x10>
    // Return incoming data from SPDR
    return(SPDR);  
 3b4:	8f b1       	in	r24, 0x0f	; 15
}
 3b6:	08 95       	ret

000003b8 <bar_graph>:
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    //If mode A is selected -> xxxxxxx1
    if(modeA){
 3b8:	81 e0       	ldi	r24, 0x01	; 1
 3ba:	90 91 1e 01 	lds	r25, 0x011E
 3be:	91 11       	cpse	r25, r1
 3c0:	01 c0       	rjmp	.+2      	; 0x3c4 <bar_graph+0xc>
 3c2:	80 e0       	ldi	r24, 0x00	; 0
    //If mode A is not selected -> xxxxxxx0
    else if(!modeA){
	write &= 0xFE;
    }
    //If mode b is selected -> xxxxxxx1x
    if(modeB){
 3c4:	90 91 1d 01 	lds	r25, 0x011D
 3c8:	91 11       	cpse	r25, r1
	write |= 0x02;
 3ca:	82 60       	ori	r24, 0x02	; 2
/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){

    SPDR = data;    //Write data to SPDR
 3cc:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 3ce:	77 9b       	sbis	0x0e, 7	; 14
 3d0:	fe cf       	rjmp	.-4      	; 0x3ce <bar_graph+0x16>
    else if(!modeB){
	write &= 0xFD;
    }
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
 3d2:	84 e0       	ldi	r24, 0x04	; 4
 3d4:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop"); //Buffer
 3d6:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 3d8:	00 00       	nop


    PORTD = (2 << PD2);  // Push data out of SPI
 3da:	88 e0       	ldi	r24, 0x08	; 8
 3dc:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop");  //Buffer
 3de:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 3e0:	00 00       	nop
 3e2:	08 95       	ret

000003e4 <display_update>:
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    int display_segment;
    segsum(value);
 3e4:	80 91 14 01 	lds	r24, 0x0114
 3e8:	90 91 15 01 	lds	r25, 0x0115
 3ec:	0e 94 b1 00 	call	0x162	; 0x162 <segsum>
    DDRA = 0xFF;  //switch PORTA to output
 3f0:	8f ef       	ldi	r24, 0xFF	; 255
 3f2:	8a bb       	out	0x1a, r24	; 26
    __asm__ __volatile__ ("nop"); //Buffer
 3f4:	00 00       	nop
    __asm__ __volatile__ ("nop"); //Buffer 
 3f6:	00 00       	nop
 3f8:	eb e2       	ldi	r30, 0x2B	; 43
 3fa:	f1 e0       	ldi	r31, 0x01	; 1
    for(display_segment = 0 ; display_segment < MAX_SEGMENT ; display_segment++){
 3fc:	80 e0       	ldi	r24, 0x00	; 0
 3fe:	90 e0       	ldi	r25, 0x00	; 0
	//send PORTB the digit to display
	//value = 1;
	//segsum(value);
	PORTB &= 0x8F;
 400:	28 b3       	in	r18, 0x18	; 24
 402:	2f 78       	andi	r18, 0x8F	; 143
 404:	28 bb       	out	0x18, r18	; 24
	PORTB |= display_segment << 4;
 406:	48 b3       	in	r20, 0x18	; 24
 408:	9c 01       	movw	r18, r24
 40a:	22 95       	swap	r18
 40c:	32 95       	swap	r19
 40e:	30 7f       	andi	r19, 0xF0	; 240
 410:	32 27       	eor	r19, r18
 412:	20 7f       	andi	r18, 0xF0	; 240
 414:	32 27       	eor	r19, r18
 416:	42 2b       	or	r20, r18
 418:	48 bb       	out	0x18, r20	; 24
	//send 7 segment code to LED segments
	//update digit to display
	PORTA = segment_data[display_segment];	
 41a:	21 91       	ld	r18, Z+
 41c:	2b bb       	out	0x1b, r18	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 41e:	af e1       	ldi	r26, 0x1F	; 31
 420:	b3 e0       	ldi	r27, 0x03	; 3
 422:	11 97       	sbiw	r26, 0x01	; 1
 424:	f1 f7       	brne	.-4      	; 0x422 <display_update+0x3e>
 426:	00 c0       	rjmp	.+0      	; 0x428 <display_update+0x44>
 428:	00 00       	nop
    int display_segment;
    segsum(value);
    DDRA = 0xFF;  //switch PORTA to output
    __asm__ __volatile__ ("nop"); //Buffer
    __asm__ __volatile__ ("nop"); //Buffer 
    for(display_segment = 0 ; display_segment < MAX_SEGMENT ; display_segment++){
 42a:	01 96       	adiw	r24, 0x01	; 1
 42c:	85 30       	cpi	r24, 0x05	; 5
 42e:	91 05       	cpc	r25, r1
 430:	39 f7       	brne	.-50     	; 0x400 <display_update+0x1c>
	//send 7 segment code to LED segments
	//update digit to display
	PORTA = segment_data[display_segment];	
	_delay_us(200);
    }
}
 432:	08 95       	ret

00000434 <decode_spi_left_knob>:
    uint8_t sw_index = 0;
    //Counter for preventing unneccessary reset    
    static uint8_t acount1 = 0;
    static uint8_t previous_encoder1 = 0; //Initialize previous    
    uint8_t direction = 0;                    //Direction variable
    encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
 434:	8c 70       	andi	r24, 0x0C	; 12
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	95 95       	asr	r25
 43a:	87 95       	ror	r24
 43c:	95 95       	asr	r25
 43e:	87 95       	ror	r24
 440:	38 2f       	mov	r19, r24
    sw_index = (previous_encoder1 << 2) | encoder1; 
 442:	e0 91 19 01 	lds	r30, 0x0119
 446:	ee 0f       	add	r30, r30
 448:	ee 0f       	add	r30, r30
 44a:	e8 2b       	or	r30, r24
    /*shift previous to the left use it as an index Since
      we know the pattern of the knob when it is turning
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
 44c:	f0 e0       	ldi	r31, 0x00	; 0
 44e:	ef 5f       	subi	r30, 0xFF	; 255
 450:	fe 4f       	sbci	r31, 0xFE	; 254
 452:	20 81       	ld	r18, Z
    //Read out the direction from table
    //value = acount2;
    if(direction == CW){  //If CW, add counter
 454:	21 30       	cpi	r18, 0x01	; 1
 456:	39 f1       	breq	.+78     	; 0x4a6 <decode_spi_left_knob+0x72>
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
 458:	22 30       	cpi	r18, 0x02	; 2
 45a:	29 f0       	breq	.+10     	; 0x466 <decode_spi_left_knob+0x32>
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 45c:	33 30       	cpi	r19, 0x03	; 3
 45e:	51 f0       	breq	.+20     	; 0x474 <decode_spi_left_knob+0x40>
	    value = value - dif;
	}
	//update_number();                 //Check number in the routine
	acount1 = 0;                     //Reset counter
    }
    previous_encoder1 = encoder1;
 460:	80 93 19 01 	sts	0x0119, r24
 464:	08 95       	ret
    //value = acount2;
    if(direction == CW){  //If CW, add counter
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
 466:	20 91 18 01 	lds	r18, 0x0118
 46a:	21 50       	subi	r18, 0x01	; 1
 46c:	20 93 18 01 	sts	0x0118, r18
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 470:	33 30       	cpi	r19, 0x03	; 3
 472:	b1 f7       	brne	.-20     	; 0x460 <decode_spi_left_knob+0x2c>
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
 474:	20 91 18 01 	lds	r18, 0x0118
 478:	3e ef       	ldi	r19, 0xFE	; 254
 47a:	32 0f       	add	r19, r18
 47c:	38 30       	cpi	r19, 0x08	; 8
 47e:	c8 f0       	brcs	.+50     	; 0x4b2 <decode_spi_left_knob+0x7e>
	    value = value + dif;
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
 480:	21 3f       	cpi	r18, 0xF1	; 241
 482:	60 f0       	brcs	.+24     	; 0x49c <decode_spi_left_knob+0x68>
	    value = value - dif;
 484:	40 91 00 01 	lds	r20, 0x0100
 488:	20 91 14 01 	lds	r18, 0x0114
 48c:	30 91 15 01 	lds	r19, 0x0115
 490:	24 1b       	sub	r18, r20
 492:	31 09       	sbc	r19, r1
 494:	30 93 15 01 	sts	0x0115, r19
 498:	20 93 14 01 	sts	0x0114, r18
	}
	//update_number();                 //Check number in the routine
	acount1 = 0;                     //Reset counter
 49c:	10 92 18 01 	sts	0x0118, r1
    }
    previous_encoder1 = encoder1;
 4a0:	80 93 19 01 	sts	0x0119, r24
 4a4:	08 95       	ret
      Which way it is turning*/
    direction = sw_table[sw_index];
    //Read out the direction from table
    //value = acount2;
    if(direction == CW){  //If CW, add counter
	acount1++;
 4a6:	20 91 18 01 	lds	r18, 0x0118
 4aa:	2f 5f       	subi	r18, 0xFF	; 255
 4ac:	20 93 18 01 	sts	0x0118, r18
 4b0:	d5 cf       	rjmp	.-86     	; 0x45c <decode_spi_left_knob+0x28>
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    value = value + dif;
 4b2:	40 91 00 01 	lds	r20, 0x0100
 4b6:	20 91 14 01 	lds	r18, 0x0114
 4ba:	30 91 15 01 	lds	r19, 0x0115
 4be:	24 0f       	add	r18, r20
 4c0:	31 1d       	adc	r19, r1
 4c2:	30 93 15 01 	sts	0x0115, r19
 4c6:	20 93 14 01 	sts	0x0114, r18
 4ca:	e8 cf       	rjmp	.-48     	; 0x49c <decode_spi_left_knob+0x68>

000004cc <decode_spi_right_knob>:
void decode_spi_right_knob(uint8_t encoder2){
    uint8_t sw_index = 0;
    static uint8_t acount2 = 0;
    static uint8_t previous_encoder2 = 0;
    uint8_t direction = 0;
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
 4cc:	83 70       	andi	r24, 0x03	; 3
    sw_index = (previous_encoder2 << 2) | encoder2;
 4ce:	e0 91 17 01 	lds	r30, 0x0117
 4d2:	ee 0f       	add	r30, r30
 4d4:	ee 0f       	add	r30, r30
 4d6:	e8 2b       	or	r30, r24
    direction = sw_table[sw_index];
 4d8:	f0 e0       	ldi	r31, 0x00	; 0
 4da:	ef 5f       	subi	r30, 0xFF	; 255
 4dc:	fe 4f       	sbci	r31, 0xFE	; 254
 4de:	90 81       	ld	r25, Z
    //value = modeA;
    if(direction == CW){
 4e0:	91 30       	cpi	r25, 0x01	; 1
 4e2:	39 f1       	breq	.+78     	; 0x532 <decode_spi_right_knob+0x66>
	acount2++;
    }	
    if(direction == CCW){
 4e4:	92 30       	cpi	r25, 0x02	; 2
 4e6:	29 f0       	breq	.+10     	; 0x4f2 <decode_spi_right_knob+0x26>
	acount2--;
    }
    if(encoder2 == 3){
 4e8:	83 30       	cpi	r24, 0x03	; 3
 4ea:	51 f0       	breq	.+20     	; 0x500 <decode_spi_right_knob+0x34>
	    value = value - dif;
	}
	//update_number();
	acount2 = 0;
    }
    previous_encoder2 = encoder2;
 4ec:	80 93 17 01 	sts	0x0117, r24
 4f0:	08 95       	ret
    //value = modeA;
    if(direction == CW){
	acount2++;
    }	
    if(direction == CCW){
	acount2--;
 4f2:	90 91 16 01 	lds	r25, 0x0116
 4f6:	91 50       	subi	r25, 0x01	; 1
 4f8:	90 93 16 01 	sts	0x0116, r25
    }
    if(encoder2 == 3){
 4fc:	83 30       	cpi	r24, 0x03	; 3
 4fe:	b1 f7       	brne	.-20     	; 0x4ec <decode_spi_right_knob+0x20>
	if((acount2 > 1) && (acount2 < 10)){
 500:	90 91 16 01 	lds	r25, 0x0116
 504:	2e ef       	ldi	r18, 0xFE	; 254
 506:	29 0f       	add	r18, r25
 508:	28 30       	cpi	r18, 0x08	; 8
 50a:	c8 f0       	brcs	.+50     	; 0x53e <decode_spi_right_knob+0x72>
	    value = value + dif;
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
 50c:	91 3f       	cpi	r25, 0xF1	; 241
 50e:	60 f0       	brcs	.+24     	; 0x528 <decode_spi_right_knob+0x5c>
	    value = value - dif;
 510:	90 91 00 01 	lds	r25, 0x0100
 514:	20 91 14 01 	lds	r18, 0x0114
 518:	30 91 15 01 	lds	r19, 0x0115
 51c:	29 1b       	sub	r18, r25
 51e:	31 09       	sbc	r19, r1
 520:	30 93 15 01 	sts	0x0115, r19
 524:	20 93 14 01 	sts	0x0114, r18
	}
	//update_number();
	acount2 = 0;
 528:	10 92 16 01 	sts	0x0116, r1
    }
    previous_encoder2 = encoder2;
 52c:	80 93 17 01 	sts	0x0117, r24
 530:	08 95       	ret
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    sw_index = (previous_encoder2 << 2) | encoder2;
    direction = sw_table[sw_index];
    //value = modeA;
    if(direction == CW){
	acount2++;
 532:	90 91 16 01 	lds	r25, 0x0116
 536:	9f 5f       	subi	r25, 0xFF	; 255
 538:	90 93 16 01 	sts	0x0116, r25
 53c:	d5 cf       	rjmp	.-86     	; 0x4e8 <decode_spi_right_knob+0x1c>
    if(direction == CCW){
	acount2--;
    }
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    value = value + dif;
 53e:	90 91 00 01 	lds	r25, 0x0100
 542:	20 91 14 01 	lds	r18, 0x0114
 546:	30 91 15 01 	lds	r19, 0x0115
 54a:	29 0f       	add	r18, r25
 54c:	31 1d       	adc	r19, r1
 54e:	30 93 15 01 	sts	0x0115, r19
 552:	20 93 14 01 	sts	0x0114, r18
 556:	e8 cf       	rjmp	.-48     	; 0x528 <decode_spi_right_knob+0x5c>

00000558 <check_knobs>:
    __asm__ __volatile__ ("nop");
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    // Return incoming data from SPDR
    return(SPDR);  
}
void check_knobs(void){
 558:	cf 93       	push	r28
 55a:	df 93       	push	r29
    static uint8_t encoder;
    encoder  = SPI_Receive();
 55c:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <SPI_Receive>
 560:	80 93 1a 01 	sts	0x011A, r24
    decode_spi_left_knob(encoder);
 564:	c8 2f       	mov	r28, r24
 566:	d0 e0       	ldi	r29, 0x00	; 0
 568:	ce 01       	movw	r24, r28
 56a:	0e 94 1a 02 	call	0x434	; 0x434 <decode_spi_left_knob>
    decode_spi_right_knob(encoder);
 56e:	ce 01       	movw	r24, r28
}
 570:	df 91       	pop	r29
 572:	cf 91       	pop	r28
}
void check_knobs(void){
    static uint8_t encoder;
    encoder  = SPI_Receive();
    decode_spi_left_knob(encoder);
    decode_spi_right_knob(encoder);
 574:	0c 94 66 02 	jmp	0x4cc	; 0x4cc <decode_spi_right_knob>

00000578 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
 578:	1f 92       	push	r1
 57a:	0f 92       	push	r0
 57c:	0f b6       	in	r0, 0x3f	; 63
 57e:	0f 92       	push	r0
 580:	11 24       	eor	r1, r1
 582:	0b b6       	in	r0, 0x3b	; 59
 584:	0f 92       	push	r0
 586:	2f 93       	push	r18
 588:	3f 93       	push	r19
 58a:	4f 93       	push	r20
 58c:	5f 93       	push	r21
 58e:	6f 93       	push	r22
 590:	7f 93       	push	r23
 592:	8f 93       	push	r24
 594:	9f 93       	push	r25
 596:	af 93       	push	r26
 598:	bf 93       	push	r27
 59a:	ef 93       	push	r30
 59c:	ff 93       	push	r31
    check_knobs();
 59e:	0e 94 ac 02 	call	0x558	; 0x558 <check_knobs>
    display_update();
 5a2:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <display_update>
    button_routine();
 5a6:	0e 94 69 01 	call	0x2d2	; 0x2d2 <button_routine>
}
 5aa:	ff 91       	pop	r31
 5ac:	ef 91       	pop	r30
 5ae:	bf 91       	pop	r27
 5b0:	af 91       	pop	r26
 5b2:	9f 91       	pop	r25
 5b4:	8f 91       	pop	r24
 5b6:	7f 91       	pop	r23
 5b8:	6f 91       	pop	r22
 5ba:	5f 91       	pop	r21
 5bc:	4f 91       	pop	r20
 5be:	3f 91       	pop	r19
 5c0:	2f 91       	pop	r18
 5c2:	0f 90       	pop	r0
 5c4:	0b be       	out	0x3b, r0	; 59
 5c6:	0f 90       	pop	r0
 5c8:	0f be       	out	0x3f, r0	; 63
 5ca:	0f 90       	pop	r0
 5cc:	1f 90       	pop	r1
 5ce:	18 95       	reti

000005d0 <update_number>:
    }
    previous_encoder2 = encoder2;
}

void update_number(void){
    if (value > (0-MAX_SUM)){
 5d0:	80 91 14 01 	lds	r24, 0x0114
 5d4:	90 91 15 01 	lds	r25, 0x0115
 5d8:	82 30       	cpi	r24, 0x02	; 2
 5da:	2c ef       	ldi	r18, 0xFC	; 252
 5dc:	92 07       	cpc	r25, r18
 5de:	58 f4       	brcc	.+22     	; 0x5f6 <update_number+0x26>
	value = MAX_SUM - (dif-1);                       	
    }
    else if (value > MAX_SUM){
 5e0:	81 15       	cp	r24, r1
 5e2:	24 e0       	ldi	r18, 0x04	; 4
 5e4:	92 07       	cpc	r25, r18
 5e6:	30 f0       	brcs	.+12     	; 0x5f4 <update_number+0x24>
	value = value - MAX_SUM;
 5e8:	8f 5f       	subi	r24, 0xFF	; 255
 5ea:	93 40       	sbci	r25, 0x03	; 3
 5ec:	90 93 15 01 	sts	0x0115, r25
 5f0:	80 93 14 01 	sts	0x0114, r24
 5f4:	08 95       	ret
    previous_encoder2 = encoder2;
}

void update_number(void){
    if (value > (0-MAX_SUM)){
	value = MAX_SUM - (dif-1);                       	
 5f6:	20 91 00 01 	lds	r18, 0x0100
 5fa:	80 e0       	ldi	r24, 0x00	; 0
 5fc:	94 e0       	ldi	r25, 0x04	; 4
 5fe:	82 1b       	sub	r24, r18
 600:	91 09       	sbc	r25, r1
 602:	90 93 15 01 	sts	0x0115, r25
 606:	80 93 14 01 	sts	0x0114, r24
 60a:	08 95       	ret

0000060c <main>:

//***********************************************************************************
int main()
{
    //set port bits 4-7 B as outputs
    DDRE = 0xc0;
 60c:	80 ec       	ldi	r24, 0xC0	; 192
 60e:	82 b9       	out	0x02, r24	; 2
    PORTE &= 0x7F;
 610:	1f 98       	cbi	0x03, 7	; 3
    DDRB = 0xF7;
 612:	87 ef       	ldi	r24, 0xF7	; 247
 614:	87 bb       	out	0x17, r24	; 23
    DDRD |= (1 << PB2);
 616:	8a 9a       	sbi	0x11, 2	; 17

    segment_data[2] = OFF;
 618:	8f ef       	ldi	r24, 0xFF	; 255
 61a:	80 93 2d 01 	sts	0x012D, r24

    TIMSK |= (1<<TOIE0);             //enable interrupts
 61e:	87 b7       	in	r24, 0x37	; 55
 620:	81 60       	ori	r24, 0x01	; 1
 622:	87 bf       	out	0x37, r24	; 55
    TCCR0 |= (1<<CS00) | (1<<CS10);  //normal mode, prescale by 128
 624:	83 b7       	in	r24, 0x33	; 51
 626:	81 60       	ori	r24, 0x01	; 1
 628:	83 bf       	out	0x33, r24	; 51
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 62a:	81 e5       	ldi	r24, 0x51	; 81
 62c:	8d b9       	out	0x0d, r24	; 13
    segment_data[2] = OFF;

    TIMSK |= (1<<TOIE0);             //enable interrupts
    TCCR0 |= (1<<CS00) | (1<<CS10);  //normal mode, prescale by 128
    SPI_init();
    sei();
 62e:	78 94       	sei
    while(1){
	bar_graph();
 630:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <bar_graph>
	display_update();
 634:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <display_update>
 638:	fb cf       	rjmp	.-10     	; 0x630 <main+0x24>

0000063a <__umulhisi3>:
 63a:	a2 9f       	mul	r26, r18
 63c:	b0 01       	movw	r22, r0
 63e:	b3 9f       	mul	r27, r19
 640:	c0 01       	movw	r24, r0
 642:	a3 9f       	mul	r26, r19
 644:	70 0d       	add	r23, r0
 646:	81 1d       	adc	r24, r1
 648:	11 24       	eor	r1, r1
 64a:	91 1d       	adc	r25, r1
 64c:	b2 9f       	mul	r27, r18
 64e:	70 0d       	add	r23, r0
 650:	81 1d       	adc	r24, r1
 652:	11 24       	eor	r1, r1
 654:	91 1d       	adc	r25, r1
 656:	08 95       	ret

00000658 <_exit>:
 658:	f8 94       	cli

0000065a <__stop_program>:
 65a:	ff cf       	rjmp	.-2      	; 0x65a <__stop_program>
