
lab3_skel.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  0000067c  00000710  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000067c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001e  00800112  00800112  00000722  2**0
                  ALLOC
  3 .stab         00001224  00000000  00000000  00000724  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ecb  00000000  00000000  00001948  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00002813  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 cc 02 	jmp	0x598	; 0x598 <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ec e7       	ldi	r30, 0x7C	; 124
  a0:	f6 e0       	ldi	r31, 0x06	; 6
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 31       	cpi	r26, 0x12	; 18
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a2 e1       	ldi	r26, 0x12	; 18
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a0 33       	cpi	r26, 0x30	; 48
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 16 03 	call	0x62c	; 0x62c <main>
  c6:	0c 94 3c 03 	jmp	0x678	; 0x678 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <chk_buttons>:



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
  ce:	20 91 1b 01 	lds	r18, 0x011B
  d2:	30 91 1c 01 	lds	r19, 0x011C
  d6:	22 0f       	add	r18, r18
  d8:	33 1f       	adc	r19, r19
  da:	49 b3       	in	r20, 0x19	; 25
  dc:	50 e0       	ldi	r21, 0x00	; 0
  de:	02 c0       	rjmp	.+4      	; 0xe4 <chk_buttons+0x16>
  e0:	55 95       	asr	r21
  e2:	47 95       	ror	r20
  e4:	8a 95       	dec	r24
  e6:	e2 f7       	brpl	.-8      	; 0xe0 <chk_buttons+0x12>
  e8:	40 fd       	sbrc	r20, 0
  ea:	0e c0       	rjmp	.+28     	; 0x108 <chk_buttons+0x3a>
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	90 ee       	ldi	r25, 0xE0	; 224
  f0:	28 2b       	or	r18, r24
  f2:	39 2b       	or	r19, r25
  f4:	30 93 1c 01 	sts	0x011C, r19
  f8:	20 93 1b 01 	sts	0x011B, r18
    if (state == 0xF000){
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	21 15       	cp	r18, r1
 100:	30 4f       	sbci	r19, 0xF0	; 240
 102:	09 f0       	breq	.+2      	; 0x106 <chk_buttons+0x38>
 104:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
    }
    return 0;

}
 106:	08 95       	ret



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	90 ee       	ldi	r25, 0xE0	; 224
 10c:	f1 cf       	rjmp	.-30     	; 0xf0 <chk_buttons+0x22>

0000010e <int2seg>:
}
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
 10e:	81 11       	cpse	r24, r1
 110:	02 c0       	rjmp	.+4      	; 0x116 <int2seg+0x8>
	return ZERO;
 112:	80 ec       	ldi	r24, 0xC0	; 192
 114:	08 95       	ret
    }
    else if(number == 1 ){
 116:	81 30       	cpi	r24, 0x01	; 1
 118:	91 f0       	breq	.+36     	; 0x13e <int2seg+0x30>
	return ONE;
    }
    else if(number == 2 ){
 11a:	82 30       	cpi	r24, 0x02	; 2
 11c:	91 f0       	breq	.+36     	; 0x142 <int2seg+0x34>
	return TWO;
    }
    else if(number == 3 ){
 11e:	83 30       	cpi	r24, 0x03	; 3
 120:	a1 f0       	breq	.+40     	; 0x14a <int2seg+0x3c>
	return THREE;
    }
    else if(number == 4 ){
 122:	84 30       	cpi	r24, 0x04	; 4
 124:	81 f0       	breq	.+32     	; 0x146 <int2seg+0x38>
	return FOUR;
    }
    else if(number == 5 ){
 126:	85 30       	cpi	r24, 0x05	; 5
 128:	91 f0       	breq	.+36     	; 0x14e <int2seg+0x40>
	return FIVE;
    }
    else if(number == 6 ){
 12a:	86 30       	cpi	r24, 0x06	; 6
 12c:	91 f0       	breq	.+36     	; 0x152 <int2seg+0x44>
	return  SIX;
    }
    else if(number == 7 ){
 12e:	87 30       	cpi	r24, 0x07	; 7
 130:	91 f0       	breq	.+36     	; 0x156 <int2seg+0x48>
	return SEVEN;
    }
    else if(number == 8 ){
 132:	88 30       	cpi	r24, 0x08	; 8
 134:	91 f0       	breq	.+36     	; 0x15a <int2seg+0x4c>
	return EIGHT;
    }
    else if(number == 9 ){
 136:	89 30       	cpi	r24, 0x09	; 9
 138:	91 f0       	breq	.+36     	; 0x15e <int2seg+0x50>
	return NINE;
    }
    else{ 
	return 0;
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	08 95       	ret
uint8_t int2seg(uint8_t number){
    if(number == 0 ){
	return ZERO;
    }
    else if(number == 1 ){
	return ONE;
 13e:	89 ef       	ldi	r24, 0xF9	; 249
 140:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
 142:	84 ea       	ldi	r24, 0xA4	; 164
 144:	08 95       	ret
    }
    else if(number == 3 ){
	return THREE;
    }
    else if(number == 4 ){
	return FOUR;
 146:	89 e9       	ldi	r24, 0x99	; 153
 148:	08 95       	ret
    }
    else if(number == 2 ){
	return TWO;
    }
    else if(number == 3 ){
	return THREE;
 14a:	80 eb       	ldi	r24, 0xB0	; 176
 14c:	08 95       	ret
    }
    else if(number == 4 ){
	return FOUR;
    }
    else if(number == 5 ){
	return FIVE;
 14e:	82 e9       	ldi	r24, 0x92	; 146
 150:	08 95       	ret
    }
    else if(number == 6 ){
	return  SIX;
 152:	82 e8       	ldi	r24, 0x82	; 130
 154:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
 156:	88 ef       	ldi	r24, 0xF8	; 248
	return NINE;
    }
    else{ 
	return 0;
    }
}
 158:	08 95       	ret
    }
    else if(number == 7 ){
	return SEVEN;
    }
    else if(number == 8 ){
	return EIGHT;
 15a:	80 e8       	ldi	r24, 0x80	; 128
 15c:	08 95       	ret
    }
    else if(number == 9 ){
	return NINE;
 15e:	80 e9       	ldi	r24, 0x90	; 144
 160:	08 95       	ret

00000162 <segsum>:
//                                   segment_sum                                    
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|

void segsum(uint16_t sum) {
 162:	ef 92       	push	r14
 164:	ff 92       	push	r15
 166:	0f 93       	push	r16
 168:	1f 93       	push	r17
 16a:	cf 93       	push	r28
 16c:	df 93       	push	r29
 16e:	ec 01       	movw	r28, r24
    //determine how many digits there are 
    int digit;
    // Break down the digits
    if(sum >= 1000){
 170:	88 3e       	cpi	r24, 0xE8	; 232
 172:	23 e0       	ldi	r18, 0x03	; 3
 174:	92 07       	cpc	r25, r18
 176:	50 f4       	brcc	.+20     	; 0x18c <segsum+0x2a>
	digit = 4;
    }
    else if (sum >= 100 && sum < 1000){
 178:	84 56       	subi	r24, 0x64	; 100
 17a:	91 09       	sbc	r25, r1
 17c:	84 38       	cpi	r24, 0x84	; 132
 17e:	33 e0       	ldi	r19, 0x03	; 3
 180:	93 07       	cpc	r25, r19
 182:	08 f0       	brcs	.+2      	; 0x186 <segsum+0x24>
 184:	7f c0       	rjmp	.+254    	; 0x284 <segsum+0x122>
	digit = 3;
 186:	03 e0       	ldi	r16, 0x03	; 3
 188:	10 e0       	ldi	r17, 0x00	; 0
 18a:	02 c0       	rjmp	.+4      	; 0x190 <segsum+0x2e>
void segsum(uint16_t sum) {
    //determine how many digits there are 
    int digit;
    // Break down the digits
    if(sum >= 1000){
	digit = 4;
 18c:	04 e0       	ldi	r16, 0x04	; 4
 18e:	10 e0       	ldi	r17, 0x00	; 0
    }
    else if (sum <10){
	digit = 1;
    }
    //break up decimal sum into 4 digit-segments
    segment_data[0] = int2seg(sum % 10); //ones
 190:	9e 01       	movw	r18, r28
 192:	ad ec       	ldi	r26, 0xCD	; 205
 194:	bc ec       	ldi	r27, 0xCC	; 204
 196:	0e 94 2d 03 	call	0x65a	; 0x65a <__umulhisi3>
 19a:	96 95       	lsr	r25
 19c:	87 95       	ror	r24
 19e:	96 95       	lsr	r25
 1a0:	87 95       	ror	r24
 1a2:	96 95       	lsr	r25
 1a4:	87 95       	ror	r24
 1a6:	3c 2f       	mov	r19, r28
 1a8:	2a e0       	ldi	r18, 0x0A	; 10
 1aa:	82 9f       	mul	r24, r18
 1ac:	30 19       	sub	r19, r0
 1ae:	11 24       	eor	r1, r1
 1b0:	83 2f       	mov	r24, r19
 1b2:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 1b6:	80 93 2b 01 	sts	0x012B, r24
    segment_data[1] = int2seg((sum % 100)/10); //tens
 1ba:	9e 01       	movw	r18, r28
 1bc:	36 95       	lsr	r19
 1be:	27 95       	ror	r18
 1c0:	36 95       	lsr	r19
 1c2:	27 95       	ror	r18
 1c4:	ab e7       	ldi	r26, 0x7B	; 123
 1c6:	b4 e1       	ldi	r27, 0x14	; 20
 1c8:	0e 94 2d 03 	call	0x65a	; 0x65a <__umulhisi3>
 1cc:	96 95       	lsr	r25
 1ce:	87 95       	ror	r24
 1d0:	44 e6       	ldi	r20, 0x64	; 100
 1d2:	48 9f       	mul	r20, r24
 1d4:	90 01       	movw	r18, r0
 1d6:	49 9f       	mul	r20, r25
 1d8:	30 0d       	add	r19, r0
 1da:	11 24       	eor	r1, r1
 1dc:	ce 01       	movw	r24, r28
 1de:	82 1b       	sub	r24, r18
 1e0:	93 0b       	sbc	r25, r19
 1e2:	9c 01       	movw	r18, r24
 1e4:	ad ec       	ldi	r26, 0xCD	; 205
 1e6:	bc ec       	ldi	r27, 0xCC	; 204
 1e8:	0e 94 2d 03 	call	0x65a	; 0x65a <__umulhisi3>
 1ec:	96 95       	lsr	r25
 1ee:	87 95       	ror	r24
 1f0:	96 95       	lsr	r25
 1f2:	87 95       	ror	r24
 1f4:	96 95       	lsr	r25
 1f6:	87 95       	ror	r24
 1f8:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 1fc:	80 93 2c 01 	sts	0x012C, r24
    //segment_data[2] = 1; //decimal
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
 200:	9e 01       	movw	r18, r28
 202:	36 95       	lsr	r19
 204:	27 95       	ror	r18
 206:	36 95       	lsr	r19
 208:	27 95       	ror	r18
 20a:	36 95       	lsr	r19
 20c:	27 95       	ror	r18
 20e:	a5 ec       	ldi	r26, 0xC5	; 197
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	0e 94 2d 03 	call	0x65a	; 0x65a <__umulhisi3>
 216:	7c 01       	movw	r14, r24
 218:	f2 94       	swap	r15
 21a:	e2 94       	swap	r14
 21c:	ef e0       	ldi	r30, 0x0F	; 15
 21e:	ee 22       	and	r14, r30
 220:	ef 24       	eor	r14, r15
 222:	fe 22       	and	r15, r30
 224:	ef 24       	eor	r14, r15
 226:	28 ee       	ldi	r18, 0xE8	; 232
 228:	33 e0       	ldi	r19, 0x03	; 3
 22a:	e2 9e       	mul	r14, r18
 22c:	c0 01       	movw	r24, r0
 22e:	e3 9e       	mul	r14, r19
 230:	90 0d       	add	r25, r0
 232:	f2 9e       	mul	r15, r18
 234:	90 0d       	add	r25, r0
 236:	11 24       	eor	r1, r1
 238:	9e 01       	movw	r18, r28
 23a:	28 1b       	sub	r18, r24
 23c:	39 0b       	sbc	r19, r25
 23e:	36 95       	lsr	r19
 240:	27 95       	ror	r18
 242:	36 95       	lsr	r19
 244:	27 95       	ror	r18
 246:	ab e7       	ldi	r26, 0x7B	; 123
 248:	b4 e1       	ldi	r27, 0x14	; 20
 24a:	0e 94 2d 03 	call	0x65a	; 0x65a <__umulhisi3>
 24e:	96 95       	lsr	r25
 250:	87 95       	ror	r24
 252:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
 256:	80 93 2e 01 	sts	0x012E, r24
    segment_data[4] = int2seg(sum/1000); //thousands
 25a:	8e 2d       	mov	r24, r14
 25c:	0e 94 87 00 	call	0x10e	; 0x10e <int2seg>
    //blank out leading zero digits 
    switch (digit){
 260:	02 30       	cpi	r16, 0x02	; 2
 262:	11 05       	cpc	r17, r1
 264:	39 f1       	breq	.+78     	; 0x2b4 <segsum+0x152>
 266:	03 30       	cpi	r16, 0x03	; 3
 268:	11 05       	cpc	r17, r1
 26a:	11 f1       	breq	.+68     	; 0x2b0 <segsum+0x14e>
 26c:	01 30       	cpi	r16, 0x01	; 1
 26e:	11 05       	cpc	r17, r1
 270:	89 f0       	breq	.+34     	; 0x294 <segsum+0x132>
	case 3:
	    segment_data[4] = OFF;
 272:	80 93 2f 01 	sts	0x012F, r24
	    break;
	default:
	    break;
    }
    //now move data to right place for misplaced colon position
}//segment_sum
 276:	df 91       	pop	r29
 278:	cf 91       	pop	r28
 27a:	1f 91       	pop	r17
 27c:	0f 91       	pop	r16
 27e:	ff 90       	pop	r15
 280:	ef 90       	pop	r14
 282:	08 95       	ret
	digit = 4;
    }
    else if (sum >= 100 && sum < 1000){
	digit = 3;
    }
    else if (sum >= 10 && sum < 100){
 284:	86 5a       	subi	r24, 0xA6	; 166
 286:	9f 4f       	sbci	r25, 0xFF	; 255
 288:	8a 35       	cpi	r24, 0x5A	; 90
 28a:	91 05       	cpc	r25, r1
 28c:	f8 f4       	brcc	.+62     	; 0x2cc <segsum+0x16a>
	digit = 2;
 28e:	02 e0       	ldi	r16, 0x02	; 2
 290:	10 e0       	ldi	r17, 0x00	; 0
 292:	7e cf       	rjmp	.-260    	; 0x190 <segsum+0x2e>
	case 2:
	    segment_data[4] = OFF;  	
	    segment_data[3] = OFF;  	
	    break;
	case 1:
	    segment_data[4] = OFF;  	
 294:	8f ef       	ldi	r24, 0xFF	; 255
 296:	80 93 2f 01 	sts	0x012F, r24
	    segment_data[3] = OFF;  	
 29a:	80 93 2e 01 	sts	0x012E, r24
	    segment_data[1] = OFF;  	
 29e:	80 93 2c 01 	sts	0x012C, r24
	    break;
	default:
	    break;
    }
    //now move data to right place for misplaced colon position
}//segment_sum
 2a2:	df 91       	pop	r29
 2a4:	cf 91       	pop	r28
 2a6:	1f 91       	pop	r17
 2a8:	0f 91       	pop	r16
 2aa:	ff 90       	pop	r15
 2ac:	ef 90       	pop	r14
 2ae:	08 95       	ret
    segment_data[3] = int2seg((sum % 1000)/100); //hundreds
    segment_data[4] = int2seg(sum/1000); //thousands
    //blank out leading zero digits 
    switch (digit){
	case 3:
	    segment_data[4] = OFF;
 2b0:	8f ef       	ldi	r24, 0xFF	; 255
 2b2:	df cf       	rjmp	.-66     	; 0x272 <segsum+0x110>
	    break;
	case 2:
	    segment_data[4] = OFF;  	
 2b4:	8f ef       	ldi	r24, 0xFF	; 255
 2b6:	80 93 2f 01 	sts	0x012F, r24
	    segment_data[3] = OFF;  	
 2ba:	80 93 2e 01 	sts	0x012E, r24
	    break;
	default:
	    break;
    }
    //now move data to right place for misplaced colon position
}//segment_sum
 2be:	df 91       	pop	r29
 2c0:	cf 91       	pop	r28
 2c2:	1f 91       	pop	r17
 2c4:	0f 91       	pop	r16
 2c6:	ff 90       	pop	r15
 2c8:	ef 90       	pop	r14
 2ca:	08 95       	ret
    }
    else if (sum >= 10 && sum < 100){
	digit = 2;
    }
    else if (sum <10){
	digit = 1;
 2cc:	01 e0       	ldi	r16, 0x01	; 1
 2ce:	10 e0       	ldi	r17, 0x00	; 0
 2d0:	5f cf       	rjmp	.-322    	; 0x190 <segsum+0x2e>

000002d2 <button_routine>:
    //now move data to right place for misplaced colon position
}//segment_sum
//***********************************************************************************
void button_routine(){
    uint8_t button;
    DDRA  = 0x00; // PORTA input mode
 2d2:	1a ba       	out	0x1a, r1	; 26
    PORTA = 0xFF; //Pull ups
 2d4:	8f ef       	ldi	r24, 0xFF	; 255
 2d6:	8b bb       	out	0x1b, r24	; 27
    __asm__ __volatile__ ("nop");
 2d8:	00 00       	nop
    __asm__ __volatile__ ("nop");
 2da:	00 00       	nop
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
 2dc:	88 b3       	in	r24, 0x18	; 24
 2de:	80 67       	ori	r24, 0x70	; 112
 2e0:	88 bb       	out	0x18, r24	; 24
    __asm__ __volatile__ ("nop");
 2e2:	00 00       	nop
    __asm__ __volatile__ ("nop");
 2e4:	00 00       	nop
 2e6:	80 91 1b 01 	lds	r24, 0x011B
 2ea:	90 91 1c 01 	lds	r25, 0x011C
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
		button = value;
 2ee:	50 91 14 01 	lds	r21, 0x0114
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
 2f2:	40 e0       	ldi	r20, 0x00	; 0
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
	    }
	    else {               //both off add 1
		dif = 1;
 2f4:	61 e0       	ldi	r22, 0x01	; 1
		// value = 4;
		dif =  2;
	    }
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
 2f6:	e4 e0       	ldi	r30, 0x04	; 4
		dif = 0;
	    }
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
 2f8:	72 e0       	ldi	r23, 0x02	; 2
 2fa:	0f c0       	rjmp	.+30     	; 0x31a <button_routine+0x48>



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 2fc:	81 e0       	ldi	r24, 0x01	; 1
 2fe:	90 ee       	ldi	r25, 0xE0	; 224
 300:	82 2b       	or	r24, r18
 302:	93 2b       	or	r25, r19
 304:	90 93 1c 01 	sts	0x011C, r25
 308:	80 93 1b 01 	sts	0x011B, r24
    if (state == 0xF000){
 30c:	81 15       	cp	r24, r1
 30e:	20 ef       	ldi	r18, 0xF0	; 240
 310:	92 07       	cpc	r25, r18
 312:	99 f0       	breq	.+38     	; 0x33a <button_routine+0x68>
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
 314:	4f 5f       	subi	r20, 0xFF	; 255
 316:	48 30       	cpi	r20, 0x08	; 8
 318:	28 f5       	brcc	.+74     	; 0x364 <button_routine+0x92>



int8_t chk_buttons(uint8_t button){
    static uint16_t state = 0;
    state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
 31a:	9c 01       	movw	r18, r24
 31c:	22 0f       	add	r18, r18
 31e:	33 1f       	adc	r19, r19
 320:	89 b3       	in	r24, 0x19	; 25
 322:	90 e0       	ldi	r25, 0x00	; 0
 324:	04 2e       	mov	r0, r20
 326:	02 c0       	rjmp	.+4      	; 0x32c <button_routine+0x5a>
 328:	95 95       	asr	r25
 32a:	87 95       	ror	r24
 32c:	0a 94       	dec	r0
 32e:	e2 f7       	brpl	.-8      	; 0x328 <button_routine+0x56>
 330:	80 ff       	sbrs	r24, 0
 332:	e4 cf       	rjmp	.-56     	; 0x2fc <button_routine+0x2a>
 334:	80 e0       	ldi	r24, 0x00	; 0
 336:	90 ee       	ldi	r25, 0xE0	; 224
 338:	e3 cf       	rjmp	.-58     	; 0x300 <button_routine+0x2e>
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
		button = value;
	    //Check the state of buttons
	    if(button == 0){
 33a:	51 11       	cpse	r21, r1
 33c:	14 c0       	rjmp	.+40     	; 0x366 <button_routine+0x94>
		modeA = !modeA;   //Inverse everytime button0 is pressed
 33e:	21 e0       	ldi	r18, 0x01	; 1
 340:	30 91 1e 01 	lds	r19, 0x011E
 344:	31 11       	cpse	r19, r1
 346:	20 e0       	ldi	r18, 0x00	; 0
 348:	20 93 1e 01 	sts	0x011E, r18
 34c:	30 91 1d 01 	lds	r19, 0x011D
	    else if( button == 1){  //Inverse everytime button1 is pressed  
		modeB = !modeB;
		//value = 2;
	    } 
	    //value = value + 100;
	    if (modeA && modeB){    //If both modes are on, add 0
 350:	21 11       	cpse	r18, r1
 352:	11 c0       	rjmp	.+34     	; 0x376 <button_routine+0xa4>
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
	    }
	    else if (modeB && !modeA){ //1-off 2-on add 4
 354:	33 23       	and	r19, r19
 356:	a9 f0       	breq	.+42     	; 0x382 <button_routine+0xb0>
		//value = modeB;
		dif =  4;
 358:	e0 93 00 01 	sts	0x0100, r30
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
		button = value;
 35c:	45 2f       	mov	r20, r21
    //enable tristate buffer for pushbutton switches
    PORTB |= 0x70; //Set S2,S1,S0 to 111
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
 35e:	4f 5f       	subi	r20, 0xFF	; 255
 360:	48 30       	cpi	r20, 0x08	; 8
 362:	d8 f2       	brcs	.-74     	; 0x31a <button_routine+0x48>
 364:	08 95       	ret
	    //Check the state of buttons
	    if(button == 0){
		modeA = !modeA;   //Inverse everytime button0 is pressed
		//value = 1;
	    }
	    else if( button == 1){  //Inverse everytime button1 is pressed  
 366:	51 30       	cpi	r21, 0x01	; 1
 368:	a1 f0       	breq	.+40     	; 0x392 <button_routine+0xc0>
 36a:	30 91 1d 01 	lds	r19, 0x011D
 36e:	20 91 1e 01 	lds	r18, 0x011E
		modeB = !modeB;
		//value = 2;
	    } 
	    //value = value + 100;
	    if (modeA && modeB){    //If both modes are on, add 0
 372:	22 23       	and	r18, r18
 374:	79 f3       	breq	.-34     	; 0x354 <button_routine+0x82>
 376:	33 23       	and	r19, r19
 378:	41 f0       	breq	.+16     	; 0x38a <button_routine+0xb8>
		//value = 4;
		dif = 0;
 37a:	10 92 00 01 	sts	0x0100, r1
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
		button = value;
 37e:	45 2f       	mov	r20, r21
		//value = 2;
	    } 
	    //value = value + 100;
	    if (modeA && modeB){    //If both modes are on, add 0
		//value = 4;
		dif = 0;
 380:	c9 cf       	rjmp	.-110    	; 0x314 <button_routine+0x42>
	    else if (modeB && !modeA){ //1-off 2-on add 4
		//value = modeB;
		dif =  4;
	    }
	    else {               //both off add 1
		dif = 1;
 382:	60 93 00 01 	sts	0x0100, r22
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
		button = value;
 386:	45 2f       	mov	r20, r21
 388:	c5 cf       	rjmp	.-118    	; 0x314 <button_routine+0x42>
		dif = 0;
	    }
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
 38a:	70 93 00 01 	sts	0x0100, r23
    __asm__ __volatile__ ("nop");
    __asm__ __volatile__ ("nop");
    //now check each button and increment the count as needed
    for (button = 0 ; button < BUTTON_COUNT ; button++){
	if (chk_buttons(button)){
		button = value;
 38e:	45 2f       	mov	r20, r21
		dif = 0;
	    }
	    else if(modeA && !modeB){ //1-on 2-off add 2
		//value = modeA;
		// value = 4;
		dif =  2;
 390:	c1 cf       	rjmp	.-126    	; 0x314 <button_routine+0x42>
	    if(button == 0){
		modeA = !modeA;   //Inverse everytime button0 is pressed
		//value = 1;
	    }
	    else if( button == 1){  //Inverse everytime button1 is pressed  
		modeB = !modeB;
 392:	31 e0       	ldi	r19, 0x01	; 1
 394:	20 91 1d 01 	lds	r18, 0x011D
 398:	21 11       	cpse	r18, r1
 39a:	05 c0       	rjmp	.+10     	; 0x3a6 <button_routine+0xd4>
 39c:	30 93 1d 01 	sts	0x011D, r19
 3a0:	20 91 1e 01 	lds	r18, 0x011E
 3a4:	d5 cf       	rjmp	.-86     	; 0x350 <button_routine+0x7e>
 3a6:	30 e0       	ldi	r19, 0x00	; 0
 3a8:	30 93 1d 01 	sts	0x011D, r19
 3ac:	20 91 1e 01 	lds	r18, 0x011E
 3b0:	cf cf       	rjmp	.-98     	; 0x350 <button_routine+0x7e>

000003b2 <SPI_init>:
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 3b2:	81 e5       	ldi	r24, 0x51	; 81
 3b4:	8d b9       	out	0x0d, r24	; 13
 3b6:	08 95       	ret

000003b8 <SPI_Transmit>:
/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){

    SPDR = data;    //Write data to SPDR
 3b8:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 3ba:	77 9b       	sbis	0x0e, 7	; 14
 3bc:	fe cf       	rjmp	.-4      	; 0x3ba <SPI_Transmit+0x2>
}
 3be:	08 95       	ret

000003c0 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
    PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
 3c0:	83 b1       	in	r24, 0x03	; 3
 3c2:	13 b8       	out	0x03, r1	; 3
    __asm__ __volatile__ ("nop");
 3c4:	00 00       	nop
    __asm__ __volatile__ ("nop");
 3c6:	00 00       	nop
    // Wait until 8 clock cycles are done 
    SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
 3c8:	1f b8       	out	0x0f, r1	; 15
    PORTE |= (1 << PE6);  
 3ca:	1e 9a       	sbi	0x03, 6	; 3
    __asm__ __volatile__ ("nop");
 3cc:	00 00       	nop
    __asm__ __volatile__ ("nop");
 3ce:	00 00       	nop
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
 3d0:	77 9b       	sbis	0x0e, 7	; 14
 3d2:	fe cf       	rjmp	.-4      	; 0x3d0 <SPI_Receive+0x10>
    // Return incoming data from SPDR
    return(SPDR);  
 3d4:	8f b1       	in	r24, 0x0f	; 15
}
 3d6:	08 95       	ret

000003d8 <bar_graph>:
 **************************************************************************/
void bar_graph(){

    uint8_t write = 0;
    //If mode A is selected -> xxxxxxx1
    if(modeA){
 3d8:	81 e0       	ldi	r24, 0x01	; 1
 3da:	90 91 1e 01 	lds	r25, 0x011E
 3de:	91 11       	cpse	r25, r1
 3e0:	01 c0       	rjmp	.+2      	; 0x3e4 <bar_graph+0xc>
 3e2:	80 e0       	ldi	r24, 0x00	; 0
    //If mode A is not selected -> xxxxxxx0
    else if(!modeA){
	write &= 0xFE;
    }
    //If mode b is selected -> xxxxxxx1x
    if(modeB){
 3e4:	90 91 1d 01 	lds	r25, 0x011D
 3e8:	91 11       	cpse	r25, r1
	write |= 0x02;
 3ea:	82 60       	ori	r24, 0x02	; 2
/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){

    SPDR = data;    //Write data to SPDR
 3ec:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF))){} //SPIN write
 3ee:	77 9b       	sbis	0x0e, 7	; 14
 3f0:	fe cf       	rjmp	.-4      	; 0x3ee <bar_graph+0x16>
    else if(!modeB){
	write &= 0xFD;
    }
    //Write the bargraph to SPI
    SPI_Transmit(write);
    PORTD = (1 << PD2);  //Push data out of SPI
 3f2:	84 e0       	ldi	r24, 0x04	; 4
 3f4:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop"); //Buffer
 3f6:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 3f8:	00 00       	nop


    PORTD = (2 << PD2);  // Push data out of SPI
 3fa:	88 e0       	ldi	r24, 0x08	; 8
 3fc:	82 bb       	out	0x12, r24	; 18
    __asm__ __volatile__ ("nop");  //Buffer
 3fe:	00 00       	nop
    __asm__ __volatile__ ("nop");  //Buffer
 400:	00 00       	nop
 402:	08 95       	ret

00000404 <display_update>:
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    int display_segment;
    segsum(value);
 404:	80 91 14 01 	lds	r24, 0x0114
 408:	90 91 15 01 	lds	r25, 0x0115
 40c:	0e 94 b1 00 	call	0x162	; 0x162 <segsum>
    DDRA = 0xFF;  //switch PORTA to output
 410:	8f ef       	ldi	r24, 0xFF	; 255
 412:	8a bb       	out	0x1a, r24	; 26
    __asm__ __volatile__ ("nop"); //Buffer
 414:	00 00       	nop
    __asm__ __volatile__ ("nop"); //Buffer 
 416:	00 00       	nop
 418:	eb e2       	ldi	r30, 0x2B	; 43
 41a:	f1 e0       	ldi	r31, 0x01	; 1
    for(display_segment = 0 ; display_segment < MAX_SEGMENT ; display_segment++){
 41c:	80 e0       	ldi	r24, 0x00	; 0
 41e:	90 e0       	ldi	r25, 0x00	; 0
	//send PORTB the digit to display
	//value = 1;
	//segsum(value);
	PORTB &= 0x8F;
 420:	28 b3       	in	r18, 0x18	; 24
 422:	2f 78       	andi	r18, 0x8F	; 143
 424:	28 bb       	out	0x18, r18	; 24
	PORTB |= display_segment << 4;
 426:	48 b3       	in	r20, 0x18	; 24
 428:	9c 01       	movw	r18, r24
 42a:	22 95       	swap	r18
 42c:	32 95       	swap	r19
 42e:	30 7f       	andi	r19, 0xF0	; 240
 430:	32 27       	eor	r19, r18
 432:	20 7f       	andi	r18, 0xF0	; 240
 434:	32 27       	eor	r19, r18
 436:	42 2b       	or	r20, r18
 438:	48 bb       	out	0x18, r20	; 24
	//send 7 segment code to LED segments
	//update digit to display
	PORTA = segment_data[display_segment];	
 43a:	21 91       	ld	r18, Z+
 43c:	2b bb       	out	0x1b, r18	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 43e:	af e1       	ldi	r26, 0x1F	; 31
 440:	b3 e0       	ldi	r27, 0x03	; 3
 442:	11 97       	sbiw	r26, 0x01	; 1
 444:	f1 f7       	brne	.-4      	; 0x442 <display_update+0x3e>
 446:	00 c0       	rjmp	.+0      	; 0x448 <display_update+0x44>
 448:	00 00       	nop
    int display_segment;
    segsum(value);
    DDRA = 0xFF;  //switch PORTA to output
    __asm__ __volatile__ ("nop"); //Buffer
    __asm__ __volatile__ ("nop"); //Buffer 
    for(display_segment = 0 ; display_segment < MAX_SEGMENT ; display_segment++){
 44a:	01 96       	adiw	r24, 0x01	; 1
 44c:	85 30       	cpi	r24, 0x05	; 5
 44e:	91 05       	cpc	r25, r1
 450:	39 f7       	brne	.-50     	; 0x420 <display_update+0x1c>
	//send 7 segment code to LED segments
	//update digit to display
	PORTA = segment_data[display_segment];	
	_delay_us(200);
    }
}
 452:	08 95       	ret

00000454 <decode_spi_left_knob>:
    uint8_t sw_index = 0;
    //Counter for preventing unneccessary reset    
    static uint8_t acount1 = 0;
    static uint8_t previous_encoder1 = 0; //Initialize previous    
    uint8_t direction = 0;                    //Direction variable
    encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
 454:	8c 70       	andi	r24, 0x0C	; 12
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	95 95       	asr	r25
 45a:	87 95       	ror	r24
 45c:	95 95       	asr	r25
 45e:	87 95       	ror	r24
 460:	38 2f       	mov	r19, r24
    sw_index = (previous_encoder1 << 2) | encoder1; 
 462:	e0 91 19 01 	lds	r30, 0x0119
 466:	ee 0f       	add	r30, r30
 468:	ee 0f       	add	r30, r30
 46a:	e8 2b       	or	r30, r24
    /*shift previous to the left use it as an index Since
      we know the pattern of the knob when it is turning
      Use that data to compare with the table to determine
      Which way it is turning*/
    direction = sw_table[sw_index];
 46c:	f0 e0       	ldi	r31, 0x00	; 0
 46e:	ef 5f       	subi	r30, 0xFF	; 255
 470:	fe 4f       	sbci	r31, 0xFE	; 254
 472:	20 81       	ld	r18, Z
    //Read out the direction from table
    //value = acount2;
    if(direction == CW){  //If CW, add counter
 474:	21 30       	cpi	r18, 0x01	; 1
 476:	39 f1       	breq	.+78     	; 0x4c6 <decode_spi_left_knob+0x72>
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
 478:	22 30       	cpi	r18, 0x02	; 2
 47a:	29 f0       	breq	.+10     	; 0x486 <decode_spi_left_knob+0x32>
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 47c:	33 30       	cpi	r19, 0x03	; 3
 47e:	51 f0       	breq	.+20     	; 0x494 <decode_spi_left_knob+0x40>
	    value = value - dif;
	}
	//update_number();                 //Check number in the routine
	acount1 = 0;                     //Reset counter
    }
    previous_encoder1 = encoder1;
 480:	80 93 19 01 	sts	0x0119, r24
 484:	08 95       	ret
    //value = acount2;
    if(direction == CW){  //If CW, add counter
	acount1++;
    }	
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
 486:	20 91 18 01 	lds	r18, 0x0118
 48a:	21 50       	subi	r18, 0x01	; 1
 48c:	20 93 18 01 	sts	0x0118, r18
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
 490:	33 30       	cpi	r19, 0x03	; 3
 492:	b1 f7       	brne	.-20     	; 0x480 <decode_spi_left_knob+0x2c>
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
 494:	20 91 18 01 	lds	r18, 0x0118
 498:	3e ef       	ldi	r19, 0xFE	; 254
 49a:	32 0f       	add	r19, r18
 49c:	38 30       	cpi	r19, 0x08	; 8
 49e:	c8 f0       	brcs	.+50     	; 0x4d2 <decode_spi_left_knob+0x7e>
	    value = value + dif;
	}
	if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
 4a0:	21 3f       	cpi	r18, 0xF1	; 241
 4a2:	60 f0       	brcs	.+24     	; 0x4bc <decode_spi_left_knob+0x68>
	    value = value - dif;
 4a4:	40 91 00 01 	lds	r20, 0x0100
 4a8:	20 91 14 01 	lds	r18, 0x0114
 4ac:	30 91 15 01 	lds	r19, 0x0115
 4b0:	24 1b       	sub	r18, r20
 4b2:	31 09       	sbc	r19, r1
 4b4:	30 93 15 01 	sts	0x0115, r19
 4b8:	20 93 14 01 	sts	0x0114, r18
	}
	//update_number();                 //Check number in the routine
	acount1 = 0;                     //Reset counter
 4bc:	10 92 18 01 	sts	0x0118, r1
    }
    previous_encoder1 = encoder1;
 4c0:	80 93 19 01 	sts	0x0119, r24
 4c4:	08 95       	ret
      Which way it is turning*/
    direction = sw_table[sw_index];
    //Read out the direction from table
    //value = acount2;
    if(direction == CW){  //If CW, add counter
	acount1++;
 4c6:	20 91 18 01 	lds	r18, 0x0118
 4ca:	2f 5f       	subi	r18, 0xFF	; 255
 4cc:	20 93 18 01 	sts	0x0118, r18
 4d0:	d5 cf       	rjmp	.-86     	; 0x47c <decode_spi_left_knob+0x28>
    if(direction == CCW){ //If CCW, decrement counter
	acount1--;
    }
    if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
	if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
	    value = value + dif;
 4d2:	40 91 00 01 	lds	r20, 0x0100
 4d6:	20 91 14 01 	lds	r18, 0x0114
 4da:	30 91 15 01 	lds	r19, 0x0115
 4de:	24 0f       	add	r18, r20
 4e0:	31 1d       	adc	r19, r1
 4e2:	30 93 15 01 	sts	0x0115, r19
 4e6:	20 93 14 01 	sts	0x0114, r18
 4ea:	e8 cf       	rjmp	.-48     	; 0x4bc <decode_spi_left_knob+0x68>

000004ec <decode_spi_right_knob>:
void decode_spi_right_knob(uint8_t encoder2){
    uint8_t sw_index = 0;
    static uint8_t acount2 = 0;
    static uint8_t previous_encoder2 = 0;
    uint8_t direction = 0;
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
 4ec:	83 70       	andi	r24, 0x03	; 3
    sw_index = (previous_encoder2 << 2) | encoder2;
 4ee:	e0 91 17 01 	lds	r30, 0x0117
 4f2:	ee 0f       	add	r30, r30
 4f4:	ee 0f       	add	r30, r30
 4f6:	e8 2b       	or	r30, r24
    direction = sw_table[sw_index];
 4f8:	f0 e0       	ldi	r31, 0x00	; 0
 4fa:	ef 5f       	subi	r30, 0xFF	; 255
 4fc:	fe 4f       	sbci	r31, 0xFE	; 254
 4fe:	90 81       	ld	r25, Z
    //value = modeA;
    if(direction == CW){
 500:	91 30       	cpi	r25, 0x01	; 1
 502:	39 f1       	breq	.+78     	; 0x552 <decode_spi_right_knob+0x66>
	acount2++;
    }	
    if(direction == CCW){
 504:	92 30       	cpi	r25, 0x02	; 2
 506:	29 f0       	breq	.+10     	; 0x512 <decode_spi_right_knob+0x26>
	acount2--;
    }
    if(encoder2 == 3){
 508:	83 30       	cpi	r24, 0x03	; 3
 50a:	51 f0       	breq	.+20     	; 0x520 <decode_spi_right_knob+0x34>
	    value = value - dif;
	}
	//update_number();
	acount2 = 0;
    }
    previous_encoder2 = encoder2;
 50c:	80 93 17 01 	sts	0x0117, r24
 510:	08 95       	ret
    //value = modeA;
    if(direction == CW){
	acount2++;
    }	
    if(direction == CCW){
	acount2--;
 512:	90 91 16 01 	lds	r25, 0x0116
 516:	91 50       	subi	r25, 0x01	; 1
 518:	90 93 16 01 	sts	0x0116, r25
    }
    if(encoder2 == 3){
 51c:	83 30       	cpi	r24, 0x03	; 3
 51e:	b1 f7       	brne	.-20     	; 0x50c <decode_spi_right_knob+0x20>
	if((acount2 > 1) && (acount2 < 10)){
 520:	90 91 16 01 	lds	r25, 0x0116
 524:	2e ef       	ldi	r18, 0xFE	; 254
 526:	29 0f       	add	r18, r25
 528:	28 30       	cpi	r18, 0x08	; 8
 52a:	c8 f0       	brcs	.+50     	; 0x55e <decode_spi_right_knob+0x72>
	    value = value + dif;
	}
	if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
 52c:	91 3f       	cpi	r25, 0xF1	; 241
 52e:	60 f0       	brcs	.+24     	; 0x548 <decode_spi_right_knob+0x5c>
	    value = value - dif;
 530:	90 91 00 01 	lds	r25, 0x0100
 534:	20 91 14 01 	lds	r18, 0x0114
 538:	30 91 15 01 	lds	r19, 0x0115
 53c:	29 1b       	sub	r18, r25
 53e:	31 09       	sbc	r19, r1
 540:	30 93 15 01 	sts	0x0115, r19
 544:	20 93 14 01 	sts	0x0114, r18
	}
	//update_number();
	acount2 = 0;
 548:	10 92 16 01 	sts	0x0116, r1
    }
    previous_encoder2 = encoder2;
 54c:	80 93 17 01 	sts	0x0117, r24
 550:	08 95       	ret
    encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    sw_index = (previous_encoder2 << 2) | encoder2;
    direction = sw_table[sw_index];
    //value = modeA;
    if(direction == CW){
	acount2++;
 552:	90 91 16 01 	lds	r25, 0x0116
 556:	9f 5f       	subi	r25, 0xFF	; 255
 558:	90 93 16 01 	sts	0x0116, r25
 55c:	d5 cf       	rjmp	.-86     	; 0x508 <decode_spi_right_knob+0x1c>
    if(direction == CCW){
	acount2--;
    }
    if(encoder2 == 3){
	if((acount2 > 1) && (acount2 < 10)){
	    value = value + dif;
 55e:	90 91 00 01 	lds	r25, 0x0100
 562:	20 91 14 01 	lds	r18, 0x0114
 566:	30 91 15 01 	lds	r19, 0x0115
 56a:	29 0f       	add	r18, r25
 56c:	31 1d       	adc	r19, r1
 56e:	30 93 15 01 	sts	0x0115, r19
 572:	20 93 14 01 	sts	0x0114, r18
 576:	e8 cf       	rjmp	.-48     	; 0x548 <decode_spi_right_knob+0x5c>

00000578 <check_knobs>:
    __asm__ __volatile__ ("nop");
    while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    // Return incoming data from SPDR
    return(SPDR);  
}
void check_knobs(void){
 578:	cf 93       	push	r28
 57a:	df 93       	push	r29
    static uint8_t encoder;
    encoder  = SPI_Receive();
 57c:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <SPI_Receive>
 580:	80 93 1a 01 	sts	0x011A, r24
    decode_spi_left_knob(encoder);
 584:	c8 2f       	mov	r28, r24
 586:	d0 e0       	ldi	r29, 0x00	; 0
 588:	ce 01       	movw	r24, r28
 58a:	0e 94 2a 02 	call	0x454	; 0x454 <decode_spi_left_knob>
    decode_spi_right_knob(encoder);
 58e:	ce 01       	movw	r24, r28
}
 590:	df 91       	pop	r29
 592:	cf 91       	pop	r28
}
void check_knobs(void){
    static uint8_t encoder;
    encoder  = SPI_Receive();
    decode_spi_left_knob(encoder);
    decode_spi_right_knob(encoder);
 594:	0c 94 76 02 	jmp	0x4ec	; 0x4ec <decode_spi_right_knob>

00000598 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
 598:	1f 92       	push	r1
 59a:	0f 92       	push	r0
 59c:	0f b6       	in	r0, 0x3f	; 63
 59e:	0f 92       	push	r0
 5a0:	11 24       	eor	r1, r1
 5a2:	0b b6       	in	r0, 0x3b	; 59
 5a4:	0f 92       	push	r0
 5a6:	2f 93       	push	r18
 5a8:	3f 93       	push	r19
 5aa:	4f 93       	push	r20
 5ac:	5f 93       	push	r21
 5ae:	6f 93       	push	r22
 5b0:	7f 93       	push	r23
 5b2:	8f 93       	push	r24
 5b4:	9f 93       	push	r25
 5b6:	af 93       	push	r26
 5b8:	bf 93       	push	r27
 5ba:	ef 93       	push	r30
 5bc:	ff 93       	push	r31
    check_knobs();
 5be:	0e 94 bc 02 	call	0x578	; 0x578 <check_knobs>
    display_update();
 5c2:	0e 94 02 02 	call	0x404	; 0x404 <display_update>
    button_routine();
 5c6:	0e 94 69 01 	call	0x2d2	; 0x2d2 <button_routine>
}
 5ca:	ff 91       	pop	r31
 5cc:	ef 91       	pop	r30
 5ce:	bf 91       	pop	r27
 5d0:	af 91       	pop	r26
 5d2:	9f 91       	pop	r25
 5d4:	8f 91       	pop	r24
 5d6:	7f 91       	pop	r23
 5d8:	6f 91       	pop	r22
 5da:	5f 91       	pop	r21
 5dc:	4f 91       	pop	r20
 5de:	3f 91       	pop	r19
 5e0:	2f 91       	pop	r18
 5e2:	0f 90       	pop	r0
 5e4:	0b be       	out	0x3b, r0	; 59
 5e6:	0f 90       	pop	r0
 5e8:	0f be       	out	0x3f, r0	; 63
 5ea:	0f 90       	pop	r0
 5ec:	1f 90       	pop	r1
 5ee:	18 95       	reti

000005f0 <update_number>:
    }
    previous_encoder2 = encoder2;
}

void update_number(void){
    if (value > (0-MAX_SUM)){
 5f0:	80 91 14 01 	lds	r24, 0x0114
 5f4:	90 91 15 01 	lds	r25, 0x0115
 5f8:	82 30       	cpi	r24, 0x02	; 2
 5fa:	2c ef       	ldi	r18, 0xFC	; 252
 5fc:	92 07       	cpc	r25, r18
 5fe:	58 f4       	brcc	.+22     	; 0x616 <update_number+0x26>
	value = MAX_SUM - (dif-1);                       	
    }
    else if (value > MAX_SUM){
 600:	81 15       	cp	r24, r1
 602:	24 e0       	ldi	r18, 0x04	; 4
 604:	92 07       	cpc	r25, r18
 606:	30 f0       	brcs	.+12     	; 0x614 <update_number+0x24>
	value = value - MAX_SUM;
 608:	8f 5f       	subi	r24, 0xFF	; 255
 60a:	93 40       	sbci	r25, 0x03	; 3
 60c:	90 93 15 01 	sts	0x0115, r25
 610:	80 93 14 01 	sts	0x0114, r24
 614:	08 95       	ret
    previous_encoder2 = encoder2;
}

void update_number(void){
    if (value > (0-MAX_SUM)){
	value = MAX_SUM - (dif-1);                       	
 616:	20 91 00 01 	lds	r18, 0x0100
 61a:	80 e0       	ldi	r24, 0x00	; 0
 61c:	94 e0       	ldi	r25, 0x04	; 4
 61e:	82 1b       	sub	r24, r18
 620:	91 09       	sbc	r25, r1
 622:	90 93 15 01 	sts	0x0115, r25
 626:	80 93 14 01 	sts	0x0114, r24
 62a:	08 95       	ret

0000062c <main>:

//***********************************************************************************
int main()
{
    //set port bits 4-7 B as outputs
    DDRE = 0xc0;
 62c:	80 ec       	ldi	r24, 0xC0	; 192
 62e:	82 b9       	out	0x02, r24	; 2
    PORTE &= 0x7F;
 630:	1f 98       	cbi	0x03, 7	; 3
    DDRB = 0xF7;
 632:	87 ef       	ldi	r24, 0xF7	; 247
 634:	87 bb       	out	0x17, r24	; 23
    DDRD |= (1 << PB2);
 636:	8a 9a       	sbi	0x11, 2	; 17

    segment_data[2] = OFF;
 638:	8f ef       	ldi	r24, 0xFF	; 255
 63a:	80 93 2d 01 	sts	0x012D, r24

    TIMSK |= (1<<TOIE0);             //enable interrupts
 63e:	87 b7       	in	r24, 0x37	; 55
 640:	81 60       	ori	r24, 0x01	; 1
 642:	87 bf       	out	0x37, r24	; 55
    TCCR0 |= (1<<CS00) | (1<<CS10);  //normal mode, prescale by 128
 644:	83 b7       	in	r24, 0x33	; 51
 646:	81 60       	ori	r24, 0x01	; 1
 648:	83 bf       	out	0x33, r24	; 51
void SPI_init(){
    /* Set MOSI and SCK output, all others input */
    //DDRB = (1<<PB3)|(1<<PB1);

    /* Enable SPI, Master, set clock rate fck/16 */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 64a:	81 e5       	ldi	r24, 0x51	; 81
 64c:	8d b9       	out	0x0d, r24	; 13
    segment_data[2] = OFF;

    TIMSK |= (1<<TOIE0);             //enable interrupts
    TCCR0 |= (1<<CS00) | (1<<CS10);  //normal mode, prescale by 128
    SPI_init();
    sei();
 64e:	78 94       	sei
    while(1){
	bar_graph();
 650:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <bar_graph>
	display_update();
 654:	0e 94 02 02 	call	0x404	; 0x404 <display_update>
 658:	fb cf       	rjmp	.-10     	; 0x650 <main+0x24>

0000065a <__umulhisi3>:
 65a:	a2 9f       	mul	r26, r18
 65c:	b0 01       	movw	r22, r0
 65e:	b3 9f       	mul	r27, r19
 660:	c0 01       	movw	r24, r0
 662:	a3 9f       	mul	r26, r19
 664:	70 0d       	add	r23, r0
 666:	81 1d       	adc	r24, r1
 668:	11 24       	eor	r1, r1
 66a:	91 1d       	adc	r25, r1
 66c:	b2 9f       	mul	r27, r18
 66e:	70 0d       	add	r23, r0
 670:	81 1d       	adc	r24, r1
 672:	11 24       	eor	r1, r1
 674:	91 1d       	adc	r25, r1
 676:	08 95       	ret

00000678 <_exit>:
 678:	f8 94       	cli

0000067a <__stop_program>:
 67a:	ff cf       	rjmp	.-2      	; 0x67a <__stop_program>
