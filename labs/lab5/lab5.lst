
lab5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  00001dcc  00001e60  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001dcc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b6  00800136  00800136  00001e96  2**0
                  ALLOC
  3 .stab         00004e54  00000000  00000000  00001e98  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000196a  00000000  00000000  00006cec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00008656  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      1c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__vector_10>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 9e 07 	jmp	0xf3c	; 0xf3c <__vector_12>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 1a 07 	jmp	0xe34	; 0xe34 <__vector_16>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 17 08 	jmp	0x102e	; 0x102e <__vector_21>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 82 0b 	jmp	0x1704	; 0x1704 <__vector_33>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	87 01       	movw	r16, r14
      8e:	8f 01       	movw	r16, r30
      90:	97 01       	movw	r18, r14
      92:	9f 01       	movw	r18, r30
      94:	a7 01       	movw	r20, r14
      96:	b0 01       	movw	r22, r0
      98:	b9 01       	movw	r22, r18
      9a:	77 01       	movw	r14, r14
      9c:	7f 01       	movw	r14, r30
      9e:	0d 03       	fmul	r16, r21
      a0:	05 03       	mulsu	r16, r21
      a2:	00 03       	mulsu	r16, r16
      a4:	2a 03       	fmul	r18, r18
      a6:	1d 03       	fmul	r17, r21
      a8:	25 03       	mulsu	r18, r21
      aa:	15 03       	mulsu	r17, r21
      ac:	de 02       	muls	r29, r30
      ae:	d6 02       	muls	r29, r22
      b0:	d1 02       	muls	r29, r17
      b2:	c9 02       	muls	r28, r25
      b4:	32 03       	mulsu	r19, r18
      b6:	e6 02       	muls	r30, r22
      b8:	bc 02       	muls	r27, r28
      ba:	a4 02       	muls	r26, r20
      bc:	52 03       	mulsu	r21, r18
      be:	fb 02       	muls	r31, r27
      c0:	f3 02       	muls	r31, r19
      c2:	eb 02       	muls	r30, r27
      c4:	72 03       	mulsu	r23, r18
      c6:	ac 02       	muls	r26, r28
      c8:	62 03       	mulsu	r22, r18
      ca:	b4 02       	muls	r27, r20
      cc:	7f 03       	fmul	r23, r23
      ce:	4a 03       	fmul	r20, r18
      d0:	6a 03       	fmul	r22, r18
      d2:	c4 02       	muls	r28, r20
      d4:	42 03       	mulsu	r20, r18
      d6:	3a 03       	fmul	r19, r18
      d8:	5a 03       	fmul	r21, r18
      da:	9f 02       	muls	r25, r31
      dc:	6d 02       	muls	r22, r29
      de:	65 02       	muls	r22, r21
      e0:	75 02       	muls	r23, r21
      e2:	77 03       	mulsu	r23, r23
      e4:	58 02       	muls	r21, r24
      e6:	50 02       	muls	r21, r16
      e8:	7a 02       	muls	r23, r26
      ea:	33 02       	muls	r19, r19
      ec:	97 02       	muls	r25, r23
      ee:	60 02       	muls	r22, r16
      f0:	43 02       	muls	r20, r19
      f2:	3b 02       	muls	r19, r27
      f4:	87 02       	muls	r24, r23
      f6:	4b 02       	muls	r20, r27
      f8:	7f 02       	muls	r23, r31
      fa:	2b 02       	muls	r18, r27
      fc:	11 02       	muls	r17, r17
      fe:	8f 02       	muls	r24, r31
     100:	01 02       	muls	r16, r17
     102:	f9 01       	movw	r30, r18
     104:	1e 02       	muls	r17, r30
     106:	16 02       	muls	r17, r22
     108:	23 02       	muls	r18, r19
     10a:	f4 01       	movw	r30, r8
     10c:	09 02       	muls	r16, r25
     10e:	dc 01       	movw	r26, r24
     110:	ec 01       	movw	r28, r24
     112:	d7 01       	movw	r26, r14
     114:	cf 01       	movw	r24, r30
     116:	c7 01       	movw	r24, r14
     118:	c2 01       	movw	r24, r4
     11a:	e4 01       	movw	r28, r8
     11c:	89 04       	cpc	r8, r9
     11e:	a7 04       	cpc	r10, r7
     120:	83 04       	cpc	r8, r3
     122:	95 04       	cpc	r9, r5
     124:	77 04       	cpc	r7, r7
     126:	7d 04       	cpc	r7, r13
     128:	77 04       	cpc	r7, r7
     12a:	7d 04       	cpc	r7, r13
     12c:	ad 04       	cpc	r10, r13
     12e:	89 04       	cpc	r8, r9
     130:	a7 04       	cpc	r10, r7
     132:	83 04       	cpc	r8, r3
     134:	95 04       	cpc	r9, r5
     136:	8f 04       	cpc	r8, r15
     138:	71 04       	cpc	r7, r1
     13a:	8f 04       	cpc	r8, r15
     13c:	71 04       	cpc	r7, r1
     13e:	d7 04       	cpc	r13, r7
     140:	13 05       	cpc	r17, r3
     142:	cb 04       	cpc	r12, r11
     144:	43 05       	cpc	r20, r3
     146:	cb 04       	cpc	r12, r11
     148:	07 05       	cpc	r16, r7
     14a:	01 05       	cpc	r16, r1
     14c:	71 04       	cpc	r7, r1
     14e:	dd 04       	cpc	r13, r13
     150:	71 04       	cpc	r7, r1
     152:	ef 04       	cpc	r14, r15
     154:	9b 04       	cpc	r9, r11
     156:	31 05       	cpc	r19, r1
     158:	77 04       	cpc	r7, r7
     15a:	25 05       	cpc	r18, r5
     15c:	b3 04       	cpc	r11, r3
     15e:	2b 05       	cpc	r18, r11
     160:	b9 04       	cpc	r11, r9
     162:	37 05       	cpc	r19, r7
     164:	fb 04       	cpc	r15, r11
     166:	a1 04       	cpc	r10, r1
     168:	9b 04       	cpc	r9, r11
     16a:	e3 04       	cpc	r14, r3
     16c:	bf 04       	cpc	r11, r15
     16e:	89 04       	cpc	r8, r9
     170:	a7 04       	cpc	r10, r7
     172:	83 04       	cpc	r8, r3
     174:	95 04       	cpc	r9, r5
     176:	77 04       	cpc	r7, r7
     178:	7d 04       	cpc	r7, r13
     17a:	77 04       	cpc	r7, r7
     17c:	7d 04       	cpc	r7, r13
     17e:	ad 04       	cpc	r10, r13
     180:	89 04       	cpc	r8, r9
     182:	0d 05       	cpc	r16, r13
     184:	a1 04       	cpc	r10, r1
     186:	83 04       	cpc	r8, r3
     188:	8f 04       	cpc	r8, r15
     18a:	71 04       	cpc	r7, r1
     18c:	8f 04       	cpc	r8, r15
     18e:	71 04       	cpc	r7, r1
     190:	d7 04       	cpc	r13, r7
     192:	19 05       	cpc	r17, r9
     194:	e9 04       	cpc	r14, r9
     196:	ad 04       	cpc	r10, r13
     198:	1f 05       	cpc	r17, r15
     19a:	dd 04       	cpc	r13, r13
     19c:	b3 04       	cpc	r11, r3
     19e:	b9 04       	cpc	r11, r9
     1a0:	9b 04       	cpc	r9, r11
     1a2:	a1 04       	cpc	r10, r1
     1a4:	3d 05       	cpc	r19, r13
     1a6:	bf 04       	cpc	r11, r15
     1a8:	e7 06       	cpc	r14, r23
     1aa:	e0 06       	cpc	r14, r16
     1ac:	d9 06       	cpc	r13, r25
     1ae:	d1 06       	cpc	r13, r17
     1b0:	c9 06       	cpc	r12, r25
     1b2:	ee 06       	cpc	r14, r30
     1b4:	fe 06       	cpc	r15, r30
     1b6:	c2 0b       	sbc	r28, r18
     1b8:	99 0b       	sbc	r25, r25
     1ba:	99 0b       	sbc	r25, r25
     1bc:	99 0b       	sbc	r25, r25
     1be:	99 0b       	sbc	r25, r25
     1c0:	99 0b       	sbc	r25, r25
     1c2:	99 0b       	sbc	r25, r25
     1c4:	99 0b       	sbc	r25, r25
     1c6:	c2 0b       	sbc	r28, r18
     1c8:	99 0b       	sbc	r25, r25
     1ca:	99 0b       	sbc	r25, r25
     1cc:	99 0b       	sbc	r25, r25
     1ce:	99 0b       	sbc	r25, r25
     1d0:	99 0b       	sbc	r25, r25
     1d2:	99 0b       	sbc	r25, r25
     1d4:	99 0b       	sbc	r25, r25
     1d6:	cc 0b       	sbc	r28, r28
     1d8:	99 0b       	sbc	r25, r25
     1da:	99 0b       	sbc	r25, r25
     1dc:	99 0b       	sbc	r25, r25
     1de:	99 0b       	sbc	r25, r25
     1e0:	99 0b       	sbc	r25, r25
     1e2:	99 0b       	sbc	r25, r25
     1e4:	99 0b       	sbc	r25, r25
     1e6:	99 0b       	sbc	r25, r25
     1e8:	99 0b       	sbc	r25, r25
     1ea:	99 0b       	sbc	r25, r25
     1ec:	99 0b       	sbc	r25, r25
     1ee:	99 0b       	sbc	r25, r25
     1f0:	99 0b       	sbc	r25, r25
     1f2:	99 0b       	sbc	r25, r25
     1f4:	99 0b       	sbc	r25, r25
     1f6:	cc 0b       	sbc	r28, r28
     1f8:	99 0b       	sbc	r25, r25
     1fa:	99 0b       	sbc	r25, r25
     1fc:	99 0b       	sbc	r25, r25
     1fe:	99 0b       	sbc	r25, r25
     200:	99 0b       	sbc	r25, r25
     202:	99 0b       	sbc	r25, r25
     204:	99 0b       	sbc	r25, r25
     206:	99 0b       	sbc	r25, r25
     208:	99 0b       	sbc	r25, r25
     20a:	99 0b       	sbc	r25, r25
     20c:	99 0b       	sbc	r25, r25
     20e:	99 0b       	sbc	r25, r25
     210:	99 0b       	sbc	r25, r25
     212:	99 0b       	sbc	r25, r25
     214:	99 0b       	sbc	r25, r25
     216:	e3 0b       	sbc	r30, r19
     218:	99 0b       	sbc	r25, r25
     21a:	99 0b       	sbc	r25, r25
     21c:	99 0b       	sbc	r25, r25
     21e:	99 0b       	sbc	r25, r25
     220:	99 0b       	sbc	r25, r25
     222:	99 0b       	sbc	r25, r25
     224:	99 0b       	sbc	r25, r25
     226:	e7 0b       	sbc	r30, r23
     228:	99 0b       	sbc	r25, r25
     22a:	99 0b       	sbc	r25, r25
     22c:	99 0b       	sbc	r25, r25
     22e:	99 0b       	sbc	r25, r25
     230:	99 0b       	sbc	r25, r25
     232:	99 0b       	sbc	r25, r25
     234:	99 0b       	sbc	r25, r25
     236:	99 0b       	sbc	r25, r25
     238:	99 0b       	sbc	r25, r25
     23a:	99 0b       	sbc	r25, r25
     23c:	99 0b       	sbc	r25, r25
     23e:	99 0b       	sbc	r25, r25
     240:	99 0b       	sbc	r25, r25
     242:	99 0b       	sbc	r25, r25
     244:	99 0b       	sbc	r25, r25
     246:	f5 0b       	sbc	r31, r21
     248:	99 0b       	sbc	r25, r25
     24a:	99 0b       	sbc	r25, r25
     24c:	99 0b       	sbc	r25, r25
     24e:	99 0b       	sbc	r25, r25
     250:	99 0b       	sbc	r25, r25
     252:	99 0b       	sbc	r25, r25
     254:	99 0b       	sbc	r25, r25
     256:	b3 0b       	sbc	r27, r19

00000258 <__ctors_end>:
     258:	11 24       	eor	r1, r1
     25a:	1f be       	out	0x3f, r1	; 63
     25c:	cf ef       	ldi	r28, 0xFF	; 255
     25e:	d0 e1       	ldi	r29, 0x10	; 16
     260:	de bf       	out	0x3e, r29	; 62
     262:	cd bf       	out	0x3d, r28	; 61

00000264 <__do_copy_data>:
     264:	11 e0       	ldi	r17, 0x01	; 1
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b1 e0       	ldi	r27, 0x01	; 1
     26a:	ec ec       	ldi	r30, 0xCC	; 204
     26c:	fd e1       	ldi	r31, 0x1D	; 29
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	a6 33       	cpi	r26, 0x36	; 54
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	21 e0       	ldi	r18, 0x01	; 1
     280:	a6 e3       	ldi	r26, 0x36	; 54
     282:	b1 e0       	ldi	r27, 0x01	; 1
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	ac 3e       	cpi	r26, 0xEC	; 236
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <main>
     292:	0c 94 e4 0e 	jmp	0x1dc8	; 0x1dc8 <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <play_rest>:
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     29a:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     29c:	10 92 78 01 	sts	0x0178, r1
     2a0:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	90 93 76 01 	sts	0x0176, r25
     2aa:	80 93 75 01 	sts	0x0175, r24
     2ae:	08 95       	ret

000002b0 <play_note>:
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
     2b0:	cf 93       	push	r28
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
     2b2:	92 98       	cbi	0x12, 2	; 18
  beat = 0;             //reset the beat counter
     2b4:	10 92 78 01 	sts	0x0178, r1
     2b8:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;  //set the max beat
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	30 93 76 01 	sts	0x0176, r19
     2c2:	20 93 75 01 	sts	0x0175, r18
  switch (octave) {
     2c6:	50 e0       	ldi	r21, 0x00	; 0
     2c8:	49 30       	cpi	r20, 0x09	; 9
     2ca:	51 05       	cpc	r21, r1
     2cc:	20 f0       	brcs	.+8      	; 0x2d6 <play_note+0x26>
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
     2ce:	1b bc       	out	0x2b, r1	; 43
     2d0:	1a bc       	out	0x2a, r1	; 42
  }
}
     2d2:	cf 91       	pop	r28
     2d4:	08 95       	ret
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2d6:	4a 5b       	subi	r20, 0xBA	; 186
     2d8:	5f 4f       	sbci	r21, 0xFF	; 255
     2da:	fa 01       	movw	r30, r20
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2dc:	99 27       	eor	r25, r25
     2de:	87 fd       	sbrc	r24, 7
     2e0:	90 95       	com	r25
     2e2:	a9 2f       	mov	r26, r25
     2e4:	b9 2f       	mov	r27, r25
     2e6:	81 54       	subi	r24, 0x41	; 65
     2e8:	91 09       	sbc	r25, r1
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2ea:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
     2ee:	87 30       	cpi	r24, 0x07	; 7
     2f0:	91 05       	cpc	r25, r1
     2f2:	78 f7       	brcc	.-34     	; 0x2d2 <play_note+0x22>
     2f4:	81 5b       	subi	r24, 0xB1	; 177
     2f6:	9f 4f       	sbci	r25, 0xFF	; 255
     2f8:	fc 01       	movw	r30, r24
     2fa:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2fe:	87 30       	cpi	r24, 0x07	; 7
     300:	91 05       	cpc	r25, r1
     302:	38 f7       	brcc	.-50     	; 0x2d2 <play_note+0x22>
     304:	8a 5a       	subi	r24, 0xAA	; 170
     306:	9f 4f       	sbci	r25, 0xFF	; 255
     308:	fc 01       	movw	r30, r24
     30a:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
     30e:	87 30       	cpi	r24, 0x07	; 7
     310:	91 05       	cpc	r25, r1
     312:	f8 f6       	brcc	.-66     	; 0x2d2 <play_note+0x22>
     314:	83 5a       	subi	r24, 0xA3	; 163
     316:	9f 4f       	sbci	r25, 0xFF	; 255
     318:	fc 01       	movw	r30, r24
     31a:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
     31e:	87 30       	cpi	r24, 0x07	; 7
     320:	91 05       	cpc	r25, r1
     322:	b8 f6       	brcc	.-82     	; 0x2d2 <play_note+0x22>
     324:	8c 59       	subi	r24, 0x9C	; 156
     326:	9f 4f       	sbci	r25, 0xFF	; 255
     328:	fc 01       	movw	r30, r24
     32a:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
     32e:	87 30       	cpi	r24, 0x07	; 7
     330:	91 05       	cpc	r25, r1
     332:	78 f6       	brcc	.-98     	; 0x2d2 <play_note+0x22>
     334:	85 59       	subi	r24, 0x95	; 149
     336:	9f 4f       	sbci	r25, 0xFF	; 255
     338:	fc 01       	movw	r30, r24
     33a:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
     33e:	87 30       	cpi	r24, 0x07	; 7
     340:	91 05       	cpc	r25, r1
     342:	38 f6       	brcc	.-114    	; 0x2d2 <play_note+0x22>
     344:	8e 58       	subi	r24, 0x8E	; 142
     346:	9f 4f       	sbci	r25, 0xFF	; 255
     348:	fc 01       	movw	r30, r24
     34a:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
     34e:	87 30       	cpi	r24, 0x07	; 7
     350:	91 05       	cpc	r25, r1
     352:	08 f0       	brcs	.+2      	; 0x356 <play_note+0xa6>
     354:	be cf       	rjmp	.-132    	; 0x2d2 <play_note+0x22>
     356:	87 58       	subi	r24, 0x87	; 135
     358:	9f 4f       	sbci	r25, 0xFF	; 255
     35a:	fc 01       	movw	r30, r24
     35c:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
     360:	87 30       	cpi	r24, 0x07	; 7
     362:	91 05       	cpc	r25, r1
     364:	08 f0       	brcs	.+2      	; 0x368 <play_note+0xb8>
     366:	b5 cf       	rjmp	.-150    	; 0x2d2 <play_note+0x22>
     368:	80 58       	subi	r24, 0x80	; 128
     36a:	9f 4f       	sbci	r25, 0xFF	; 255
     36c:	fc 01       	movw	r30, r24
     36e:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
     372:	87 30       	cpi	r24, 0x07	; 7
     374:	91 05       	cpc	r25, r1
     376:	08 f0       	brcs	.+2      	; 0x37a <play_note+0xca>
     378:	ac cf       	rjmp	.-168    	; 0x2d2 <play_note+0x22>
     37a:	89 57       	subi	r24, 0x79	; 121
     37c:	9f 4f       	sbci	r25, 0xFF	; 255
     37e:	fc 01       	movw	r30, r24
     380:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
     384:	88 e5       	ldi	r24, 0x58	; 88
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	9b bd       	out	0x2b, r25	; 43
     38a:	8a bd       	out	0x2a, r24	; 42
	break;
     38c:	a2 cf       	rjmp	.-188    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
     38e:	66 23       	and	r22, r22
     390:	09 f4       	brne	.+2      	; 0x394 <play_note+0xe4>
     392:	0f c2       	rjmp	.+1054   	; 0x7b2 <play_note+0x502>
     394:	83 e6       	ldi	r24, 0x63	; 99
     396:	90 e0       	ldi	r25, 0x00	; 0
     398:	9b bd       	out	0x2b, r25	; 43
     39a:	8a bd       	out	0x2a, r24	; 42
     39c:	9a cf       	rjmp	.-204    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
     39e:	66 23       	and	r22, r22
     3a0:	09 f4       	brne	.+2      	; 0x3a4 <play_note+0xf4>
     3a2:	11 c2       	rjmp	.+1058   	; 0x7c6 <play_note+0x516>
     3a4:	8f e6       	ldi	r24, 0x6F	; 111
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	9b bd       	out	0x2b, r25	; 43
     3aa:	8a bd       	out	0x2a, r24	; 42
     3ac:	92 cf       	rjmp	.-220    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
     3ae:	86 e7       	ldi	r24, 0x76	; 118
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	9b bd       	out	0x2b, r25	; 43
     3b4:	8a bd       	out	0x2a, r24	; 42
	break;
     3b6:	8d cf       	rjmp	.-230    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
     3b8:	66 23       	and	r22, r22
     3ba:	09 f4       	brne	.+2      	; 0x3be <play_note+0x10e>
     3bc:	ff c1       	rjmp	.+1022   	; 0x7bc <play_note+0x50c>
     3be:	8a e4       	ldi	r24, 0x4A	; 74
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	9b bd       	out	0x2b, r25	; 43
     3c4:	8a bd       	out	0x2a, r24	; 42
     3c6:	85 cf       	rjmp	.-246    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
     3c8:	66 23       	and	r22, r22
     3ca:	09 f4       	brne	.+2      	; 0x3ce <play_note+0x11e>
     3cc:	01 c2       	rjmp	.+1026   	; 0x7d0 <play_note+0x520>
     3ce:	83 e5       	ldi	r24, 0x53	; 83
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	9b bd       	out	0x2b, r25	; 43
     3d4:	8a bd       	out	0x2a, r24	; 42
     3d6:	7d cf       	rjmp	.-262    	; 0x2d2 <play_note+0x22>
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
     3d8:	66 23       	and	r22, r22
     3da:	09 f4       	brne	.+2      	; 0x3de <play_note+0x12e>
     3dc:	b8 c1       	rjmp	.+880    	; 0x74e <play_note+0x49e>
     3de:	82 e4       	ldi	r24, 0x42	; 66
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	9b bd       	out	0x2b, r25	; 43
     3e4:	8a bd       	out	0x2a, r24	; 42
     3e6:	75 cf       	rjmp	.-278    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
     3e8:	81 eb       	ldi	r24, 0xB1	; 177
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	9b bd       	out	0x2b, r25	; 43
     3ee:	8a bd       	out	0x2a, r24	; 42
	break;
     3f0:	70 cf       	rjmp	.-288    	; 0x2d2 <play_note+0x22>
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
     3f2:	66 23       	and	r22, r22
     3f4:	09 f4       	brne	.+2      	; 0x3f8 <play_note+0x148>
     3f6:	d3 c1       	rjmp	.+934    	; 0x79e <play_note+0x4ee>
     3f8:	85 e8       	ldi	r24, 0x85	; 133
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	9b bd       	out	0x2b, r25	; 43
     3fe:	8a bd       	out	0x2a, r24	; 42
     400:	68 cf       	rjmp	.-304    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
     402:	66 23       	and	r22, r22
     404:	09 f4       	brne	.+2      	; 0x408 <play_note+0x158>
     406:	c1 c1       	rjmp	.+898    	; 0x78a <play_note+0x4da>
     408:	85 e9       	ldi	r24, 0x95	; 149
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	9b bd       	out	0x2b, r25	; 43
     40e:	8a bd       	out	0x2a, r24	; 42
     410:	60 cf       	rjmp	.-320    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
     412:	66 23       	and	r22, r22
     414:	09 f4       	brne	.+2      	; 0x418 <play_note+0x168>
     416:	be c1       	rjmp	.+892    	; 0x794 <play_note+0x4e4>
     418:	87 ea       	ldi	r24, 0xA7	; 167
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9b bd       	out	0x2b, r25	; 43
     41e:	8a bd       	out	0x2a, r24	; 42
     420:	58 cf       	rjmp	.-336    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
     422:	84 e6       	ldi	r24, 0x64	; 100
     424:	91 e0       	ldi	r25, 0x01	; 1
     426:	9b bd       	out	0x2b, r25	; 43
     428:	8a bd       	out	0x2a, r24	; 42
	break;
     42a:	53 cf       	rjmp	.-346    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
     42c:	66 23       	and	r22, r22
     42e:	09 f4       	brne	.+2      	; 0x432 <play_note+0x182>
     430:	bb c1       	rjmp	.+886    	; 0x7a8 <play_note+0x4f8>
     432:	80 ee       	ldi	r24, 0xE0	; 224
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	9b bd       	out	0x2b, r25	; 43
     438:	8a bd       	out	0x2a, r24	; 42
     43a:	4b cf       	rjmp	.-362    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
     43c:	8d ee       	ldi	r24, 0xED	; 237
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	9b bd       	out	0x2b, r25	; 43
     442:	8a bd       	out	0x2a, r24	; 42
	break;
     444:	46 cf       	rjmp	.-372    	; 0x2d2 <play_note+0x22>
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
     446:	66 23       	and	r22, r22
     448:	09 f4       	brne	.+2      	; 0x44c <play_note+0x19c>
     44a:	8b c1       	rjmp	.+790    	; 0x762 <play_note+0x4b2>
     44c:	87 ec       	ldi	r24, 0xC7	; 199
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	9b bd       	out	0x2b, r25	; 43
     452:	8a bd       	out	0x2a, r24	; 42
     454:	3e cf       	rjmp	.-388    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
     456:	66 23       	and	r22, r22
     458:	09 f4       	brne	.+2      	; 0x45c <play_note+0x1ac>
     45a:	74 c1       	rjmp	.+744    	; 0x744 <play_note+0x494>
     45c:	80 e9       	ldi	r24, 0x90	; 144
     45e:	91 e0       	ldi	r25, 0x01	; 1
     460:	9b bd       	out	0x2b, r25	; 43
     462:	8a bd       	out	0x2a, r24	; 42
     464:	36 cf       	rjmp	.-404    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
     466:	66 23       	and	r22, r22
     468:	09 f4       	brne	.+2      	; 0x46c <play_note+0x1bc>
     46a:	cb c1       	rjmp	.+918    	; 0x802 <play_note+0x552>
     46c:	84 e8       	ldi	r24, 0x84	; 132
     46e:	93 e0       	ldi	r25, 0x03	; 3
     470:	9b bd       	out	0x2b, r25	; 43
     472:	8a bd       	out	0x2a, r24	; 42
     474:	2e cf       	rjmp	.-420    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
     476:	66 23       	and	r22, r22
     478:	09 f4       	brne	.+2      	; 0x47c <play_note+0x1cc>
     47a:	af c1       	rjmp	.+862    	; 0x7da <play_note+0x52a>
     47c:	8b e2       	ldi	r24, 0x2B	; 43
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	9b bd       	out	0x2b, r25	; 43
     482:	8a bd       	out	0x2a, r24	; 42
     484:	26 cf       	rjmp	.-436    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
     486:	66 23       	and	r22, r22
     488:	09 f4       	brne	.+2      	; 0x48c <play_note+0x1dc>
     48a:	b1 c1       	rjmp	.+866    	; 0x7ee <play_note+0x53e>
     48c:	82 ea       	ldi	r24, 0xA2	; 162
     48e:	92 e0       	ldi	r25, 0x02	; 2
     490:	9b bd       	out	0x2b, r25	; 43
     492:	8a bd       	out	0x2a, r24	; 42
     494:	1e cf       	rjmp	.-452    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
     496:	8c ed       	ldi	r24, 0xDC	; 220
     498:	91 e0       	ldi	r25, 0x01	; 1
     49a:	9b bd       	out	0x2b, r25	; 43
     49c:	8a bd       	out	0x2a, r24	; 42
	break;
     49e:	19 cf       	rjmp	.-462    	; 0x2d2 <play_note+0x22>
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
     4a0:	66 23       	and	r22, r22
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <play_note+0x1f6>
     4a4:	59 c1       	rjmp	.+690    	; 0x758 <play_note+0x4a8>
     4a6:	87 e1       	ldi	r24, 0x17	; 23
     4a8:	92 e0       	ldi	r25, 0x02	; 2
     4aa:	9b bd       	out	0x2b, r25	; 43
     4ac:	8a bd       	out	0x2a, r24	; 42
     4ae:	11 cf       	rjmp	.-478    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
     4b0:	66 23       	and	r22, r22
     4b2:	09 f4       	brne	.+2      	; 0x4b6 <play_note+0x206>
     4b4:	b0 c1       	rjmp	.+864    	; 0x816 <play_note+0x566>
     4b6:	88 e5       	ldi	r24, 0x58	; 88
     4b8:	92 e0       	ldi	r25, 0x02	; 2
     4ba:	9b bd       	out	0x2b, r25	; 43
     4bc:	8a bd       	out	0x2a, r24	; 42
     4be:	09 cf       	rjmp	.-494    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
     4c0:	8a ec       	ldi	r24, 0xCA	; 202
     4c2:	92 e0       	ldi	r25, 0x02	; 2
     4c4:	9b bd       	out	0x2b, r25	; 43
     4c6:	8a bd       	out	0x2a, r24	; 42
	break;
     4c8:	04 cf       	rjmp	.-504    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
     4ca:	66 23       	and	r22, r22
     4cc:	09 f4       	brne	.+2      	; 0x4d0 <play_note+0x220>
     4ce:	35 c1       	rjmp	.+618    	; 0x73a <play_note+0x48a>
     4d0:	86 e4       	ldi	r24, 0x46	; 70
     4d2:	96 e0       	ldi	r25, 0x06	; 6
     4d4:	9b bd       	out	0x2b, r25	; 43
     4d6:	8a bd       	out	0x2a, r24	; 42
     4d8:	fc ce       	rjmp	.-520    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
     4da:	66 23       	and	r22, r22
     4dc:	09 f4       	brne	.+2      	; 0x4e0 <play_note+0x230>
     4de:	82 c1       	rjmp	.+772    	; 0x7e4 <play_note+0x534>
     4e0:	8a e0       	ldi	r24, 0x0A	; 10
     4e2:	97 e0       	ldi	r25, 0x07	; 7
     4e4:	9b bd       	out	0x2b, r25	; 43
     4e6:	8a bd       	out	0x2a, r24	; 42
     4e8:	f4 ce       	rjmp	.-536    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
     4ea:	86 e9       	ldi	r24, 0x96	; 150
     4ec:	95 e0       	ldi	r25, 0x05	; 5
     4ee:	9b bd       	out	0x2b, r25	; 43
     4f0:	8a bd       	out	0x2a, r24	; 42
	break;
     4f2:	ef ce       	rjmp	.-546    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
     4f4:	8a eb       	ldi	r24, 0xBA	; 186
     4f6:	93 e0       	ldi	r25, 0x03	; 3
     4f8:	9b bd       	out	0x2b, r25	; 43
     4fa:	8a bd       	out	0x2a, r24	; 42
	break;
     4fc:	ea ce       	rjmp	.-556    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
     4fe:	66 23       	and	r22, r22
     500:	09 f4       	brne	.+2      	; 0x504 <play_note+0x254>
     502:	7a c1       	rjmp	.+756    	; 0x7f8 <play_note+0x548>
     504:	81 ec       	ldi	r24, 0xC1	; 193
     506:	91 e0       	ldi	r25, 0x01	; 1
     508:	9b bd       	out	0x2b, r25	; 43
     50a:	8a bd       	out	0x2a, r24	; 42
     50c:	e2 ce       	rjmp	.-572    	; 0x2d2 <play_note+0x22>
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
     50e:	66 23       	and	r22, r22
     510:	09 f4       	brne	.+2      	; 0x514 <play_note+0x264>
     512:	7c c1       	rjmp	.+760    	; 0x80c <play_note+0x55c>
     514:	8b e0       	ldi	r24, 0x0B	; 11
     516:	91 e0       	ldi	r25, 0x01	; 1
     518:	9b bd       	out	0x2b, r25	; 43
     51a:	8a bd       	out	0x2a, r24	; 42
     51c:	da ce       	rjmp	.-588    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
     51e:	66 23       	and	r22, r22
     520:	09 f4       	brne	.+2      	; 0x524 <play_note+0x274>
     522:	7e c1       	rjmp	.+764    	; 0x820 <play_note+0x570>
     524:	80 e5       	ldi	r24, 0x50	; 80
     526:	91 e0       	ldi	r25, 0x01	; 1
     528:	9b bd       	out	0x2b, r25	; 43
     52a:	8a bd       	out	0x2a, r24	; 42
     52c:	d2 ce       	rjmp	.-604    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
     52e:	66 23       	and	r22, r22
     530:	09 f4       	brne	.+2      	; 0x534 <play_note+0x284>
     532:	ad c1       	rjmp	.+858    	; 0x88e <play_note+0x5de>
     534:	82 e2       	ldi	r24, 0x22	; 34
     536:	93 e0       	ldi	r25, 0x03	; 3
     538:	9b bd       	out	0x2b, r25	; 43
     53a:	8a bd       	out	0x2a, r24	; 42
     53c:	ca ce       	rjmp	.-620    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
     53e:	86 e7       	ldi	r24, 0x76	; 118
     540:	97 e0       	ldi	r25, 0x07	; 7
     542:	9b bd       	out	0x2b, r25	; 43
     544:	8a bd       	out	0x2a, r24	; 42
	break;
     546:	c5 ce       	rjmp	.-630    	; 0x2d2 <play_note+0x22>
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
     548:	66 23       	and	r22, r22
     54a:	09 f4       	brne	.+2      	; 0x54e <play_note+0x29e>
     54c:	0f c1       	rjmp	.+542    	; 0x76c <play_note+0x4bc>
     54e:	8e ec       	ldi	r24, 0xCE	; 206
     550:	92 e1       	ldi	r25, 0x12	; 18
     552:	9b bd       	out	0x2b, r25	; 43
     554:	8a bd       	out	0x2a, r24	; 42
     556:	bd ce       	rjmp	.-646    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
     558:	66 23       	and	r22, r22
     55a:	09 f4       	brne	.+2      	; 0x55e <play_note+0x2ae>
     55c:	7a c1       	rjmp	.+756    	; 0x852 <play_note+0x5a2>
     55e:	8d e1       	ldi	r24, 0x1D	; 29
     560:	95 e1       	ldi	r25, 0x15	; 21
     562:	9b bd       	out	0x2b, r25	; 43
     564:	8a bd       	out	0x2a, r24	; 42
     566:	b5 ce       	rjmp	.-662    	; 0x2d2 <play_note+0x22>
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
     568:	66 23       	and	r22, r22
     56a:	09 f4       	brne	.+2      	; 0x56e <play_note+0x2be>
     56c:	dc c0       	rjmp	.+440    	; 0x726 <play_note+0x476>
     56e:	80 e6       	ldi	r24, 0x60	; 96
     570:	98 e0       	ldi	r25, 0x08	; 8
     572:	9b bd       	out	0x2b, r25	; 43
     574:	8a bd       	out	0x2a, r24	; 42
     576:	ad ce       	rjmp	.-678    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
     578:	66 23       	and	r22, r22
     57a:	09 f4       	brne	.+2      	; 0x57e <play_note+0x2ce>
     57c:	92 c1       	rjmp	.+804    	; 0x8a2 <play_note+0x5f2>
     57e:	80 e1       	ldi	r24, 0x10	; 16
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	9b bd       	out	0x2b, r25	; 43
     584:	8a bd       	out	0x2a, r24	; 42
     586:	a5 ce       	rjmp	.-694    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
     588:	8e e2       	ldi	r24, 0x2E	; 46
     58a:	9b e0       	ldi	r25, 0x0B	; 11
     58c:	9b bd       	out	0x2b, r25	; 43
     58e:	8a bd       	out	0x2a, r24	; 42
	break;
     590:	a0 ce       	rjmp	.-704    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
     592:	66 23       	and	r22, r22
     594:	09 f4       	brne	.+2      	; 0x598 <play_note+0x2e8>
     596:	49 c1       	rjmp	.+658    	; 0x82a <play_note+0x57a>
     598:	8b e1       	ldi	r24, 0x1B	; 27
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	9b bd       	out	0x2b, r25	; 43
     59e:	8a bd       	out	0x2a, r24	; 42
     5a0:	98 ce       	rjmp	.-720    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
     5a2:	8c e1       	ldi	r24, 0x1C	; 28
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	9b bd       	out	0x2b, r25	; 43
     5a8:	8a bd       	out	0x2a, r24	; 42
	break;
     5aa:	93 ce       	rjmp	.-730    	; 0x2d2 <play_note+0x22>
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
     5ac:	66 23       	and	r22, r22
     5ae:	09 f4       	brne	.+2      	; 0x5b2 <play_note+0x302>
     5b0:	41 c1       	rjmp	.+642    	; 0x834 <play_note+0x584>
     5b2:	87 e0       	ldi	r24, 0x07	; 7
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	9b bd       	out	0x2b, r25	; 43
     5b8:	8a bd       	out	0x2a, r24	; 42
     5ba:	8b ce       	rjmp	.-746    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
     5bc:	66 23       	and	r22, r22
     5be:	09 f4       	brne	.+2      	; 0x5c2 <play_note+0x312>
     5c0:	da c0       	rjmp	.+436    	; 0x776 <play_note+0x4c6>
     5c2:	8b e0       	ldi	r24, 0x0B	; 11
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	9b bd       	out	0x2b, r25	; 43
     5c8:	8a bd       	out	0x2a, r24	; 42
     5ca:	83 ce       	rjmp	.-762    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
     5cc:	82 e1       	ldi	r24, 0x12	; 18
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	9b bd       	out	0x2b, r25	; 43
     5d2:	8a bd       	out	0x2a, r24	; 42
	break;
     5d4:	7e ce       	rjmp	.-772    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
     5d6:	66 23       	and	r22, r22
     5d8:	09 f4       	brne	.+2      	; 0x5dc <play_note+0x32c>
     5da:	9b c0       	rjmp	.+310    	; 0x712 <play_note+0x462>
     5dc:	89 e1       	ldi	r24, 0x19	; 25
     5de:	99 e1       	ldi	r25, 0x19	; 25
     5e0:	9b bd       	out	0x2b, r25	; 43
     5e2:	8a bd       	out	0x2a, r24	; 42
     5e4:	76 ce       	rjmp	.-788    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
     5e6:	66 23       	and	r22, r22
     5e8:	09 f4       	brne	.+2      	; 0x5ec <play_note+0x33c>
     5ea:	29 c1       	rjmp	.+594    	; 0x83e <play_note+0x58e>
     5ec:	80 e3       	ldi	r24, 0x30	; 48
     5ee:	9c e1       	ldi	r25, 0x1C	; 28
     5f0:	9b bd       	out	0x2b, r25	; 43
     5f2:	8a bd       	out	0x2a, r24	; 42
     5f4:	6e ce       	rjmp	.-804    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
     5f6:	8c ed       	ldi	r24, 0xDC	; 220
     5f8:	9d e1       	ldi	r25, 0x1D	; 29
     5fa:	9b bd       	out	0x2b, r25	; 43
     5fc:	8a bd       	out	0x2a, r24	; 42
	break;
     5fe:	69 ce       	rjmp	.-814    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
     600:	8a e3       	ldi	r24, 0x3A	; 58
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	9b bd       	out	0x2b, r25	; 43
     606:	8a bd       	out	0x2a, r24	; 42
	break;
     608:	64 ce       	rjmp	.-824    	; 0x2d2 <play_note+0x22>
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
     60a:	66 23       	and	r22, r22
     60c:	09 f4       	brne	.+2      	; 0x610 <play_note+0x360>
     60e:	35 c1       	rjmp	.+618    	; 0x87a <play_note+0x5ca>
     610:	80 e2       	ldi	r24, 0x20	; 32
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	9b bd       	out	0x2b, r25	; 43
     616:	8a bd       	out	0x2a, r24	; 42
     618:	5c ce       	rjmp	.-840    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
     61a:	66 23       	and	r22, r22
     61c:	09 f4       	brne	.+2      	; 0x620 <play_note+0x370>
     61e:	32 c1       	rjmp	.+612    	; 0x884 <play_note+0x5d4>
     620:	84 e2       	ldi	r24, 0x24	; 36
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	9b bd       	out	0x2b, r25	; 43
     626:	8a bd       	out	0x2a, r24	; 42
     628:	54 ce       	rjmp	.-856    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
     62a:	66 23       	and	r22, r22
     62c:	09 f4       	brne	.+2      	; 0x630 <play_note+0x380>
     62e:	76 c0       	rjmp	.+236    	; 0x71c <play_note+0x46c>
     630:	89 e2       	ldi	r24, 0x29	; 41
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	9b bd       	out	0x2b, r25	; 43
     636:	8a bd       	out	0x2a, r24	; 42
     638:	4c ce       	rjmp	.-872    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
     63a:	66 23       	and	r22, r22
     63c:	09 f4       	brne	.+2      	; 0x640 <play_note+0x390>
     63e:	78 c0       	rjmp	.+240    	; 0x730 <play_note+0x480>
     640:	81 e3       	ldi	r24, 0x31	; 49
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	9b bd       	out	0x2b, r25	; 43
     646:	8a bd       	out	0x2a, r24	; 42
     648:	44 ce       	rjmp	.-888    	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
     64a:	8b e2       	ldi	r24, 0x2B	; 43
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	9b bd       	out	0x2b, r25	; 43
     650:	8a bd       	out	0x2a, r24	; 42
	break;
     652:	3f ce       	rjmp	.-898    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
     654:	66 23       	and	r22, r22
     656:	09 f4       	brne	.+2      	; 0x65a <play_note+0x3aa>
     658:	93 c0       	rjmp	.+294    	; 0x780 <play_note+0x4d0>
     65a:	87 e3       	ldi	r24, 0x37	; 55
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	9b bd       	out	0x2b, r25	; 43
     660:	8a bd       	out	0x2a, r24	; 42
     662:	37 ce       	rjmp	.-914    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
     664:	66 23       	and	r22, r22
     666:	09 f4       	brne	.+2      	; 0x66a <play_note+0x3ba>
     668:	4f c0       	rjmp	.+158    	; 0x708 <play_note+0x458>
     66a:	88 e1       	ldi	r24, 0x18	; 24
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	9b bd       	out	0x2b, r25	; 43
     670:	8a bd       	out	0x2a, r24	; 42
     672:	2f ce       	rjmp	.-930    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
     674:	66 23       	and	r22, r22
     676:	09 f4       	brne	.+2      	; 0x67a <play_note+0x3ca>
     678:	f6 c0       	rjmp	.+492    	; 0x866 <play_note+0x5b6>
     67a:	82 eb       	ldi	r24, 0xB2	; 178
     67c:	94 e0       	ldi	r25, 0x04	; 4
     67e:	9b bd       	out	0x2b, r25	; 43
     680:	8a bd       	out	0x2a, r24	; 42
     682:	27 ce       	rjmp	.-946    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
     684:	66 23       	and	r22, r22
     686:	09 f4       	brne	.+2      	; 0x68a <play_note+0x3da>
     688:	16 c1       	rjmp	.+556    	; 0x8b6 <play_note+0x606>
     68a:	8d e8       	ldi	r24, 0x8D	; 141
     68c:	9a e0       	ldi	r25, 0x0A	; 10
     68e:	9b bd       	out	0x2b, r25	; 43
     690:	8a bd       	out	0x2a, r24	; 42
     692:	1f ce       	rjmp	.-962    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
     694:	66 23       	and	r22, r22
     696:	09 f4       	brne	.+2      	; 0x69a <play_note+0x3ea>
     698:	d7 c0       	rjmp	.+430    	; 0x848 <play_note+0x598>
     69a:	86 e1       	ldi	r24, 0x16	; 22
     69c:	9e e0       	ldi	r25, 0x0E	; 14
     69e:	9b bd       	out	0x2b, r25	; 43
     6a0:	8a bd       	out	0x2a, r24	; 42
     6a2:	17 ce       	rjmp	.-978    	; 0x2d2 <play_note+0x22>
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
     6a4:	66 23       	and	r22, r22
     6a6:	09 f4       	brne	.+2      	; 0x6aa <play_note+0x3fa>
     6a8:	f7 c0       	rjmp	.+494    	; 0x898 <play_note+0x5e8>
     6aa:	80 ec       	ldi	r24, 0xC0	; 192
     6ac:	90 e1       	ldi	r25, 0x10	; 16
     6ae:	9b bd       	out	0x2b, r25	; 43
     6b0:	8a bd       	out	0x2a, r24	; 42
     6b2:	0f ce       	rjmp	.-994    	; 0x2d2 <play_note+0x22>
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
     6b4:	66 23       	and	r22, r22
     6b6:	09 f4       	brne	.+2      	; 0x6ba <play_note+0x40a>
     6b8:	d1 c0       	rjmp	.+418    	; 0x85c <play_note+0x5ac>
     6ba:	8f e2       	ldi	r24, 0x2F	; 47
     6bc:	94 e0       	ldi	r25, 0x04	; 4
     6be:	9b bd       	out	0x2b, r25	; 43
     6c0:	8a bd       	out	0x2a, r24	; 42
     6c2:	07 ce       	rjmp	.-1010   	; 0x2d2 <play_note+0x22>
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
     6c4:	66 23       	and	r22, r22
     6c6:	09 f4       	brne	.+2      	; 0x6ca <play_note+0x41a>
     6c8:	f1 c0       	rjmp	.+482    	; 0x8ac <play_note+0x5fc>
     6ca:	87 e6       	ldi	r24, 0x67	; 103
     6cc:	99 e0       	ldi	r25, 0x09	; 9
     6ce:	9b bd       	out	0x2b, r25	; 43
     6d0:	8a bd       	out	0x2a, r24	; 42
     6d2:	ff cd       	rjmp	.-1026   	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
     6d4:	66 23       	and	r22, r22
     6d6:	09 f4       	brne	.+2      	; 0x6da <play_note+0x42a>
     6d8:	cb c0       	rjmp	.+406    	; 0x870 <play_note+0x5c0>
     6da:	8d e8       	ldi	r24, 0x8D	; 141
     6dc:	9c e0       	ldi	r25, 0x0C	; 12
     6de:	9b bd       	out	0x2b, r25	; 43
     6e0:	8a bd       	out	0x2a, r24	; 42
     6e2:	f7 cd       	rjmp	.-1042   	; 0x2d2 <play_note+0x22>
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
     6e4:	8d e5       	ldi	r24, 0x5D	; 93
     6e6:	96 e1       	ldi	r25, 0x16	; 22
     6e8:	9b bd       	out	0x2b, r25	; 43
     6ea:	8a bd       	out	0x2a, r24	; 42
	break;
     6ec:	f2 cd       	rjmp	.-1052   	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
     6ee:	66 23       	and	r22, r22
     6f0:	09 f4       	brne	.+2      	; 0x6f4 <play_note+0x444>
     6f2:	e6 c0       	rjmp	.+460    	; 0x8c0 <play_note+0x610>
     6f4:	86 e4       	ldi	r24, 0x46	; 70
     6f6:	95 e0       	ldi	r25, 0x05	; 5
     6f8:	9b bd       	out	0x2b, r25	; 43
     6fa:	8a bd       	out	0x2a, r24	; 42
     6fc:	ea cd       	rjmp	.-1068   	; 0x2d2 <play_note+0x22>
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
     6fe:	8d ee       	ldi	r24, 0xED	; 237
     700:	9e e0       	ldi	r25, 0x0E	; 14
     702:	9b bd       	out	0x2b, r25	; 43
     704:	8a bd       	out	0x2a, r24	; 42
	break;
     706:	e5 cd       	rjmp	.-1078   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
     708:	85 e1       	ldi	r24, 0x15	; 21
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	9b bd       	out	0x2b, r25	; 43
     70e:	8a bd       	out	0x2a, r24	; 42
     710:	e0 cd       	rjmp	.-1088   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
     712:	82 eb       	ldi	r24, 0xB2	; 178
     714:	97 e1       	ldi	r25, 0x17	; 23
     716:	9b bd       	out	0x2b, r25	; 43
     718:	8a bd       	out	0x2a, r24	; 42
     71a:	db cd       	rjmp	.-1098   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
     71c:	86 e2       	ldi	r24, 0x26	; 38
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	9b bd       	out	0x2b, r25	; 43
     722:	8a bd       	out	0x2a, r24	; 42
     724:	d6 cd       	rjmp	.-1108   	; 0x2d2 <play_note+0x22>
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
     726:	87 ee       	ldi	r24, 0xE7	; 231
     728:	97 e0       	ldi	r25, 0x07	; 7
     72a:	9b bd       	out	0x2b, r25	; 43
     72c:	8a bd       	out	0x2a, r24	; 42
     72e:	d1 cd       	rjmp	.-1118   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
     730:	8e e2       	ldi	r24, 0x2E	; 46
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9b bd       	out	0x2b, r25	; 43
     736:	8a bd       	out	0x2a, r24	; 42
     738:	cc cd       	rjmp	.-1128   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
     73a:	8b ee       	ldi	r24, 0xEB	; 235
     73c:	95 e0       	ldi	r25, 0x05	; 5
     73e:	9b bd       	out	0x2b, r25	; 43
     740:	8a bd       	out	0x2a, r24	; 42
     742:	c7 cd       	rjmp	.-1138   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
     744:	8a e7       	ldi	r24, 0x7A	; 122
     746:	91 e0       	ldi	r25, 0x01	; 1
     748:	9b bd       	out	0x2b, r25	; 43
     74a:	8a bd       	out	0x2a, r24	; 42
     74c:	c2 cd       	rjmp	.-1148   	; 0x2d2 <play_note+0x22>
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
     74e:	8e e3       	ldi	r24, 0x3E	; 62
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	9b bd       	out	0x2b, r25	; 43
     754:	8a bd       	out	0x2a, r24	; 42
     756:	bd cd       	rjmp	.-1158   	; 0x2d2 <play_note+0x22>
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
     758:	89 ef       	ldi	r24, 0xF9	; 249
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	9b bd       	out	0x2b, r25	; 43
     75e:	8a bd       	out	0x2a, r24	; 42
     760:	b8 cd       	rjmp	.-1168   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
     762:	8c eb       	ldi	r24, 0xBC	; 188
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	9b bd       	out	0x2b, r25	; 43
     768:	8a bd       	out	0x2a, r24	; 42
     76a:	b3 cd       	rjmp	.-1178   	; 0x2d2 <play_note+0x22>
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
     76c:	80 ec       	ldi	r24, 0xC0	; 192
     76e:	91 e1       	ldi	r25, 0x11	; 17
     770:	9b bd       	out	0x2b, r25	; 43
     772:	8a bd       	out	0x2a, r24	; 42
     774:	ae cd       	rjmp	.-1188   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
     776:	89 e0       	ldi	r24, 0x09	; 9
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	9b bd       	out	0x2b, r25	; 43
     77c:	8a bd       	out	0x2a, r24	; 42
     77e:	a9 cd       	rjmp	.-1198   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
     780:	84 e3       	ldi	r24, 0x34	; 52
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	9b bd       	out	0x2b, r25	; 43
     786:	8a bd       	out	0x2a, r24	; 42
     788:	a4 cd       	rjmp	.-1208   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
     78a:	8d e8       	ldi	r24, 0x8D	; 141
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	9b bd       	out	0x2b, r25	; 43
     790:	8a bd       	out	0x2a, r24	; 42
     792:	9f cd       	rjmp	.-1218   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
     794:	8e e9       	ldi	r24, 0x9E	; 158
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	9b bd       	out	0x2b, r25	; 43
     79a:	8a bd       	out	0x2a, r24	; 42
     79c:	9a cd       	rjmp	.-1228   	; 0x2d2 <play_note+0x22>
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
     79e:	8d e7       	ldi	r24, 0x7D	; 125
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	9b bd       	out	0x2b, r25	; 43
     7a4:	8a bd       	out	0x2a, r24	; 42
     7a6:	95 cd       	rjmp	.-1238   	; 0x2d2 <play_note+0x22>
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
     7a8:	83 ed       	ldi	r24, 0xD3	; 211
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	9b bd       	out	0x2b, r25	; 43
     7ae:	8a bd       	out	0x2a, r24	; 42
     7b0:	90 cd       	rjmp	.-1248   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
     7b2:	8d e5       	ldi	r24, 0x5D	; 93
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	9b bd       	out	0x2b, r25	; 43
     7b8:	8a bd       	out	0x2a, r24	; 42
     7ba:	8b cd       	rjmp	.-1258   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
     7bc:	86 e4       	ldi	r24, 0x46	; 70
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	9b bd       	out	0x2b, r25	; 43
     7c2:	8a bd       	out	0x2a, r24	; 42
     7c4:	86 cd       	rjmp	.-1268   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
     7c6:	89 e6       	ldi	r24, 0x69	; 105
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	9b bd       	out	0x2b, r25	; 43
     7cc:	8a bd       	out	0x2a, r24	; 42
     7ce:	81 cd       	rjmp	.-1278   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
     7d0:	8e e4       	ldi	r24, 0x4E	; 78
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	9b bd       	out	0x2b, r25	; 43
     7d6:	8a bd       	out	0x2a, r24	; 42
     7d8:	7c cd       	rjmp	.-1288   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
     7da:	8b e1       	ldi	r24, 0x1B	; 27
     7dc:	91 e0       	ldi	r25, 0x01	; 1
     7de:	9b bd       	out	0x2b, r25	; 43
     7e0:	8a bd       	out	0x2a, r24	; 42
     7e2:	77 cd       	rjmp	.-1298   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
     7e4:	85 ea       	ldi	r24, 0xA5	; 165
     7e6:	96 e0       	ldi	r25, 0x06	; 6
     7e8:	9b bd       	out	0x2b, r25	; 43
     7ea:	8a bd       	out	0x2a, r24	; 42
     7ec:	72 cd       	rjmp	.-1308   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
     7ee:	8c e7       	ldi	r24, 0x7C	; 124
     7f0:	92 e0       	ldi	r25, 0x02	; 2
     7f2:	9b bd       	out	0x2b, r25	; 43
     7f4:	8a bd       	out	0x2a, r24	; 42
     7f6:	6d cd       	rjmp	.-1318   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
     7f8:	88 ea       	ldi	r24, 0xA8	; 168
     7fa:	91 e0       	ldi	r25, 0x01	; 1
     7fc:	9b bd       	out	0x2b, r25	; 43
     7fe:	8a bd       	out	0x2a, r24	; 42
     800:	68 cd       	rjmp	.-1328   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
     802:	82 e5       	ldi	r24, 0x52	; 82
     804:	93 e0       	ldi	r25, 0x03	; 3
     806:	9b bd       	out	0x2b, r25	; 43
     808:	8a bd       	out	0x2a, r24	; 42
     80a:	63 cd       	rjmp	.-1338   	; 0x2d2 <play_note+0x22>
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
     80c:	8c ef       	ldi	r24, 0xFC	; 252
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	9b bd       	out	0x2b, r25	; 43
     812:	8a bd       	out	0x2a, r24	; 42
     814:	5e cd       	rjmp	.-1348   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
     816:	87 e3       	ldi	r24, 0x37	; 55
     818:	92 e0       	ldi	r25, 0x02	; 2
     81a:	9b bd       	out	0x2b, r25	; 43
     81c:	8a bd       	out	0x2a, r24	; 42
     81e:	59 cd       	rjmp	.-1358   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
     820:	8d e3       	ldi	r24, 0x3D	; 61
     822:	91 e0       	ldi	r25, 0x01	; 1
     824:	9b bd       	out	0x2b, r25	; 43
     826:	8a bd       	out	0x2a, r24	; 42
     828:	54 cd       	rjmp	.-1368   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
     82a:	89 e1       	ldi	r24, 0x19	; 25
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	9b bd       	out	0x2b, r25	; 43
     830:	8a bd       	out	0x2a, r24	; 42
     832:	4f cd       	rjmp	.-1378   	; 0x2d2 <play_note+0x22>
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
     834:	85 e0       	ldi	r24, 0x05	; 5
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	9b bd       	out	0x2b, r25	; 43
     83a:	8a bd       	out	0x2a, r24	; 42
     83c:	4a cd       	rjmp	.-1388   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
     83e:	8a e9       	ldi	r24, 0x9A	; 154
     840:	9a e1       	ldi	r25, 0x1A	; 26
     842:	9b bd       	out	0x2b, r25	; 43
     844:	8a bd       	out	0x2a, r24	; 42
     846:	45 cd       	rjmp	.-1398   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
     848:	8c e4       	ldi	r24, 0x4C	; 76
     84a:	9d e0       	ldi	r25, 0x0D	; 13
     84c:	9b bd       	out	0x2b, r25	; 43
     84e:	8a bd       	out	0x2a, r24	; 42
     850:	40 cd       	rjmp	.-1408   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
     852:	8d ee       	ldi	r24, 0xED	; 237
     854:	93 e1       	ldi	r25, 0x13	; 19
     856:	9b bd       	out	0x2b, r25	; 43
     858:	8a bd       	out	0x2a, r24	; 42
     85a:	3b cd       	rjmp	.-1418   	; 0x2d2 <play_note+0x22>
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
     85c:	83 ef       	ldi	r24, 0xF3	; 243
     85e:	93 e0       	ldi	r25, 0x03	; 3
     860:	9b bd       	out	0x2b, r25	; 43
     862:	8a bd       	out	0x2a, r24	; 42
     864:	36 cd       	rjmp	.-1428   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
     866:	8f e6       	ldi	r24, 0x6F	; 111
     868:	94 e0       	ldi	r25, 0x04	; 4
     86a:	9b bd       	out	0x2b, r25	; 43
     86c:	8a bd       	out	0x2a, r24	; 42
     86e:	31 cd       	rjmp	.-1438   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
     870:	88 ed       	ldi	r24, 0xD8	; 216
     872:	9b e0       	ldi	r25, 0x0B	; 11
     874:	9b bd       	out	0x2b, r25	; 43
     876:	8a bd       	out	0x2a, r24	; 42
     878:	2c cd       	rjmp	.-1448   	; 0x2d2 <play_note+0x22>
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
     87a:	8e e1       	ldi	r24, 0x1E	; 30
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	9b bd       	out	0x2b, r25	; 43
     880:	8a bd       	out	0x2a, r24	; 42
     882:	27 cd       	rjmp	.-1458   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
     884:	82 e2       	ldi	r24, 0x22	; 34
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	9b bd       	out	0x2b, r25	; 43
     88a:	8a bd       	out	0x2a, r24	; 42
     88c:	22 cd       	rjmp	.-1468   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
     88e:	85 ef       	ldi	r24, 0xF5	; 245
     890:	92 e0       	ldi	r25, 0x02	; 2
     892:	9b bd       	out	0x2b, r25	; 43
     894:	8a bd       	out	0x2a, r24	; 42
     896:	1d cd       	rjmp	.-1478   	; 0x2d2 <play_note+0x22>
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
     898:	80 ed       	ldi	r24, 0xD0	; 208
     89a:	9f e0       	ldi	r25, 0x0F	; 15
     89c:	9b bd       	out	0x2b, r25	; 43
     89e:	8a bd       	out	0x2a, r24	; 42
     8a0:	18 cd       	rjmp	.-1488   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
     8a2:	8d e0       	ldi	r24, 0x0D	; 13
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	9b bd       	out	0x2b, r25	; 43
     8a8:	8a bd       	out	0x2a, r24	; 42
     8aa:	13 cd       	rjmp	.-1498   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
     8ac:	8f ed       	ldi	r24, 0xDF	; 223
     8ae:	98 e0       	ldi	r25, 0x08	; 8
     8b0:	9b bd       	out	0x2b, r25	; 43
     8b2:	8a bd       	out	0x2a, r24	; 42
     8b4:	0e cd       	rjmp	.-1508   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
     8b6:	86 ef       	ldi	r24, 0xF6	; 246
     8b8:	99 e0       	ldi	r25, 0x09	; 9
     8ba:	9b bd       	out	0x2b, r25	; 43
     8bc:	8a bd       	out	0x2a, r24	; 42
     8be:	09 cd       	rjmp	.-1518   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
     8c0:	8a ef       	ldi	r24, 0xFA	; 250
     8c2:	94 e0       	ldi	r25, 0x04	; 4
     8c4:	9b bd       	out	0x2b, r25	; 43
     8c6:	8a bd       	out	0x2a, r24	; 42
     8c8:	04 cd       	rjmp	.-1528   	; 0x2d2 <play_note+0x22>

000008ca <song0>:
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8ca:	86 34       	cpi	r24, 0x46	; 70
     8cc:	91 05       	cpc	r25, r1
     8ce:	20 f0       	brcs	.+8      	; 0x8d8 <song0+0xe>
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	80 93 67 01 	sts	0x0167, r24
     8d6:	08 95       	ret
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8d8:	fc 01       	movw	r30, r24
     8da:	e2 57       	subi	r30, 0x72	; 114
     8dc:	ff 4f       	sbci	r31, 0xFF	; 255
     8de:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
     8e2:	22 e0       	ldi	r18, 0x02	; 2
     8e4:	44 e0       	ldi	r20, 0x04	; 4
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	81 e4       	ldi	r24, 0x41	; 65
     8ea:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
     8ee:	26 e0       	ldi	r18, 0x06	; 6
     8f0:	44 e0       	ldi	r20, 0x04	; 4
     8f2:	60 e0       	ldi	r22, 0x00	; 0
     8f4:	81 e4       	ldi	r24, 0x41	; 65
     8f6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
     8fa:	22 e0       	ldi	r18, 0x02	; 2
     8fc:	44 e0       	ldi	r20, 0x04	; 4
     8fe:	61 e0       	ldi	r22, 0x01	; 1
     900:	81 e4       	ldi	r24, 0x41	; 65
     902:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
     906:	28 e0       	ldi	r18, 0x08	; 8
     908:	44 e0       	ldi	r20, 0x04	; 4
     90a:	60 e0       	ldi	r22, 0x00	; 0
     90c:	84 e4       	ldi	r24, 0x44	; 68
     90e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
     912:	28 e0       	ldi	r18, 0x08	; 8
     914:	44 e0       	ldi	r20, 0x04	; 4
     916:	60 e0       	ldi	r22, 0x00	; 0
     918:	86 e4       	ldi	r24, 0x46	; 70
     91a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
     91e:	26 e0       	ldi	r18, 0x06	; 6
     920:	44 e0       	ldi	r20, 0x04	; 4
     922:	61 e0       	ldi	r22, 0x01	; 1
     924:	82 e4       	ldi	r24, 0x42	; 66
     926:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
     92a:	28 e0       	ldi	r18, 0x08	; 8
     92c:	44 e0       	ldi	r20, 0x04	; 4
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	83 e4       	ldi	r24, 0x43	; 67
     932:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
     936:	28 e0       	ldi	r18, 0x08	; 8
     938:	44 e0       	ldi	r20, 0x04	; 4
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	81 e4       	ldi	r24, 0x41	; 65
     93e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 67: play_note('G', 0, 4, 8);
     942:	28 e0       	ldi	r18, 0x08	; 8
     944:	44 e0       	ldi	r20, 0x04	; 4
     946:	60 e0       	ldi	r22, 0x00	; 0
     948:	87 e4       	ldi	r24, 0x47	; 71
     94a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
     94e:	28 e0       	ldi	r18, 0x08	; 8
     950:	44 e0       	ldi	r20, 0x04	; 4
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	85 e4       	ldi	r24, 0x45	; 69
     956:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
     95a:	20 e1       	ldi	r18, 0x10	; 16
     95c:	44 e0       	ldi	r20, 0x04	; 4
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	81 e4       	ldi	r24, 0x41	; 65
     962:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
     966:	24 e0       	ldi	r18, 0x04	; 4
     968:	45 e0       	ldi	r20, 0x05	; 5
     96a:	60 e0       	ldi	r22, 0x00	; 0
     96c:	83 e4       	ldi	r24, 0x43	; 67
     96e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 65: play_note('D', 0, 5, 4);
     972:	24 e0       	ldi	r18, 0x04	; 4
     974:	45 e0       	ldi	r20, 0x05	; 5
     976:	60 e0       	ldi	r22, 0x00	; 0
     978:	84 e4       	ldi	r24, 0x44	; 68
     97a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     97e:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     980:	10 92 78 01 	sts	0x0178, r1
     984:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     988:	88 e0       	ldi	r24, 0x08	; 8
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	90 93 76 01 	sts	0x0176, r25
     990:	80 93 75 01 	sts	0x0175, r24
     994:	08 95       	ret
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     996:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     998:	10 92 78 01 	sts	0x0178, r1
     99c:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	90 93 76 01 	sts	0x0176, r25
     9a8:	80 93 75 01 	sts	0x0175, r24
     9ac:	08 95       	ret
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
     9ae:	20 e1       	ldi	r18, 0x10	; 16
     9b0:	44 e0       	ldi	r20, 0x04	; 4
     9b2:	61 e0       	ldi	r22, 0x01	; 1
     9b4:	82 e4       	ldi	r24, 0x42	; 66
     9b6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
     9ba:	28 e0       	ldi	r18, 0x08	; 8
     9bc:	44 e0       	ldi	r20, 0x04	; 4
     9be:	61 e0       	ldi	r22, 0x01	; 1
     9c0:	82 e4       	ldi	r24, 0x42	; 66
     9c2:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
     9c6:	28 e1       	ldi	r18, 0x18	; 24
     9c8:	44 e0       	ldi	r20, 0x04	; 4
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	87 e4       	ldi	r24, 0x47	; 71
     9ce:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
     9d2:	20 e1       	ldi	r18, 0x10	; 16
     9d4:	45 e0       	ldi	r20, 0x05	; 5
     9d6:	60 e0       	ldi	r22, 0x00	; 0
     9d8:	84 e4       	ldi	r24, 0x44	; 68
     9da:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     9de:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     9e0:	10 92 78 01 	sts	0x0178, r1
     9e4:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     9e8:	82 e0       	ldi	r24, 0x02	; 2
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	90 93 76 01 	sts	0x0176, r25
     9f0:	80 93 75 01 	sts	0x0175, r24
     9f4:	08 95       	ret
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
     9f6:	24 e0       	ldi	r18, 0x04	; 4
     9f8:	44 e0       	ldi	r20, 0x04	; 4
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	81 e4       	ldi	r24, 0x41	; 65
     9fe:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
     a02:	26 e0       	ldi	r18, 0x06	; 6
     a04:	44 e0       	ldi	r20, 0x04	; 4
     a06:	60 e0       	ldi	r22, 0x00	; 0
     a08:	87 e4       	ldi	r24, 0x47	; 71
     a0a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
     a0e:	24 e0       	ldi	r18, 0x04	; 4
     a10:	44 e0       	ldi	r20, 0x04	; 4
     a12:	61 e0       	ldi	r22, 0x01	; 1
     a14:	87 e4       	ldi	r24, 0x47	; 71
     a16:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
     a1a:	28 e0       	ldi	r18, 0x08	; 8
     a1c:	44 e0       	ldi	r20, 0x04	; 4
     a1e:	61 e0       	ldi	r22, 0x01	; 1
     a20:	87 e4       	ldi	r24, 0x47	; 71
     a22:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
     a26:	23 e0       	ldi	r18, 0x03	; 3
     a28:	44 e0       	ldi	r20, 0x04	; 4
     a2a:	60 e0       	ldi	r22, 0x00	; 0
     a2c:	87 e4       	ldi	r24, 0x47	; 71
     a2e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
     a32:	20 e1       	ldi	r18, 0x10	; 16
     a34:	44 e0       	ldi	r20, 0x04	; 4
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	84 e4       	ldi	r24, 0x44	; 68
     a3a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
     a3e:	20 e1       	ldi	r18, 0x10	; 16
     a40:	45 e0       	ldi	r20, 0x05	; 5
     a42:	60 e0       	ldi	r22, 0x00	; 0
     a44:	83 e4       	ldi	r24, 0x43	; 67
     a46:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
     a4a:	22 e0       	ldi	r18, 0x02	; 2
     a4c:	44 e0       	ldi	r20, 0x04	; 4
     a4e:	61 e0       	ldi	r22, 0x01	; 1
     a50:	82 e4       	ldi	r24, 0x42	; 66
     a52:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
     a56:	24 e0       	ldi	r18, 0x04	; 4
     a58:	45 e0       	ldi	r20, 0x05	; 5
     a5a:	61 e0       	ldi	r22, 0x01	; 1
     a5c:	84 e4       	ldi	r24, 0x44	; 68
     a5e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
     a62:	24 e0       	ldi	r18, 0x04	; 4
     a64:	44 e0       	ldi	r20, 0x04	; 4
     a66:	61 e0       	ldi	r22, 0x01	; 1
     a68:	81 e4       	ldi	r24, 0x41	; 65
     a6a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
     a6e:	28 e0       	ldi	r18, 0x08	; 8
     a70:	44 e0       	ldi	r20, 0x04	; 4
     a72:	60 e0       	ldi	r22, 0x00	; 0
     a74:	82 e4       	ldi	r24, 0x42	; 66
     a76:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
     a7a:	28 e1       	ldi	r18, 0x18	; 24
     a7c:	44 e0       	ldi	r20, 0x04	; 4
     a7e:	60 e0       	ldi	r22, 0x00	; 0
     a80:	86 e4       	ldi	r24, 0x46	; 70
     a82:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
     a86:	27 e0       	ldi	r18, 0x07	; 7
     a88:	44 e0       	ldi	r20, 0x04	; 4
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	87 e4       	ldi	r24, 0x47	; 71
     a8e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>

00000a92 <play_song>:
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     a92:	86 2f       	mov	r24, r22
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000a9a <music_off>:
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     a9a:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     a9e:	8e b5       	in	r24, 0x2e	; 46
     aa0:	8c 7f       	andi	r24, 0xFC	; 252
     aa2:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     aa4:	92 9a       	sbi	0x12, 2	; 18
     aa6:	08 95       	ret

00000aa8 <music_on>:
}

void music_on(void) {
  //this starts the alarm timer running
  notes=0;
     aa8:	10 92 67 01 	sts	0x0167, r1
  TCCR1B |= (1<<CS11)|(1<<CS10);
     aac:	8e b5       	in	r24, 0x2e	; 46
     aae:	83 60       	ori	r24, 0x03	; 3
     ab0:	8e bd       	out	0x2e, r24	; 46
  //unmutes the output
  PORTD &= unmute;
     ab2:	92 98       	cbi	0x12, 2	; 18
  //and starts the selected song
  play_song(song, notes);
     ab4:	80 91 67 01 	lds	r24, 0x0167
     ab8:	90 91 74 01 	lds	r25, 0x0174
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000ac2 <music_init>:
  play_song(song, notes);
}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  DDRD |= (1<<PD7);
     ac2:	8f 9a       	sbi	0x11, 7	; 17
  TIMSK |= (1<<OCIE1A) | (1<<TOIE0);  //enable timer interrupt 1 on compare
     ac4:	87 b7       	in	r24, 0x37	; 55
     ac6:	81 61       	ori	r24, 0x11	; 17
     ac8:	87 bf       	out	0x37, r24	; 55
  TCCR1A = 0x00;         //TCNT1, normal port operation
     aca:	1f bc       	out	0x2f, r1	; 47
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
     acc:	8e b5       	in	r24, 0x2e	; 46
     ace:	88 60       	ori	r24, 0x08	; 8
     ad0:	8e bd       	out	0x2e, r24	; 46
  TCCR1C = 0x00;         //no forced compare
     ad2:	10 92 7a 00 	sts	0x007A, r1
  OCR1A = 0x0033;        //(use to vary alarm frequency)
     ad6:	83 e3       	ldi	r24, 0x33	; 51
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	9b bd       	out	0x2b, r25	; 43
     adc:	8a bd       	out	0x2a, r24	; 42
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     ade:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     ae2:	8e b5       	in	r24, 0x2e	; 46
     ae4:	8c 7f       	andi	r24, 0xFC	; 252
     ae6:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     ae8:	92 9a       	sbi	0x12, 2	; 18
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0033;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
     aea:	10 92 78 01 	sts	0x0178, r1
     aee:	10 92 77 01 	sts	0x0177, r1
  max_beat = 0;
     af2:	10 92 76 01 	sts	0x0176, r1
     af6:	10 92 75 01 	sts	0x0175, r1
  notes = 0;
     afa:	10 92 67 01 	sts	0x0167, r1
  song = 0;              //beaver fight song
     afe:	10 92 74 01 	sts	0x0174, r1
     b02:	08 95       	ret

00000b04 <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b04:	20 91 58 01 	lds	r18, 0x0158
     b08:	30 91 59 01 	lds	r19, 0x0159
     b0c:	22 0f       	add	r18, r18
     b0e:	33 1f       	adc	r19, r19
     b10:	49 b3       	in	r20, 0x19	; 25
     b12:	50 e0       	ldi	r21, 0x00	; 0
     b14:	02 c0       	rjmp	.+4      	; 0xb1a <chk_buttons+0x16>
     b16:	55 95       	asr	r21
     b18:	47 95       	ror	r20
     b1a:	8a 95       	dec	r24
     b1c:	e2 f7       	brpl	.-8      	; 0xb16 <chk_buttons+0x12>
     b1e:	40 fd       	sbrc	r20, 0
     b20:	0e c0       	rjmp	.+28     	; 0xb3e <chk_buttons+0x3a>
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	90 ee       	ldi	r25, 0xE0	; 224
     b26:	28 2b       	or	r18, r24
     b28:	39 2b       	or	r19, r25
     b2a:	30 93 59 01 	sts	0x0159, r19
     b2e:	20 93 58 01 	sts	0x0158, r18
	if (state == 0xF000){
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	21 15       	cp	r18, r1
     b36:	30 4f       	sbci	r19, 0xF0	; 240
     b38:	09 f0       	breq	.+2      	; 0xb3c <chk_buttons+0x38>
     b3a:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}
	return 0;
}
     b3c:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	90 ee       	ldi	r25, 0xE0	; 224
     b42:	f1 cf       	rjmp	.-30     	; 0xb26 <chk_buttons+0x22>

00000b44 <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
     b44:	81 11       	cpse	r24, r1
     b46:	02 c0       	rjmp	.+4      	; 0xb4c <int2seg+0x8>
		return ZERO;
     b48:	80 ec       	ldi	r24, 0xC0	; 192
     b4a:	08 95       	ret
	}
	else if(number == 1 ){
     b4c:	81 30       	cpi	r24, 0x01	; 1
     b4e:	91 f0       	breq	.+36     	; 0xb74 <int2seg+0x30>
		return ONE;
	}
	else if(number == 2 ){
     b50:	82 30       	cpi	r24, 0x02	; 2
     b52:	91 f0       	breq	.+36     	; 0xb78 <int2seg+0x34>
		return TWO;
	}
	else if(number == 3 ){
     b54:	83 30       	cpi	r24, 0x03	; 3
     b56:	a1 f0       	breq	.+40     	; 0xb80 <int2seg+0x3c>
		return THREE;
	}
	else if(number == 4 ){
     b58:	84 30       	cpi	r24, 0x04	; 4
     b5a:	81 f0       	breq	.+32     	; 0xb7c <int2seg+0x38>
		return FOUR;
	}
	else if(number == 5 ){
     b5c:	85 30       	cpi	r24, 0x05	; 5
     b5e:	91 f0       	breq	.+36     	; 0xb84 <int2seg+0x40>
		return FIVE;
	}
	else if(number == 6 ){
     b60:	86 30       	cpi	r24, 0x06	; 6
     b62:	91 f0       	breq	.+36     	; 0xb88 <int2seg+0x44>
		return  SIX;
	}
	else if(number == 7 ){
     b64:	87 30       	cpi	r24, 0x07	; 7
     b66:	91 f0       	breq	.+36     	; 0xb8c <int2seg+0x48>
		return SEVEN;
	}
	else if(number == 8 ){
     b68:	88 30       	cpi	r24, 0x08	; 8
     b6a:	91 f0       	breq	.+36     	; 0xb90 <int2seg+0x4c>
		return EIGHT;
	}
	else if(number == 9 ){
     b6c:	89 30       	cpi	r24, 0x09	; 9
     b6e:	91 f0       	breq	.+36     	; 0xb94 <int2seg+0x50>
		return NINE;
	}
	else{ 
		return 0;
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	08 95       	ret
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
		return ZERO;
	}
	else if(number == 1 ){
		return ONE;
     b74:	89 ef       	ldi	r24, 0xF9	; 249
     b76:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
     b78:	84 ea       	ldi	r24, 0xA4	; 164
     b7a:	08 95       	ret
	}
	else if(number == 3 ){
		return THREE;
	}
	else if(number == 4 ){
		return FOUR;
     b7c:	89 e9       	ldi	r24, 0x99	; 153
     b7e:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
	}
	else if(number == 3 ){
		return THREE;
     b80:	80 eb       	ldi	r24, 0xB0	; 176
     b82:	08 95       	ret
	}
	else if(number == 4 ){
		return FOUR;
	}
	else if(number == 5 ){
		return FIVE;
     b84:	82 e9       	ldi	r24, 0x92	; 146
     b86:	08 95       	ret
	}
	else if(number == 6 ){
		return  SIX;
     b88:	82 e8       	ldi	r24, 0x82	; 130
     b8a:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
     b8c:	88 ef       	ldi	r24, 0xF8	; 248
		return NINE;
	}
	else{ 
		return 0;
	}
}
     b8e:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
	}
	else if(number == 8 ){
		return EIGHT;
     b90:	80 e8       	ldi	r24, 0x80	; 128
     b92:	08 95       	ret
	}
	else if(number == 9 ){
		return NINE;
     b94:	80 e9       	ldi	r24, 0x90	; 144
     b96:	08 95       	ret

00000b98 <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
     b98:	ff 92       	push	r15
     b9a:	0f 93       	push	r16
     b9c:	1f 93       	push	r17
     b9e:	cf 93       	push	r28
     ba0:	df 93       	push	r29
     ba2:	ec 01       	movw	r28, r24
	//determine how many digits there are 
	//int digit;
	// Break down the digits

	if(ticker%2 == 1){
     ba4:	80 91 5a 01 	lds	r24, 0x015A
     ba8:	80 ff       	sbrs	r24, 0
     baa:	82 c0       	rjmp	.+260    	; 0xcb0 <segsum+0x118>
		segment_data[2] = 0xFC;
     bac:	8c ef       	ldi	r24, 0xFC	; 252
     bae:	80 93 80 01 	sts	0x0180, r24
		segment_data[2] = 0xFF;
	} 
	//When setting alarm is on)
	//break up decimal sum into 4 digit-segments

	segment_data[0] = int2seg(sum % 10); //ones
     bb2:	9e 01       	movw	r18, r28
     bb4:	ad ec       	ldi	r26, 0xCD	; 205
     bb6:	bc ec       	ldi	r27, 0xCC	; 204
     bb8:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <__umulhisi3>
     bbc:	96 95       	lsr	r25
     bbe:	87 95       	ror	r24
     bc0:	96 95       	lsr	r25
     bc2:	87 95       	ror	r24
     bc4:	96 95       	lsr	r25
     bc6:	87 95       	ror	r24
     bc8:	3c 2f       	mov	r19, r28
     bca:	2a e0       	ldi	r18, 0x0A	; 10
     bcc:	82 9f       	mul	r24, r18
     bce:	30 19       	sub	r19, r0
     bd0:	11 24       	eor	r1, r1
     bd2:	83 2f       	mov	r24, r19
     bd4:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     bd8:	f8 2e       	mov	r15, r24
	segment_data[1] = int2seg((sum % 100)/10); //tens
     bda:	9e 01       	movw	r18, r28
     bdc:	36 95       	lsr	r19
     bde:	27 95       	ror	r18
     be0:	36 95       	lsr	r19
     be2:	27 95       	ror	r18
     be4:	ab e7       	ldi	r26, 0x7B	; 123
     be6:	b4 e1       	ldi	r27, 0x14	; 20
     be8:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <__umulhisi3>
     bec:	96 95       	lsr	r25
     bee:	87 95       	ror	r24
     bf0:	44 e6       	ldi	r20, 0x64	; 100
     bf2:	48 9f       	mul	r20, r24
     bf4:	90 01       	movw	r18, r0
     bf6:	49 9f       	mul	r20, r25
     bf8:	30 0d       	add	r19, r0
     bfa:	11 24       	eor	r1, r1
     bfc:	ce 01       	movw	r24, r28
     bfe:	82 1b       	sub	r24, r18
     c00:	93 0b       	sbc	r25, r19
     c02:	9c 01       	movw	r18, r24
     c04:	ad ec       	ldi	r26, 0xCD	; 205
     c06:	bc ec       	ldi	r27, 0xCC	; 204
     c08:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <__umulhisi3>
     c0c:	96 95       	lsr	r25
     c0e:	87 95       	ror	r24
     c10:	96 95       	lsr	r25
     c12:	87 95       	ror	r24
     c14:	96 95       	lsr	r25
     c16:	87 95       	ror	r24
     c18:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c1c:	80 93 7f 01 	sts	0x017F, r24
	//segment_data[2] = 1; //decimal
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
     c20:	9e 01       	movw	r18, r28
     c22:	36 95       	lsr	r19
     c24:	27 95       	ror	r18
     c26:	36 95       	lsr	r19
     c28:	27 95       	ror	r18
     c2a:	36 95       	lsr	r19
     c2c:	27 95       	ror	r18
     c2e:	a5 ec       	ldi	r26, 0xC5	; 197
     c30:	b0 e2       	ldi	r27, 0x20	; 32
     c32:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <__umulhisi3>
     c36:	8c 01       	movw	r16, r24
     c38:	12 95       	swap	r17
     c3a:	02 95       	swap	r16
     c3c:	0f 70       	andi	r16, 0x0F	; 15
     c3e:	01 27       	eor	r16, r17
     c40:	1f 70       	andi	r17, 0x0F	; 15
     c42:	01 27       	eor	r16, r17
     c44:	48 ee       	ldi	r20, 0xE8	; 232
     c46:	53 e0       	ldi	r21, 0x03	; 3
     c48:	04 9f       	mul	r16, r20
     c4a:	90 01       	movw	r18, r0
     c4c:	05 9f       	mul	r16, r21
     c4e:	30 0d       	add	r19, r0
     c50:	14 9f       	mul	r17, r20
     c52:	30 0d       	add	r19, r0
     c54:	11 24       	eor	r1, r1
     c56:	ce 01       	movw	r24, r28
     c58:	82 1b       	sub	r24, r18
     c5a:	93 0b       	sbc	r25, r19
     c5c:	9c 01       	movw	r18, r24
     c5e:	36 95       	lsr	r19
     c60:	27 95       	ror	r18
     c62:	36 95       	lsr	r19
     c64:	27 95       	ror	r18
     c66:	ab e7       	ldi	r26, 0x7B	; 123
     c68:	b4 e1       	ldi	r27, 0x14	; 20
     c6a:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <__umulhisi3>
     c6e:	96 95       	lsr	r25
     c70:	87 95       	ror	r24
     c72:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c76:	80 93 81 01 	sts	0x0181, r24
	segment_data[4] = int2seg(sum/1000); //thousands
     c7a:	80 2f       	mov	r24, r16
     c7c:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c80:	80 93 82 01 	sts	0x0182, r24
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
     c84:	80 91 40 01 	lds	r24, 0x0140
     c88:	88 23       	and	r24, r24
     c8a:	21 f0       	breq	.+8      	; 0xc94 <segsum+0xfc>
     c8c:	80 91 66 01 	lds	r24, 0x0166
     c90:	81 11       	cpse	r24, r1
     c92:	12 c0       	rjmp	.+36     	; 0xcb8 <segsum+0x120>
		segment_data[0] &= 0x7F;
	}
	else{
		segment_data[0] |= 0b10000000;
     c94:	8f 2d       	mov	r24, r15
     c96:	80 68       	ori	r24, 0x80	; 128
     c98:	80 93 7e 01 	sts	0x017E, r24
	}
	if(mode == 1 && blink){
     c9c:	80 91 60 01 	lds	r24, 0x0160
     ca0:	81 30       	cpi	r24, 0x01	; 1
     ca2:	91 f0       	breq	.+36     	; 0xcc8 <segsum+0x130>
		segment_data[4] = 0xFF;
		segment_data[3] = 0xFF;
		segment_data[1] = 0xFF;
		segment_data[0] = 0xFF;
	}
}//segment_sum
     ca4:	df 91       	pop	r29
     ca6:	cf 91       	pop	r28
     ca8:	1f 91       	pop	r17
     caa:	0f 91       	pop	r16
     cac:	ff 90       	pop	r15
     cae:	08 95       	ret

	if(ticker%2 == 1){
		segment_data[2] = 0xFC;
	}
	else{
		segment_data[2] = 0xFF;
     cb0:	8f ef       	ldi	r24, 0xFF	; 255
     cb2:	80 93 80 01 	sts	0x0180, r24
     cb6:	7d cf       	rjmp	.-262    	; 0xbb2 <segsum+0x1a>
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
	segment_data[4] = int2seg(sum/1000); //thousands
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
		segment_data[0] &= 0x7F;
     cb8:	8f 2d       	mov	r24, r15
     cba:	8f 77       	andi	r24, 0x7F	; 127
     cbc:	80 93 7e 01 	sts	0x017E, r24
	}
	else{
		segment_data[0] |= 0b10000000;
	}
	if(mode == 1 && blink){
     cc0:	80 91 60 01 	lds	r24, 0x0160
     cc4:	81 30       	cpi	r24, 0x01	; 1
     cc6:	71 f7       	brne	.-36     	; 0xca4 <segsum+0x10c>
     cc8:	80 91 37 01 	lds	r24, 0x0137
     ccc:	88 23       	and	r24, r24
     cce:	51 f3       	breq	.-44     	; 0xca4 <segsum+0x10c>
		segment_data[4] = 0xFF;
     cd0:	8f ef       	ldi	r24, 0xFF	; 255
     cd2:	80 93 82 01 	sts	0x0182, r24
		segment_data[3] = 0xFF;
     cd6:	80 93 81 01 	sts	0x0181, r24
		segment_data[1] = 0xFF;
     cda:	80 93 7f 01 	sts	0x017F, r24
		segment_data[0] = 0xFF;
     cde:	80 93 7e 01 	sts	0x017E, r24
	}
}//segment_sum
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	08 95       	ret

00000cee <button_routine>:
//***********************************************************************************
void button_routine(){
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
	// L -> R
	// 3 2 1 0 7 6 5 4
	uint8_t button = 0;
	//static int previous_mode;   
	DDRA  = 0x00; // PORTA input mode
     cf4:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0xFF; //Pull ups
     cf6:	8f ef       	ldi	r24, 0xFF	; 255
     cf8:	8b bb       	out	0x1b, r24	; 27
	__asm__ __volatile__ ("nop");
     cfa:	00 00       	nop
	__asm__ __volatile__ ("nop");
     cfc:	00 00       	nop
	//enable tristate buffer for pushbutton switches
	PORTB |= 0x70; //Set S2,S1,S0 to 111
     cfe:	88 b3       	in	r24, 0x18	; 24
     d00:	80 67       	ori	r24, 0x70	; 112
     d02:	88 bb       	out	0x18, r24	; 24
	__asm__ __volatile__ ("nop");
     d04:	00 00       	nop
	__asm__ __volatile__ ("nop");
     d06:	00 00       	nop
     d08:	20 e0       	ldi	r18, 0x00	; 0
     d0a:	30 e0       	ldi	r19, 0x00	; 0
				case 7:
					if(alarm_on && music_status){
						music_off();
						music_status = 0;
					}
					alarm_on = !alarm_on;
     d0c:	d1 e0       	ldi	r29, 0x01	; 1
				case 3:
					if(mode == 3){
						mode = 0;			
					}
					else{
						mode = 3;
     d0e:	c3 e0       	ldi	r28, 0x03	; 3
				case 2:
					if(mode == 2){
						mode = 0;	
					}
					else{
						mode = 2;
     d10:	12 e0       	ldi	r17, 0x02	; 2
     d12:	10 c0       	rjmp	.+32     	; 0xd34 <button_routine+0x46>
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d14:	61 e0       	ldi	r22, 0x01	; 1
     d16:	70 ee       	ldi	r23, 0xE0	; 224
     d18:	46 2b       	or	r20, r22
     d1a:	57 2b       	or	r21, r23
     d1c:	50 93 59 01 	sts	0x0159, r21
     d20:	40 93 58 01 	sts	0x0158, r20
	if (state == 0xF000){
     d24:	41 15       	cp	r20, r1
     d26:	50 4f       	sbci	r21, 0xF0	; 240
     d28:	c9 f0       	breq	.+50     	; 0xd5c <button_routine+0x6e>
     d2a:	2f 5f       	subi	r18, 0xFF	; 255
     d2c:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d2e:	28 30       	cpi	r18, 0x08	; 8
     d30:	31 05       	cpc	r19, r1
     d32:	11 f1       	breq	.+68     	; 0xd78 <button_routine+0x8a>
     d34:	82 2f       	mov	r24, r18
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d36:	40 91 58 01 	lds	r20, 0x0158
     d3a:	50 91 59 01 	lds	r21, 0x0159
     d3e:	44 0f       	add	r20, r20
     d40:	55 1f       	adc	r21, r21
     d42:	69 b3       	in	r22, 0x19	; 25
     d44:	70 e0       	ldi	r23, 0x00	; 0
     d46:	02 2e       	mov	r0, r18
     d48:	02 c0       	rjmp	.+4      	; 0xd4e <button_routine+0x60>
     d4a:	75 95       	asr	r23
     d4c:	67 95       	ror	r22
     d4e:	0a 94       	dec	r0
     d50:	e2 f7       	brpl	.-8      	; 0xd4a <button_routine+0x5c>
     d52:	60 ff       	sbrs	r22, 0
     d54:	df cf       	rjmp	.-66     	; 0xd14 <button_routine+0x26>
     d56:	60 e0       	ldi	r22, 0x00	; 0
     d58:	70 ee       	ldi	r23, 0xE0	; 224
     d5a:	de cf       	rjmp	.-68     	; 0xd18 <button_routine+0x2a>
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	87 30       	cpi	r24, 0x07	; 7
     d62:	91 05       	cpc	r25, r1
     d64:	88 f0       	brcs	.+34     	; 0xd88 <button_routine+0x9a>
				case 0:  
					mode = 0;
					break;
				case 1:
					if(mode == 1){
						mode = 0;	
     d66:	10 92 60 01 	sts	0x0160, r1
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     d6a:	d0 93 49 01 	sts	0x0149, r29
     d6e:	2f 5f       	subi	r18, 0xFF	; 255
     d70:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d72:	28 30       	cpi	r18, 0x08	; 8
     d74:	31 05       	cpc	r19, r1
     d76:	f1 f6       	brne	.-68     	; 0xd34 <button_routine+0x46>
					break;
			}
			bar_graph_flag = 1;	
		}
	}
	DDRA = 0xFF;  //switch PORTA to output
     d78:	8f ef       	ldi	r24, 0xFF	; 255
     d7a:	8a bb       	out	0x1a, r24	; 26
	__asm__ __volatile__ ("nop"); //Buffer
     d7c:	00 00       	nop
	__asm__ __volatile__ ("nop"); //Buffer 
     d7e:	00 00       	nop

}
     d80:	df 91       	pop	r29
     d82:	cf 91       	pop	r28
     d84:	1f 91       	pop	r17
     d86:	08 95       	ret
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
     d88:	8c 52       	subi	r24, 0x2C	; 44
     d8a:	9f 4f       	sbci	r25, 0xFF	; 255
     d8c:	fc 01       	movw	r30, r24
     d8e:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
					break;
				case 4:
					temp_mode = !temp_mode;
					break;
				case 5:
					show_ampm = !show_ampm;
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	90 91 66 01 	lds	r25, 0x0166
     d98:	91 11       	cpse	r25, r1
     d9a:	80 e0       	ldi	r24, 0x00	; 0
     d9c:	80 93 66 01 	sts	0x0166, r24
					//show_temp = !show_temp;
					break;
     da0:	e4 cf       	rjmp	.-56     	; 0xd6a <button_routine+0x7c>
					else{
						mode = 3;
					}
					break;
				case 4:
					temp_mode = !temp_mode;
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	90 91 36 01 	lds	r25, 0x0136
     da8:	91 11       	cpse	r25, r1
     daa:	80 e0       	ldi	r24, 0x00	; 0
     dac:	80 93 36 01 	sts	0x0136, r24
					break;
     db0:	dc cf       	rjmp	.-72     	; 0xd6a <button_routine+0x7c>
					else{
						mode = 2;
					}
					break;
				case 3:
					if(mode == 3){
     db2:	80 91 60 01 	lds	r24, 0x0160
     db6:	83 30       	cpi	r24, 0x03	; 3
     db8:	b1 f2       	breq	.-84     	; 0xd66 <button_routine+0x78>
						mode = 0;			
					}
					else{
						mode = 3;
     dba:	c0 93 60 01 	sts	0x0160, r28
     dbe:	d5 cf       	rjmp	.-86     	; 0xd6a <button_routine+0x7c>
					else{
						mode = 1;
					}
					break;
				case 2:
					if(mode == 2){
     dc0:	80 91 60 01 	lds	r24, 0x0160
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	79 f2       	breq	.-98     	; 0xd66 <button_routine+0x78>
						mode = 0;	
					}
					else{
						mode = 2;
     dc8:	10 93 60 01 	sts	0x0160, r17
     dcc:	ce cf       	rjmp	.-100    	; 0xd6a <button_routine+0x7c>
			switch(button){
				case 0:  
					mode = 0;
					break;
				case 1:
					if(mode == 1){
     dce:	80 91 60 01 	lds	r24, 0x0160
     dd2:	81 30       	cpi	r24, 0x01	; 1
     dd4:	41 f2       	breq	.-112    	; 0xd66 <button_routine+0x78>
						mode = 0;	
					}
					else{
						mode = 1;
     dd6:	d0 93 60 01 	sts	0x0160, r29
     dda:	c7 cf       	rjmp	.-114    	; 0xd6a <button_routine+0x7c>
				case 5:
					show_ampm = !show_ampm;
					//show_temp = !show_temp;
					break;
				case 6:
					if(music_status){
     ddc:	80 91 38 01 	lds	r24, 0x0138
     de0:	88 23       	and	r24, r24
     de2:	09 f4       	brne	.+2      	; 0xde6 <button_routine+0xf8>
     de4:	c2 cf       	rjmp	.-124    	; 0xd6a <button_routine+0x7c>
						snooze_flag = 1;
     de6:	d0 93 3a 01 	sts	0x013A, r29
						music_status = 0;
     dea:	10 92 38 01 	sts	0x0138, r1
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     dee:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     df2:	8e b5       	in	r24, 0x2e	; 46
     df4:	8c 7f       	andi	r24, 0xFC	; 252
     df6:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     df8:	92 9a       	sbi	0x12, 2	; 18
     dfa:	b7 cf       	rjmp	.-146    	; 0xd6a <button_routine+0x7c>
						music_off();
					}
					break;
				case 7:
					if(alarm_on && music_status){
     dfc:	80 91 39 01 	lds	r24, 0x0139
     e00:	88 23       	and	r24, r24
     e02:	79 f0       	breq	.+30     	; 0xe22 <button_routine+0x134>
     e04:	90 91 38 01 	lds	r25, 0x0138
     e08:	99 23       	and	r25, r25
     e0a:	91 f0       	breq	.+36     	; 0xe30 <button_routine+0x142>
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     e0c:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     e10:	8e b5       	in	r24, 0x2e	; 46
     e12:	8c 7f       	andi	r24, 0xFC	; 252
     e14:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     e16:	92 9a       	sbi	0x12, 2	; 18
						music_off();
						music_status = 0;
     e18:	10 92 38 01 	sts	0x0138, r1
     e1c:	90 91 39 01 	lds	r25, 0x0139
     e20:	01 c0       	rjmp	.+2      	; 0xe24 <button_routine+0x136>
     e22:	90 e0       	ldi	r25, 0x00	; 0
					}
					alarm_on = !alarm_on;
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	91 11       	cpse	r25, r1
     e28:	80 e0       	ldi	r24, 0x00	; 0
     e2a:	80 93 39 01 	sts	0x0139, r24
					//alarm_change = 1; 
					break;
     e2e:	9d cf       	rjmp	.-198    	; 0xd6a <button_routine+0x7c>
     e30:	98 2f       	mov	r25, r24
     e32:	f8 cf       	rjmp	.-16     	; 0xe24 <button_routine+0x136>

00000e34 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
     e34:	1f 92       	push	r1
     e36:	0f 92       	push	r0
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	0f 92       	push	r0
     e3c:	11 24       	eor	r1, r1
     e3e:	0b b6       	in	r0, 0x3b	; 59
     e40:	0f 92       	push	r0
     e42:	2f 93       	push	r18
     e44:	3f 93       	push	r19
     e46:	4f 93       	push	r20
     e48:	5f 93       	push	r21
     e4a:	6f 93       	push	r22
     e4c:	7f 93       	push	r23
     e4e:	8f 93       	push	r24
     e50:	9f 93       	push	r25
     e52:	af 93       	push	r26
     e54:	bf 93       	push	r27
     e56:	cf 93       	push	r28
     e58:	ef 93       	push	r30
     e5a:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
     e5c:	20 91 57 01 	lds	r18, 0x0157
     e60:	2f 5f       	subi	r18, 0xFF	; 255
     e62:	20 93 57 01 	sts	0x0157, r18
	//update_time();
	if(count%2 == 0){
     e66:	20 fd       	sbrc	r18, 0
     e68:	03 c0       	rjmp	.+6      	; 0xe70 <__vector_16+0x3c>
		update_LCD = 1;
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	80 93 4b 01 	sts	0x014B, r24

	}
	if(count%8 == 0){
     e70:	82 2f       	mov	r24, r18
     e72:	87 70       	andi	r24, 0x07	; 7
     e74:	81 f4       	brne	.+32     	; 0xe96 <__vector_16+0x62>
		//	update_LCD = 1;
		beat++;
     e76:	80 91 77 01 	lds	r24, 0x0177
     e7a:	90 91 78 01 	lds	r25, 0x0178
     e7e:	01 96       	adiw	r24, 0x01	; 1
     e80:	90 93 78 01 	sts	0x0178, r25
     e84:	80 93 77 01 	sts	0x0177, r24
		blink = !blink;
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	90 91 37 01 	lds	r25, 0x0137
     e8e:	91 11       	cpse	r25, r1
     e90:	3f c0       	rjmp	.+126    	; 0xf10 <__vector_16+0xdc>
     e92:	80 93 37 01 	sts	0x0137, r24
	}
	if((count%128)==0){
     e96:	2f 77       	andi	r18, 0x7F	; 127
     e98:	39 f5       	brne	.+78     	; 0xee8 <__vector_16+0xb4>
		ticker++;     
     e9a:	80 91 5a 01 	lds	r24, 0x015A
     e9e:	8f 5f       	subi	r24, 0xFF	; 255
     ea0:	80 93 5a 01 	sts	0x015A, r24
		second++; 
     ea4:	80 91 5f 01 	lds	r24, 0x015F
     ea8:	8f 5f       	subi	r24, 0xFF	; 255
     eaa:	80 93 5f 01 	sts	0x015F, r24
		reset_temp = 1;   
     eae:	c1 e0       	ldi	r28, 0x01	; 1
     eb0:	c0 93 4a 01 	sts	0x014A, r28
		if(alarm_on){
     eb4:	80 91 39 01 	lds	r24, 0x0139
     eb8:	88 23       	and	r24, r24
     eba:	b1 f0       	breq	.+44     	; 0xee8 <__vector_16+0xb4>
			if ((alarm_time == time) && !snooze_flag && !music_status){
     ebc:	20 91 44 01 	lds	r18, 0x0144
     ec0:	30 91 45 01 	lds	r19, 0x0145
     ec4:	80 91 46 01 	lds	r24, 0x0146
     ec8:	90 91 47 01 	lds	r25, 0x0147
     ecc:	28 17       	cp	r18, r24
     ece:	39 07       	cpc	r19, r25
     ed0:	41 f1       	breq	.+80     	; 0xf22 <__vector_16+0xee>
				//play music
				music_on();
				music_status = 1;
			}
			else if(snooze_flag){
     ed2:	80 91 3a 01 	lds	r24, 0x013A
     ed6:	88 23       	and	r24, r24
     ed8:	39 f0       	breq	.+14     	; 0xee8 <__vector_16+0xb4>
				snooze_second++;
     eda:	80 91 3b 01 	lds	r24, 0x013B
     ede:	8f 5f       	subi	r24, 0xFF	; 255
     ee0:	80 93 3b 01 	sts	0x013B, r24
				if(snooze_second >= 10){
     ee4:	8a 30       	cpi	r24, 0x0A	; 10
     ee6:	b0 f4       	brcc	.+44     	; 0xf14 <__vector_16+0xe0>
					snooze_second = 0;
				}	
			}
		}
	}
}
     ee8:	ff 91       	pop	r31
     eea:	ef 91       	pop	r30
     eec:	cf 91       	pop	r28
     eee:	bf 91       	pop	r27
     ef0:	af 91       	pop	r26
     ef2:	9f 91       	pop	r25
     ef4:	8f 91       	pop	r24
     ef6:	7f 91       	pop	r23
     ef8:	6f 91       	pop	r22
     efa:	5f 91       	pop	r21
     efc:	4f 91       	pop	r20
     efe:	3f 91       	pop	r19
     f00:	2f 91       	pop	r18
     f02:	0f 90       	pop	r0
     f04:	0b be       	out	0x3b, r0	; 59
     f06:	0f 90       	pop	r0
     f08:	0f be       	out	0x3f, r0	; 63
     f0a:	0f 90       	pop	r0
     f0c:	1f 90       	pop	r1
     f0e:	18 95       	reti

	}
	if(count%8 == 0){
		//	update_LCD = 1;
		beat++;
		blink = !blink;
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	bf cf       	rjmp	.-130    	; 0xe92 <__vector_16+0x5e>
				music_status = 1;
			}
			else if(snooze_flag){
				snooze_second++;
				if(snooze_second >= 10){
					snooze_flag = 0;
     f14:	10 92 3a 01 	sts	0x013A, r1
					music_on();
     f18:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
					snooze_second = 0;
     f1c:	10 92 3b 01 	sts	0x013B, r1
     f20:	e3 cf       	rjmp	.-58     	; 0xee8 <__vector_16+0xb4>
	if((count%128)==0){
		ticker++;     
		second++; 
		reset_temp = 1;   
		if(alarm_on){
			if ((alarm_time == time) && !snooze_flag && !music_status){
     f22:	80 91 3a 01 	lds	r24, 0x013A
     f26:	81 11       	cpse	r24, r1
     f28:	d8 cf       	rjmp	.-80     	; 0xeda <__vector_16+0xa6>
     f2a:	80 91 38 01 	lds	r24, 0x0138
     f2e:	81 11       	cpse	r24, r1
     f30:	db cf       	rjmp	.-74     	; 0xee8 <__vector_16+0xb4>
				//play music
				music_on();
     f32:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
				music_status = 1;
     f36:	c0 93 38 01 	sts	0x0138, r28
     f3a:	d6 cf       	rjmp	.-84     	; 0xee8 <__vector_16+0xb4>

00000f3c <__vector_12>:
			}
		}
	}
}

ISR(TIMER1_COMPA_vect){
     f3c:	1f 92       	push	r1
     f3e:	0f 92       	push	r0
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	0f 92       	push	r0
     f44:	11 24       	eor	r1, r1
     f46:	0b b6       	in	r0, 0x3b	; 59
     f48:	0f 92       	push	r0
     f4a:	2f 93       	push	r18
     f4c:	3f 93       	push	r19
     f4e:	4f 93       	push	r20
     f50:	5f 93       	push	r21
     f52:	6f 93       	push	r22
     f54:	7f 93       	push	r23
     f56:	8f 93       	push	r24
     f58:	9f 93       	push	r25
     f5a:	af 93       	push	r26
     f5c:	bf 93       	push	r27
     f5e:	ef 93       	push	r30
     f60:	ff 93       	push	r31
	PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
     f62:	82 b3       	in	r24, 0x12	; 18
     f64:	80 58       	subi	r24, 0x80	; 128
     f66:	82 bb       	out	0x12, r24	; 18
	PORTB |= (1<<PB0);
     f68:	c0 9a       	sbi	0x18, 0	; 24
	if(beat >= max_beat) {   //if we've played the note long enough
     f6a:	20 91 77 01 	lds	r18, 0x0177
     f6e:	30 91 78 01 	lds	r19, 0x0178
     f72:	80 91 75 01 	lds	r24, 0x0175
     f76:	90 91 76 01 	lds	r25, 0x0176
     f7a:	28 17       	cp	r18, r24
     f7c:	39 07       	cpc	r19, r25
     f7e:	60 f0       	brcs	.+24     	; 0xf98 <__vector_12+0x5c>
		notes++;               //move on to the next note
     f80:	80 91 67 01 	lds	r24, 0x0167
     f84:	8f 5f       	subi	r24, 0xFF	; 255
     f86:	80 93 67 01 	sts	0x0167, r24
		play_song(song, notes);//and play it
     f8a:	80 91 67 01 	lds	r24, 0x0167
     f8e:	90 91 74 01 	lds	r25, 0x0174
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	0e 94 65 04 	call	0x8ca	; 0x8ca <song0>
	}
}
     f98:	ff 91       	pop	r31
     f9a:	ef 91       	pop	r30
     f9c:	bf 91       	pop	r27
     f9e:	af 91       	pop	r26
     fa0:	9f 91       	pop	r25
     fa2:	8f 91       	pop	r24
     fa4:	7f 91       	pop	r23
     fa6:	6f 91       	pop	r22
     fa8:	5f 91       	pop	r21
     faa:	4f 91       	pop	r20
     fac:	3f 91       	pop	r19
     fae:	2f 91       	pop	r18
     fb0:	0f 90       	pop	r0
     fb2:	0b be       	out	0x3b, r0	; 59
     fb4:	0f 90       	pop	r0
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	0f 90       	pop	r0
     fba:	1f 90       	pop	r1
     fbc:	18 95       	reti

00000fbe <__vector_10>:

ISR(TIMER2_OVF_vect){
     fbe:	1f 92       	push	r1
     fc0:	0f 92       	push	r0
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	0f 92       	push	r0
     fc6:	11 24       	eor	r1, r1
     fc8:	0b b6       	in	r0, 0x3b	; 59
     fca:	0f 92       	push	r0
     fcc:	2f 93       	push	r18
     fce:	3f 93       	push	r19
     fd0:	4f 93       	push	r20
     fd2:	5f 93       	push	r21
     fd4:	6f 93       	push	r22
     fd6:	7f 93       	push	r23
     fd8:	8f 93       	push	r24
     fda:	9f 93       	push	r25
     fdc:	af 93       	push	r26
     fde:	bf 93       	push	r27
     fe0:	cf 93       	push	r28
     fe2:	ef 93       	push	r30
     fe4:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
     fe6:	c0 91 56 01 	lds	r28, 0x0156
     fea:	cf 5f       	subi	r28, 0xFF	; 255
     fec:	c0 93 56 01 	sts	0x0156, r28
	//display_update();

	if(count%64 == 0){
     ff0:	8c 2f       	mov	r24, r28
     ff2:	8f 73       	andi	r24, 0x3F	; 63
     ff4:	c9 f0       	breq	.+50     	; 0x1028 <__vector_10+0x6a>
		button_routine();
	}

	switch(count%8){
     ff6:	c7 70       	andi	r28, 0x07	; 7
     ff8:	19 f4       	brne	.+6      	; 0x1000 <__vector_10+0x42>
		case 0:
			//TODO
			encode_flag = 1;
     ffa:	81 e0       	ldi	r24, 0x01	; 1
     ffc:	80 93 4d 01 	sts	0x014D, r24
		case 1:
			break;
		default:
			break;
	}    
} 
    1000:	ff 91       	pop	r31
    1002:	ef 91       	pop	r30
    1004:	cf 91       	pop	r28
    1006:	bf 91       	pop	r27
    1008:	af 91       	pop	r26
    100a:	9f 91       	pop	r25
    100c:	8f 91       	pop	r24
    100e:	7f 91       	pop	r23
    1010:	6f 91       	pop	r22
    1012:	5f 91       	pop	r21
    1014:	4f 91       	pop	r20
    1016:	3f 91       	pop	r19
    1018:	2f 91       	pop	r18
    101a:	0f 90       	pop	r0
    101c:	0b be       	out	0x3b, r0	; 59
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	0f 90       	pop	r0
    1024:	1f 90       	pop	r1
    1026:	18 95       	reti
	static uint8_t count = 0;
	count++;
	//display_update();

	if(count%64 == 0){
		button_routine();
    1028:	0e 94 77 06 	call	0xcee	; 0xcee <button_routine>
    102c:	e4 cf       	rjmp	.-56     	; 0xff6 <__vector_10+0x38>

0000102e <__vector_21>:
		default:
			break;
	}    
} 

ISR(ADC_vect){
    102e:	1f 92       	push	r1
    1030:	0f 92       	push	r0
    1032:	0f b6       	in	r0, 0x3f	; 63
    1034:	0f 92       	push	r0
    1036:	11 24       	eor	r1, r1
    1038:	8f 93       	push	r24
    103a:	9f 93       	push	r25

	if(ADCH < 100){
    103c:	85 b1       	in	r24, 0x05	; 5
    103e:	84 36       	cpi	r24, 0x64	; 100
    1040:	48 f0       	brcs	.+18     	; 0x1054 <__vector_21+0x26>
		OCR2 = 100-ADCH;
	}  
	else{
		OCR2 = 1;// brightness_level;
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	83 bd       	out	0x23, r24	; 35
	}
}
    1046:	9f 91       	pop	r25
    1048:	8f 91       	pop	r24
    104a:	0f 90       	pop	r0
    104c:	0f be       	out	0x3f, r0	; 63
    104e:	0f 90       	pop	r0
    1050:	1f 90       	pop	r1
    1052:	18 95       	reti
} 

ISR(ADC_vect){

	if(ADCH < 100){
		OCR2 = 100-ADCH;
    1054:	95 b1       	in	r25, 0x05	; 5
    1056:	84 e6       	ldi	r24, 0x64	; 100
    1058:	89 1b       	sub	r24, r25
    105a:	83 bd       	out	0x23, r24	; 35
	}  
	else{
		OCR2 = 1;// brightness_level;
	}
}
    105c:	9f 91       	pop	r25
    105e:	8f 91       	pop	r24
    1060:	0f 90       	pop	r0
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	0f 90       	pop	r0
    1066:	1f 90       	pop	r1
    1068:	18 95       	reti

0000106a <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
    106a:	80 91 5f 01 	lds	r24, 0x015F
		minute++;
    106e:	20 91 5e 01 	lds	r18, 0x015E
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
    1072:	8c 33       	cpi	r24, 0x3C	; 60
    1074:	28 f0       	brcs	.+10     	; 0x1080 <update_time+0x16>
		minute++;
    1076:	2f 5f       	subi	r18, 0xFF	; 255
    1078:	20 93 5e 01 	sts	0x015E, r18
		second = 0;
    107c:	10 92 5f 01 	sts	0x015F, r1
	}             
	if(minute >=60){
		hour++;
    1080:	e0 91 5d 01 	lds	r30, 0x015D
	// static int minute_change = 0;
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
    1084:	2c 33       	cpi	r18, 0x3C	; 60
    1086:	c0 f5       	brcc	.+112    	; 0x10f8 <update_time+0x8e>
    1088:	30 e0       	ldi	r19, 0x00	; 0
		hour++;
		minute = 0;
	}
	if(hour >= 24){
    108a:	e8 31       	cpi	r30, 0x18	; 24
    108c:	f0 f5       	brcc	.+124    	; 0x110a <__stack+0xb>
    108e:	6e 2f       	mov	r22, r30
    1090:	70 e0       	ldi	r23, 0x00	; 0
    1092:	84 e6       	ldi	r24, 0x64	; 100
    1094:	e8 9f       	mul	r30, r24
    1096:	a0 01       	movw	r20, r0
    1098:	11 24       	eor	r1, r1
		hour = 0;
	} 

	alarm_time = (alarm_hour * 100) + alarm_minute;
    109a:	f0 91 5b 01 	lds	r31, 0x015B
    109e:	80 91 5c 01 	lds	r24, 0x015C
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	a4 e6       	ldi	r26, 0x64	; 100
    10a6:	fa 9f       	mul	r31, r26
    10a8:	80 0d       	add	r24, r0
    10aa:	91 1d       	adc	r25, r1
    10ac:	11 24       	eor	r1, r1
    10ae:	90 93 45 01 	sts	0x0145, r25
    10b2:	80 93 44 01 	sts	0x0144, r24
	// if(minute_change){
	time = (hour * 100) + minute;
    10b6:	c9 01       	movw	r24, r18
    10b8:	84 0f       	add	r24, r20
    10ba:	95 1f       	adc	r25, r21
    10bc:	90 93 47 01 	sts	0x0147, r25
    10c0:	80 93 46 01 	sts	0x0146, r24
	// minute_change = 0;

	if(show_ampm){
    10c4:	40 91 66 01 	lds	r20, 0x0166
    10c8:	44 23       	and	r20, r20
    10ca:	39 f1       	breq	.+78     	; 0x111a <__stack+0x1b>
		if(hour>=12){
    10cc:	ec 30       	cpi	r30, 0x0C	; 12
    10ce:	50 f1       	brcs	.+84     	; 0x1124 <__stack+0x25>
			if(hour == 12){
    10d0:	ec 30       	cpi	r30, 0x0C	; 12
    10d2:	d1 f1       	breq	.+116    	; 0x1148 <__stack+0x49>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour-12)*100 + minute;
    10d4:	6c 50       	subi	r22, 0x0C	; 12
    10d6:	71 09       	sbc	r23, r1
    10d8:	44 e6       	ldi	r20, 0x64	; 100
    10da:	46 9f       	mul	r20, r22
    10dc:	c0 01       	movw	r24, r0
    10de:	47 9f       	mul	r20, r23
    10e0:	90 0d       	add	r25, r0
    10e2:	11 24       	eor	r1, r1
    10e4:	82 0f       	add	r24, r18
    10e6:	93 1f       	adc	r25, r19
    10e8:	90 93 43 01 	sts	0x0143, r25
    10ec:	80 93 42 01 	sts	0x0142, r24
				am_pm = 1;
    10f0:	81 e0       	ldi	r24, 0x01	; 1
    10f2:	80 93 40 01 	sts	0x0140, r24
    10f6:	08 95       	ret
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
		hour++;
    10f8:	ef 5f       	subi	r30, 0xFF	; 255
    10fa:	e0 93 5d 01 	sts	0x015D, r30
		minute = 0;
    10fe:	10 92 5e 01 	sts	0x015E, r1
    1102:	20 e0       	ldi	r18, 0x00	; 0
    1104:	30 e0       	ldi	r19, 0x00	; 0
	}
	if(hour >= 24){
    1106:	e8 31       	cpi	r30, 0x18	; 24
    1108:	10 f2       	brcs	.-124    	; 0x108e <update_time+0x24>
		hour = 0;
    110a:	10 92 5d 01 	sts	0x015D, r1
    110e:	40 e0       	ldi	r20, 0x00	; 0
    1110:	50 e0       	ldi	r21, 0x00	; 0
    1112:	60 e0       	ldi	r22, 0x00	; 0
    1114:	70 e0       	ldi	r23, 0x00	; 0
    1116:	e0 e0       	ldi	r30, 0x00	; 0
    1118:	c0 cf       	rjmp	.-128    	; 0x109a <update_time+0x30>
			}
			am_pm = 0;
		}
	}
	else{
		show_time = (hour * 100) + minute;
    111a:	90 93 43 01 	sts	0x0143, r25
    111e:	80 93 42 01 	sts	0x0142, r24
    1122:	08 95       	ret
				show_time = (hour-12)*100 + minute;
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
    1124:	ee 23       	and	r30, r30
    1126:	39 f0       	breq	.+14     	; 0x1136 <__stack+0x37>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour)*100 + minute;
    1128:	90 93 43 01 	sts	0x0143, r25
    112c:	80 93 42 01 	sts	0x0142, r24
			}
			am_pm = 0;
    1130:	10 92 40 01 	sts	0x0140, r1
    1134:	08 95       	ret
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
				show_time = 1200 + minute;
    1136:	20 55       	subi	r18, 0x50	; 80
    1138:	3b 4f       	sbci	r19, 0xFB	; 251
    113a:	30 93 43 01 	sts	0x0143, r19
    113e:	20 93 42 01 	sts	0x0142, r18
			}
			else{
				show_time = (hour)*100 + minute;
			}
			am_pm = 0;
    1142:	10 92 40 01 	sts	0x0140, r1
    1146:	08 95       	ret
	// minute_change = 0;

	if(show_ampm){
		if(hour>=12){
			if(hour == 12){
				show_time = 1200 + minute;
    1148:	20 55       	subi	r18, 0x50	; 80
    114a:	3b 4f       	sbci	r19, 0xFB	; 251
    114c:	30 93 43 01 	sts	0x0143, r19
    1150:	20 93 42 01 	sts	0x0142, r18
    1154:	08 95       	ret

00001156 <SPI_init>:
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    1156:	80 e5       	ldi	r24, 0x50	; 80
    1158:	8d b9       	out	0x0d, r24	; 13
    115a:	08 95       	ret

0000115c <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    115c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    115e:	77 9b       	sbis	0x0e, 7	; 14
    1160:	fe cf       	rjmp	.-4      	; 0x115e <SPI_Transmit+0x2>
}
    1162:	08 95       	ret

00001164 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
	PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
    1164:	83 b1       	in	r24, 0x03	; 3
    1166:	13 b8       	out	0x03, r1	; 3
	__asm__ __volatile__ ("nop");
    1168:	00 00       	nop
	__asm__ __volatile__ ("nop");
    116a:	00 00       	nop
	// Wait until 8 clock cycles are done 
	SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
    116c:	1f b8       	out	0x0f, r1	; 15
	PORTE |= (1 << PE6);  
    116e:	1e 9a       	sbi	0x03, 6	; 3
	__asm__ __volatile__ ("nop");
    1170:	00 00       	nop
	__asm__ __volatile__ ("nop");
    1172:	00 00       	nop
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    1174:	77 9b       	sbis	0x0e, 7	; 14
    1176:	fe cf       	rjmp	.-4      	; 0x1174 <SPI_Receive+0x10>
	// Return incoming data from SPDR
	return(SPDR);  
    1178:	8f b1       	in	r24, 0x0f	; 15
}
    117a:	08 95       	ret

0000117c <bar_graph>:
 *void bar_graph()
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
    117c:	80 91 60 01 	lds	r24, 0x0160
    1180:	88 23       	and	r24, r24
    1182:	b9 f0       	breq	.+46     	; 0x11b2 <bar_graph+0x36>
		write = 0x00;
	}
	else{
		write = 1<<(mode-1);
    1184:	9f ef       	ldi	r25, 0xFF	; 255
    1186:	98 0f       	add	r25, r24
    1188:	81 e0       	ldi	r24, 0x01	; 1
    118a:	01 c0       	rjmp	.+2      	; 0x118e <bar_graph+0x12>
    118c:	88 0f       	add	r24, r24
    118e:	9a 95       	dec	r25
    1190:	ea f7       	brpl	.-6      	; 0x118c <bar_graph+0x10>
	}

	if(alarm_on != 0){
    1192:	90 91 39 01 	lds	r25, 0x0139
    1196:	91 11       	cpse	r25, r1
		write = 0xFF;
    1198:	8f ef       	ldi	r24, 0xFF	; 255

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    119a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    119c:	77 9b       	sbis	0x0e, 7	; 14
    119e:	fe cf       	rjmp	.-4      	; 0x119c <bar_graph+0x20>

	if(alarm_on != 0){
		write = 0xFF;
	}
	SPI_Transmit(write);
	PORTD = (1 << PD2);  //Push data out of SPI
    11a0:	84 e0       	ldi	r24, 0x04	; 4
    11a2:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop"); //Buffer
    11a4:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    11a6:	00 00       	nop


	PORTD = (2 << PD2);  // Push data out of SPI
    11a8:	88 e0       	ldi	r24, 0x08	; 8
    11aa:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop");  //Buffer
    11ac:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    11ae:	00 00       	nop
    11b0:	08 95       	ret
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
		write = 0x00;
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	ee cf       	rjmp	.-36     	; 0x1192 <bar_graph+0x16>

000011b6 <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
	uint8_t display_segment = 0;
	//static uint8_t rotate_7seg = 0;
	switch(mode){
    11b6:	80 91 60 01 	lds	r24, 0x0160
    11ba:	83 30       	cpi	r24, 0x03	; 3
    11bc:	41 f1       	breq	.+80     	; 0x120e <display_update+0x58>
    11be:	84 30       	cpi	r24, 0x04	; 4
    11c0:	41 f0       	breq	.+16     	; 0x11d2 <display_update+0x1c>
    11c2:	82 30       	cpi	r24, 0x02	; 2
    11c4:	d9 f0       	breq	.+54     	; 0x11fc <display_update+0x46>
			segment_data[2] = 0xFF; //decimal
			break;
		case 4:
			break;
		default:
			segsum(show_time);
    11c6:	80 91 42 01 	lds	r24, 0x0142
    11ca:	90 91 43 01 	lds	r25, 0x0143
    11ce:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
    11d2:	ee e7       	ldi	r30, 0x7E	; 126
    11d4:	f1 e0       	ldi	r31, 0x01	; 1
	__asm__ __volatile__ ("nop");  //Buffer
}
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    11d6:	80 e0       	ldi	r24, 0x00	; 0

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
		PORTB = display_segment << 4;
		PORTA = segment_data[display_segment];
		_delay_us(80);
		PORTA = OFF;
    11d8:	2f ef       	ldi	r18, 0xFF	; 255
			segsum(show_time);
			break;
	}

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
		PORTB = display_segment << 4;
    11da:	98 2f       	mov	r25, r24
    11dc:	92 95       	swap	r25
    11de:	90 7f       	andi	r25, 0xF0	; 240
    11e0:	98 bb       	out	0x18, r25	; 24
		PORTA = segment_data[display_segment];
    11e2:	91 91       	ld	r25, Z+
    11e4:	9b bb       	out	0x1b, r25	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    11e6:	af e3       	ldi	r26, 0x3F	; 63
    11e8:	b1 e0       	ldi	r27, 0x01	; 1
    11ea:	11 97       	sbiw	r26, 0x01	; 1
    11ec:	f1 f7       	brne	.-4      	; 0x11ea <display_update+0x34>
    11ee:	00 c0       	rjmp	.+0      	; 0x11f0 <display_update+0x3a>
    11f0:	00 00       	nop
		_delay_us(80);
		PORTA = OFF;
    11f2:	2b bb       	out	0x1b, r18	; 27
		default:
			segsum(show_time);
			break;
	}

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
    11f4:	8f 5f       	subi	r24, 0xFF	; 255
    11f6:	85 30       	cpi	r24, 0x05	; 5
    11f8:	81 f7       	brne	.-32     	; 0x11da <display_update+0x24>
		PORTB = display_segment << 4;
		PORTA = segment_data[display_segment];
		_delay_us(80);
		PORTA = OFF;
	}
}
    11fa:	08 95       	ret
void display_update(){
	uint8_t display_segment = 0;
	//static uint8_t rotate_7seg = 0;
	switch(mode){
		case 2:
			segsum(alarm_time);
    11fc:	80 91 44 01 	lds	r24, 0x0144
    1200:	90 91 45 01 	lds	r25, 0x0145
    1204:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0x00;
    1208:	10 92 80 01 	sts	0x0180, r1
			break;
    120c:	e2 cf       	rjmp	.-60     	; 0x11d2 <display_update+0x1c>
		case 3:
			segsum(OCR3A);
    120e:	80 91 86 00 	lds	r24, 0x0086
    1212:	90 91 87 00 	lds	r25, 0x0087
    1216:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0xFF; //decimal
    121a:	8f ef       	ldi	r24, 0xFF	; 255
    121c:	80 93 80 01 	sts	0x0180, r24
			break;
    1220:	d8 cf       	rjmp	.-80     	; 0x11d2 <display_update+0x1c>

00001222 <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
	switch(mode){
    1222:	80 91 60 01 	lds	r24, 0x0160
    1226:	81 30       	cpi	r24, 0x01	; 1
    1228:	59 f0       	breq	.+22     	; 0x1240 <right_inc+0x1e>
    122a:	82 30       	cpi	r24, 0x02	; 2
    122c:	41 f4       	brne	.+16     	; 0x123e <right_inc+0x1c>
				minute = 0;	    
			}     
			second++;
			break;
		case 2: 
			alarm_minute++;
    122e:	80 91 5c 01 	lds	r24, 0x015C
    1232:	8f 5f       	subi	r24, 0xFF	; 255
			if(alarm_minute >= 60){
    1234:	8c 33       	cpi	r24, 0x3C	; 60
    1236:	88 f0       	brcs	.+34     	; 0x125a <right_inc+0x38>
				alarm_minute = 0;	
    1238:	10 92 5c 01 	sts	0x015C, r1
    123c:	08 95       	ret
    123e:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    1240:	80 91 5e 01 	lds	r24, 0x015E
    1244:	8f 5f       	subi	r24, 0xFF	; 255
			if(minute >= 60){
    1246:	8c 33       	cpi	r24, 0x3C	; 60
    1248:	58 f0       	brcs	.+22     	; 0x1260 <right_inc+0x3e>
				minute = 0;	    
    124a:	10 92 5e 01 	sts	0x015E, r1
			}     
			second++;
    124e:	80 91 5f 01 	lds	r24, 0x015F
    1252:	8f 5f       	subi	r24, 0xFF	; 255
    1254:	80 93 5f 01 	sts	0x015F, r24
			break;
    1258:	08 95       	ret
		case 2: 
			alarm_minute++;
    125a:	80 93 5c 01 	sts	0x015C, r24
    125e:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    1260:	80 93 5e 01 	sts	0x015E, r24
			if(minute >= 60){
				minute = 0;	    
			}     
			second++;
    1264:	80 91 5f 01 	lds	r24, 0x015F
    1268:	8f 5f       	subi	r24, 0xFF	; 255
    126a:	80 93 5f 01 	sts	0x015F, r24
			break;
    126e:	08 95       	ret

00001270 <right_dec>:
		default:
			break;             
	}
}
void right_dec(){
	switch(mode){
    1270:	80 91 60 01 	lds	r24, 0x0160
    1274:	81 30       	cpi	r24, 0x01	; 1
    1276:	71 f0       	breq	.+28     	; 0x1294 <right_dec+0x24>
    1278:	82 30       	cpi	r24, 0x02	; 2
    127a:	59 f4       	brne	.+22     	; 0x1292 <right_dec+0x22>
			if(minute >= 240){
				minute = 59;	    
			}   
			break;
		case 2: 
			alarm_minute--;
    127c:	80 91 5c 01 	lds	r24, 0x015C
    1280:	81 50       	subi	r24, 0x01	; 1
    1282:	80 93 5c 01 	sts	0x015C, r24
			if(alarm_minute >= 240){
    1286:	80 3f       	cpi	r24, 0xF0	; 240
    1288:	18 f0       	brcs	.+6      	; 0x1290 <right_dec+0x20>
				alarm_minute = 59;	
    128a:	8b e3       	ldi	r24, 0x3B	; 59
    128c:	80 93 5c 01 	sts	0x015C, r24
    1290:	08 95       	ret
    1292:	08 95       	ret
void right_dec(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute--;
    1294:	80 91 5e 01 	lds	r24, 0x015E
    1298:	81 50       	subi	r24, 0x01	; 1
    129a:	80 93 5e 01 	sts	0x015E, r24
			if(minute >= 240){
    129e:	80 3f       	cpi	r24, 0xF0	; 240
    12a0:	b8 f3       	brcs	.-18     	; 0x1290 <right_dec+0x20>
				minute = 59;	    
    12a2:	8b e3       	ldi	r24, 0x3B	; 59
    12a4:	80 93 5e 01 	sts	0x015E, r24
    12a8:	08 95       	ret

000012aa <decode_spi_right_knob>:
	previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
    12aa:	cf 93       	push	r28
    12ac:	df 93       	push	r29
    12ae:	1f 92       	push	r1
    12b0:	cd b7       	in	r28, 0x3d	; 61
    12b2:	de b7       	in	r29, 0x3e	; 62
	uint8_t sw_index = 0;
	static uint8_t acount2 = 0;
	static uint8_t previous_encoder2 = 0;
	uint8_t direction = 0;
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    12b4:	83 70       	andi	r24, 0x03	; 3
	sw_index = (previous_encoder2 << 2) | encoder2;
    12b6:	e0 91 51 01 	lds	r30, 0x0151
    12ba:	ee 0f       	add	r30, r30
    12bc:	ee 0f       	add	r30, r30
    12be:	e8 2b       	or	r30, r24
	direction = sw_table[sw_index];
    12c0:	f0 e0       	ldi	r31, 0x00	; 0
    12c2:	ed 5f       	subi	r30, 0xFD	; 253
    12c4:	fe 4f       	sbci	r31, 0xFE	; 254
    12c6:	90 81       	ld	r25, Z
	//value = modeA;
	if(direction == CW){
    12c8:	91 30       	cpi	r25, 0x01	; 1
    12ca:	09 f1       	breq	.+66     	; 0x130e <decode_spi_right_knob+0x64>
		acount2++;
	}	
	if(direction == CCW){
    12cc:	92 30       	cpi	r25, 0x02	; 2
    12ce:	41 f0       	breq	.+16     	; 0x12e0 <decode_spi_right_knob+0x36>
		acount2--;
	}
	if(encoder2 == 3){
    12d0:	83 30       	cpi	r24, 0x03	; 3
    12d2:	69 f0       	breq	.+26     	; 0x12ee <decode_spi_right_knob+0x44>
			right_dec();
		}
		//update_number();
		acount2 = 0;
	}
	previous_encoder2 = encoder2;
    12d4:	80 93 51 01 	sts	0x0151, r24
}
    12d8:	0f 90       	pop	r0
    12da:	df 91       	pop	r29
    12dc:	cf 91       	pop	r28
    12de:	08 95       	ret
	//value = modeA;
	if(direction == CW){
		acount2++;
	}	
	if(direction == CCW){
		acount2--;
    12e0:	90 91 50 01 	lds	r25, 0x0150
    12e4:	91 50       	subi	r25, 0x01	; 1
    12e6:	90 93 50 01 	sts	0x0150, r25
	}
	if(encoder2 == 3){
    12ea:	83 30       	cpi	r24, 0x03	; 3
    12ec:	99 f7       	brne	.-26     	; 0x12d4 <decode_spi_right_knob+0x2a>
		if((acount2 > 1) && (acount2 < 10)){
    12ee:	90 91 50 01 	lds	r25, 0x0150
    12f2:	2e ef       	ldi	r18, 0xFE	; 254
    12f4:	29 0f       	add	r18, r25
    12f6:	28 30       	cpi	r18, 0x08	; 8
    12f8:	b8 f0       	brcs	.+46     	; 0x1328 <decode_spi_right_knob+0x7e>
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
    12fa:	91 3f       	cpi	r25, 0xF1	; 241
    12fc:	70 f4       	brcc	.+28     	; 0x131a <decode_spi_right_knob+0x70>
			right_dec();
		}
		//update_number();
		acount2 = 0;
    12fe:	10 92 50 01 	sts	0x0150, r1
	}
	previous_encoder2 = encoder2;
    1302:	80 93 51 01 	sts	0x0151, r24
}
    1306:	0f 90       	pop	r0
    1308:	df 91       	pop	r29
    130a:	cf 91       	pop	r28
    130c:	08 95       	ret
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
	sw_index = (previous_encoder2 << 2) | encoder2;
	direction = sw_table[sw_index];
	//value = modeA;
	if(direction == CW){
		acount2++;
    130e:	90 91 50 01 	lds	r25, 0x0150
    1312:	9f 5f       	subi	r25, 0xFF	; 255
    1314:	90 93 50 01 	sts	0x0150, r25
    1318:	db cf       	rjmp	.-74     	; 0x12d0 <decode_spi_right_knob+0x26>
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
    131a:	89 83       	std	Y+1, r24	; 0x01
    131c:	0e 94 38 09 	call	0x1270	; 0x1270 <right_dec>
    1320:	89 81       	ldd	r24, Y+1	; 0x01
		}
		//update_number();
		acount2 = 0;
    1322:	10 92 50 01 	sts	0x0150, r1
    1326:	ed cf       	rjmp	.-38     	; 0x1302 <decode_spi_right_knob+0x58>
	if(direction == CCW){
		acount2--;
	}
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
    1328:	89 83       	std	Y+1, r24	; 0x01
    132a:	0e 94 11 09 	call	0x1222	; 0x1222 <right_inc>
    132e:	89 81       	ldd	r24, Y+1	; 0x01
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
		}
		//update_number();
		acount2 = 0;
    1330:	10 92 50 01 	sts	0x0150, r1
    1334:	e6 cf       	rjmp	.-52     	; 0x1302 <decode_spi_right_knob+0x58>

00001336 <left_inc>:
			break;
	}

}
void left_inc(){
	switch(mode){
    1336:	80 91 60 01 	lds	r24, 0x0160
    133a:	82 30       	cpi	r24, 0x02	; 2
    133c:	21 f1       	breq	.+72     	; 0x1386 <left_inc+0x50>
    133e:	b8 f0       	brcs	.+46     	; 0x136e <left_inc+0x38>
    1340:	83 30       	cpi	r24, 0x03	; 3
    1342:	51 f0       	breq	.+20     	; 0x1358 <left_inc+0x22>
    1344:	84 30       	cpi	r24, 0x04	; 4
    1346:	71 f5       	brne	.+92     	; 0x13a4 <left_inc+0x6e>
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	90 91 36 01 	lds	r25, 0x0136
    134e:	91 11       	cpse	r25, r1
    1350:	24 c0       	rjmp	.+72     	; 0x139a <left_inc+0x64>
    1352:	80 93 36 01 	sts	0x0136, r24
    1356:	08 95       	ret
			if(alarm_hour >= 24){
				alarm_hour = 0;
			}
			break;
		case 3:
			volume++;
    1358:	80 91 00 01 	lds	r24, 0x0100
    135c:	8f 5f       	subi	r24, 0xFF	; 255
    135e:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	90 93 87 00 	sts	0x0087, r25
    1368:	80 93 86 00 	sts	0x0086, r24
			break;
    136c:	08 95       	ret
			break;
	}

}
void left_inc(){
	switch(mode){
    136e:	81 30       	cpi	r24, 0x01	; 1
    1370:	c1 f4       	brne	.+48     	; 0x13a2 <left_inc+0x6c>
		case 0: 
			break;
		case 1:
			hour++;
    1372:	80 91 5d 01 	lds	r24, 0x015D
    1376:	8f 5f       	subi	r24, 0xFF	; 255
    1378:	80 93 5d 01 	sts	0x015D, r24
			if(hour >= 24){
    137c:	88 31       	cpi	r24, 0x18	; 24
    137e:	58 f3       	brcs	.-42     	; 0x1356 <left_inc+0x20>
				hour = 0;	    
    1380:	10 92 5d 01 	sts	0x015D, r1
    1384:	08 95       	ret
			}   
			break;
		case 2: 
			alarm_hour++;
    1386:	80 91 5b 01 	lds	r24, 0x015B
    138a:	8f 5f       	subi	r24, 0xFF	; 255
    138c:	80 93 5b 01 	sts	0x015B, r24
			if(alarm_hour >= 24){
    1390:	88 31       	cpi	r24, 0x18	; 24
    1392:	08 f3       	brcs	.-62     	; 0x1356 <left_inc+0x20>
				alarm_hour = 0;
    1394:	10 92 5b 01 	sts	0x015B, r1
    1398:	08 95       	ret
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	80 93 36 01 	sts	0x0136, r24
    13a0:	da cf       	rjmp	.-76     	; 0x1356 <left_inc+0x20>
    13a2:	08 95       	ret
    13a4:	08 95       	ret

000013a6 <left_dec>:
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    13a6:	80 91 60 01 	lds	r24, 0x0160
    13aa:	82 30       	cpi	r24, 0x02	; 2
    13ac:	29 f1       	breq	.+74     	; 0x13f8 <left_dec+0x52>
    13ae:	b8 f0       	brcs	.+46     	; 0x13de <left_dec+0x38>
    13b0:	83 30       	cpi	r24, 0x03	; 3
    13b2:	51 f0       	breq	.+20     	; 0x13c8 <left_dec+0x22>
    13b4:	84 30       	cpi	r24, 0x04	; 4
    13b6:	81 f5       	brne	.+96     	; 0x1418 <left_dec+0x72>
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	90 91 36 01 	lds	r25, 0x0136
    13be:	91 11       	cpse	r25, r1
    13c0:	26 c0       	rjmp	.+76     	; 0x140e <left_dec+0x68>
    13c2:	80 93 36 01 	sts	0x0136, r24
    13c6:	08 95       	ret
			if(alarm_hour >= 240){
				alarm_hour = 23;
			}
			break;
		case 3:
			volume--;
    13c8:	80 91 00 01 	lds	r24, 0x0100
    13cc:	81 50       	subi	r24, 0x01	; 1
    13ce:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    13d2:	90 e0       	ldi	r25, 0x00	; 0
    13d4:	90 93 87 00 	sts	0x0087, r25
    13d8:	80 93 86 00 	sts	0x0086, r24
			break;
    13dc:	08 95       	ret
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    13de:	81 30       	cpi	r24, 0x01	; 1
    13e0:	d1 f4       	brne	.+52     	; 0x1416 <left_dec+0x70>
		case 0: 
			break;
		case 1:
			hour--;    
    13e2:	80 91 5d 01 	lds	r24, 0x015D
    13e6:	81 50       	subi	r24, 0x01	; 1
    13e8:	80 93 5d 01 	sts	0x015D, r24
			if(hour >= 240){
    13ec:	80 3f       	cpi	r24, 0xF0	; 240
    13ee:	58 f3       	brcs	.-42     	; 0x13c6 <left_dec+0x20>
				hour = 23;	    
    13f0:	87 e1       	ldi	r24, 0x17	; 23
    13f2:	80 93 5d 01 	sts	0x015D, r24
    13f6:	08 95       	ret
			}   
			break;
		case 2:
			alarm_hour--;
    13f8:	80 91 5b 01 	lds	r24, 0x015B
    13fc:	81 50       	subi	r24, 0x01	; 1
    13fe:	80 93 5b 01 	sts	0x015B, r24
			if(alarm_hour >= 240){
    1402:	80 3f       	cpi	r24, 0xF0	; 240
    1404:	00 f3       	brcs	.-64     	; 0x13c6 <left_dec+0x20>
				alarm_hour = 23;
    1406:	87 e1       	ldi	r24, 0x17	; 23
    1408:	80 93 5b 01 	sts	0x015B, r24
    140c:	08 95       	ret
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    140e:	80 e0       	ldi	r24, 0x00	; 0
    1410:	80 93 36 01 	sts	0x0136, r24
    1414:	d8 cf       	rjmp	.-80     	; 0x13c6 <left_dec+0x20>
    1416:	08 95       	ret
    1418:	08 95       	ret

0000141a <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
	uint8_t sw_index = 0;
	//Counter for preventing unneccessary reset    
	static uint8_t acount1 = 0;
	static uint8_t previous_encoder1 = 0; //Initialize previous    
	uint8_t direction = 0;                    //Direction variable
	encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
    141e:	8c 70       	andi	r24, 0x0C	; 12
    1420:	c8 2f       	mov	r28, r24
    1422:	d0 e0       	ldi	r29, 0x00	; 0
    1424:	d5 95       	asr	r29
    1426:	c7 95       	ror	r28
    1428:	d5 95       	asr	r29
    142a:	c7 95       	ror	r28
    142c:	9c 2f       	mov	r25, r28
	sw_index = (previous_encoder1 << 2) | encoder1; 
    142e:	e0 91 53 01 	lds	r30, 0x0153
    1432:	ee 0f       	add	r30, r30
    1434:	ee 0f       	add	r30, r30
    1436:	ec 2b       	or	r30, r28
	/*shift previous to the left use it as an index Since
	  we know the pattern of the knob when it is turning
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
    1438:	f0 e0       	ldi	r31, 0x00	; 0
    143a:	ed 5f       	subi	r30, 0xFD	; 253
    143c:	fe 4f       	sbci	r31, 0xFE	; 254
    143e:	80 81       	ld	r24, Z
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	f9 f0       	breq	.+62     	; 0x1482 <decode_spi_left_knob+0x68>
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
    1444:	82 30       	cpi	r24, 0x02	; 2
    1446:	39 f0       	breq	.+14     	; 0x1456 <decode_spi_left_knob+0x3c>
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    1448:	93 30       	cpi	r25, 0x03	; 3
    144a:	61 f0       	breq	.+24     	; 0x1464 <decode_spi_left_knob+0x4a>
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
	}
	previous_encoder1 = encoder1;
    144c:	c0 93 53 01 	sts	0x0153, r28
}
    1450:	df 91       	pop	r29
    1452:	cf 91       	pop	r28
    1454:	08 95       	ret
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
    1456:	80 91 52 01 	lds	r24, 0x0152
    145a:	81 50       	subi	r24, 0x01	; 1
    145c:	80 93 52 01 	sts	0x0152, r24
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    1460:	93 30       	cpi	r25, 0x03	; 3
    1462:	a1 f7       	brne	.-24     	; 0x144c <decode_spi_left_knob+0x32>
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
    1464:	80 91 52 01 	lds	r24, 0x0152
    1468:	9e ef       	ldi	r25, 0xFE	; 254
    146a:	98 0f       	add	r25, r24
    146c:	98 30       	cpi	r25, 0x08	; 8
    146e:	a0 f0       	brcs	.+40     	; 0x1498 <decode_spi_left_knob+0x7e>
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
    1470:	81 3f       	cpi	r24, 0xF1	; 241
    1472:	68 f4       	brcc	.+26     	; 0x148e <decode_spi_left_knob+0x74>
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    1474:	10 92 52 01 	sts	0x0152, r1
	}
	previous_encoder1 = encoder1;
    1478:	c0 93 53 01 	sts	0x0153, r28
}
    147c:	df 91       	pop	r29
    147e:	cf 91       	pop	r28
    1480:	08 95       	ret
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
    1482:	80 91 52 01 	lds	r24, 0x0152
    1486:	8f 5f       	subi	r24, 0xFF	; 255
    1488:	80 93 52 01 	sts	0x0152, r24
    148c:	dd cf       	rjmp	.-70     	; 0x1448 <decode_spi_left_knob+0x2e>
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
    148e:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <left_dec>
		}
		acount1 = 0;                     //Reset counter
    1492:	10 92 52 01 	sts	0x0152, r1
    1496:	f0 cf       	rjmp	.-32     	; 0x1478 <decode_spi_left_knob+0x5e>
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
    1498:	0e 94 9b 09 	call	0x1336	; 0x1336 <left_inc>
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    149c:	10 92 52 01 	sts	0x0152, r1
    14a0:	eb cf       	rjmp	.-42     	; 0x1478 <decode_spi_left_knob+0x5e>

000014a2 <check_knobs>:
	__asm__ __volatile__ ("nop");
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
	// Return incoming data from SPDR
	return(SPDR);  
}
void check_knobs(void){
    14a2:	cf 93       	push	r28
	static uint8_t cnt = 0;
	static uint8_t encoder;
	cnt++;
    14a4:	c0 91 55 01 	lds	r28, 0x0155
    14a8:	cf 5f       	subi	r28, 0xFF	; 255
    14aa:	c0 93 55 01 	sts	0x0155, r28
	encoder = SPI_Receive();
    14ae:	0e 94 b2 08 	call	0x1164	; 0x1164 <SPI_Receive>
    14b2:	80 93 54 01 	sts	0x0154, r24
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
    14b6:	c0 ff       	sbrs	r28, 0
    14b8:	03 c0       	rjmp	.+6      	; 0x14c0 <check_knobs+0x1e>
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
	}
}
    14ba:	cf 91       	pop	r28
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
    14bc:	0c 94 55 09 	jmp	0x12aa	; 0x12aa <decode_spi_right_knob>
	}
}
    14c0:	cf 91       	pop	r28
	static uint8_t encoder;
	cnt++;
	encoder = SPI_Receive();
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
    14c2:	0c 94 0d 0a 	jmp	0x141a	; 0x141a <decode_spi_left_knob>

000014c6 <get_remote_temp>:

//TOD
// Pull temp functions from temp directory
// Display temp

uint16_t get_remote_temp(uint8_t f_or_c){
    14c6:	cf 93       	push	r28
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(f_or_c == 1){
    14c8:	81 30       	cpi	r24, 0x01	; 1
    14ca:	79 f0       	breq	.+30     	; 0x14ea <get_remote_temp+0x24>
		uart_putc(CELCIUS); //Ask atmega48 for celcius
	}
	else{
		uart_putc(FARENHEIT); //Ask for F
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	0e 94 3f 0c 	call	0x187e	; 0x187e <uart_putc>
	}

	lo = uart_getc(); //Get low byte
    14d2:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <uart_getc>
    14d6:	c8 2f       	mov	r28, r24
	hi = uart_getc(); //Get high byte
    14d8:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <uart_getc>

	tmp = (hi<<8) | lo; //Concatinate
    14dc:	2c 2f       	mov	r18, r28
    14de:	30 e0       	ldi	r19, 0x00	; 0
	return tmp;	   //return tempearture
}
    14e0:	a9 01       	movw	r20, r18
    14e2:	58 2b       	or	r21, r24
    14e4:	ca 01       	movw	r24, r20
    14e6:	cf 91       	pop	r28
    14e8:	08 95       	ret
uint16_t get_remote_temp(uint8_t f_or_c){
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(f_or_c == 1){
		uart_putc(CELCIUS); //Ask atmega48 for celcius
    14ea:	82 e0       	ldi	r24, 0x02	; 2
    14ec:	0e 94 3f 0c 	call	0x187e	; 0x187e <uart_putc>
    14f0:	f0 cf       	rjmp	.-32     	; 0x14d2 <get_remote_temp+0xc>

000014f2 <generate_temp_str>:

	tmp = (hi<<8) | lo; //Concatinate
	return tmp;	   //return tempearture
}

void generate_temp_str(){
    14f2:	ef 92       	push	r14
    14f4:	ff 92       	push	r15
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	cf 93       	push	r28
    14fc:	df 93       	push	r29
    14fe:	00 d0       	rcall	.+0      	; 0x1500 <generate_temp_str+0xe>
    1500:	00 d0       	rcall	.+0      	; 0x1502 <generate_temp_str+0x10>
    1502:	00 d0       	rcall	.+0      	; 0x1504 <generate_temp_str+0x12>
    1504:	cd b7       	in	r28, 0x3d	; 61
    1506:	de b7       	in	r29, 0x3e	; 62
	uint16_t remote_temp, local_temp;
	char local_buf[3];
	char remote_buf[3];
	if(reset_temp == 0){
    1508:	80 91 4a 01 	lds	r24, 0x014A
    150c:	88 23       	and	r24, r24
    150e:	e9 f1       	breq	.+122    	; 0x158a <generate_temp_str+0x98>
		return;
	}
	//TODO

	if(temp_mode){
    1510:	80 91 36 01 	lds	r24, 0x0136
    1514:	81 11       	cpse	r24, r1
    1516:	46 c0       	rjmp	.+140    	; 0x15a4 <generate_temp_str+0xb2>
		loc_temp_str[15] = 'C';
		rem_temp_str[15] = 'C';

	}
	else {
		local_temp = get_local_temp(2);
    1518:	82 e0       	ldi	r24, 0x02	; 2
    151a:	0e 94 9d 0c 	call	0x193a	; 0x193a <get_local_temp>
    151e:	7c 01       	movw	r14, r24
		remote_temp = get_remote_temp(2);
    1520:	82 e0       	ldi	r24, 0x02	; 2
    1522:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <get_remote_temp>
    1526:	8c 01       	movw	r16, r24
		loc_temp_str[15] = 'F';
    1528:	e0 91 63 01 	lds	r30, 0x0163
    152c:	f0 91 64 01 	lds	r31, 0x0164
    1530:	86 e4       	ldi	r24, 0x46	; 70
    1532:	87 87       	std	Z+15, r24	; 0x0f
		rem_temp_str[15] = 'F';
    1534:	e0 91 61 01 	lds	r30, 0x0161
    1538:	f0 91 62 01 	lds	r31, 0x0162
    153c:	87 87       	std	Z+15, r24	; 0x0f
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    153e:	4a e0       	ldi	r20, 0x0A	; 10
    1540:	be 01       	movw	r22, r28
    1542:	6c 5f       	subi	r22, 0xFC	; 252
    1544:	7f 4f       	sbci	r23, 0xFF	; 255
    1546:	c7 01       	movw	r24, r14
    1548:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <__itoa_ncheck>
    154c:	4a e0       	ldi	r20, 0x0A	; 10
    154e:	be 01       	movw	r22, r28
    1550:	6f 5f       	subi	r22, 0xFF	; 255
    1552:	7f 4f       	sbci	r23, 0xFF	; 255
    1554:	c8 01       	movw	r24, r16
    1556:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <__itoa_ncheck>
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);
	
	if(local_buf[2] == '1'){
    155a:	8e 81       	ldd	r24, Y+6	; 0x06
		loc_temp_str[12] = local_buf[0];
    155c:	e0 91 63 01 	lds	r30, 0x0163
    1560:	f0 91 64 01 	lds	r31, 0x0164
		rem_temp_str[15] = 'F';
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);
	
	if(local_buf[2] == '1'){
    1564:	81 33       	cpi	r24, 0x31	; 49
    1566:	91 f1       	breq	.+100    	; 0x15cc <generate_temp_str+0xda>
		loc_temp_str[12] = local_buf[0];
		loc_temp_str[13] = local_buf[1];
		loc_temp_str[14] = local_buf[2];
	}
	else{
	loc_temp_str[13] = local_buf[0];
    1568:	8c 81       	ldd	r24, Y+4	; 0x04
    156a:	85 87       	std	Z+13, r24	; 0x0d
	loc_temp_str[14] = local_buf[1];
    156c:	8d 81       	ldd	r24, Y+5	; 0x05
    156e:	86 87       	std	Z+14, r24	; 0x0e
	}
	if(remote_buf[2] == '1'){
    1570:	8b 81       	ldd	r24, Y+3	; 0x03
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    1572:	e0 91 61 01 	lds	r30, 0x0161
    1576:	f0 91 62 01 	lds	r31, 0x0162
	}
	else{
	loc_temp_str[13] = local_buf[0];
	loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    157a:	81 33       	cpi	r24, 0x31	; 49
    157c:	99 f1       	breq	.+102    	; 0x15e4 <generate_temp_str+0xf2>
		rem_temp_str[12] = remote_buf[0];
		rem_temp_str[13] = remote_buf[1];
		rem_temp_str[14] = remote_buf[2];
	}
	else{
		rem_temp_str[13] = remote_buf[0];
    157e:	89 81       	ldd	r24, Y+1	; 0x01
    1580:	85 87       	std	Z+13, r24	; 0x0d
		rem_temp_str[14] = remote_buf[1];
    1582:	8a 81       	ldd	r24, Y+2	; 0x02
    1584:	86 87       	std	Z+14, r24	; 0x0e
	}
	//l_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	reset_temp = 0;
    1586:	10 92 4a 01 	sts	0x014A, r1
}
    158a:	26 96       	adiw	r28, 0x06	; 6
    158c:	0f b6       	in	r0, 0x3f	; 63
    158e:	f8 94       	cli
    1590:	de bf       	out	0x3e, r29	; 62
    1592:	0f be       	out	0x3f, r0	; 63
    1594:	cd bf       	out	0x3d, r28	; 61
    1596:	df 91       	pop	r29
    1598:	cf 91       	pop	r28
    159a:	1f 91       	pop	r17
    159c:	0f 91       	pop	r16
    159e:	ff 90       	pop	r15
    15a0:	ef 90       	pop	r14
    15a2:	08 95       	ret
		return;
	}
	//TODO

	if(temp_mode){
		remote_temp = get_remote_temp(1);
    15a4:	81 e0       	ldi	r24, 0x01	; 1
    15a6:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <get_remote_temp>
    15aa:	8c 01       	movw	r16, r24
		local_temp = get_local_temp(1);
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	0e 94 9d 0c 	call	0x193a	; 0x193a <get_local_temp>
    15b2:	7c 01       	movw	r14, r24
		loc_temp_str[15] = 'C';
    15b4:	e0 91 63 01 	lds	r30, 0x0163
    15b8:	f0 91 64 01 	lds	r31, 0x0164
    15bc:	83 e4       	ldi	r24, 0x43	; 67
    15be:	87 87       	std	Z+15, r24	; 0x0f
		rem_temp_str[15] = 'C';
    15c0:	e0 91 61 01 	lds	r30, 0x0161
    15c4:	f0 91 62 01 	lds	r31, 0x0162
    15c8:	87 87       	std	Z+15, r24	; 0x0f
    15ca:	b9 cf       	rjmp	.-142    	; 0x153e <generate_temp_str+0x4c>
	}
	itoa(local_temp,local_buf, 10);
	itoa(remote_temp,remote_buf, 10);
	
	if(local_buf[2] == '1'){
		loc_temp_str[12] = local_buf[0];
    15cc:	9c 81       	ldd	r25, Y+4	; 0x04
    15ce:	94 87       	std	Z+12, r25	; 0x0c
		loc_temp_str[13] = local_buf[1];
    15d0:	9d 81       	ldd	r25, Y+5	; 0x05
    15d2:	95 87       	std	Z+13, r25	; 0x0d
		loc_temp_str[14] = local_buf[2];
    15d4:	86 87       	std	Z+14, r24	; 0x0e
	}
	else{
	loc_temp_str[13] = local_buf[0];
	loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    15d6:	8b 81       	ldd	r24, Y+3	; 0x03
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    15d8:	e0 91 61 01 	lds	r30, 0x0161
    15dc:	f0 91 62 01 	lds	r31, 0x0162
	}
	else{
	loc_temp_str[13] = local_buf[0];
	loc_temp_str[14] = local_buf[1];
	}
	if(remote_buf[2] == '1'){
    15e0:	81 33       	cpi	r24, 0x31	; 49
    15e2:	69 f6       	brne	.-102    	; 0x157e <generate_temp_str+0x8c>
		//rem_temp_str[11] = remote_buf[2];
		rem_temp_str[12] = remote_buf[0];
    15e4:	99 81       	ldd	r25, Y+1	; 0x01
    15e6:	94 87       	std	Z+12, r25	; 0x0c
		rem_temp_str[13] = remote_buf[1];
    15e8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ea:	95 87       	std	Z+13, r25	; 0x0d
		rem_temp_str[14] = remote_buf[2];
    15ec:	86 87       	std	Z+14, r24	; 0x0e
    15ee:	cb cf       	rjmp	.-106    	; 0x1586 <generate_temp_str+0x94>

000015f0 <show_temperature>:
	static uint8_t counter = 0;
	//loc_temp_str = "Local  temp:   C";
	//rem_temp_str = "Remote temp:   C";
	//loc_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	generate_temp_str();
    15f0:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <generate_temp_str>
	//If temp string is not already displayed, diisplay it
	if(counter <= 15){
    15f4:	80 91 4f 01 	lds	r24, 0x014F
    15f8:	80 31       	cpi	r24, 0x10	; 16
    15fa:	50 f0       	brcs	.+20     	; 0x1610 <show_temperature+0x20>
			//_delay_ms(1);
		}
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
    15fc:	90 ef       	ldi	r25, 0xF0	; 240
    15fe:	98 0f       	add	r25, r24
    1600:	90 31       	cpi	r25, 0x10	; 16
    1602:	f8 f0       	brcs	.+62     	; 0x1642 <show_temperature+0x52>
		//if(counter == 31){
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
    1604:	8b 34       	cpi	r24, 0x4B	; 75
    1606:	b0 f4       	brcc	.+44     	; 0x1634 <show_temperature+0x44>
		temp_is_up = 1;
		counter = 0;
		cursor_home();
	}
	else{
		counter++;
    1608:	8f 5f       	subi	r24, 0xFF	; 255
    160a:	80 93 4f 01 	sts	0x014F, r24
    160e:	08 95       	ret
	//loc_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	generate_temp_str();
	//If temp string is not already displayed, diisplay it
	if(counter <= 15){
		char2lcd(loc_temp_str[counter]);
    1610:	e0 91 63 01 	lds	r30, 0x0163
    1614:	f0 91 64 01 	lds	r31, 0x0164
    1618:	e8 0f       	add	r30, r24
    161a:	f1 1d       	adc	r31, r1
    161c:	80 81       	ld	r24, Z
    161e:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <char2lcd>
		if(counter == 15){
    1622:	80 91 4f 01 	lds	r24, 0x014F
    1626:	8f 30       	cpi	r24, 0x0F	; 15
    1628:	79 f7       	brne	.-34     	; 0x1608 <show_temperature+0x18>
			home_line2();
    162a:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <home_line2>
    162e:	80 91 4f 01 	lds	r24, 0x014F
    1632:	ea cf       	rjmp	.-44     	; 0x1608 <show_temperature+0x18>
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
		temp_is_up = 1;
    1634:	81 e0       	ldi	r24, 0x01	; 1
    1636:	80 93 48 01 	sts	0x0148, r24
		counter = 0;
    163a:	10 92 4f 01 	sts	0x014F, r1
		cursor_home();
    163e:	0c 94 ef 0c 	jmp	0x19de	; 0x19de <cursor_home>
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
		//minute++;
		char2lcd(rem_temp_str[counter-16]);
    1642:	e0 91 61 01 	lds	r30, 0x0161
    1646:	f0 91 62 01 	lds	r31, 0x0162
    164a:	e8 0f       	add	r30, r24
    164c:	f1 1d       	adc	r31, r1
    164e:	70 97       	sbiw	r30, 0x10	; 16
    1650:	80 81       	ld	r24, Z
    1652:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <char2lcd>
		counter++;
    1656:	80 91 4f 01 	lds	r24, 0x014F
    165a:	8f 5f       	subi	r24, 0xFF	; 255
    165c:	80 93 4f 01 	sts	0x014F, r24
    1660:	08 95       	ret

00001662 <LCD_Display>:


void LCD_Display(){
	static uint8_t counter = 0;

	if(counter <= 15){
    1662:	80 91 4e 01 	lds	r24, 0x014E
    1666:	80 31       	cpi	r24, 0x10	; 16
    1668:	30 f4       	brcc	.+12     	; 0x1676 <LCD_Display+0x14>
		//	char2lcd(rem_temp_str[counter]);
		if(counter == 15){
    166a:	8f 30       	cpi	r24, 0x0F	; 15
    166c:	79 f0       	breq	.+30     	; 0x168c <LCD_Display+0x2a>
	}
	else if(counter >=100){
		counter = 0;
	}
	else{
		counter++;
    166e:	8f 5f       	subi	r24, 0xFF	; 255
    1670:	80 93 4e 01 	sts	0x014E, r24
    1674:	08 95       	ret
			//_delay_ms(1);
		}
		counter++;
		//	return;
	}
	else if (counter >=16 && counter <= 31){
    1676:	90 ef       	ldi	r25, 0xF0	; 240
    1678:	98 0f       	add	r25, r24
    167a:	90 31       	cpi	r25, 0x10	; 16
    167c:	c0 f3       	brcs	.-16     	; 0x166e <LCD_Display+0xc>
		//	//minute++;
		//	char2lcd(loc_temp_str[counter-16]);
		counter++;
		//return;
	}
	else if(counter >= 75){ 
    167e:	8b 34       	cpi	r24, 0x4B	; 75
    1680:	b0 f3       	brcs	.-20     	; 0x166e <LCD_Display+0xc>
		//counter = 0;
		//loc_temp_str = "";
		//rem_temp_str = "";
		//loc_temp_str = "Local  temp:   C";
		//rem_temp_str = "Remote temp:   C";
		counter++;
    1682:	8f 5f       	subi	r24, 0xFF	; 255
    1684:	80 93 4e 01 	sts	0x014E, r24
		cursor_home();
    1688:	0c 94 ef 0c 	jmp	0x19de	; 0x19de <cursor_home>
	static uint8_t counter = 0;

	if(counter <= 15){
		//	char2lcd(rem_temp_str[counter]);
		if(counter == 15){
			home_line2();
    168c:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <home_line2>
    1690:	80 91 4e 01 	lds	r24, 0x014E
    1694:	ec cf       	rjmp	.-40     	; 0x166e <LCD_Display+0xc>

00001696 <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1696:	83 b7       	in	r24, 0x33	; 51
    1698:	81 60       	ori	r24, 0x01	; 1
    169a:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    169c:	80 b7       	in	r24, 0x30	; 48
    169e:	88 60       	ori	r24, 0x08	; 8
    16a0:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    16a2:	85 b5       	in	r24, 0x25	; 37
    16a4:	8a 67       	ori	r24, 0x7A	; 122
    16a6:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    16a8:	87 b7       	in	r24, 0x37	; 55
    16aa:	81 64       	ori	r24, 0x41	; 65
    16ac:	87 bf       	out	0x37, r24	; 55
    16ae:	08 95       	ret

000016b0 <ADC_init>:
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    16b0:	e1 e6       	ldi	r30, 0x61	; 97
    16b2:	f0 e0       	ldi	r31, 0x00	; 0
    16b4:	80 81       	ld	r24, Z
    16b6:	80 83       	st	Z, r24
	PORTF = 0x00;
    16b8:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    16bc:	87 b1       	in	r24, 0x07	; 7
    16be:	80 66       	ori	r24, 0x60	; 96
    16c0:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    16c2:	86 b1       	in	r24, 0x06	; 6
    16c4:	8f 6e       	ori	r24, 0xEF	; 239
    16c6:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    16c8:	8f ef       	ldi	r24, 0xFF	; 255
    16ca:	83 bd       	out	0x23, r24	; 35
    16cc:	08 95       	ret

000016ce <volume_control_init>:
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    16ce:	81 e8       	ldi	r24, 0x81	; 129
    16d0:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    16d4:	89 e0       	ldi	r24, 0x09	; 9
    16d6:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    16da:	80 91 00 01 	lds	r24, 0x0100
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	90 93 87 00 	sts	0x0087, r25
    16e4:	80 93 86 00 	sts	0x0086, r24
    16e8:	08 95       	ret

000016ea <initialize_string>:
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    16ea:	83 e1       	ldi	r24, 0x13	; 19
    16ec:	91 e0       	ldi	r25, 0x01	; 1
    16ee:	90 93 64 01 	sts	0x0164, r25
    16f2:	80 93 63 01 	sts	0x0163, r24
	rem_temp_str = "Remote temp:   C";
    16f6:	84 e2       	ldi	r24, 0x24	; 36
    16f8:	91 e0       	ldi	r25, 0x01	; 1
    16fa:	90 93 62 01 	sts	0x0162, r25
    16fe:	80 93 61 01 	sts	0x0161, r24
    1702:	08 95       	ret

00001704 <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    1704:	1f 92       	push	r1
    1706:	0f 92       	push	r0
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	0f 92       	push	r0
    170c:	11 24       	eor	r1, r1
    170e:	0b b6       	in	r0, 0x3b	; 59
    1710:	0f 92       	push	r0
    1712:	2f 93       	push	r18
    1714:	3f 93       	push	r19
    1716:	8f 93       	push	r24
    1718:	9f 93       	push	r25
    171a:	af 93       	push	r26
    171c:	bf 93       	push	r27
    171e:	ef 93       	push	r30
    1720:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    1722:	80 91 71 00 	lds	r24, 0x0071
    1726:	90 e0       	ldi	r25, 0x00	; 0
    1728:	fc 01       	movw	r30, r24
    172a:	38 97       	sbiw	r30, 0x08	; 8
    172c:	e1 35       	cpi	r30, 0x51	; 81
    172e:	f1 05       	cpc	r31, r1
    1730:	b0 f0       	brcs	.+44     	; 0x175e <__vector_33+0x5a>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    1732:	80 91 71 00 	lds	r24, 0x0071
    1736:	80 93 83 01 	sts	0x0183, r24
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    173a:	84 e0       	ldi	r24, 0x04	; 4
    173c:	80 93 74 00 	sts	0x0074, r24
  }//switch
}//TWI_isr
    1740:	ff 91       	pop	r31
    1742:	ef 91       	pop	r30
    1744:	bf 91       	pop	r27
    1746:	af 91       	pop	r26
    1748:	9f 91       	pop	r25
    174a:	8f 91       	pop	r24
    174c:	3f 91       	pop	r19
    174e:	2f 91       	pop	r18
    1750:	0f 90       	pop	r0
    1752:	0b be       	out	0x3b, r0	; 59
    1754:	0f 90       	pop	r0
    1756:	0f be       	out	0x3f, r0	; 63
    1758:	0f 90       	pop	r0
    175a:	1f 90       	pop	r1
    175c:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    175e:	e5 52       	subi	r30, 0x25	; 37
    1760:	ff 4f       	sbci	r31, 0xFF	; 255
    1762:	0c 94 9a 0e 	jmp	0x1d34	; 0x1d34 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    1766:	80 91 65 01 	lds	r24, 0x0165
    176a:	e0 91 84 01 	lds	r30, 0x0184
    176e:	f0 91 85 01 	lds	r31, 0x0185
    1772:	e8 0f       	add	r30, r24
    1774:	f1 1d       	adc	r31, r1
    1776:	80 91 73 00 	lds	r24, 0x0073
    177a:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    177c:	84 e9       	ldi	r24, 0x94	; 148
    177e:	80 93 74 00 	sts	0x0074, r24
      break;      
    1782:	de cf       	rjmp	.-68     	; 0x1740 <__vector_33+0x3c>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    1784:	80 91 86 01 	lds	r24, 0x0186
    1788:	80 93 73 00 	sts	0x0073, r24
      twi_buf_ptr = 0;      //initalize buffer pointer 
    178c:	10 92 65 01 	sts	0x0165, r1
      TWCR = TWCR_SEND;     //send SLA+RW
    1790:	85 e8       	ldi	r24, 0x85	; 133
    1792:	80 93 74 00 	sts	0x0074, r24
      break;
    1796:	d4 cf       	rjmp	.-88     	; 0x1740 <__vector_33+0x3c>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    1798:	80 91 65 01 	lds	r24, 0x0165
    179c:	90 91 87 01 	lds	r25, 0x0187
    17a0:	89 17       	cp	r24, r25
    17a2:	60 f7       	brcc	.-40     	; 0x177c <__vector_33+0x78>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    17a4:	e0 91 84 01 	lds	r30, 0x0184
    17a8:	f0 91 85 01 	lds	r31, 0x0185
    17ac:	91 e0       	ldi	r25, 0x01	; 1
    17ae:	98 0f       	add	r25, r24
    17b0:	90 93 65 01 	sts	0x0165, r25
    17b4:	e8 0f       	add	r30, r24
    17b6:	f1 1d       	adc	r31, r1
    17b8:	80 81       	ld	r24, Z
    17ba:	80 93 73 00 	sts	0x0073, r24
        TWCR = TWCR_SEND;               //send next byte 
    17be:	85 e8       	ldi	r24, 0x85	; 133
    17c0:	80 93 74 00 	sts	0x0074, r24
    17c4:	bd cf       	rjmp	.-134    	; 0x1740 <__vector_33+0x3c>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    17c6:	85 ea       	ldi	r24, 0xA5	; 165
    17c8:	80 93 74 00 	sts	0x0074, r24
      break;
    17cc:	b9 cf       	rjmp	.-142    	; 0x1740 <__vector_33+0x3c>
    17ce:	20 91 65 01 	lds	r18, 0x0165
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    17d2:	80 91 87 01 	lds	r24, 0x0187
    17d6:	30 e0       	ldi	r19, 0x00	; 0
    17d8:	90 e0       	ldi	r25, 0x00	; 0
    17da:	01 97       	sbiw	r24, 0x01	; 1
    17dc:	28 17       	cp	r18, r24
    17de:	39 07       	cpc	r19, r25
    17e0:	dc f4       	brge	.+54     	; 0x1818 <__vector_33+0x114>
    17e2:	85 ec       	ldi	r24, 0xC5	; 197
    17e4:	80 93 74 00 	sts	0x0074, r24
    17e8:	ab cf       	rjmp	.-170    	; 0x1740 <__vector_33+0x3c>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    17ea:	e0 91 84 01 	lds	r30, 0x0184
    17ee:	f0 91 85 01 	lds	r31, 0x0185
    17f2:	80 91 65 01 	lds	r24, 0x0165
    17f6:	21 e0       	ldi	r18, 0x01	; 1
    17f8:	28 0f       	add	r18, r24
    17fa:	20 93 65 01 	sts	0x0165, r18
    17fe:	e8 0f       	add	r30, r24
    1800:	f1 1d       	adc	r31, r1
    1802:	80 91 73 00 	lds	r24, 0x0073
    1806:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1808:	80 91 87 01 	lds	r24, 0x0187
    180c:	30 e0       	ldi	r19, 0x00	; 0
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	01 97       	sbiw	r24, 0x01	; 1
    1812:	28 17       	cp	r18, r24
    1814:	39 07       	cpc	r19, r25
    1816:	2c f3       	brlt	.-54     	; 0x17e2 <__vector_33+0xde>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    1818:	85 e8       	ldi	r24, 0x85	; 133
    181a:	80 93 74 00 	sts	0x0074, r24
    181e:	90 cf       	rjmp	.-224    	; 0x1740 <__vector_33+0x3c>

00001820 <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1820:	80 91 74 00 	lds	r24, 0x0074
}
    1824:	81 70       	andi	r24, 0x01	; 1
    1826:	08 95       	ret

00001828 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1828:	90 91 74 00 	lds	r25, 0x0074
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    182c:	90 fd       	sbrc	r25, 0
    182e:	fc cf       	rjmp	.-8      	; 0x1828 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    1830:	8e 7f       	andi	r24, 0xFE	; 254
    1832:	80 93 86 01 	sts	0x0186, r24
  twi_buf = twi_data;                   //load pointer to write buffer
    1836:	70 93 85 01 	sts	0x0185, r23
    183a:	60 93 84 01 	sts	0x0184, r22
  twi_msg_size = byte_cnt;              //load size of xfer 
    183e:	40 93 87 01 	sts	0x0187, r20
  TWCR = TWCR_START;                    //initiate START
    1842:	85 ea       	ldi	r24, 0xA5	; 165
    1844:	80 93 74 00 	sts	0x0074, r24
    1848:	08 95       	ret

0000184a <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    184a:	90 91 74 00 	lds	r25, 0x0074
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    184e:	90 fd       	sbrc	r25, 0
    1850:	fc cf       	rjmp	.-8      	; 0x184a <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    1852:	81 60       	ori	r24, 0x01	; 1
    1854:	80 93 86 01 	sts	0x0186, r24
  twi_buf = twi_data;                  //load pointer to write buffer
    1858:	70 93 85 01 	sts	0x0185, r23
    185c:	60 93 84 01 	sts	0x0184, r22
  twi_msg_size = byte_cnt;             //load size of xfer 
    1860:	40 93 87 01 	sts	0x0187, r20
  TWCR = TWCR_START;                   //initiate START
    1864:	85 ea       	ldi	r24, 0xA5	; 165
    1866:	80 93 74 00 	sts	0x0074, r24
    186a:	08 95       	ret

0000186c <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    186c:	8f ef       	ldi	r24, 0xFF	; 255
    186e:	80 93 73 00 	sts	0x0073, r24
  TWSR = 0x00;     //prescaler value = 1
    1872:	10 92 71 00 	sts	0x0071, r1
  TWBR = TWI_TWBR; //defined in twi_master.h 
    1876:	8c e0       	ldi	r24, 0x0C	; 12
    1878:	80 93 70 00 	sts	0x0070, r24
    187c:	08 95       	ret

0000187e <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    187e:	5d 9b       	sbis	0x0b, 5	; 11
    1880:	fe cf       	rjmp	.-4      	; 0x187e <uart_putc>
    UDR0 = data;    // Send data byte
    1882:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1884:	5d 9b       	sbis	0x0b, 5	; 11
    1886:	fe cf       	rjmp	.-4      	; 0x1884 <uart_putc+0x6>
}
    1888:	08 95       	ret

0000188a <uart_puts>:
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    188a:	fc 01       	movw	r30, r24
    188c:	20 81       	ld	r18, Z
    188e:	22 23       	and	r18, r18
    1890:	49 f0       	breq	.+18     	; 0x18a4 <uart_puts+0x1a>
    1892:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1894:	5d 9b       	sbis	0x0b, 5	; 11
    1896:	fe cf       	rjmp	.-4      	; 0x1894 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    1898:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    189a:	5d 9b       	sbis	0x0b, 5	; 11
    189c:	fe cf       	rjmp	.-4      	; 0x189a <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    189e:	21 91       	ld	r18, Z+
    18a0:	21 11       	cpse	r18, r1
    18a2:	f8 cf       	rjmp	.-16     	; 0x1894 <uart_puts+0xa>
    18a4:	08 95       	ret

000018a6 <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    18a6:	9c 01       	movw	r18, r24
    18a8:	fc 01       	movw	r30, r24
    18aa:	44 91       	lpm	r20, Z
    18ac:	44 23       	and	r20, r20
    18ae:	69 f0       	breq	.+26     	; 0x18ca <uart_puts_p+0x24>
	uart_putc(pgm_read_byte(str++));
    18b0:	01 96       	adiw	r24, 0x01	; 1
    18b2:	f9 01       	movw	r30, r18
    18b4:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    18b6:	5d 9b       	sbis	0x0b, 5	; 11
    18b8:	fe cf       	rjmp	.-4      	; 0x18b6 <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    18ba:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    18bc:	5d 9b       	sbis	0x0b, 5	; 11
    18be:	fe cf       	rjmp	.-4      	; 0x18bc <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    18c0:	9c 01       	movw	r18, r24
    18c2:	fc 01       	movw	r30, r24
    18c4:	44 91       	lpm	r20, Z
    18c6:	41 11       	cpse	r20, r1
    18c8:	f3 cf       	rjmp	.-26     	; 0x18b0 <uart_puts_p+0xa>
	uart_putc(pgm_read_byte(str++));
    }
}
    18ca:	08 95       	ret

000018cc <uart_init>:
//must be in place for the MAX232 chip to get data.

void uart_init(){
    //rx and tx enable, receive interrupt enabled, 8 bit characters
    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
    UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!
    18cc:	8a b1       	in	r24, 0x0a	; 10
    18ce:	88 61       	ori	r24, 0x18	; 24
    18d0:	8a b9       	out	0x0a, r24	; 10

    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
    //async operation, no parity,  one stop bit, 8-bit characters
    UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    18d2:	e5 e9       	ldi	r30, 0x95	; 149
    18d4:	f0 e0       	ldi	r31, 0x00	; 0
    18d6:	80 81       	ld	r24, Z
    18d8:	86 60       	ori	r24, 0x06	; 6
    18da:	80 83       	st	Z, r24
    UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    18dc:	10 92 90 00 	sts	0x0090, r1
    UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    18e0:	87 e6       	ldi	r24, 0x67	; 103
    18e2:	89 b9       	out	0x09, r24	; 9
    18e4:	08 95       	ret

000018e6 <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    18e6:	80 e8       	ldi	r24, 0x80	; 128
    18e8:	9e e3       	ldi	r25, 0x3E	; 62
    18ea:	03 c0       	rjmp	.+6      	; 0x18f2 <uart_getc+0xc>
    18ec:	01 97       	sbiw	r24, 0x01	; 1
	timer++;
	if(timer >= 16000){ return(0);}
    18ee:	00 97       	sbiw	r24, 0x00	; 0
    18f0:	21 f0       	breq	.+8      	; 0x18fa <uart_getc+0x14>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    18f2:	5f 9b       	sbis	0x0b, 7	; 11
    18f4:	fb cf       	rjmp	.-10     	; 0x18ec <uart_getc+0x6>
	//what should we return if nothing comes in?
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
    18f6:	8c b1       	in	r24, 0x0c	; 12
    18f8:	08 95       	ret
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
	timer++;
	if(timer >= 16000){ return(0);}
    18fa:	80 e0       	ldi	r24, 0x00	; 0
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
}
    18fc:	08 95       	ret

000018fe <lm73_temp_convert>:
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
    18fe:	62 30       	cpi	r22, 0x02	; 2
    1900:	09 f0       	breq	.+2      	; 0x1904 <lm73_temp_convert+0x6>
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    1902:	08 95       	ret
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
	lm73_temp = (lm73_temp*9/5)+32;
    1904:	9c 01       	movw	r18, r24
    1906:	22 0f       	add	r18, r18
    1908:	33 1f       	adc	r19, r19
    190a:	22 0f       	add	r18, r18
    190c:	33 1f       	adc	r19, r19
    190e:	22 0f       	add	r18, r18
    1910:	33 1f       	adc	r19, r19
    1912:	28 0f       	add	r18, r24
    1914:	39 1f       	adc	r19, r25
    1916:	ad ec       	ldi	r26, 0xCD	; 205
    1918:	bc ec       	ldi	r27, 0xCC	; 204
    191a:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <__umulhisi3>
    191e:	96 95       	lsr	r25
    1920:	87 95       	ror	r24
    1922:	96 95       	lsr	r25
    1924:	87 95       	ror	r24
    1926:	80 96       	adiw	r24, 0x20	; 32
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    1928:	08 95       	ret

0000192a <lm73_init>:
//******************************************************************************
void lm73_init(){
	lm73_wr_buf[0] = LM73_PTR_TEMP;
    192a:	10 92 d8 01 	sts	0x01D8, r1
	twi_start_wr(LM73_ADDRESS, lm73_wr_buf, 2);
    192e:	42 e0       	ldi	r20, 0x02	; 2
    1930:	68 ed       	ldi	r22, 0xD8	; 216
    1932:	71 e0       	ldi	r23, 0x01	; 1
    1934:	80 e9       	ldi	r24, 0x90	; 144
    1936:	0c 94 14 0c 	jmp	0x1828	; 0x1828 <twi_start_wr>

0000193a <get_local_temp>:

}

uint16_t get_local_temp(uint8_t f_not_c){
    193a:	cf 93       	push	r28
    193c:	c8 2f       	mov	r28, r24
	uint16_t ret, lm73_temp;
	twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2);
    193e:	42 e0       	ldi	r20, 0x02	; 2
    1940:	6a ed       	ldi	r22, 0xDA	; 218
    1942:	71 e0       	ldi	r23, 0x01	; 1
    1944:	80 e9       	ldi	r24, 0x90	; 144
    1946:	0e 94 25 0c 	call	0x184a	; 0x184a <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    194a:	8f e3       	ldi	r24, 0x3F	; 63
    194c:	9f e1       	ldi	r25, 0x1F	; 31
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	f1 f7       	brne	.-4      	; 0x194e <get_local_temp+0x14>
    1952:	00 c0       	rjmp	.+0      	; 0x1954 <get_local_temp+0x1a>
    1954:	00 00       	nop
	_delay_ms(2);    //wait for it to finish
	//now assemble the two bytes read back into one 16-bit value
	//save high temperature byte into lm73_temp
	lm73_temp = lm73_rd_buf[0] << 8;
    1956:	20 91 da 01 	lds	r18, 0x01DA
    195a:	30 e0       	ldi	r19, 0x00	; 0
    195c:	92 2f       	mov	r25, r18
    195e:	88 27       	eor	r24, r24
	//shift it into upper byte 
	//"OR" in the low temp byte to lm73_temp 
	lm73_temp |= lm73_rd_buf[1];
    1960:	20 91 db 01 	lds	r18, 0x01DB
    1964:	82 2b       	or	r24, r18
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
    1966:	88 0f       	add	r24, r24
    1968:	89 2f       	mov	r24, r25
    196a:	88 1f       	adc	r24, r24
    196c:	99 0b       	sbc	r25, r25
    196e:	91 95       	neg	r25
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 2){
    1970:	c2 30       	cpi	r28, 0x02	; 2
    1972:	91 f4       	brne	.+36     	; 0x1998 <get_local_temp+0x5e>
	lm73_temp = (lm73_temp*9/5)+32;
    1974:	9c 01       	movw	r18, r24
    1976:	22 0f       	add	r18, r18
    1978:	33 1f       	adc	r19, r19
    197a:	22 0f       	add	r18, r18
    197c:	33 1f       	adc	r19, r19
    197e:	22 0f       	add	r18, r18
    1980:	33 1f       	adc	r19, r19
    1982:	28 0f       	add	r18, r24
    1984:	39 1f       	adc	r19, r25
    1986:	ad ec       	ldi	r26, 0xCD	; 205
    1988:	bc ec       	ldi	r27, 0xCC	; 204
    198a:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <__umulhisi3>
    198e:	96 95       	lsr	r25
    1990:	87 95       	ror	r24
    1992:	96 95       	lsr	r25
    1994:	87 95       	ror	r24
    1996:	80 96       	adiw	r24, 0x20	; 32
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
	ret = lm73_temp_convert(lm73_temp, f_not_c);

	return ret;
}
    1998:	cf 91       	pop	r28
    199a:	08 95       	ret

0000199c <strobe_lcd>:

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    199c:	e2 e6       	ldi	r30, 0x62	; 98
    199e:	f0 e0       	ldi	r31, 0x00	; 0
    19a0:	80 81       	ld	r24, Z
    19a2:	88 60       	ori	r24, 0x08	; 8
    19a4:	80 83       	st	Z, r24
	PORTF &= ~0x08;
    19a6:	80 81       	ld	r24, Z
    19a8:	87 7f       	andi	r24, 0xF7	; 247
    19aa:	80 83       	st	Z, r24
    19ac:	08 95       	ret

000019ae <clear_display>:
}          
 
void clear_display(void){
	SPDR = 0x00;    //command, not data
    19ae:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19b0:	77 9b       	sbis	0x0e, 7	; 14
    19b2:	fe cf       	rjmp	.-4      	; 0x19b0 <clear_display+0x2>
	SPDR = 0x01;    //clear display command
    19b4:	81 e0       	ldi	r24, 0x01	; 1
    19b6:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19b8:	77 9b       	sbis	0x0e, 7	; 14
    19ba:	fe cf       	rjmp	.-4      	; 0x19b8 <clear_display+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    19bc:	80 91 62 00 	lds	r24, 0x0062
    19c0:	88 60       	ori	r24, 0x08	; 8
    19c2:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    19c6:	80 91 62 00 	lds	r24, 0x0062
    19ca:	87 7f       	andi	r24, 0xF7	; 247
    19cc:	80 93 62 00 	sts	0x0062, r24
    19d0:	8f e3       	ldi	r24, 0x3F	; 63
    19d2:	9f e1       	ldi	r25, 0x1F	; 31
    19d4:	01 97       	sbiw	r24, 0x01	; 1
    19d6:	f1 f7       	brne	.-4      	; 0x19d4 <clear_display+0x26>
    19d8:	00 c0       	rjmp	.+0      	; 0x19da <clear_display+0x2c>
    19da:	00 00       	nop
    19dc:	08 95       	ret

000019de <cursor_home>:
	strobe_lcd();   //strobe the LCD enable pin
	_delay_ms(2);   //obligatory waiting for slow LCD
}         

void cursor_home(void){
	SPDR = 0x00;    //command, not data
    19de:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19e0:	77 9b       	sbis	0x0e, 7	; 14
    19e2:	fe cf       	rjmp	.-4      	; 0x19e0 <cursor_home+0x2>
	SPDR = 0x02;   // cursor go home position
    19e4:	82 e0       	ldi	r24, 0x02	; 2
    19e6:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19e8:	77 9b       	sbis	0x0e, 7	; 14
    19ea:	fe cf       	rjmp	.-4      	; 0x19e8 <cursor_home+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    19ec:	80 91 62 00 	lds	r24, 0x0062
    19f0:	88 60       	ori	r24, 0x08	; 8
    19f2:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    19f6:	80 91 62 00 	lds	r24, 0x0062
    19fa:	87 7f       	andi	r24, 0xF7	; 247
    19fc:	80 93 62 00 	sts	0x0062, r24
    1a00:	08 95       	ret

00001a02 <home_line2>:
	strobe_lcd();
//	_delay_ms(1);  //not necessary with alarm_clock.c code
}         
  
void home_line2(void){
	SPDR = 0x00;    //command, not data
    1a02:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a04:	77 9b       	sbis	0x0e, 7	; 14
    1a06:	fe cf       	rjmp	.-4      	; 0x1a04 <home_line2+0x2>
	SPDR = 0xC0;   // cursor go home on line 2
    1a08:	80 ec       	ldi	r24, 0xC0	; 192
    1a0a:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a0c:	77 9b       	sbis	0x0e, 7	; 14
    1a0e:	fe cf       	rjmp	.-4      	; 0x1a0c <home_line2+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a10:	80 91 62 00 	lds	r24, 0x0062
    1a14:	88 60       	ori	r24, 0x08	; 8
    1a16:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a1a:	80 91 62 00 	lds	r24, 0x0062
    1a1e:	87 7f       	andi	r24, 0xF7	; 247
    1a20:	80 93 62 00 	sts	0x0062, r24
    1a24:	08 95       	ret

00001a26 <fill_spaces>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd(); 
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
    1a26:	80 e1       	ldi	r24, 0x10	; 16
    1a28:	90 e0       	ldi	r25, 0x00	; 0
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    1a2a:	41 e0       	ldi	r20, 0x01	; 1
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		SPDR = 0x20; 
    1a2c:	30 e2       	ldi	r19, 0x20	; 32
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    1a2e:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a30:	77 9b       	sbis	0x0e, 7	; 14
    1a32:	fe cf       	rjmp	.-4      	; 0x1a30 <fill_spaces+0xa>
		SPDR = 0x20; 
    1a34:	3f b9       	out	0x0f, r19	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a36:	77 9b       	sbis	0x0e, 7	; 14
    1a38:	fe cf       	rjmp	.-4      	; 0x1a36 <fill_spaces+0x10>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a3a:	20 91 62 00 	lds	r18, 0x0062
    1a3e:	28 60       	ori	r18, 0x08	; 8
    1a40:	20 93 62 00 	sts	0x0062, r18
	PORTF &= ~0x08;
    1a44:	20 91 62 00 	lds	r18, 0x0062
    1a48:	27 7f       	andi	r18, 0xF7	; 247
    1a4a:	20 93 62 00 	sts	0x0062, r18
    1a4e:	ef e9       	ldi	r30, 0x9F	; 159
    1a50:	ff e0       	ldi	r31, 0x0F	; 15
    1a52:	31 97       	sbiw	r30, 0x01	; 1
    1a54:	f1 f7       	brne	.-4      	; 0x1a52 <fill_spaces+0x2c>
    1a56:	00 c0       	rjmp	.+0      	; 0x1a58 <fill_spaces+0x32>
    1a58:	00 00       	nop
    1a5a:	01 97       	sbiw	r24, 0x01	; 1
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
    1a5c:	00 97       	sbiw	r24, 0x00	; 0
    1a5e:	39 f7       	brne	.-50     	; 0x1a2e <fill_spaces+0x8>
		SPDR = 0x20; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_ms(1);
	}
}  
    1a60:	08 95       	ret

00001a62 <char2lcd>:
   
void char2lcd(char a_char){
	//sends a char to the LCD
	//usage: char2lcd('H');  // send an H to the LCD
	SPDR = 0x01;   //set SR for data xfer with LSB=1
    1a62:	91 e0       	ldi	r25, 0x01	; 1
    1a64:	9f b9       	out	0x0f, r25	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a66:	77 9b       	sbis	0x0e, 7	; 14
    1a68:	fe cf       	rjmp	.-4      	; 0x1a66 <char2lcd+0x4>
	SPDR = a_char; //send the char to the SPI port
    1a6a:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a6c:	77 9b       	sbis	0x0e, 7	; 14
    1a6e:	fe cf       	rjmp	.-4      	; 0x1a6c <char2lcd+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a70:	80 91 62 00 	lds	r24, 0x0062
    1a74:	88 60       	ori	r24, 0x08	; 8
    1a76:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a7a:	80 91 62 00 	lds	r24, 0x0062
    1a7e:	87 7f       	andi	r24, 0xF7	; 247
    1a80:	80 93 62 00 	sts	0x0062, r24
    1a84:	8f e9       	ldi	r24, 0x9F	; 159
    1a86:	9f e0       	ldi	r25, 0x0F	; 15
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	f1 f7       	brne	.-4      	; 0x1a88 <char2lcd+0x26>
    1a8c:	00 c0       	rjmp	.+0      	; 0x1a8e <char2lcd+0x2c>
    1a8e:	00 00       	nop
    1a90:	08 95       	ret

00001a92 <cursor_off>:
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void cursor_off(void){
	//cuts cursor off 
	SPDR = 0x00;   //set SR for data xfer with LSB=1
    1a92:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a94:	77 9b       	sbis	0x0e, 7	; 14
    1a96:	fe cf       	rjmp	.-4      	; 0x1a94 <cursor_off+0x2>
	SPDR = 0x0C; //send the command to cut off cursor
    1a98:	8c e0       	ldi	r24, 0x0C	; 12
    1a9a:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a9c:	77 9b       	sbis	0x0e, 7	; 14
    1a9e:	fe cf       	rjmp	.-4      	; 0x1a9c <cursor_off+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1aa0:	80 91 62 00 	lds	r24, 0x0062
    1aa4:	88 60       	ori	r24, 0x08	; 8
    1aa6:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1aaa:	80 91 62 00 	lds	r24, 0x0062
    1aae:	87 7f       	andi	r24, 0xF7	; 247
    1ab0:	80 93 62 00 	sts	0x0062, r24
    1ab4:	8f e9       	ldi	r24, 0x9F	; 159
    1ab6:	9f e0       	ldi	r25, 0x0F	; 15
    1ab8:	01 97       	sbiw	r24, 0x01	; 1
    1aba:	f1 f7       	brne	.-4      	; 0x1ab8 <cursor_off+0x26>
    1abc:	00 c0       	rjmp	.+0      	; 0x1abe <cursor_off+0x2c>
    1abe:	00 00       	nop
    1ac0:	08 95       	ret

00001ac2 <string2lcd>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();  //toggle the enable bit
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void string2lcd(char *lcd_str){
    1ac2:	dc 01       	movw	r26, r24

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1ac4:	80 e0       	ldi	r24, 0x00	; 0
    1ac6:	90 e0       	ldi	r25, 0x00	; 0
    1ac8:	20 e0       	ldi	r18, 0x00	; 0
    1aca:	30 e0       	ldi	r19, 0x00	; 0
		SPDR = 0x01; //set SR for data
    1acc:	41 e0       	ldi	r20, 0x01	; 1
    1ace:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1ad0:	77 9b       	sbis	0x0e, 7	; 14
    1ad2:	fe cf       	rjmp	.-4      	; 0x1ad0 <string2lcd+0xe>
		SPDR = lcd_str[count]; 
    1ad4:	fd 01       	movw	r30, r26
    1ad6:	e8 0f       	add	r30, r24
    1ad8:	f9 1f       	adc	r31, r25
    1ada:	80 81       	ld	r24, Z
    1adc:	8f b9       	out	0x0f, r24	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1ade:	77 9b       	sbis	0x0e, 7	; 14
    1ae0:	fe cf       	rjmp	.-4      	; 0x1ade <string2lcd+0x1c>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1ae2:	80 91 62 00 	lds	r24, 0x0062
    1ae6:	88 60       	ori	r24, 0x08	; 8
    1ae8:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1aec:	80 91 62 00 	lds	r24, 0x0062
    1af0:	87 7f       	andi	r24, 0xF7	; 247
    1af2:	80 93 62 00 	sts	0x0062, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1af6:	8f e8       	ldi	r24, 0x8F	; 143
    1af8:	91 e0       	ldi	r25, 0x01	; 1
    1afa:	01 97       	sbiw	r24, 0x01	; 1
    1afc:	f1 f7       	brne	.-4      	; 0x1afa <string2lcd+0x38>
    1afe:	00 c0       	rjmp	.+0      	; 0x1b00 <string2lcd+0x3e>
    1b00:	00 00       	nop
  
void string2lcd(char *lcd_str){

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1b02:	2f 5f       	subi	r18, 0xFF	; 255
    1b04:	3f 4f       	sbci	r19, 0xFF	; 255
    1b06:	c9 01       	movw	r24, r18
    1b08:	fd 01       	movw	r30, r26
    1b0a:	01 90       	ld	r0, Z+
    1b0c:	00 20       	and	r0, r0
    1b0e:	e9 f7       	brne	.-6      	; 0x1b0a <string2lcd+0x48>
    1b10:	ea 1b       	sub	r30, r26
    1b12:	fb 0b       	sbc	r31, r27
    1b14:	32 97       	sbiw	r30, 0x02	; 2
    1b16:	e2 17       	cp	r30, r18
    1b18:	f3 07       	cpc	r31, r19
    1b1a:	c8 f6       	brcc	.-78     	; 0x1ace <string2lcd+0xc>
		SPDR = lcd_str[count]; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_us(100);
	}                  
} 
    1b1c:	08 95       	ret

00001b1e <lcd_init>:
    1b1e:	80 91 61 00 	lds	r24, 0x0061
    1b22:	88 60       	ori	r24, 0x08	; 8
    1b24:	80 93 61 00 	sts	0x0061, r24
    1b28:	8f e5       	ldi	r24, 0x5F	; 95
    1b2a:	9a ee       	ldi	r25, 0xEA	; 234
    1b2c:	01 97       	sbiw	r24, 0x01	; 1
    1b2e:	f1 f7       	brne	.-4      	; 0x1b2c <lcd_init+0xe>
    1b30:	00 c0       	rjmp	.+0      	; 0x1b32 <lcd_init+0x14>
    1b32:	00 00       	nop
    1b34:	83 e0       	ldi	r24, 0x03	; 3
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	30 e3       	ldi	r19, 0x30	; 48
    1b3a:	1f b8       	out	0x0f, r1	; 15
    1b3c:	77 9b       	sbis	0x0e, 7	; 14
    1b3e:	fe cf       	rjmp	.-4      	; 0x1b3c <lcd_init+0x1e>
    1b40:	3f b9       	out	0x0f, r19	; 15
    1b42:	77 9b       	sbis	0x0e, 7	; 14
    1b44:	fe cf       	rjmp	.-4      	; 0x1b42 <lcd_init+0x24>
    1b46:	20 91 62 00 	lds	r18, 0x0062
    1b4a:	28 60       	ori	r18, 0x08	; 8
    1b4c:	20 93 62 00 	sts	0x0062, r18
    1b50:	20 91 62 00 	lds	r18, 0x0062
    1b54:	27 7f       	andi	r18, 0xF7	; 247
    1b56:	20 93 62 00 	sts	0x0062, r18
    1b5a:	ef e5       	ldi	r30, 0x5F	; 95
    1b5c:	fd e6       	ldi	r31, 0x6D	; 109
    1b5e:	31 97       	sbiw	r30, 0x01	; 1
    1b60:	f1 f7       	brne	.-4      	; 0x1b5e <lcd_init+0x40>
    1b62:	00 c0       	rjmp	.+0      	; 0x1b64 <lcd_init+0x46>
    1b64:	00 00       	nop
    1b66:	01 97       	sbiw	r24, 0x01	; 1
    1b68:	00 97       	sbiw	r24, 0x00	; 0
    1b6a:	39 f7       	brne	.-50     	; 0x1b3a <lcd_init+0x1c>
    1b6c:	1f b8       	out	0x0f, r1	; 15
    1b6e:	77 9b       	sbis	0x0e, 7	; 14
    1b70:	fe cf       	rjmp	.-4      	; 0x1b6e <lcd_init+0x50>
    1b72:	88 e3       	ldi	r24, 0x38	; 56
    1b74:	8f b9       	out	0x0f, r24	; 15
    1b76:	77 9b       	sbis	0x0e, 7	; 14
    1b78:	fe cf       	rjmp	.-4      	; 0x1b76 <lcd_init+0x58>
    1b7a:	80 91 62 00 	lds	r24, 0x0062
    1b7e:	88 60       	ori	r24, 0x08	; 8
    1b80:	80 93 62 00 	sts	0x0062, r24
    1b84:	80 91 62 00 	lds	r24, 0x0062
    1b88:	87 7f       	andi	r24, 0xF7	; 247
    1b8a:	80 93 62 00 	sts	0x0062, r24
    1b8e:	8f e1       	ldi	r24, 0x1F	; 31
    1b90:	9e e4       	ldi	r25, 0x4E	; 78
    1b92:	01 97       	sbiw	r24, 0x01	; 1
    1b94:	f1 f7       	brne	.-4      	; 0x1b92 <lcd_init+0x74>
    1b96:	00 c0       	rjmp	.+0      	; 0x1b98 <lcd_init+0x7a>
    1b98:	00 00       	nop
    1b9a:	1f b8       	out	0x0f, r1	; 15
    1b9c:	77 9b       	sbis	0x0e, 7	; 14
    1b9e:	fe cf       	rjmp	.-4      	; 0x1b9c <lcd_init+0x7e>
    1ba0:	88 e0       	ldi	r24, 0x08	; 8
    1ba2:	8f b9       	out	0x0f, r24	; 15
    1ba4:	77 9b       	sbis	0x0e, 7	; 14
    1ba6:	fe cf       	rjmp	.-4      	; 0x1ba4 <lcd_init+0x86>
    1ba8:	80 91 62 00 	lds	r24, 0x0062
    1bac:	88 60       	ori	r24, 0x08	; 8
    1bae:	80 93 62 00 	sts	0x0062, r24
    1bb2:	80 91 62 00 	lds	r24, 0x0062
    1bb6:	87 7f       	andi	r24, 0xF7	; 247
    1bb8:	80 93 62 00 	sts	0x0062, r24
    1bbc:	ef e1       	ldi	r30, 0x1F	; 31
    1bbe:	fe e4       	ldi	r31, 0x4E	; 78
    1bc0:	31 97       	sbiw	r30, 0x01	; 1
    1bc2:	f1 f7       	brne	.-4      	; 0x1bc0 <lcd_init+0xa2>
    1bc4:	00 c0       	rjmp	.+0      	; 0x1bc6 <lcd_init+0xa8>
    1bc6:	00 00       	nop
    1bc8:	1f b8       	out	0x0f, r1	; 15
    1bca:	77 9b       	sbis	0x0e, 7	; 14
    1bcc:	fe cf       	rjmp	.-4      	; 0x1bca <lcd_init+0xac>
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	8f b9       	out	0x0f, r24	; 15
    1bd2:	77 9b       	sbis	0x0e, 7	; 14
    1bd4:	fe cf       	rjmp	.-4      	; 0x1bd2 <lcd_init+0xb4>
    1bd6:	80 91 62 00 	lds	r24, 0x0062
    1bda:	88 60       	ori	r24, 0x08	; 8
    1bdc:	80 93 62 00 	sts	0x0062, r24
    1be0:	80 91 62 00 	lds	r24, 0x0062
    1be4:	87 7f       	andi	r24, 0xF7	; 247
    1be6:	80 93 62 00 	sts	0x0062, r24
    1bea:	8f e1       	ldi	r24, 0x1F	; 31
    1bec:	9e e4       	ldi	r25, 0x4E	; 78
    1bee:	01 97       	sbiw	r24, 0x01	; 1
    1bf0:	f1 f7       	brne	.-4      	; 0x1bee <lcd_init+0xd0>
    1bf2:	00 c0       	rjmp	.+0      	; 0x1bf4 <lcd_init+0xd6>
    1bf4:	00 00       	nop
    1bf6:	1f b8       	out	0x0f, r1	; 15
    1bf8:	77 9b       	sbis	0x0e, 7	; 14
    1bfa:	fe cf       	rjmp	.-4      	; 0x1bf8 <lcd_init+0xda>
    1bfc:	86 e0       	ldi	r24, 0x06	; 6
    1bfe:	8f b9       	out	0x0f, r24	; 15
    1c00:	77 9b       	sbis	0x0e, 7	; 14
    1c02:	fe cf       	rjmp	.-4      	; 0x1c00 <lcd_init+0xe2>
    1c04:	80 91 62 00 	lds	r24, 0x0062
    1c08:	88 60       	ori	r24, 0x08	; 8
    1c0a:	80 93 62 00 	sts	0x0062, r24
    1c0e:	80 91 62 00 	lds	r24, 0x0062
    1c12:	87 7f       	andi	r24, 0xF7	; 247
    1c14:	80 93 62 00 	sts	0x0062, r24
    1c18:	ef e1       	ldi	r30, 0x1F	; 31
    1c1a:	fe e4       	ldi	r31, 0x4E	; 78
    1c1c:	31 97       	sbiw	r30, 0x01	; 1
    1c1e:	f1 f7       	brne	.-4      	; 0x1c1c <lcd_init+0xfe>
    1c20:	00 c0       	rjmp	.+0      	; 0x1c22 <lcd_init+0x104>
    1c22:	00 00       	nop
    1c24:	1f b8       	out	0x0f, r1	; 15
    1c26:	77 9b       	sbis	0x0e, 7	; 14
    1c28:	fe cf       	rjmp	.-4      	; 0x1c26 <lcd_init+0x108>
    1c2a:	8e e0       	ldi	r24, 0x0E	; 14
    1c2c:	8f b9       	out	0x0f, r24	; 15
    1c2e:	77 9b       	sbis	0x0e, 7	; 14
    1c30:	fe cf       	rjmp	.-4      	; 0x1c2e <lcd_init+0x110>
    1c32:	80 91 62 00 	lds	r24, 0x0062
    1c36:	88 60       	ori	r24, 0x08	; 8
    1c38:	80 93 62 00 	sts	0x0062, r24
    1c3c:	80 91 62 00 	lds	r24, 0x0062
    1c40:	87 7f       	andi	r24, 0xF7	; 247
    1c42:	80 93 62 00 	sts	0x0062, r24
    1c46:	8f e1       	ldi	r24, 0x1F	; 31
    1c48:	9e e4       	ldi	r25, 0x4E	; 78
    1c4a:	01 97       	sbiw	r24, 0x01	; 1
    1c4c:	f1 f7       	brne	.-4      	; 0x1c4a <lcd_init+0x12c>
    1c4e:	00 c0       	rjmp	.+0      	; 0x1c50 <lcd_init+0x132>
    1c50:	00 00       	nop
    1c52:	08 95       	ret

00001c54 <main>:

int main()
{
	//set port bits 4-7 B as outputs
	//uint8_t c = 0;
	DDRE = 0xFF;
    1c54:	9f ef       	ldi	r25, 0xFF	; 255
    1c56:	92 b9       	out	0x02, r25	; 2
	PORTE &= 0x7F;
    1c58:	1f 98       	cbi	0x03, 7	; 3
	DDRB = 0xF7;
    1c5a:	87 ef       	ldi	r24, 0xF7	; 247
    1c5c:	87 bb       	out	0x17, r24	; 23
	DDRD |= (1 << PB2);
    1c5e:	8a 9a       	sbi	0x11, 2	; 17

	volume = 100;
    1c60:	84 e6       	ldi	r24, 0x64	; 100
    1c62:	80 93 00 01 	sts	0x0100, r24
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1c66:	83 b7       	in	r24, 0x33	; 51
    1c68:	81 60       	ori	r24, 0x01	; 1
    1c6a:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    1c6c:	80 b7       	in	r24, 0x30	; 48
    1c6e:	88 60       	ori	r24, 0x08	; 8
    1c70:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1c72:	85 b5       	in	r24, 0x25	; 37
    1c74:	8a 67       	ori	r24, 0x7A	; 122
    1c76:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1c78:	87 b7       	in	r24, 0x37	; 55
    1c7a:	81 64       	ori	r24, 0x41	; 65
    1c7c:	87 bf       	out	0x37, r24	; 55
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    1c7e:	80 91 61 00 	lds	r24, 0x0061
    1c82:	80 93 61 00 	sts	0x0061, r24
	PORTF = 0x00;
    1c86:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1c8a:	87 b1       	in	r24, 0x07	; 7
    1c8c:	80 66       	ori	r24, 0x60	; 96
    1c8e:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1c90:	86 b1       	in	r24, 0x06	; 6
    1c92:	8f 6e       	ori	r24, 0xEF	; 239
    1c94:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    1c96:	93 bd       	out	0x23, r25	; 35
	DDRD |= (1 << PB2);

	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
    1c98:	0e 94 61 05 	call	0xac2	; 0xac2 <music_init>
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    1c9c:	80 e5       	ldi	r24, 0x50	; 80
    1c9e:	8d b9       	out	0x0d, r24	; 13
	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
	SPI_init();
	lcd_init();
    1ca0:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <lcd_init>
	init_twi();
    1ca4:	0e 94 36 0c 	call	0x186c	; 0x186c <init_twi>
	uart_init();
    1ca8:	0e 94 66 0c 	call	0x18cc	; 0x18cc <uart_init>
	OCR2 = 0xFF;
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1cac:	81 e8       	ldi	r24, 0x81	; 129
    1cae:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    1cb2:	89 e0       	ldi	r24, 0x09	; 9
    1cb4:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    1cb8:	80 91 00 01 	lds	r24, 0x0100
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	90 93 87 00 	sts	0x0087, r25
    1cc2:	80 93 86 00 	sts	0x0086, r24
	SPI_init();
	lcd_init();
	init_twi();
	uart_init();
	volume_control_init();
	lm73_init();
    1cc6:	0e 94 95 0c 	call	0x192a	; 0x192a <lm73_init>
	cursor_off();
    1cca:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <cursor_off>
	TCCR3B = (1<<WGM32) | (1<<CS30);
	OCR3A = volume;
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    1cce:	83 e1       	ldi	r24, 0x13	; 19
    1cd0:	91 e0       	ldi	r25, 0x01	; 1
    1cd2:	90 93 64 01 	sts	0x0164, r25
    1cd6:	80 93 63 01 	sts	0x0163, r24
	rem_temp_str = "Remote temp:   C";
    1cda:	84 e2       	ldi	r24, 0x24	; 36
    1cdc:	91 e0       	ldi	r25, 0x01	; 1
    1cde:	90 93 62 01 	sts	0x0162, r25
    1ce2:	80 93 61 01 	sts	0x0161, r24
	volume_control_init();
	lm73_init();
	cursor_off();
	initialize_string();
	//strcpy(loc_temp_str, "Local  temp:   C");
	sei();
    1ce6:	78 94       	sei
    1ce8:	08 c0       	rjmp	.+16     	; 0x1cfa <main+0xa6>
		  }*/
		if(encode_flag){
			check_knobs();
			encode_flag = 0;
		}
		if(bar_graph_flag){
    1cea:	80 91 49 01 	lds	r24, 0x0149
    1cee:	81 11       	cpse	r24, r1
    1cf0:	14 c0       	rjmp	.+40     	; 0x1d1a <main+0xc6>
			bar_graph();
			bar_graph_flag = 0;
		}
		if(update_LCD){
    1cf2:	80 91 4b 01 	lds	r24, 0x014B
    1cf6:	81 11       	cpse	r24, r1
    1cf8:	18 c0       	rjmp	.+48     	; 0x1d2a <main+0xd6>
	sei();
	//string2lcd("hello");
	while(1){
		//_delay_ms(100);
		//clear_display();
		display_update();
    1cfa:	0e 94 db 08 	call	0x11b6	; 0x11b6 <display_update>
		update_time();
    1cfe:	0e 94 35 08 	call	0x106a	; 0x106a <update_time>
		//}
		/*if(reset_temp){
		  generate_temp_str();
		  reset_temp = 0;
		  }*/
		if(encode_flag){
    1d02:	80 91 4d 01 	lds	r24, 0x014D
    1d06:	88 23       	and	r24, r24
    1d08:	81 f3       	breq	.-32     	; 0x1cea <main+0x96>
			check_knobs();
    1d0a:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <check_knobs>
			encode_flag = 0;
    1d0e:	10 92 4d 01 	sts	0x014D, r1
		}
		if(bar_graph_flag){
    1d12:	80 91 49 01 	lds	r24, 0x0149
    1d16:	88 23       	and	r24, r24
    1d18:	61 f3       	breq	.-40     	; 0x1cf2 <main+0x9e>
			bar_graph();
    1d1a:	0e 94 be 08 	call	0x117c	; 0x117c <bar_graph>
			bar_graph_flag = 0;
    1d1e:	10 92 49 01 	sts	0x0149, r1
		}
		if(update_LCD){
    1d22:	80 91 4b 01 	lds	r24, 0x014B
    1d26:	88 23       	and	r24, r24
    1d28:	41 f3       	breq	.-48     	; 0x1cfa <main+0xa6>

			show_temperature();
    1d2a:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <show_temperature>
			update_LCD = 0;
    1d2e:	10 92 4b 01 	sts	0x014B, r1
    1d32:	e3 cf       	rjmp	.-58     	; 0x1cfa <main+0xa6>

00001d34 <__tablejump2__>:
    1d34:	ee 0f       	add	r30, r30
    1d36:	ff 1f       	adc	r31, r31

00001d38 <__tablejump__>:
    1d38:	05 90       	lpm	r0, Z+
    1d3a:	f4 91       	lpm	r31, Z
    1d3c:	e0 2d       	mov	r30, r0
    1d3e:	09 94       	ijmp

00001d40 <__umulhisi3>:
    1d40:	a2 9f       	mul	r26, r18
    1d42:	b0 01       	movw	r22, r0
    1d44:	b3 9f       	mul	r27, r19
    1d46:	c0 01       	movw	r24, r0
    1d48:	a3 9f       	mul	r26, r19
    1d4a:	70 0d       	add	r23, r0
    1d4c:	81 1d       	adc	r24, r1
    1d4e:	11 24       	eor	r1, r1
    1d50:	91 1d       	adc	r25, r1
    1d52:	b2 9f       	mul	r27, r18
    1d54:	70 0d       	add	r23, r0
    1d56:	81 1d       	adc	r24, r1
    1d58:	11 24       	eor	r1, r1
    1d5a:	91 1d       	adc	r25, r1
    1d5c:	08 95       	ret

00001d5e <__itoa_ncheck>:
    1d5e:	bb 27       	eor	r27, r27
    1d60:	4a 30       	cpi	r20, 0x0A	; 10
    1d62:	31 f4       	brne	.+12     	; 0x1d70 <__itoa_ncheck+0x12>
    1d64:	99 23       	and	r25, r25
    1d66:	22 f4       	brpl	.+8      	; 0x1d70 <__itoa_ncheck+0x12>
    1d68:	bd e2       	ldi	r27, 0x2D	; 45
    1d6a:	90 95       	com	r25
    1d6c:	81 95       	neg	r24
    1d6e:	9f 4f       	sbci	r25, 0xFF	; 255
    1d70:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__utoa_common>

00001d74 <__utoa_ncheck>:
    1d74:	bb 27       	eor	r27, r27

00001d76 <__utoa_common>:
    1d76:	fb 01       	movw	r30, r22
    1d78:	55 27       	eor	r21, r21
    1d7a:	aa 27       	eor	r26, r26
    1d7c:	88 0f       	add	r24, r24
    1d7e:	99 1f       	adc	r25, r25
    1d80:	aa 1f       	adc	r26, r26
    1d82:	a4 17       	cp	r26, r20
    1d84:	10 f0       	brcs	.+4      	; 0x1d8a <__utoa_common+0x14>
    1d86:	a4 1b       	sub	r26, r20
    1d88:	83 95       	inc	r24
    1d8a:	50 51       	subi	r21, 0x10	; 16
    1d8c:	b9 f7       	brne	.-18     	; 0x1d7c <__utoa_common+0x6>
    1d8e:	a0 5d       	subi	r26, 0xD0	; 208
    1d90:	aa 33       	cpi	r26, 0x3A	; 58
    1d92:	08 f0       	brcs	.+2      	; 0x1d96 <__utoa_common+0x20>
    1d94:	a9 5d       	subi	r26, 0xD9	; 217
    1d96:	a1 93       	st	Z+, r26
    1d98:	00 97       	sbiw	r24, 0x00	; 0
    1d9a:	79 f7       	brne	.-34     	; 0x1d7a <__utoa_common+0x4>
    1d9c:	b1 11       	cpse	r27, r1
    1d9e:	b1 93       	st	Z+, r27
    1da0:	11 92       	st	Z+, r1
    1da2:	cb 01       	movw	r24, r22
    1da4:	0c 94 d4 0e 	jmp	0x1da8	; 0x1da8 <strrev>

00001da8 <strrev>:
    1da8:	dc 01       	movw	r26, r24
    1daa:	fc 01       	movw	r30, r24
    1dac:	67 2f       	mov	r22, r23
    1dae:	71 91       	ld	r23, Z+
    1db0:	77 23       	and	r23, r23
    1db2:	e1 f7       	brne	.-8      	; 0x1dac <strrev+0x4>
    1db4:	32 97       	sbiw	r30, 0x02	; 2
    1db6:	04 c0       	rjmp	.+8      	; 0x1dc0 <strrev+0x18>
    1db8:	7c 91       	ld	r23, X
    1dba:	6d 93       	st	X+, r22
    1dbc:	70 83       	st	Z, r23
    1dbe:	62 91       	ld	r22, -Z
    1dc0:	ae 17       	cp	r26, r30
    1dc2:	bf 07       	cpc	r27, r31
    1dc4:	c8 f3       	brcs	.-14     	; 0x1db8 <strrev+0x10>
    1dc6:	08 95       	ret

00001dc8 <_exit>:
    1dc8:	f8 94       	cli

00001dca <__stop_program>:
    1dca:	ff cf       	rjmp	.-2      	; 0x1dca <__stop_program>
