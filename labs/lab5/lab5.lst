
lab5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  00001d2e  00001dc2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d2e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b6  00800136  00800136  00001df8  2**0
                  ALLOC
  3 .stab         00004ce0  00000000  00000000  00001df8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001922  00000000  00000000  00006ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000083fa  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      1c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 29 0a 	jmp	0x1452	; 0x1452 <__vector_10>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 f9 06 	jmp	0xdf2	; 0xdf2 <__vector_12>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 77 06 	jmp	0xcee	; 0xcee <__vector_16>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 3a 07 	jmp	0xe74	; 0xe74 <__vector_21>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 47 0b 	jmp	0x168e	; 0x168e <__vector_33>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	87 01       	movw	r16, r14
      8e:	8f 01       	movw	r16, r30
      90:	97 01       	movw	r18, r14
      92:	9f 01       	movw	r18, r30
      94:	a7 01       	movw	r20, r14
      96:	b0 01       	movw	r22, r0
      98:	b9 01       	movw	r22, r18
      9a:	77 01       	movw	r14, r14
      9c:	7f 01       	movw	r14, r30
      9e:	0d 03       	fmul	r16, r21
      a0:	05 03       	mulsu	r16, r21
      a2:	00 03       	mulsu	r16, r16
      a4:	2a 03       	fmul	r18, r18
      a6:	1d 03       	fmul	r17, r21
      a8:	25 03       	mulsu	r18, r21
      aa:	15 03       	mulsu	r17, r21
      ac:	de 02       	muls	r29, r30
      ae:	d6 02       	muls	r29, r22
      b0:	d1 02       	muls	r29, r17
      b2:	c9 02       	muls	r28, r25
      b4:	32 03       	mulsu	r19, r18
      b6:	e6 02       	muls	r30, r22
      b8:	bc 02       	muls	r27, r28
      ba:	a4 02       	muls	r26, r20
      bc:	52 03       	mulsu	r21, r18
      be:	fb 02       	muls	r31, r27
      c0:	f3 02       	muls	r31, r19
      c2:	eb 02       	muls	r30, r27
      c4:	72 03       	mulsu	r23, r18
      c6:	ac 02       	muls	r26, r28
      c8:	62 03       	mulsu	r22, r18
      ca:	b4 02       	muls	r27, r20
      cc:	7f 03       	fmul	r23, r23
      ce:	4a 03       	fmul	r20, r18
      d0:	6a 03       	fmul	r22, r18
      d2:	c4 02       	muls	r28, r20
      d4:	42 03       	mulsu	r20, r18
      d6:	3a 03       	fmul	r19, r18
      d8:	5a 03       	fmul	r21, r18
      da:	9f 02       	muls	r25, r31
      dc:	6d 02       	muls	r22, r29
      de:	65 02       	muls	r22, r21
      e0:	75 02       	muls	r23, r21
      e2:	77 03       	mulsu	r23, r23
      e4:	58 02       	muls	r21, r24
      e6:	50 02       	muls	r21, r16
      e8:	7a 02       	muls	r23, r26
      ea:	33 02       	muls	r19, r19
      ec:	97 02       	muls	r25, r23
      ee:	60 02       	muls	r22, r16
      f0:	43 02       	muls	r20, r19
      f2:	3b 02       	muls	r19, r27
      f4:	87 02       	muls	r24, r23
      f6:	4b 02       	muls	r20, r27
      f8:	7f 02       	muls	r23, r31
      fa:	2b 02       	muls	r18, r27
      fc:	11 02       	muls	r17, r17
      fe:	8f 02       	muls	r24, r31
     100:	01 02       	muls	r16, r17
     102:	f9 01       	movw	r30, r18
     104:	1e 02       	muls	r17, r30
     106:	16 02       	muls	r17, r22
     108:	23 02       	muls	r18, r19
     10a:	f4 01       	movw	r30, r8
     10c:	09 02       	muls	r16, r25
     10e:	dc 01       	movw	r26, r24
     110:	ec 01       	movw	r28, r24
     112:	d7 01       	movw	r26, r14
     114:	cf 01       	movw	r24, r30
     116:	c7 01       	movw	r24, r14
     118:	c2 01       	movw	r24, r4
     11a:	e4 01       	movw	r28, r8
     11c:	89 04       	cpc	r8, r9
     11e:	a7 04       	cpc	r10, r7
     120:	83 04       	cpc	r8, r3
     122:	95 04       	cpc	r9, r5
     124:	77 04       	cpc	r7, r7
     126:	7d 04       	cpc	r7, r13
     128:	77 04       	cpc	r7, r7
     12a:	7d 04       	cpc	r7, r13
     12c:	ad 04       	cpc	r10, r13
     12e:	89 04       	cpc	r8, r9
     130:	a7 04       	cpc	r10, r7
     132:	83 04       	cpc	r8, r3
     134:	95 04       	cpc	r9, r5
     136:	8f 04       	cpc	r8, r15
     138:	71 04       	cpc	r7, r1
     13a:	8f 04       	cpc	r8, r15
     13c:	71 04       	cpc	r7, r1
     13e:	d7 04       	cpc	r13, r7
     140:	13 05       	cpc	r17, r3
     142:	cb 04       	cpc	r12, r11
     144:	43 05       	cpc	r20, r3
     146:	cb 04       	cpc	r12, r11
     148:	07 05       	cpc	r16, r7
     14a:	01 05       	cpc	r16, r1
     14c:	71 04       	cpc	r7, r1
     14e:	dd 04       	cpc	r13, r13
     150:	71 04       	cpc	r7, r1
     152:	ef 04       	cpc	r14, r15
     154:	9b 04       	cpc	r9, r11
     156:	31 05       	cpc	r19, r1
     158:	77 04       	cpc	r7, r7
     15a:	25 05       	cpc	r18, r5
     15c:	b3 04       	cpc	r11, r3
     15e:	2b 05       	cpc	r18, r11
     160:	b9 04       	cpc	r11, r9
     162:	37 05       	cpc	r19, r7
     164:	fb 04       	cpc	r15, r11
     166:	a1 04       	cpc	r10, r1
     168:	9b 04       	cpc	r9, r11
     16a:	e3 04       	cpc	r14, r3
     16c:	bf 04       	cpc	r11, r15
     16e:	89 04       	cpc	r8, r9
     170:	a7 04       	cpc	r10, r7
     172:	83 04       	cpc	r8, r3
     174:	95 04       	cpc	r9, r5
     176:	77 04       	cpc	r7, r7
     178:	7d 04       	cpc	r7, r13
     17a:	77 04       	cpc	r7, r7
     17c:	7d 04       	cpc	r7, r13
     17e:	ad 04       	cpc	r10, r13
     180:	89 04       	cpc	r8, r9
     182:	0d 05       	cpc	r16, r13
     184:	a1 04       	cpc	r10, r1
     186:	83 04       	cpc	r8, r3
     188:	8f 04       	cpc	r8, r15
     18a:	71 04       	cpc	r7, r1
     18c:	8f 04       	cpc	r8, r15
     18e:	71 04       	cpc	r7, r1
     190:	d7 04       	cpc	r13, r7
     192:	19 05       	cpc	r17, r9
     194:	e9 04       	cpc	r14, r9
     196:	ad 04       	cpc	r10, r13
     198:	1f 05       	cpc	r17, r15
     19a:	dd 04       	cpc	r13, r13
     19c:	b3 04       	cpc	r11, r3
     19e:	b9 04       	cpc	r11, r9
     1a0:	9b 04       	cpc	r9, r11
     1a2:	a1 04       	cpc	r10, r1
     1a4:	3d 05       	cpc	r19, r13
     1a6:	bf 04       	cpc	r11, r15
     1a8:	6d 08       	sbc	r6, r13
     1aa:	66 08       	sbc	r6, r6
     1ac:	5f 08       	sbc	r5, r15
     1ae:	53 08       	sbc	r5, r3
     1b0:	53 08       	sbc	r5, r3
     1b2:	74 08       	sbc	r7, r4
     1b4:	83 08       	sbc	r8, r3
     1b6:	87 0b       	sbc	r24, r23
     1b8:	5e 0b       	sbc	r21, r30
     1ba:	5e 0b       	sbc	r21, r30
     1bc:	5e 0b       	sbc	r21, r30
     1be:	5e 0b       	sbc	r21, r30
     1c0:	5e 0b       	sbc	r21, r30
     1c2:	5e 0b       	sbc	r21, r30
     1c4:	5e 0b       	sbc	r21, r30
     1c6:	87 0b       	sbc	r24, r23
     1c8:	5e 0b       	sbc	r21, r30
     1ca:	5e 0b       	sbc	r21, r30
     1cc:	5e 0b       	sbc	r21, r30
     1ce:	5e 0b       	sbc	r21, r30
     1d0:	5e 0b       	sbc	r21, r30
     1d2:	5e 0b       	sbc	r21, r30
     1d4:	5e 0b       	sbc	r21, r30
     1d6:	91 0b       	sbc	r25, r17
     1d8:	5e 0b       	sbc	r21, r30
     1da:	5e 0b       	sbc	r21, r30
     1dc:	5e 0b       	sbc	r21, r30
     1de:	5e 0b       	sbc	r21, r30
     1e0:	5e 0b       	sbc	r21, r30
     1e2:	5e 0b       	sbc	r21, r30
     1e4:	5e 0b       	sbc	r21, r30
     1e6:	5e 0b       	sbc	r21, r30
     1e8:	5e 0b       	sbc	r21, r30
     1ea:	5e 0b       	sbc	r21, r30
     1ec:	5e 0b       	sbc	r21, r30
     1ee:	5e 0b       	sbc	r21, r30
     1f0:	5e 0b       	sbc	r21, r30
     1f2:	5e 0b       	sbc	r21, r30
     1f4:	5e 0b       	sbc	r21, r30
     1f6:	91 0b       	sbc	r25, r17
     1f8:	5e 0b       	sbc	r21, r30
     1fa:	5e 0b       	sbc	r21, r30
     1fc:	5e 0b       	sbc	r21, r30
     1fe:	5e 0b       	sbc	r21, r30
     200:	5e 0b       	sbc	r21, r30
     202:	5e 0b       	sbc	r21, r30
     204:	5e 0b       	sbc	r21, r30
     206:	5e 0b       	sbc	r21, r30
     208:	5e 0b       	sbc	r21, r30
     20a:	5e 0b       	sbc	r21, r30
     20c:	5e 0b       	sbc	r21, r30
     20e:	5e 0b       	sbc	r21, r30
     210:	5e 0b       	sbc	r21, r30
     212:	5e 0b       	sbc	r21, r30
     214:	5e 0b       	sbc	r21, r30
     216:	a8 0b       	sbc	r26, r24
     218:	5e 0b       	sbc	r21, r30
     21a:	5e 0b       	sbc	r21, r30
     21c:	5e 0b       	sbc	r21, r30
     21e:	5e 0b       	sbc	r21, r30
     220:	5e 0b       	sbc	r21, r30
     222:	5e 0b       	sbc	r21, r30
     224:	5e 0b       	sbc	r21, r30
     226:	ac 0b       	sbc	r26, r28
     228:	5e 0b       	sbc	r21, r30
     22a:	5e 0b       	sbc	r21, r30
     22c:	5e 0b       	sbc	r21, r30
     22e:	5e 0b       	sbc	r21, r30
     230:	5e 0b       	sbc	r21, r30
     232:	5e 0b       	sbc	r21, r30
     234:	5e 0b       	sbc	r21, r30
     236:	5e 0b       	sbc	r21, r30
     238:	5e 0b       	sbc	r21, r30
     23a:	5e 0b       	sbc	r21, r30
     23c:	5e 0b       	sbc	r21, r30
     23e:	5e 0b       	sbc	r21, r30
     240:	5e 0b       	sbc	r21, r30
     242:	5e 0b       	sbc	r21, r30
     244:	5e 0b       	sbc	r21, r30
     246:	ba 0b       	sbc	r27, r26
     248:	5e 0b       	sbc	r21, r30
     24a:	5e 0b       	sbc	r21, r30
     24c:	5e 0b       	sbc	r21, r30
     24e:	5e 0b       	sbc	r21, r30
     250:	5e 0b       	sbc	r21, r30
     252:	5e 0b       	sbc	r21, r30
     254:	5e 0b       	sbc	r21, r30
     256:	78 0b       	sbc	r23, r24

00000258 <__ctors_end>:
     258:	11 24       	eor	r1, r1
     25a:	1f be       	out	0x3f, r1	; 63
     25c:	cf ef       	ldi	r28, 0xFF	; 255
     25e:	d0 e1       	ldi	r29, 0x10	; 16
     260:	de bf       	out	0x3e, r29	; 62
     262:	cd bf       	out	0x3d, r28	; 61

00000264 <__do_copy_data>:
     264:	11 e0       	ldi	r17, 0x01	; 1
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b1 e0       	ldi	r27, 0x01	; 1
     26a:	ee e2       	ldi	r30, 0x2E	; 46
     26c:	fd e1       	ldi	r31, 0x1D	; 29
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	a6 33       	cpi	r26, 0x36	; 54
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	21 e0       	ldi	r18, 0x01	; 1
     280:	a6 e3       	ldi	r26, 0x36	; 54
     282:	b1 e0       	ldi	r27, 0x01	; 1
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	ac 3e       	cpi	r26, 0xEC	; 236
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <main>
     292:	0c 94 95 0e 	jmp	0x1d2a	; 0x1d2a <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <play_rest>:
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     29a:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     29c:	10 92 76 01 	sts	0x0176, r1
     2a0:	10 92 75 01 	sts	0x0175, r1
  max_beat = duration;
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	90 93 74 01 	sts	0x0174, r25
     2aa:	80 93 73 01 	sts	0x0173, r24
     2ae:	08 95       	ret

000002b0 <play_note>:
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
     2b0:	cf 93       	push	r28
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
     2b2:	92 98       	cbi	0x12, 2	; 18
  beat = 0;             //reset the beat counter
     2b4:	10 92 76 01 	sts	0x0176, r1
     2b8:	10 92 75 01 	sts	0x0175, r1
  max_beat = duration;  //set the max beat
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	30 93 74 01 	sts	0x0174, r19
     2c2:	20 93 73 01 	sts	0x0173, r18
  switch (octave) {
     2c6:	50 e0       	ldi	r21, 0x00	; 0
     2c8:	49 30       	cpi	r20, 0x09	; 9
     2ca:	51 05       	cpc	r21, r1
     2cc:	20 f0       	brcs	.+8      	; 0x2d6 <play_note+0x26>
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
     2ce:	1b bc       	out	0x2b, r1	; 43
     2d0:	1a bc       	out	0x2a, r1	; 42
  }
}
     2d2:	cf 91       	pop	r28
     2d4:	08 95       	ret
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2d6:	4a 5b       	subi	r20, 0xBA	; 186
     2d8:	5f 4f       	sbci	r21, 0xFF	; 255
     2da:	fa 01       	movw	r30, r20
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2dc:	99 27       	eor	r25, r25
     2de:	87 fd       	sbrc	r24, 7
     2e0:	90 95       	com	r25
     2e2:	a9 2f       	mov	r26, r25
     2e4:	b9 2f       	mov	r27, r25
     2e6:	81 54       	subi	r24, 0x41	; 65
     2e8:	91 09       	sbc	r25, r1
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2ea:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
     2ee:	87 30       	cpi	r24, 0x07	; 7
     2f0:	91 05       	cpc	r25, r1
     2f2:	78 f7       	brcc	.-34     	; 0x2d2 <play_note+0x22>
     2f4:	81 5b       	subi	r24, 0xB1	; 177
     2f6:	9f 4f       	sbci	r25, 0xFF	; 255
     2f8:	fc 01       	movw	r30, r24
     2fa:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2fe:	87 30       	cpi	r24, 0x07	; 7
     300:	91 05       	cpc	r25, r1
     302:	38 f7       	brcc	.-50     	; 0x2d2 <play_note+0x22>
     304:	8a 5a       	subi	r24, 0xAA	; 170
     306:	9f 4f       	sbci	r25, 0xFF	; 255
     308:	fc 01       	movw	r30, r24
     30a:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
     30e:	87 30       	cpi	r24, 0x07	; 7
     310:	91 05       	cpc	r25, r1
     312:	f8 f6       	brcc	.-66     	; 0x2d2 <play_note+0x22>
     314:	83 5a       	subi	r24, 0xA3	; 163
     316:	9f 4f       	sbci	r25, 0xFF	; 255
     318:	fc 01       	movw	r30, r24
     31a:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
     31e:	87 30       	cpi	r24, 0x07	; 7
     320:	91 05       	cpc	r25, r1
     322:	b8 f6       	brcc	.-82     	; 0x2d2 <play_note+0x22>
     324:	8c 59       	subi	r24, 0x9C	; 156
     326:	9f 4f       	sbci	r25, 0xFF	; 255
     328:	fc 01       	movw	r30, r24
     32a:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
     32e:	87 30       	cpi	r24, 0x07	; 7
     330:	91 05       	cpc	r25, r1
     332:	78 f6       	brcc	.-98     	; 0x2d2 <play_note+0x22>
     334:	85 59       	subi	r24, 0x95	; 149
     336:	9f 4f       	sbci	r25, 0xFF	; 255
     338:	fc 01       	movw	r30, r24
     33a:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
     33e:	87 30       	cpi	r24, 0x07	; 7
     340:	91 05       	cpc	r25, r1
     342:	38 f6       	brcc	.-114    	; 0x2d2 <play_note+0x22>
     344:	8e 58       	subi	r24, 0x8E	; 142
     346:	9f 4f       	sbci	r25, 0xFF	; 255
     348:	fc 01       	movw	r30, r24
     34a:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
     34e:	87 30       	cpi	r24, 0x07	; 7
     350:	91 05       	cpc	r25, r1
     352:	08 f0       	brcs	.+2      	; 0x356 <play_note+0xa6>
     354:	be cf       	rjmp	.-132    	; 0x2d2 <play_note+0x22>
     356:	87 58       	subi	r24, 0x87	; 135
     358:	9f 4f       	sbci	r25, 0xFF	; 255
     35a:	fc 01       	movw	r30, r24
     35c:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
     360:	87 30       	cpi	r24, 0x07	; 7
     362:	91 05       	cpc	r25, r1
     364:	08 f0       	brcs	.+2      	; 0x368 <play_note+0xb8>
     366:	b5 cf       	rjmp	.-150    	; 0x2d2 <play_note+0x22>
     368:	80 58       	subi	r24, 0x80	; 128
     36a:	9f 4f       	sbci	r25, 0xFF	; 255
     36c:	fc 01       	movw	r30, r24
     36e:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
     372:	87 30       	cpi	r24, 0x07	; 7
     374:	91 05       	cpc	r25, r1
     376:	08 f0       	brcs	.+2      	; 0x37a <play_note+0xca>
     378:	ac cf       	rjmp	.-168    	; 0x2d2 <play_note+0x22>
     37a:	89 57       	subi	r24, 0x79	; 121
     37c:	9f 4f       	sbci	r25, 0xFF	; 255
     37e:	fc 01       	movw	r30, r24
     380:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
     384:	88 e5       	ldi	r24, 0x58	; 88
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	9b bd       	out	0x2b, r25	; 43
     38a:	8a bd       	out	0x2a, r24	; 42
	break;
     38c:	a2 cf       	rjmp	.-188    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
     38e:	66 23       	and	r22, r22
     390:	09 f4       	brne	.+2      	; 0x394 <play_note+0xe4>
     392:	0f c2       	rjmp	.+1054   	; 0x7b2 <play_note+0x502>
     394:	83 e6       	ldi	r24, 0x63	; 99
     396:	90 e0       	ldi	r25, 0x00	; 0
     398:	9b bd       	out	0x2b, r25	; 43
     39a:	8a bd       	out	0x2a, r24	; 42
     39c:	9a cf       	rjmp	.-204    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
     39e:	66 23       	and	r22, r22
     3a0:	09 f4       	brne	.+2      	; 0x3a4 <play_note+0xf4>
     3a2:	11 c2       	rjmp	.+1058   	; 0x7c6 <play_note+0x516>
     3a4:	8f e6       	ldi	r24, 0x6F	; 111
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	9b bd       	out	0x2b, r25	; 43
     3aa:	8a bd       	out	0x2a, r24	; 42
     3ac:	92 cf       	rjmp	.-220    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
     3ae:	86 e7       	ldi	r24, 0x76	; 118
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	9b bd       	out	0x2b, r25	; 43
     3b4:	8a bd       	out	0x2a, r24	; 42
	break;
     3b6:	8d cf       	rjmp	.-230    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
     3b8:	66 23       	and	r22, r22
     3ba:	09 f4       	brne	.+2      	; 0x3be <play_note+0x10e>
     3bc:	ff c1       	rjmp	.+1022   	; 0x7bc <play_note+0x50c>
     3be:	8a e4       	ldi	r24, 0x4A	; 74
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	9b bd       	out	0x2b, r25	; 43
     3c4:	8a bd       	out	0x2a, r24	; 42
     3c6:	85 cf       	rjmp	.-246    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
     3c8:	66 23       	and	r22, r22
     3ca:	09 f4       	brne	.+2      	; 0x3ce <play_note+0x11e>
     3cc:	01 c2       	rjmp	.+1026   	; 0x7d0 <play_note+0x520>
     3ce:	83 e5       	ldi	r24, 0x53	; 83
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	9b bd       	out	0x2b, r25	; 43
     3d4:	8a bd       	out	0x2a, r24	; 42
     3d6:	7d cf       	rjmp	.-262    	; 0x2d2 <play_note+0x22>
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
     3d8:	66 23       	and	r22, r22
     3da:	09 f4       	brne	.+2      	; 0x3de <play_note+0x12e>
     3dc:	b8 c1       	rjmp	.+880    	; 0x74e <play_note+0x49e>
     3de:	82 e4       	ldi	r24, 0x42	; 66
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	9b bd       	out	0x2b, r25	; 43
     3e4:	8a bd       	out	0x2a, r24	; 42
     3e6:	75 cf       	rjmp	.-278    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
     3e8:	81 eb       	ldi	r24, 0xB1	; 177
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	9b bd       	out	0x2b, r25	; 43
     3ee:	8a bd       	out	0x2a, r24	; 42
	break;
     3f0:	70 cf       	rjmp	.-288    	; 0x2d2 <play_note+0x22>
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
     3f2:	66 23       	and	r22, r22
     3f4:	09 f4       	brne	.+2      	; 0x3f8 <play_note+0x148>
     3f6:	d3 c1       	rjmp	.+934    	; 0x79e <play_note+0x4ee>
     3f8:	85 e8       	ldi	r24, 0x85	; 133
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	9b bd       	out	0x2b, r25	; 43
     3fe:	8a bd       	out	0x2a, r24	; 42
     400:	68 cf       	rjmp	.-304    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
     402:	66 23       	and	r22, r22
     404:	09 f4       	brne	.+2      	; 0x408 <play_note+0x158>
     406:	c1 c1       	rjmp	.+898    	; 0x78a <play_note+0x4da>
     408:	85 e9       	ldi	r24, 0x95	; 149
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	9b bd       	out	0x2b, r25	; 43
     40e:	8a bd       	out	0x2a, r24	; 42
     410:	60 cf       	rjmp	.-320    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
     412:	66 23       	and	r22, r22
     414:	09 f4       	brne	.+2      	; 0x418 <play_note+0x168>
     416:	be c1       	rjmp	.+892    	; 0x794 <play_note+0x4e4>
     418:	87 ea       	ldi	r24, 0xA7	; 167
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9b bd       	out	0x2b, r25	; 43
     41e:	8a bd       	out	0x2a, r24	; 42
     420:	58 cf       	rjmp	.-336    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
     422:	84 e6       	ldi	r24, 0x64	; 100
     424:	91 e0       	ldi	r25, 0x01	; 1
     426:	9b bd       	out	0x2b, r25	; 43
     428:	8a bd       	out	0x2a, r24	; 42
	break;
     42a:	53 cf       	rjmp	.-346    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
     42c:	66 23       	and	r22, r22
     42e:	09 f4       	brne	.+2      	; 0x432 <play_note+0x182>
     430:	bb c1       	rjmp	.+886    	; 0x7a8 <play_note+0x4f8>
     432:	80 ee       	ldi	r24, 0xE0	; 224
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	9b bd       	out	0x2b, r25	; 43
     438:	8a bd       	out	0x2a, r24	; 42
     43a:	4b cf       	rjmp	.-362    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
     43c:	8d ee       	ldi	r24, 0xED	; 237
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	9b bd       	out	0x2b, r25	; 43
     442:	8a bd       	out	0x2a, r24	; 42
	break;
     444:	46 cf       	rjmp	.-372    	; 0x2d2 <play_note+0x22>
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
     446:	66 23       	and	r22, r22
     448:	09 f4       	brne	.+2      	; 0x44c <play_note+0x19c>
     44a:	8b c1       	rjmp	.+790    	; 0x762 <play_note+0x4b2>
     44c:	87 ec       	ldi	r24, 0xC7	; 199
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	9b bd       	out	0x2b, r25	; 43
     452:	8a bd       	out	0x2a, r24	; 42
     454:	3e cf       	rjmp	.-388    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
     456:	66 23       	and	r22, r22
     458:	09 f4       	brne	.+2      	; 0x45c <play_note+0x1ac>
     45a:	74 c1       	rjmp	.+744    	; 0x744 <play_note+0x494>
     45c:	80 e9       	ldi	r24, 0x90	; 144
     45e:	91 e0       	ldi	r25, 0x01	; 1
     460:	9b bd       	out	0x2b, r25	; 43
     462:	8a bd       	out	0x2a, r24	; 42
     464:	36 cf       	rjmp	.-404    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
     466:	66 23       	and	r22, r22
     468:	09 f4       	brne	.+2      	; 0x46c <play_note+0x1bc>
     46a:	cb c1       	rjmp	.+918    	; 0x802 <play_note+0x552>
     46c:	84 e8       	ldi	r24, 0x84	; 132
     46e:	93 e0       	ldi	r25, 0x03	; 3
     470:	9b bd       	out	0x2b, r25	; 43
     472:	8a bd       	out	0x2a, r24	; 42
     474:	2e cf       	rjmp	.-420    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
     476:	66 23       	and	r22, r22
     478:	09 f4       	brne	.+2      	; 0x47c <play_note+0x1cc>
     47a:	af c1       	rjmp	.+862    	; 0x7da <play_note+0x52a>
     47c:	8b e2       	ldi	r24, 0x2B	; 43
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	9b bd       	out	0x2b, r25	; 43
     482:	8a bd       	out	0x2a, r24	; 42
     484:	26 cf       	rjmp	.-436    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
     486:	66 23       	and	r22, r22
     488:	09 f4       	brne	.+2      	; 0x48c <play_note+0x1dc>
     48a:	b1 c1       	rjmp	.+866    	; 0x7ee <play_note+0x53e>
     48c:	82 ea       	ldi	r24, 0xA2	; 162
     48e:	92 e0       	ldi	r25, 0x02	; 2
     490:	9b bd       	out	0x2b, r25	; 43
     492:	8a bd       	out	0x2a, r24	; 42
     494:	1e cf       	rjmp	.-452    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
     496:	8c ed       	ldi	r24, 0xDC	; 220
     498:	91 e0       	ldi	r25, 0x01	; 1
     49a:	9b bd       	out	0x2b, r25	; 43
     49c:	8a bd       	out	0x2a, r24	; 42
	break;
     49e:	19 cf       	rjmp	.-462    	; 0x2d2 <play_note+0x22>
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
     4a0:	66 23       	and	r22, r22
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <play_note+0x1f6>
     4a4:	59 c1       	rjmp	.+690    	; 0x758 <play_note+0x4a8>
     4a6:	87 e1       	ldi	r24, 0x17	; 23
     4a8:	92 e0       	ldi	r25, 0x02	; 2
     4aa:	9b bd       	out	0x2b, r25	; 43
     4ac:	8a bd       	out	0x2a, r24	; 42
     4ae:	11 cf       	rjmp	.-478    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
     4b0:	66 23       	and	r22, r22
     4b2:	09 f4       	brne	.+2      	; 0x4b6 <play_note+0x206>
     4b4:	b0 c1       	rjmp	.+864    	; 0x816 <play_note+0x566>
     4b6:	88 e5       	ldi	r24, 0x58	; 88
     4b8:	92 e0       	ldi	r25, 0x02	; 2
     4ba:	9b bd       	out	0x2b, r25	; 43
     4bc:	8a bd       	out	0x2a, r24	; 42
     4be:	09 cf       	rjmp	.-494    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
     4c0:	8a ec       	ldi	r24, 0xCA	; 202
     4c2:	92 e0       	ldi	r25, 0x02	; 2
     4c4:	9b bd       	out	0x2b, r25	; 43
     4c6:	8a bd       	out	0x2a, r24	; 42
	break;
     4c8:	04 cf       	rjmp	.-504    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
     4ca:	66 23       	and	r22, r22
     4cc:	09 f4       	brne	.+2      	; 0x4d0 <play_note+0x220>
     4ce:	35 c1       	rjmp	.+618    	; 0x73a <play_note+0x48a>
     4d0:	86 e4       	ldi	r24, 0x46	; 70
     4d2:	96 e0       	ldi	r25, 0x06	; 6
     4d4:	9b bd       	out	0x2b, r25	; 43
     4d6:	8a bd       	out	0x2a, r24	; 42
     4d8:	fc ce       	rjmp	.-520    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
     4da:	66 23       	and	r22, r22
     4dc:	09 f4       	brne	.+2      	; 0x4e0 <play_note+0x230>
     4de:	82 c1       	rjmp	.+772    	; 0x7e4 <play_note+0x534>
     4e0:	8a e0       	ldi	r24, 0x0A	; 10
     4e2:	97 e0       	ldi	r25, 0x07	; 7
     4e4:	9b bd       	out	0x2b, r25	; 43
     4e6:	8a bd       	out	0x2a, r24	; 42
     4e8:	f4 ce       	rjmp	.-536    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
     4ea:	86 e9       	ldi	r24, 0x96	; 150
     4ec:	95 e0       	ldi	r25, 0x05	; 5
     4ee:	9b bd       	out	0x2b, r25	; 43
     4f0:	8a bd       	out	0x2a, r24	; 42
	break;
     4f2:	ef ce       	rjmp	.-546    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
     4f4:	8a eb       	ldi	r24, 0xBA	; 186
     4f6:	93 e0       	ldi	r25, 0x03	; 3
     4f8:	9b bd       	out	0x2b, r25	; 43
     4fa:	8a bd       	out	0x2a, r24	; 42
	break;
     4fc:	ea ce       	rjmp	.-556    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
     4fe:	66 23       	and	r22, r22
     500:	09 f4       	brne	.+2      	; 0x504 <play_note+0x254>
     502:	7a c1       	rjmp	.+756    	; 0x7f8 <play_note+0x548>
     504:	81 ec       	ldi	r24, 0xC1	; 193
     506:	91 e0       	ldi	r25, 0x01	; 1
     508:	9b bd       	out	0x2b, r25	; 43
     50a:	8a bd       	out	0x2a, r24	; 42
     50c:	e2 ce       	rjmp	.-572    	; 0x2d2 <play_note+0x22>
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
     50e:	66 23       	and	r22, r22
     510:	09 f4       	brne	.+2      	; 0x514 <play_note+0x264>
     512:	7c c1       	rjmp	.+760    	; 0x80c <play_note+0x55c>
     514:	8b e0       	ldi	r24, 0x0B	; 11
     516:	91 e0       	ldi	r25, 0x01	; 1
     518:	9b bd       	out	0x2b, r25	; 43
     51a:	8a bd       	out	0x2a, r24	; 42
     51c:	da ce       	rjmp	.-588    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
     51e:	66 23       	and	r22, r22
     520:	09 f4       	brne	.+2      	; 0x524 <play_note+0x274>
     522:	7e c1       	rjmp	.+764    	; 0x820 <play_note+0x570>
     524:	80 e5       	ldi	r24, 0x50	; 80
     526:	91 e0       	ldi	r25, 0x01	; 1
     528:	9b bd       	out	0x2b, r25	; 43
     52a:	8a bd       	out	0x2a, r24	; 42
     52c:	d2 ce       	rjmp	.-604    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
     52e:	66 23       	and	r22, r22
     530:	09 f4       	brne	.+2      	; 0x534 <play_note+0x284>
     532:	ad c1       	rjmp	.+858    	; 0x88e <play_note+0x5de>
     534:	82 e2       	ldi	r24, 0x22	; 34
     536:	93 e0       	ldi	r25, 0x03	; 3
     538:	9b bd       	out	0x2b, r25	; 43
     53a:	8a bd       	out	0x2a, r24	; 42
     53c:	ca ce       	rjmp	.-620    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
     53e:	86 e7       	ldi	r24, 0x76	; 118
     540:	97 e0       	ldi	r25, 0x07	; 7
     542:	9b bd       	out	0x2b, r25	; 43
     544:	8a bd       	out	0x2a, r24	; 42
	break;
     546:	c5 ce       	rjmp	.-630    	; 0x2d2 <play_note+0x22>
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
     548:	66 23       	and	r22, r22
     54a:	09 f4       	brne	.+2      	; 0x54e <play_note+0x29e>
     54c:	0f c1       	rjmp	.+542    	; 0x76c <play_note+0x4bc>
     54e:	8e ec       	ldi	r24, 0xCE	; 206
     550:	92 e1       	ldi	r25, 0x12	; 18
     552:	9b bd       	out	0x2b, r25	; 43
     554:	8a bd       	out	0x2a, r24	; 42
     556:	bd ce       	rjmp	.-646    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
     558:	66 23       	and	r22, r22
     55a:	09 f4       	brne	.+2      	; 0x55e <play_note+0x2ae>
     55c:	7a c1       	rjmp	.+756    	; 0x852 <play_note+0x5a2>
     55e:	8d e1       	ldi	r24, 0x1D	; 29
     560:	95 e1       	ldi	r25, 0x15	; 21
     562:	9b bd       	out	0x2b, r25	; 43
     564:	8a bd       	out	0x2a, r24	; 42
     566:	b5 ce       	rjmp	.-662    	; 0x2d2 <play_note+0x22>
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
     568:	66 23       	and	r22, r22
     56a:	09 f4       	brne	.+2      	; 0x56e <play_note+0x2be>
     56c:	dc c0       	rjmp	.+440    	; 0x726 <play_note+0x476>
     56e:	80 e6       	ldi	r24, 0x60	; 96
     570:	98 e0       	ldi	r25, 0x08	; 8
     572:	9b bd       	out	0x2b, r25	; 43
     574:	8a bd       	out	0x2a, r24	; 42
     576:	ad ce       	rjmp	.-678    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
     578:	66 23       	and	r22, r22
     57a:	09 f4       	brne	.+2      	; 0x57e <play_note+0x2ce>
     57c:	92 c1       	rjmp	.+804    	; 0x8a2 <play_note+0x5f2>
     57e:	80 e1       	ldi	r24, 0x10	; 16
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	9b bd       	out	0x2b, r25	; 43
     584:	8a bd       	out	0x2a, r24	; 42
     586:	a5 ce       	rjmp	.-694    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
     588:	8e e2       	ldi	r24, 0x2E	; 46
     58a:	9b e0       	ldi	r25, 0x0B	; 11
     58c:	9b bd       	out	0x2b, r25	; 43
     58e:	8a bd       	out	0x2a, r24	; 42
	break;
     590:	a0 ce       	rjmp	.-704    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
     592:	66 23       	and	r22, r22
     594:	09 f4       	brne	.+2      	; 0x598 <play_note+0x2e8>
     596:	49 c1       	rjmp	.+658    	; 0x82a <play_note+0x57a>
     598:	8b e1       	ldi	r24, 0x1B	; 27
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	9b bd       	out	0x2b, r25	; 43
     59e:	8a bd       	out	0x2a, r24	; 42
     5a0:	98 ce       	rjmp	.-720    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
     5a2:	8c e1       	ldi	r24, 0x1C	; 28
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	9b bd       	out	0x2b, r25	; 43
     5a8:	8a bd       	out	0x2a, r24	; 42
	break;
     5aa:	93 ce       	rjmp	.-730    	; 0x2d2 <play_note+0x22>
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
     5ac:	66 23       	and	r22, r22
     5ae:	09 f4       	brne	.+2      	; 0x5b2 <play_note+0x302>
     5b0:	41 c1       	rjmp	.+642    	; 0x834 <play_note+0x584>
     5b2:	87 e0       	ldi	r24, 0x07	; 7
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	9b bd       	out	0x2b, r25	; 43
     5b8:	8a bd       	out	0x2a, r24	; 42
     5ba:	8b ce       	rjmp	.-746    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
     5bc:	66 23       	and	r22, r22
     5be:	09 f4       	brne	.+2      	; 0x5c2 <play_note+0x312>
     5c0:	da c0       	rjmp	.+436    	; 0x776 <play_note+0x4c6>
     5c2:	8b e0       	ldi	r24, 0x0B	; 11
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	9b bd       	out	0x2b, r25	; 43
     5c8:	8a bd       	out	0x2a, r24	; 42
     5ca:	83 ce       	rjmp	.-762    	; 0x2d2 <play_note+0x22>
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
     5cc:	82 e1       	ldi	r24, 0x12	; 18
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	9b bd       	out	0x2b, r25	; 43
     5d2:	8a bd       	out	0x2a, r24	; 42
	break;
     5d4:	7e ce       	rjmp	.-772    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
     5d6:	66 23       	and	r22, r22
     5d8:	09 f4       	brne	.+2      	; 0x5dc <play_note+0x32c>
     5da:	9b c0       	rjmp	.+310    	; 0x712 <play_note+0x462>
     5dc:	89 e1       	ldi	r24, 0x19	; 25
     5de:	99 e1       	ldi	r25, 0x19	; 25
     5e0:	9b bd       	out	0x2b, r25	; 43
     5e2:	8a bd       	out	0x2a, r24	; 42
     5e4:	76 ce       	rjmp	.-788    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
     5e6:	66 23       	and	r22, r22
     5e8:	09 f4       	brne	.+2      	; 0x5ec <play_note+0x33c>
     5ea:	29 c1       	rjmp	.+594    	; 0x83e <play_note+0x58e>
     5ec:	80 e3       	ldi	r24, 0x30	; 48
     5ee:	9c e1       	ldi	r25, 0x1C	; 28
     5f0:	9b bd       	out	0x2b, r25	; 43
     5f2:	8a bd       	out	0x2a, r24	; 42
     5f4:	6e ce       	rjmp	.-804    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
     5f6:	8c ed       	ldi	r24, 0xDC	; 220
     5f8:	9d e1       	ldi	r25, 0x1D	; 29
     5fa:	9b bd       	out	0x2b, r25	; 43
     5fc:	8a bd       	out	0x2a, r24	; 42
	break;
     5fe:	69 ce       	rjmp	.-814    	; 0x2d2 <play_note+0x22>
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
     600:	8a e3       	ldi	r24, 0x3A	; 58
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	9b bd       	out	0x2b, r25	; 43
     606:	8a bd       	out	0x2a, r24	; 42
	break;
     608:	64 ce       	rjmp	.-824    	; 0x2d2 <play_note+0x22>
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
     60a:	66 23       	and	r22, r22
     60c:	09 f4       	brne	.+2      	; 0x610 <play_note+0x360>
     60e:	35 c1       	rjmp	.+618    	; 0x87a <play_note+0x5ca>
     610:	80 e2       	ldi	r24, 0x20	; 32
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	9b bd       	out	0x2b, r25	; 43
     616:	8a bd       	out	0x2a, r24	; 42
     618:	5c ce       	rjmp	.-840    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
     61a:	66 23       	and	r22, r22
     61c:	09 f4       	brne	.+2      	; 0x620 <play_note+0x370>
     61e:	32 c1       	rjmp	.+612    	; 0x884 <play_note+0x5d4>
     620:	84 e2       	ldi	r24, 0x24	; 36
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	9b bd       	out	0x2b, r25	; 43
     626:	8a bd       	out	0x2a, r24	; 42
     628:	54 ce       	rjmp	.-856    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
     62a:	66 23       	and	r22, r22
     62c:	09 f4       	brne	.+2      	; 0x630 <play_note+0x380>
     62e:	76 c0       	rjmp	.+236    	; 0x71c <play_note+0x46c>
     630:	89 e2       	ldi	r24, 0x29	; 41
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	9b bd       	out	0x2b, r25	; 43
     636:	8a bd       	out	0x2a, r24	; 42
     638:	4c ce       	rjmp	.-872    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
     63a:	66 23       	and	r22, r22
     63c:	09 f4       	brne	.+2      	; 0x640 <play_note+0x390>
     63e:	78 c0       	rjmp	.+240    	; 0x730 <play_note+0x480>
     640:	81 e3       	ldi	r24, 0x31	; 49
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	9b bd       	out	0x2b, r25	; 43
     646:	8a bd       	out	0x2a, r24	; 42
     648:	44 ce       	rjmp	.-888    	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
     64a:	8b e2       	ldi	r24, 0x2B	; 43
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	9b bd       	out	0x2b, r25	; 43
     650:	8a bd       	out	0x2a, r24	; 42
	break;
     652:	3f ce       	rjmp	.-898    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
     654:	66 23       	and	r22, r22
     656:	09 f4       	brne	.+2      	; 0x65a <play_note+0x3aa>
     658:	93 c0       	rjmp	.+294    	; 0x780 <play_note+0x4d0>
     65a:	87 e3       	ldi	r24, 0x37	; 55
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	9b bd       	out	0x2b, r25	; 43
     660:	8a bd       	out	0x2a, r24	; 42
     662:	37 ce       	rjmp	.-914    	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
     664:	66 23       	and	r22, r22
     666:	09 f4       	brne	.+2      	; 0x66a <play_note+0x3ba>
     668:	4f c0       	rjmp	.+158    	; 0x708 <play_note+0x458>
     66a:	88 e1       	ldi	r24, 0x18	; 24
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	9b bd       	out	0x2b, r25	; 43
     670:	8a bd       	out	0x2a, r24	; 42
     672:	2f ce       	rjmp	.-930    	; 0x2d2 <play_note+0x22>
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
     674:	66 23       	and	r22, r22
     676:	09 f4       	brne	.+2      	; 0x67a <play_note+0x3ca>
     678:	f6 c0       	rjmp	.+492    	; 0x866 <play_note+0x5b6>
     67a:	82 eb       	ldi	r24, 0xB2	; 178
     67c:	94 e0       	ldi	r25, 0x04	; 4
     67e:	9b bd       	out	0x2b, r25	; 43
     680:	8a bd       	out	0x2a, r24	; 42
     682:	27 ce       	rjmp	.-946    	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
     684:	66 23       	and	r22, r22
     686:	09 f4       	brne	.+2      	; 0x68a <play_note+0x3da>
     688:	16 c1       	rjmp	.+556    	; 0x8b6 <play_note+0x606>
     68a:	8d e8       	ldi	r24, 0x8D	; 141
     68c:	9a e0       	ldi	r25, 0x0A	; 10
     68e:	9b bd       	out	0x2b, r25	; 43
     690:	8a bd       	out	0x2a, r24	; 42
     692:	1f ce       	rjmp	.-962    	; 0x2d2 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
     694:	66 23       	and	r22, r22
     696:	09 f4       	brne	.+2      	; 0x69a <play_note+0x3ea>
     698:	d7 c0       	rjmp	.+430    	; 0x848 <play_note+0x598>
     69a:	86 e1       	ldi	r24, 0x16	; 22
     69c:	9e e0       	ldi	r25, 0x0E	; 14
     69e:	9b bd       	out	0x2b, r25	; 43
     6a0:	8a bd       	out	0x2a, r24	; 42
     6a2:	17 ce       	rjmp	.-978    	; 0x2d2 <play_note+0x22>
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
     6a4:	66 23       	and	r22, r22
     6a6:	09 f4       	brne	.+2      	; 0x6aa <play_note+0x3fa>
     6a8:	f7 c0       	rjmp	.+494    	; 0x898 <play_note+0x5e8>
     6aa:	80 ec       	ldi	r24, 0xC0	; 192
     6ac:	90 e1       	ldi	r25, 0x10	; 16
     6ae:	9b bd       	out	0x2b, r25	; 43
     6b0:	8a bd       	out	0x2a, r24	; 42
     6b2:	0f ce       	rjmp	.-994    	; 0x2d2 <play_note+0x22>
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
     6b4:	66 23       	and	r22, r22
     6b6:	09 f4       	brne	.+2      	; 0x6ba <play_note+0x40a>
     6b8:	d1 c0       	rjmp	.+418    	; 0x85c <play_note+0x5ac>
     6ba:	8f e2       	ldi	r24, 0x2F	; 47
     6bc:	94 e0       	ldi	r25, 0x04	; 4
     6be:	9b bd       	out	0x2b, r25	; 43
     6c0:	8a bd       	out	0x2a, r24	; 42
     6c2:	07 ce       	rjmp	.-1010   	; 0x2d2 <play_note+0x22>
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
     6c4:	66 23       	and	r22, r22
     6c6:	09 f4       	brne	.+2      	; 0x6ca <play_note+0x41a>
     6c8:	f1 c0       	rjmp	.+482    	; 0x8ac <play_note+0x5fc>
     6ca:	87 e6       	ldi	r24, 0x67	; 103
     6cc:	99 e0       	ldi	r25, 0x09	; 9
     6ce:	9b bd       	out	0x2b, r25	; 43
     6d0:	8a bd       	out	0x2a, r24	; 42
     6d2:	ff cd       	rjmp	.-1026   	; 0x2d2 <play_note+0x22>
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
     6d4:	66 23       	and	r22, r22
     6d6:	09 f4       	brne	.+2      	; 0x6da <play_note+0x42a>
     6d8:	cb c0       	rjmp	.+406    	; 0x870 <play_note+0x5c0>
     6da:	8d e8       	ldi	r24, 0x8D	; 141
     6dc:	9c e0       	ldi	r25, 0x0C	; 12
     6de:	9b bd       	out	0x2b, r25	; 43
     6e0:	8a bd       	out	0x2a, r24	; 42
     6e2:	f7 cd       	rjmp	.-1042   	; 0x2d2 <play_note+0x22>
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
     6e4:	8d e5       	ldi	r24, 0x5D	; 93
     6e6:	96 e1       	ldi	r25, 0x16	; 22
     6e8:	9b bd       	out	0x2b, r25	; 43
     6ea:	8a bd       	out	0x2a, r24	; 42
	break;
     6ec:	f2 cd       	rjmp	.-1052   	; 0x2d2 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
     6ee:	66 23       	and	r22, r22
     6f0:	09 f4       	brne	.+2      	; 0x6f4 <play_note+0x444>
     6f2:	e6 c0       	rjmp	.+460    	; 0x8c0 <play_note+0x610>
     6f4:	86 e4       	ldi	r24, 0x46	; 70
     6f6:	95 e0       	ldi	r25, 0x05	; 5
     6f8:	9b bd       	out	0x2b, r25	; 43
     6fa:	8a bd       	out	0x2a, r24	; 42
     6fc:	ea cd       	rjmp	.-1068   	; 0x2d2 <play_note+0x22>
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
     6fe:	8d ee       	ldi	r24, 0xED	; 237
     700:	9e e0       	ldi	r25, 0x0E	; 14
     702:	9b bd       	out	0x2b, r25	; 43
     704:	8a bd       	out	0x2a, r24	; 42
	break;
     706:	e5 cd       	rjmp	.-1078   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
     708:	85 e1       	ldi	r24, 0x15	; 21
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	9b bd       	out	0x2b, r25	; 43
     70e:	8a bd       	out	0x2a, r24	; 42
     710:	e0 cd       	rjmp	.-1088   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
     712:	82 eb       	ldi	r24, 0xB2	; 178
     714:	97 e1       	ldi	r25, 0x17	; 23
     716:	9b bd       	out	0x2b, r25	; 43
     718:	8a bd       	out	0x2a, r24	; 42
     71a:	db cd       	rjmp	.-1098   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
     71c:	86 e2       	ldi	r24, 0x26	; 38
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	9b bd       	out	0x2b, r25	; 43
     722:	8a bd       	out	0x2a, r24	; 42
     724:	d6 cd       	rjmp	.-1108   	; 0x2d2 <play_note+0x22>
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
     726:	87 ee       	ldi	r24, 0xE7	; 231
     728:	97 e0       	ldi	r25, 0x07	; 7
     72a:	9b bd       	out	0x2b, r25	; 43
     72c:	8a bd       	out	0x2a, r24	; 42
     72e:	d1 cd       	rjmp	.-1118   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
     730:	8e e2       	ldi	r24, 0x2E	; 46
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9b bd       	out	0x2b, r25	; 43
     736:	8a bd       	out	0x2a, r24	; 42
     738:	cc cd       	rjmp	.-1128   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
     73a:	8b ee       	ldi	r24, 0xEB	; 235
     73c:	95 e0       	ldi	r25, 0x05	; 5
     73e:	9b bd       	out	0x2b, r25	; 43
     740:	8a bd       	out	0x2a, r24	; 42
     742:	c7 cd       	rjmp	.-1138   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
     744:	8a e7       	ldi	r24, 0x7A	; 122
     746:	91 e0       	ldi	r25, 0x01	; 1
     748:	9b bd       	out	0x2b, r25	; 43
     74a:	8a bd       	out	0x2a, r24	; 42
     74c:	c2 cd       	rjmp	.-1148   	; 0x2d2 <play_note+0x22>
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
     74e:	8e e3       	ldi	r24, 0x3E	; 62
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	9b bd       	out	0x2b, r25	; 43
     754:	8a bd       	out	0x2a, r24	; 42
     756:	bd cd       	rjmp	.-1158   	; 0x2d2 <play_note+0x22>
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
     758:	89 ef       	ldi	r24, 0xF9	; 249
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	9b bd       	out	0x2b, r25	; 43
     75e:	8a bd       	out	0x2a, r24	; 42
     760:	b8 cd       	rjmp	.-1168   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
     762:	8c eb       	ldi	r24, 0xBC	; 188
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	9b bd       	out	0x2b, r25	; 43
     768:	8a bd       	out	0x2a, r24	; 42
     76a:	b3 cd       	rjmp	.-1178   	; 0x2d2 <play_note+0x22>
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
     76c:	80 ec       	ldi	r24, 0xC0	; 192
     76e:	91 e1       	ldi	r25, 0x11	; 17
     770:	9b bd       	out	0x2b, r25	; 43
     772:	8a bd       	out	0x2a, r24	; 42
     774:	ae cd       	rjmp	.-1188   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
     776:	89 e0       	ldi	r24, 0x09	; 9
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	9b bd       	out	0x2b, r25	; 43
     77c:	8a bd       	out	0x2a, r24	; 42
     77e:	a9 cd       	rjmp	.-1198   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
     780:	84 e3       	ldi	r24, 0x34	; 52
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	9b bd       	out	0x2b, r25	; 43
     786:	8a bd       	out	0x2a, r24	; 42
     788:	a4 cd       	rjmp	.-1208   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
     78a:	8d e8       	ldi	r24, 0x8D	; 141
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	9b bd       	out	0x2b, r25	; 43
     790:	8a bd       	out	0x2a, r24	; 42
     792:	9f cd       	rjmp	.-1218   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
     794:	8e e9       	ldi	r24, 0x9E	; 158
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	9b bd       	out	0x2b, r25	; 43
     79a:	8a bd       	out	0x2a, r24	; 42
     79c:	9a cd       	rjmp	.-1228   	; 0x2d2 <play_note+0x22>
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
     79e:	8d e7       	ldi	r24, 0x7D	; 125
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	9b bd       	out	0x2b, r25	; 43
     7a4:	8a bd       	out	0x2a, r24	; 42
     7a6:	95 cd       	rjmp	.-1238   	; 0x2d2 <play_note+0x22>
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
     7a8:	83 ed       	ldi	r24, 0xD3	; 211
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	9b bd       	out	0x2b, r25	; 43
     7ae:	8a bd       	out	0x2a, r24	; 42
     7b0:	90 cd       	rjmp	.-1248   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
     7b2:	8d e5       	ldi	r24, 0x5D	; 93
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	9b bd       	out	0x2b, r25	; 43
     7b8:	8a bd       	out	0x2a, r24	; 42
     7ba:	8b cd       	rjmp	.-1258   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
     7bc:	86 e4       	ldi	r24, 0x46	; 70
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	9b bd       	out	0x2b, r25	; 43
     7c2:	8a bd       	out	0x2a, r24	; 42
     7c4:	86 cd       	rjmp	.-1268   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
     7c6:	89 e6       	ldi	r24, 0x69	; 105
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	9b bd       	out	0x2b, r25	; 43
     7cc:	8a bd       	out	0x2a, r24	; 42
     7ce:	81 cd       	rjmp	.-1278   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
     7d0:	8e e4       	ldi	r24, 0x4E	; 78
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	9b bd       	out	0x2b, r25	; 43
     7d6:	8a bd       	out	0x2a, r24	; 42
     7d8:	7c cd       	rjmp	.-1288   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
     7da:	8b e1       	ldi	r24, 0x1B	; 27
     7dc:	91 e0       	ldi	r25, 0x01	; 1
     7de:	9b bd       	out	0x2b, r25	; 43
     7e0:	8a bd       	out	0x2a, r24	; 42
     7e2:	77 cd       	rjmp	.-1298   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
     7e4:	85 ea       	ldi	r24, 0xA5	; 165
     7e6:	96 e0       	ldi	r25, 0x06	; 6
     7e8:	9b bd       	out	0x2b, r25	; 43
     7ea:	8a bd       	out	0x2a, r24	; 42
     7ec:	72 cd       	rjmp	.-1308   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
     7ee:	8c e7       	ldi	r24, 0x7C	; 124
     7f0:	92 e0       	ldi	r25, 0x02	; 2
     7f2:	9b bd       	out	0x2b, r25	; 43
     7f4:	8a bd       	out	0x2a, r24	; 42
     7f6:	6d cd       	rjmp	.-1318   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
     7f8:	88 ea       	ldi	r24, 0xA8	; 168
     7fa:	91 e0       	ldi	r25, 0x01	; 1
     7fc:	9b bd       	out	0x2b, r25	; 43
     7fe:	8a bd       	out	0x2a, r24	; 42
     800:	68 cd       	rjmp	.-1328   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
     802:	82 e5       	ldi	r24, 0x52	; 82
     804:	93 e0       	ldi	r25, 0x03	; 3
     806:	9b bd       	out	0x2b, r25	; 43
     808:	8a bd       	out	0x2a, r24	; 42
     80a:	63 cd       	rjmp	.-1338   	; 0x2d2 <play_note+0x22>
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
     80c:	8c ef       	ldi	r24, 0xFC	; 252
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	9b bd       	out	0x2b, r25	; 43
     812:	8a bd       	out	0x2a, r24	; 42
     814:	5e cd       	rjmp	.-1348   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
     816:	87 e3       	ldi	r24, 0x37	; 55
     818:	92 e0       	ldi	r25, 0x02	; 2
     81a:	9b bd       	out	0x2b, r25	; 43
     81c:	8a bd       	out	0x2a, r24	; 42
     81e:	59 cd       	rjmp	.-1358   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
     820:	8d e3       	ldi	r24, 0x3D	; 61
     822:	91 e0       	ldi	r25, 0x01	; 1
     824:	9b bd       	out	0x2b, r25	; 43
     826:	8a bd       	out	0x2a, r24	; 42
     828:	54 cd       	rjmp	.-1368   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
     82a:	89 e1       	ldi	r24, 0x19	; 25
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	9b bd       	out	0x2b, r25	; 43
     830:	8a bd       	out	0x2a, r24	; 42
     832:	4f cd       	rjmp	.-1378   	; 0x2d2 <play_note+0x22>
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
     834:	85 e0       	ldi	r24, 0x05	; 5
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	9b bd       	out	0x2b, r25	; 43
     83a:	8a bd       	out	0x2a, r24	; 42
     83c:	4a cd       	rjmp	.-1388   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
     83e:	8a e9       	ldi	r24, 0x9A	; 154
     840:	9a e1       	ldi	r25, 0x1A	; 26
     842:	9b bd       	out	0x2b, r25	; 43
     844:	8a bd       	out	0x2a, r24	; 42
     846:	45 cd       	rjmp	.-1398   	; 0x2d2 <play_note+0x22>
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
     848:	8c e4       	ldi	r24, 0x4C	; 76
     84a:	9d e0       	ldi	r25, 0x0D	; 13
     84c:	9b bd       	out	0x2b, r25	; 43
     84e:	8a bd       	out	0x2a, r24	; 42
     850:	40 cd       	rjmp	.-1408   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
     852:	8d ee       	ldi	r24, 0xED	; 237
     854:	93 e1       	ldi	r25, 0x13	; 19
     856:	9b bd       	out	0x2b, r25	; 43
     858:	8a bd       	out	0x2a, r24	; 42
     85a:	3b cd       	rjmp	.-1418   	; 0x2d2 <play_note+0x22>
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
     85c:	83 ef       	ldi	r24, 0xF3	; 243
     85e:	93 e0       	ldi	r25, 0x03	; 3
     860:	9b bd       	out	0x2b, r25	; 43
     862:	8a bd       	out	0x2a, r24	; 42
     864:	36 cd       	rjmp	.-1428   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
     866:	8f e6       	ldi	r24, 0x6F	; 111
     868:	94 e0       	ldi	r25, 0x04	; 4
     86a:	9b bd       	out	0x2b, r25	; 43
     86c:	8a bd       	out	0x2a, r24	; 42
     86e:	31 cd       	rjmp	.-1438   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
     870:	88 ed       	ldi	r24, 0xD8	; 216
     872:	9b e0       	ldi	r25, 0x0B	; 11
     874:	9b bd       	out	0x2b, r25	; 43
     876:	8a bd       	out	0x2a, r24	; 42
     878:	2c cd       	rjmp	.-1448   	; 0x2d2 <play_note+0x22>
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
     87a:	8e e1       	ldi	r24, 0x1E	; 30
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	9b bd       	out	0x2b, r25	; 43
     880:	8a bd       	out	0x2a, r24	; 42
     882:	27 cd       	rjmp	.-1458   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
     884:	82 e2       	ldi	r24, 0x22	; 34
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	9b bd       	out	0x2b, r25	; 43
     88a:	8a bd       	out	0x2a, r24	; 42
     88c:	22 cd       	rjmp	.-1468   	; 0x2d2 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
     88e:	85 ef       	ldi	r24, 0xF5	; 245
     890:	92 e0       	ldi	r25, 0x02	; 2
     892:	9b bd       	out	0x2b, r25	; 43
     894:	8a bd       	out	0x2a, r24	; 42
     896:	1d cd       	rjmp	.-1478   	; 0x2d2 <play_note+0x22>
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
     898:	80 ed       	ldi	r24, 0xD0	; 208
     89a:	9f e0       	ldi	r25, 0x0F	; 15
     89c:	9b bd       	out	0x2b, r25	; 43
     89e:	8a bd       	out	0x2a, r24	; 42
     8a0:	18 cd       	rjmp	.-1488   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
     8a2:	8d e0       	ldi	r24, 0x0D	; 13
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	9b bd       	out	0x2b, r25	; 43
     8a8:	8a bd       	out	0x2a, r24	; 42
     8aa:	13 cd       	rjmp	.-1498   	; 0x2d2 <play_note+0x22>
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
     8ac:	8f ed       	ldi	r24, 0xDF	; 223
     8ae:	98 e0       	ldi	r25, 0x08	; 8
     8b0:	9b bd       	out	0x2b, r25	; 43
     8b2:	8a bd       	out	0x2a, r24	; 42
     8b4:	0e cd       	rjmp	.-1508   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
     8b6:	86 ef       	ldi	r24, 0xF6	; 246
     8b8:	99 e0       	ldi	r25, 0x09	; 9
     8ba:	9b bd       	out	0x2b, r25	; 43
     8bc:	8a bd       	out	0x2a, r24	; 42
     8be:	09 cd       	rjmp	.-1518   	; 0x2d2 <play_note+0x22>
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
     8c0:	8a ef       	ldi	r24, 0xFA	; 250
     8c2:	94 e0       	ldi	r25, 0x04	; 4
     8c4:	9b bd       	out	0x2b, r25	; 43
     8c6:	8a bd       	out	0x2a, r24	; 42
     8c8:	04 cd       	rjmp	.-1528   	; 0x2d2 <play_note+0x22>

000008ca <song0>:
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8ca:	86 34       	cpi	r24, 0x46	; 70
     8cc:	91 05       	cpc	r25, r1
     8ce:	20 f0       	brcs	.+8      	; 0x8d8 <song0+0xe>
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	80 93 63 01 	sts	0x0163, r24
     8d6:	08 95       	ret
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8d8:	fc 01       	movw	r30, r24
     8da:	e2 57       	subi	r30, 0x72	; 114
     8dc:	ff 4f       	sbci	r31, 0xFF	; 255
     8de:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
     8e2:	22 e0       	ldi	r18, 0x02	; 2
     8e4:	44 e0       	ldi	r20, 0x04	; 4
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	81 e4       	ldi	r24, 0x41	; 65
     8ea:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
     8ee:	26 e0       	ldi	r18, 0x06	; 6
     8f0:	44 e0       	ldi	r20, 0x04	; 4
     8f2:	60 e0       	ldi	r22, 0x00	; 0
     8f4:	81 e4       	ldi	r24, 0x41	; 65
     8f6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
     8fa:	22 e0       	ldi	r18, 0x02	; 2
     8fc:	44 e0       	ldi	r20, 0x04	; 4
     8fe:	61 e0       	ldi	r22, 0x01	; 1
     900:	81 e4       	ldi	r24, 0x41	; 65
     902:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
     906:	28 e0       	ldi	r18, 0x08	; 8
     908:	44 e0       	ldi	r20, 0x04	; 4
     90a:	60 e0       	ldi	r22, 0x00	; 0
     90c:	84 e4       	ldi	r24, 0x44	; 68
     90e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
     912:	28 e0       	ldi	r18, 0x08	; 8
     914:	44 e0       	ldi	r20, 0x04	; 4
     916:	60 e0       	ldi	r22, 0x00	; 0
     918:	86 e4       	ldi	r24, 0x46	; 70
     91a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
     91e:	26 e0       	ldi	r18, 0x06	; 6
     920:	44 e0       	ldi	r20, 0x04	; 4
     922:	61 e0       	ldi	r22, 0x01	; 1
     924:	82 e4       	ldi	r24, 0x42	; 66
     926:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
     92a:	28 e0       	ldi	r18, 0x08	; 8
     92c:	44 e0       	ldi	r20, 0x04	; 4
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	83 e4       	ldi	r24, 0x43	; 67
     932:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
     936:	28 e0       	ldi	r18, 0x08	; 8
     938:	44 e0       	ldi	r20, 0x04	; 4
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	81 e4       	ldi	r24, 0x41	; 65
     93e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 67: play_note('G', 0, 4, 8);
     942:	28 e0       	ldi	r18, 0x08	; 8
     944:	44 e0       	ldi	r20, 0x04	; 4
     946:	60 e0       	ldi	r22, 0x00	; 0
     948:	87 e4       	ldi	r24, 0x47	; 71
     94a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
     94e:	28 e0       	ldi	r18, 0x08	; 8
     950:	44 e0       	ldi	r20, 0x04	; 4
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	85 e4       	ldi	r24, 0x45	; 69
     956:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
     95a:	20 e1       	ldi	r18, 0x10	; 16
     95c:	44 e0       	ldi	r20, 0x04	; 4
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	81 e4       	ldi	r24, 0x41	; 65
     962:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
     966:	24 e0       	ldi	r18, 0x04	; 4
     968:	45 e0       	ldi	r20, 0x05	; 5
     96a:	60 e0       	ldi	r22, 0x00	; 0
     96c:	83 e4       	ldi	r24, 0x43	; 67
     96e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 65: play_note('D', 0, 5, 4);
     972:	24 e0       	ldi	r18, 0x04	; 4
     974:	45 e0       	ldi	r20, 0x05	; 5
     976:	60 e0       	ldi	r22, 0x00	; 0
     978:	84 e4       	ldi	r24, 0x44	; 68
     97a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     97e:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     980:	10 92 76 01 	sts	0x0176, r1
     984:	10 92 75 01 	sts	0x0175, r1
  max_beat = duration;
     988:	88 e0       	ldi	r24, 0x08	; 8
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	90 93 74 01 	sts	0x0174, r25
     990:	80 93 73 01 	sts	0x0173, r24
     994:	08 95       	ret
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     996:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     998:	10 92 76 01 	sts	0x0176, r1
     99c:	10 92 75 01 	sts	0x0175, r1
  max_beat = duration;
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	90 93 74 01 	sts	0x0174, r25
     9a8:	80 93 73 01 	sts	0x0173, r24
     9ac:	08 95       	ret
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
     9ae:	20 e1       	ldi	r18, 0x10	; 16
     9b0:	44 e0       	ldi	r20, 0x04	; 4
     9b2:	61 e0       	ldi	r22, 0x01	; 1
     9b4:	82 e4       	ldi	r24, 0x42	; 66
     9b6:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
     9ba:	28 e0       	ldi	r18, 0x08	; 8
     9bc:	44 e0       	ldi	r20, 0x04	; 4
     9be:	61 e0       	ldi	r22, 0x01	; 1
     9c0:	82 e4       	ldi	r24, 0x42	; 66
     9c2:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
     9c6:	28 e1       	ldi	r18, 0x18	; 24
     9c8:	44 e0       	ldi	r20, 0x04	; 4
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	87 e4       	ldi	r24, 0x47	; 71
     9ce:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
     9d2:	20 e1       	ldi	r18, 0x10	; 16
     9d4:	45 e0       	ldi	r20, 0x05	; 5
     9d6:	60 e0       	ldi	r22, 0x00	; 0
     9d8:	84 e4       	ldi	r24, 0x44	; 68
     9da:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     9de:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     9e0:	10 92 76 01 	sts	0x0176, r1
     9e4:	10 92 75 01 	sts	0x0175, r1
  max_beat = duration;
     9e8:	82 e0       	ldi	r24, 0x02	; 2
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	90 93 74 01 	sts	0x0174, r25
     9f0:	80 93 73 01 	sts	0x0173, r24
     9f4:	08 95       	ret
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
     9f6:	24 e0       	ldi	r18, 0x04	; 4
     9f8:	44 e0       	ldi	r20, 0x04	; 4
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	81 e4       	ldi	r24, 0x41	; 65
     9fe:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
     a02:	26 e0       	ldi	r18, 0x06	; 6
     a04:	44 e0       	ldi	r20, 0x04	; 4
     a06:	60 e0       	ldi	r22, 0x00	; 0
     a08:	87 e4       	ldi	r24, 0x47	; 71
     a0a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
     a0e:	24 e0       	ldi	r18, 0x04	; 4
     a10:	44 e0       	ldi	r20, 0x04	; 4
     a12:	61 e0       	ldi	r22, 0x01	; 1
     a14:	87 e4       	ldi	r24, 0x47	; 71
     a16:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
     a1a:	28 e0       	ldi	r18, 0x08	; 8
     a1c:	44 e0       	ldi	r20, 0x04	; 4
     a1e:	61 e0       	ldi	r22, 0x01	; 1
     a20:	87 e4       	ldi	r24, 0x47	; 71
     a22:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
     a26:	23 e0       	ldi	r18, 0x03	; 3
     a28:	44 e0       	ldi	r20, 0x04	; 4
     a2a:	60 e0       	ldi	r22, 0x00	; 0
     a2c:	87 e4       	ldi	r24, 0x47	; 71
     a2e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
     a32:	20 e1       	ldi	r18, 0x10	; 16
     a34:	44 e0       	ldi	r20, 0x04	; 4
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	84 e4       	ldi	r24, 0x44	; 68
     a3a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
     a3e:	20 e1       	ldi	r18, 0x10	; 16
     a40:	45 e0       	ldi	r20, 0x05	; 5
     a42:	60 e0       	ldi	r22, 0x00	; 0
     a44:	83 e4       	ldi	r24, 0x43	; 67
     a46:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
     a4a:	22 e0       	ldi	r18, 0x02	; 2
     a4c:	44 e0       	ldi	r20, 0x04	; 4
     a4e:	61 e0       	ldi	r22, 0x01	; 1
     a50:	82 e4       	ldi	r24, 0x42	; 66
     a52:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
     a56:	24 e0       	ldi	r18, 0x04	; 4
     a58:	45 e0       	ldi	r20, 0x05	; 5
     a5a:	61 e0       	ldi	r22, 0x01	; 1
     a5c:	84 e4       	ldi	r24, 0x44	; 68
     a5e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
     a62:	24 e0       	ldi	r18, 0x04	; 4
     a64:	44 e0       	ldi	r20, 0x04	; 4
     a66:	61 e0       	ldi	r22, 0x01	; 1
     a68:	81 e4       	ldi	r24, 0x41	; 65
     a6a:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
     a6e:	28 e0       	ldi	r18, 0x08	; 8
     a70:	44 e0       	ldi	r20, 0x04	; 4
     a72:	60 e0       	ldi	r22, 0x00	; 0
     a74:	82 e4       	ldi	r24, 0x42	; 66
     a76:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
     a7a:	28 e1       	ldi	r18, 0x18	; 24
     a7c:	44 e0       	ldi	r20, 0x04	; 4
     a7e:	60 e0       	ldi	r22, 0x00	; 0
     a80:	86 e4       	ldi	r24, 0x46	; 70
     a82:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
     a86:	27 e0       	ldi	r18, 0x07	; 7
     a88:	44 e0       	ldi	r20, 0x04	; 4
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	87 e4       	ldi	r24, 0x47	; 71
     a8e:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <play_note>

00000a92 <play_song>:
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     a92:	86 2f       	mov	r24, r22
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000a9a <music_off>:
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     a9a:	10 92 63 01 	sts	0x0163, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     a9e:	8e b5       	in	r24, 0x2e	; 46
     aa0:	8c 7f       	andi	r24, 0xFC	; 252
     aa2:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     aa4:	92 9a       	sbi	0x12, 2	; 18
     aa6:	08 95       	ret

00000aa8 <music_on>:
}

void music_on(void) {
  //this starts the alarm timer running
  notes=0;
     aa8:	10 92 63 01 	sts	0x0163, r1
  TCCR1B |= (1<<CS11)|(1<<CS10);
     aac:	8e b5       	in	r24, 0x2e	; 46
     aae:	83 60       	ori	r24, 0x03	; 3
     ab0:	8e bd       	out	0x2e, r24	; 46
  //unmutes the output
  PORTD &= unmute;
     ab2:	92 98       	cbi	0x12, 2	; 18
  //and starts the selected song
  play_song(song, notes);
     ab4:	80 91 63 01 	lds	r24, 0x0163
     ab8:	90 91 72 01 	lds	r25, 0x0172
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <song0>

00000ac2 <music_init>:
  play_song(song, notes);
}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  DDRD |= (1<<PD7);
     ac2:	8f 9a       	sbi	0x11, 7	; 17
  TIMSK |= (1<<OCIE1A) | (1<<TOIE0);  //enable timer interrupt 1 on compare
     ac4:	87 b7       	in	r24, 0x37	; 55
     ac6:	81 61       	ori	r24, 0x11	; 17
     ac8:	87 bf       	out	0x37, r24	; 55
  TCCR1A = 0x00;         //TCNT1, normal port operation
     aca:	1f bc       	out	0x2f, r1	; 47
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
     acc:	8e b5       	in	r24, 0x2e	; 46
     ace:	88 60       	ori	r24, 0x08	; 8
     ad0:	8e bd       	out	0x2e, r24	; 46
  TCCR1C = 0x00;         //no forced compare
     ad2:	10 92 7a 00 	sts	0x007A, r1
  OCR1A = 0x0033;        //(use to vary alarm frequency)
     ad6:	83 e3       	ldi	r24, 0x33	; 51
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	9b bd       	out	0x2b, r25	; 43
     adc:	8a bd       	out	0x2a, r24	; 42
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     ade:	10 92 63 01 	sts	0x0163, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     ae2:	8e b5       	in	r24, 0x2e	; 46
     ae4:	8c 7f       	andi	r24, 0xFC	; 252
     ae6:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     ae8:	92 9a       	sbi	0x12, 2	; 18
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0033;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
     aea:	10 92 76 01 	sts	0x0176, r1
     aee:	10 92 75 01 	sts	0x0175, r1
  max_beat = 0;
     af2:	10 92 74 01 	sts	0x0174, r1
     af6:	10 92 73 01 	sts	0x0173, r1
  notes = 0;
     afa:	10 92 63 01 	sts	0x0163, r1
  song = 0;              //beaver fight song
     afe:	10 92 72 01 	sts	0x0172, r1
     b02:	08 95       	ret

00000b04 <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b04:	20 91 58 01 	lds	r18, 0x0158
     b08:	30 91 59 01 	lds	r19, 0x0159
     b0c:	22 0f       	add	r18, r18
     b0e:	33 1f       	adc	r19, r19
     b10:	49 b3       	in	r20, 0x19	; 25
     b12:	50 e0       	ldi	r21, 0x00	; 0
     b14:	02 c0       	rjmp	.+4      	; 0xb1a <chk_buttons+0x16>
     b16:	55 95       	asr	r21
     b18:	47 95       	ror	r20
     b1a:	8a 95       	dec	r24
     b1c:	e2 f7       	brpl	.-8      	; 0xb16 <chk_buttons+0x12>
     b1e:	40 fd       	sbrc	r20, 0
     b20:	0e c0       	rjmp	.+28     	; 0xb3e <chk_buttons+0x3a>
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	90 ee       	ldi	r25, 0xE0	; 224
     b26:	28 2b       	or	r18, r24
     b28:	39 2b       	or	r19, r25
     b2a:	30 93 59 01 	sts	0x0159, r19
     b2e:	20 93 58 01 	sts	0x0158, r18
	if (state == 0xF000){
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	21 15       	cp	r18, r1
     b36:	30 4f       	sbci	r19, 0xF0	; 240
     b38:	09 f0       	breq	.+2      	; 0xb3c <chk_buttons+0x38>
     b3a:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}
	return 0;
}
     b3c:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	90 ee       	ldi	r25, 0xE0	; 224
     b42:	f1 cf       	rjmp	.-30     	; 0xb26 <chk_buttons+0x22>

00000b44 <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
     b44:	81 11       	cpse	r24, r1
     b46:	02 c0       	rjmp	.+4      	; 0xb4c <int2seg+0x8>
		return ZERO;
     b48:	80 ec       	ldi	r24, 0xC0	; 192
     b4a:	08 95       	ret
	}
	else if(number == 1 ){
     b4c:	81 30       	cpi	r24, 0x01	; 1
     b4e:	91 f0       	breq	.+36     	; 0xb74 <int2seg+0x30>
		return ONE;
	}
	else if(number == 2 ){
     b50:	82 30       	cpi	r24, 0x02	; 2
     b52:	91 f0       	breq	.+36     	; 0xb78 <int2seg+0x34>
		return TWO;
	}
	else if(number == 3 ){
     b54:	83 30       	cpi	r24, 0x03	; 3
     b56:	a1 f0       	breq	.+40     	; 0xb80 <int2seg+0x3c>
		return THREE;
	}
	else if(number == 4 ){
     b58:	84 30       	cpi	r24, 0x04	; 4
     b5a:	81 f0       	breq	.+32     	; 0xb7c <int2seg+0x38>
		return FOUR;
	}
	else if(number == 5 ){
     b5c:	85 30       	cpi	r24, 0x05	; 5
     b5e:	91 f0       	breq	.+36     	; 0xb84 <int2seg+0x40>
		return FIVE;
	}
	else if(number == 6 ){
     b60:	86 30       	cpi	r24, 0x06	; 6
     b62:	91 f0       	breq	.+36     	; 0xb88 <int2seg+0x44>
		return  SIX;
	}
	else if(number == 7 ){
     b64:	87 30       	cpi	r24, 0x07	; 7
     b66:	91 f0       	breq	.+36     	; 0xb8c <int2seg+0x48>
		return SEVEN;
	}
	else if(number == 8 ){
     b68:	88 30       	cpi	r24, 0x08	; 8
     b6a:	91 f0       	breq	.+36     	; 0xb90 <int2seg+0x4c>
		return EIGHT;
	}
	else if(number == 9 ){
     b6c:	89 30       	cpi	r24, 0x09	; 9
     b6e:	91 f0       	breq	.+36     	; 0xb94 <int2seg+0x50>
		return NINE;
	}
	else{ 
		return 0;
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	08 95       	ret
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
		return ZERO;
	}
	else if(number == 1 ){
		return ONE;
     b74:	89 ef       	ldi	r24, 0xF9	; 249
     b76:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
     b78:	84 ea       	ldi	r24, 0xA4	; 164
     b7a:	08 95       	ret
	}
	else if(number == 3 ){
		return THREE;
	}
	else if(number == 4 ){
		return FOUR;
     b7c:	89 e9       	ldi	r24, 0x99	; 153
     b7e:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
	}
	else if(number == 3 ){
		return THREE;
     b80:	80 eb       	ldi	r24, 0xB0	; 176
     b82:	08 95       	ret
	}
	else if(number == 4 ){
		return FOUR;
	}
	else if(number == 5 ){
		return FIVE;
     b84:	82 e9       	ldi	r24, 0x92	; 146
     b86:	08 95       	ret
	}
	else if(number == 6 ){
		return  SIX;
     b88:	82 e8       	ldi	r24, 0x82	; 130
     b8a:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
     b8c:	88 ef       	ldi	r24, 0xF8	; 248
		return NINE;
	}
	else{ 
		return 0;
	}
}
     b8e:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
	}
	else if(number == 8 ){
		return EIGHT;
     b90:	80 e8       	ldi	r24, 0x80	; 128
     b92:	08 95       	ret
	}
	else if(number == 9 ){
		return NINE;
     b94:	80 e9       	ldi	r24, 0x90	; 144
     b96:	08 95       	ret

00000b98 <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
     b98:	ff 92       	push	r15
     b9a:	0f 93       	push	r16
     b9c:	1f 93       	push	r17
     b9e:	cf 93       	push	r28
     ba0:	df 93       	push	r29
     ba2:	ec 01       	movw	r28, r24
	//determine how many digits there are 
	//int digit;
	// Break down the digits

	if(ticker%2 == 1){
     ba4:	80 91 5a 01 	lds	r24, 0x015A
     ba8:	80 ff       	sbrs	r24, 0
     baa:	82 c0       	rjmp	.+260    	; 0xcb0 <segsum+0x118>
		segment_data[2] = 0xFC;
     bac:	8c ef       	ldi	r24, 0xFC	; 252
     bae:	80 93 80 01 	sts	0x0180, r24
		segment_data[2] = 0xFF;
	} 
	//When setting alarm is on)
	//break up decimal sum into 4 digit-segments

	segment_data[0] = int2seg(sum % 10); //ones
     bb2:	9e 01       	movw	r18, r28
     bb4:	ad ec       	ldi	r26, 0xCD	; 205
     bb6:	bc ec       	ldi	r27, 0xCC	; 204
     bb8:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
     bbc:	96 95       	lsr	r25
     bbe:	87 95       	ror	r24
     bc0:	96 95       	lsr	r25
     bc2:	87 95       	ror	r24
     bc4:	96 95       	lsr	r25
     bc6:	87 95       	ror	r24
     bc8:	3c 2f       	mov	r19, r28
     bca:	2a e0       	ldi	r18, 0x0A	; 10
     bcc:	82 9f       	mul	r24, r18
     bce:	30 19       	sub	r19, r0
     bd0:	11 24       	eor	r1, r1
     bd2:	83 2f       	mov	r24, r19
     bd4:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     bd8:	f8 2e       	mov	r15, r24
	segment_data[1] = int2seg((sum % 100)/10); //tens
     bda:	9e 01       	movw	r18, r28
     bdc:	36 95       	lsr	r19
     bde:	27 95       	ror	r18
     be0:	36 95       	lsr	r19
     be2:	27 95       	ror	r18
     be4:	ab e7       	ldi	r26, 0x7B	; 123
     be6:	b4 e1       	ldi	r27, 0x14	; 20
     be8:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
     bec:	96 95       	lsr	r25
     bee:	87 95       	ror	r24
     bf0:	44 e6       	ldi	r20, 0x64	; 100
     bf2:	48 9f       	mul	r20, r24
     bf4:	90 01       	movw	r18, r0
     bf6:	49 9f       	mul	r20, r25
     bf8:	30 0d       	add	r19, r0
     bfa:	11 24       	eor	r1, r1
     bfc:	ce 01       	movw	r24, r28
     bfe:	82 1b       	sub	r24, r18
     c00:	93 0b       	sbc	r25, r19
     c02:	9c 01       	movw	r18, r24
     c04:	ad ec       	ldi	r26, 0xCD	; 205
     c06:	bc ec       	ldi	r27, 0xCC	; 204
     c08:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
     c0c:	96 95       	lsr	r25
     c0e:	87 95       	ror	r24
     c10:	96 95       	lsr	r25
     c12:	87 95       	ror	r24
     c14:	96 95       	lsr	r25
     c16:	87 95       	ror	r24
     c18:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c1c:	80 93 7f 01 	sts	0x017F, r24
	//segment_data[2] = 1; //decimal
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
     c20:	9e 01       	movw	r18, r28
     c22:	36 95       	lsr	r19
     c24:	27 95       	ror	r18
     c26:	36 95       	lsr	r19
     c28:	27 95       	ror	r18
     c2a:	36 95       	lsr	r19
     c2c:	27 95       	ror	r18
     c2e:	a5 ec       	ldi	r26, 0xC5	; 197
     c30:	b0 e2       	ldi	r27, 0x20	; 32
     c32:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
     c36:	8c 01       	movw	r16, r24
     c38:	12 95       	swap	r17
     c3a:	02 95       	swap	r16
     c3c:	0f 70       	andi	r16, 0x0F	; 15
     c3e:	01 27       	eor	r16, r17
     c40:	1f 70       	andi	r17, 0x0F	; 15
     c42:	01 27       	eor	r16, r17
     c44:	48 ee       	ldi	r20, 0xE8	; 232
     c46:	53 e0       	ldi	r21, 0x03	; 3
     c48:	04 9f       	mul	r16, r20
     c4a:	90 01       	movw	r18, r0
     c4c:	05 9f       	mul	r16, r21
     c4e:	30 0d       	add	r19, r0
     c50:	14 9f       	mul	r17, r20
     c52:	30 0d       	add	r19, r0
     c54:	11 24       	eor	r1, r1
     c56:	ce 01       	movw	r24, r28
     c58:	82 1b       	sub	r24, r18
     c5a:	93 0b       	sbc	r25, r19
     c5c:	9c 01       	movw	r18, r24
     c5e:	36 95       	lsr	r19
     c60:	27 95       	ror	r18
     c62:	36 95       	lsr	r19
     c64:	27 95       	ror	r18
     c66:	ab e7       	ldi	r26, 0x7B	; 123
     c68:	b4 e1       	ldi	r27, 0x14	; 20
     c6a:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
     c6e:	96 95       	lsr	r25
     c70:	87 95       	ror	r24
     c72:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c76:	80 93 81 01 	sts	0x0181, r24
	segment_data[4] = int2seg(sum/1000); //thousands
     c7a:	80 2f       	mov	r24, r16
     c7c:	0e 94 a2 05 	call	0xb44	; 0xb44 <int2seg>
     c80:	80 93 82 01 	sts	0x0182, r24
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
     c84:	80 91 40 01 	lds	r24, 0x0140
     c88:	88 23       	and	r24, r24
     c8a:	21 f0       	breq	.+8      	; 0xc94 <segsum+0xfc>
     c8c:	80 91 62 01 	lds	r24, 0x0162
     c90:	81 11       	cpse	r24, r1
     c92:	12 c0       	rjmp	.+36     	; 0xcb8 <segsum+0x120>
		segment_data[0] &= 0x7F;
	}
	else{
		segment_data[0] |= 0b10000000;
     c94:	8f 2d       	mov	r24, r15
     c96:	80 68       	ori	r24, 0x80	; 128
     c98:	80 93 7e 01 	sts	0x017E, r24
	}
	if(mode == 1 && blink){
     c9c:	80 91 60 01 	lds	r24, 0x0160
     ca0:	81 30       	cpi	r24, 0x01	; 1
     ca2:	91 f0       	breq	.+36     	; 0xcc8 <segsum+0x130>
		segment_data[4] = 0xFF;
		segment_data[3] = 0xFF;
		segment_data[1] = 0xFF;
		segment_data[0] = 0xFF;
	}
}//segment_sum
     ca4:	df 91       	pop	r29
     ca6:	cf 91       	pop	r28
     ca8:	1f 91       	pop	r17
     caa:	0f 91       	pop	r16
     cac:	ff 90       	pop	r15
     cae:	08 95       	ret

	if(ticker%2 == 1){
		segment_data[2] = 0xFC;
	}
	else{
		segment_data[2] = 0xFF;
     cb0:	8f ef       	ldi	r24, 0xFF	; 255
     cb2:	80 93 80 01 	sts	0x0180, r24
     cb6:	7d cf       	rjmp	.-262    	; 0xbb2 <segsum+0x1a>
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
	segment_data[4] = int2seg(sum/1000); //thousands
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
		segment_data[0] &= 0x7F;
     cb8:	8f 2d       	mov	r24, r15
     cba:	8f 77       	andi	r24, 0x7F	; 127
     cbc:	80 93 7e 01 	sts	0x017E, r24
	}
	else{
		segment_data[0] |= 0b10000000;
	}
	if(mode == 1 && blink){
     cc0:	80 91 60 01 	lds	r24, 0x0160
     cc4:	81 30       	cpi	r24, 0x01	; 1
     cc6:	71 f7       	brne	.-36     	; 0xca4 <segsum+0x10c>
     cc8:	80 91 37 01 	lds	r24, 0x0137
     ccc:	88 23       	and	r24, r24
     cce:	51 f3       	breq	.-44     	; 0xca4 <segsum+0x10c>
		segment_data[4] = 0xFF;
     cd0:	8f ef       	ldi	r24, 0xFF	; 255
     cd2:	80 93 82 01 	sts	0x0182, r24
		segment_data[3] = 0xFF;
     cd6:	80 93 81 01 	sts	0x0181, r24
		segment_data[1] = 0xFF;
     cda:	80 93 7f 01 	sts	0x017F, r24
		segment_data[0] = 0xFF;
     cde:	80 93 7e 01 	sts	0x017E, r24
	}
}//segment_sum
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	08 95       	ret

00000cee <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
     cee:	1f 92       	push	r1
     cf0:	0f 92       	push	r0
     cf2:	0f b6       	in	r0, 0x3f	; 63
     cf4:	0f 92       	push	r0
     cf6:	11 24       	eor	r1, r1
     cf8:	0b b6       	in	r0, 0x3b	; 59
     cfa:	0f 92       	push	r0
     cfc:	2f 93       	push	r18
     cfe:	3f 93       	push	r19
     d00:	4f 93       	push	r20
     d02:	5f 93       	push	r21
     d04:	6f 93       	push	r22
     d06:	7f 93       	push	r23
     d08:	8f 93       	push	r24
     d0a:	9f 93       	push	r25
     d0c:	af 93       	push	r26
     d0e:	bf 93       	push	r27
     d10:	cf 93       	push	r28
     d12:	ef 93       	push	r30
     d14:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
     d16:	20 91 57 01 	lds	r18, 0x0157
     d1a:	2f 5f       	subi	r18, 0xFF	; 255
     d1c:	20 93 57 01 	sts	0x0157, r18
	//update_time();
	update_LCD = 1;
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	80 93 4a 01 	sts	0x014A, r24
	if(count%8 == 0){
     d26:	82 2f       	mov	r24, r18
     d28:	87 70       	andi	r24, 0x07	; 7
     d2a:	81 f4       	brne	.+32     	; 0xd4c <__vector_16+0x5e>
		beat++;
     d2c:	80 91 75 01 	lds	r24, 0x0175
     d30:	90 91 76 01 	lds	r25, 0x0176
     d34:	01 96       	adiw	r24, 0x01	; 1
     d36:	90 93 76 01 	sts	0x0176, r25
     d3a:	80 93 75 01 	sts	0x0175, r24
		blink = !blink;
     d3e:	81 e0       	ldi	r24, 0x01	; 1
     d40:	90 91 37 01 	lds	r25, 0x0137
     d44:	91 11       	cpse	r25, r1
     d46:	3f c0       	rjmp	.+126    	; 0xdc6 <__vector_16+0xd8>
     d48:	80 93 37 01 	sts	0x0137, r24
	}
	if((count%128)==0){
     d4c:	2f 77       	andi	r18, 0x7F	; 127
     d4e:	39 f5       	brne	.+78     	; 0xd9e <__vector_16+0xb0>
		ticker++;     
     d50:	80 91 5a 01 	lds	r24, 0x015A
     d54:	8f 5f       	subi	r24, 0xFF	; 255
     d56:	80 93 5a 01 	sts	0x015A, r24
		second++; 
     d5a:	80 91 5f 01 	lds	r24, 0x015F
     d5e:	8f 5f       	subi	r24, 0xFF	; 255
     d60:	80 93 5f 01 	sts	0x015F, r24
		reset_temp = 1;   
     d64:	c1 e0       	ldi	r28, 0x01	; 1
     d66:	c0 93 49 01 	sts	0x0149, r28
		if(alarm_on){
     d6a:	80 91 39 01 	lds	r24, 0x0139
     d6e:	88 23       	and	r24, r24
     d70:	b1 f0       	breq	.+44     	; 0xd9e <__vector_16+0xb0>
			if ((alarm_time == time) && !snooze_flag && !music_status){
     d72:	20 91 44 01 	lds	r18, 0x0144
     d76:	30 91 45 01 	lds	r19, 0x0145
     d7a:	80 91 46 01 	lds	r24, 0x0146
     d7e:	90 91 47 01 	lds	r25, 0x0147
     d82:	28 17       	cp	r18, r24
     d84:	39 07       	cpc	r19, r25
     d86:	41 f1       	breq	.+80     	; 0xdd8 <__vector_16+0xea>
				//play music
				music_on();
				music_status = 1;
			}
			else if(snooze_flag){
     d88:	80 91 3a 01 	lds	r24, 0x013A
     d8c:	88 23       	and	r24, r24
     d8e:	39 f0       	breq	.+14     	; 0xd9e <__vector_16+0xb0>
				snooze_second++;
     d90:	80 91 3b 01 	lds	r24, 0x013B
     d94:	8f 5f       	subi	r24, 0xFF	; 255
     d96:	80 93 3b 01 	sts	0x013B, r24
				if(snooze_second >= 10){
     d9a:	8a 30       	cpi	r24, 0x0A	; 10
     d9c:	b0 f4       	brcc	.+44     	; 0xdca <__vector_16+0xdc>
					snooze_second = 0;
				}	
			}
		}
	}
}
     d9e:	ff 91       	pop	r31
     da0:	ef 91       	pop	r30
     da2:	cf 91       	pop	r28
     da4:	bf 91       	pop	r27
     da6:	af 91       	pop	r26
     da8:	9f 91       	pop	r25
     daa:	8f 91       	pop	r24
     dac:	7f 91       	pop	r23
     dae:	6f 91       	pop	r22
     db0:	5f 91       	pop	r21
     db2:	4f 91       	pop	r20
     db4:	3f 91       	pop	r19
     db6:	2f 91       	pop	r18
     db8:	0f 90       	pop	r0
     dba:	0b be       	out	0x3b, r0	; 59
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	0f 90       	pop	r0
     dc2:	1f 90       	pop	r1
     dc4:	18 95       	reti
	count++;
	//update_time();
	update_LCD = 1;
	if(count%8 == 0){
		beat++;
		blink = !blink;
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	bf cf       	rjmp	.-130    	; 0xd48 <__vector_16+0x5a>
				music_status = 1;
			}
			else if(snooze_flag){
				snooze_second++;
				if(snooze_second >= 10){
					snooze_flag = 0;
     dca:	10 92 3a 01 	sts	0x013A, r1
					music_on();
     dce:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
					snooze_second = 0;
     dd2:	10 92 3b 01 	sts	0x013B, r1
     dd6:	e3 cf       	rjmp	.-58     	; 0xd9e <__vector_16+0xb0>
	if((count%128)==0){
		ticker++;     
		second++; 
		reset_temp = 1;   
		if(alarm_on){
			if ((alarm_time == time) && !snooze_flag && !music_status){
     dd8:	80 91 3a 01 	lds	r24, 0x013A
     ddc:	81 11       	cpse	r24, r1
     dde:	d8 cf       	rjmp	.-80     	; 0xd90 <__vector_16+0xa2>
     de0:	80 91 38 01 	lds	r24, 0x0138
     de4:	81 11       	cpse	r24, r1
     de6:	db cf       	rjmp	.-74     	; 0xd9e <__vector_16+0xb0>
				//play music
				music_on();
     de8:	0e 94 54 05 	call	0xaa8	; 0xaa8 <music_on>
				music_status = 1;
     dec:	c0 93 38 01 	sts	0x0138, r28
     df0:	d6 cf       	rjmp	.-84     	; 0xd9e <__vector_16+0xb0>

00000df2 <__vector_12>:
			}
		}
	}
}

ISR(TIMER1_COMPA_vect){
     df2:	1f 92       	push	r1
     df4:	0f 92       	push	r0
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	0f 92       	push	r0
     dfa:	11 24       	eor	r1, r1
     dfc:	0b b6       	in	r0, 0x3b	; 59
     dfe:	0f 92       	push	r0
     e00:	2f 93       	push	r18
     e02:	3f 93       	push	r19
     e04:	4f 93       	push	r20
     e06:	5f 93       	push	r21
     e08:	6f 93       	push	r22
     e0a:	7f 93       	push	r23
     e0c:	8f 93       	push	r24
     e0e:	9f 93       	push	r25
     e10:	af 93       	push	r26
     e12:	bf 93       	push	r27
     e14:	ef 93       	push	r30
     e16:	ff 93       	push	r31
	PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
     e18:	82 b3       	in	r24, 0x12	; 18
     e1a:	80 58       	subi	r24, 0x80	; 128
     e1c:	82 bb       	out	0x12, r24	; 18
	PORTB |= (1<<PB0);
     e1e:	c0 9a       	sbi	0x18, 0	; 24
	if(beat >= max_beat) {   //if we've played the note long enough
     e20:	20 91 75 01 	lds	r18, 0x0175
     e24:	30 91 76 01 	lds	r19, 0x0176
     e28:	80 91 73 01 	lds	r24, 0x0173
     e2c:	90 91 74 01 	lds	r25, 0x0174
     e30:	28 17       	cp	r18, r24
     e32:	39 07       	cpc	r19, r25
     e34:	60 f0       	brcs	.+24     	; 0xe4e <__vector_12+0x5c>
		notes++;               //move on to the next note
     e36:	80 91 63 01 	lds	r24, 0x0163
     e3a:	8f 5f       	subi	r24, 0xFF	; 255
     e3c:	80 93 63 01 	sts	0x0163, r24
		play_song(song, notes);//and play it
     e40:	80 91 63 01 	lds	r24, 0x0163
     e44:	90 91 72 01 	lds	r25, 0x0172
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	0e 94 65 04 	call	0x8ca	; 0x8ca <song0>
	}
}
     e4e:	ff 91       	pop	r31
     e50:	ef 91       	pop	r30
     e52:	bf 91       	pop	r27
     e54:	af 91       	pop	r26
     e56:	9f 91       	pop	r25
     e58:	8f 91       	pop	r24
     e5a:	7f 91       	pop	r23
     e5c:	6f 91       	pop	r22
     e5e:	5f 91       	pop	r21
     e60:	4f 91       	pop	r20
     e62:	3f 91       	pop	r19
     e64:	2f 91       	pop	r18
     e66:	0f 90       	pop	r0
     e68:	0b be       	out	0x3b, r0	; 59
     e6a:	0f 90       	pop	r0
     e6c:	0f be       	out	0x3f, r0	; 63
     e6e:	0f 90       	pop	r0
     e70:	1f 90       	pop	r1
     e72:	18 95       	reti

00000e74 <__vector_21>:
		default:
			break;
	}    
} 

ISR(ADC_vect){
     e74:	1f 92       	push	r1
     e76:	0f 92       	push	r0
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	0f 92       	push	r0
     e7c:	11 24       	eor	r1, r1
     e7e:	8f 93       	push	r24
     e80:	9f 93       	push	r25

	if(ADCH < 100){
     e82:	85 b1       	in	r24, 0x05	; 5
     e84:	84 36       	cpi	r24, 0x64	; 100
     e86:	48 f0       	brcs	.+18     	; 0xe9a <__vector_21+0x26>
		OCR2 = 100-ADCH;
	}  
	else{
		OCR2 = 1;// brightness_level;
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	83 bd       	out	0x23, r24	; 35
	}
}
     e8c:	9f 91       	pop	r25
     e8e:	8f 91       	pop	r24
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63
     e94:	0f 90       	pop	r0
     e96:	1f 90       	pop	r1
     e98:	18 95       	reti
} 

ISR(ADC_vect){

	if(ADCH < 100){
		OCR2 = 100-ADCH;
     e9a:	95 b1       	in	r25, 0x05	; 5
     e9c:	84 e6       	ldi	r24, 0x64	; 100
     e9e:	89 1b       	sub	r24, r25
     ea0:	83 bd       	out	0x23, r24	; 35
	}  
	else{
		OCR2 = 1;// brightness_level;
	}
}
     ea2:	9f 91       	pop	r25
     ea4:	8f 91       	pop	r24
     ea6:	0f 90       	pop	r0
     ea8:	0f be       	out	0x3f, r0	; 63
     eaa:	0f 90       	pop	r0
     eac:	1f 90       	pop	r1
     eae:	18 95       	reti

00000eb0 <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
     eb0:	80 91 5f 01 	lds	r24, 0x015F
		minute++;
     eb4:	20 91 5e 01 	lds	r18, 0x015E
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
     eb8:	8c 33       	cpi	r24, 0x3C	; 60
     eba:	28 f0       	brcs	.+10     	; 0xec6 <update_time+0x16>
		minute++;
     ebc:	2f 5f       	subi	r18, 0xFF	; 255
     ebe:	20 93 5e 01 	sts	0x015E, r18
		second = 0;
     ec2:	10 92 5f 01 	sts	0x015F, r1
	}             
	if(minute >=60){
		hour++;
     ec6:	e0 91 5d 01 	lds	r30, 0x015D
	// static int minute_change = 0;
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
     eca:	2c 33       	cpi	r18, 0x3C	; 60
     ecc:	c0 f5       	brcc	.+112    	; 0xf3e <update_time+0x8e>
     ece:	30 e0       	ldi	r19, 0x00	; 0
		hour++;
		minute = 0;
	}
	if(hour >= 24){
     ed0:	e8 31       	cpi	r30, 0x18	; 24
     ed2:	f0 f5       	brcc	.+124    	; 0xf50 <update_time+0xa0>
     ed4:	6e 2f       	mov	r22, r30
     ed6:	70 e0       	ldi	r23, 0x00	; 0
     ed8:	84 e6       	ldi	r24, 0x64	; 100
     eda:	e8 9f       	mul	r30, r24
     edc:	a0 01       	movw	r20, r0
     ede:	11 24       	eor	r1, r1
		hour = 0;
	} 

	alarm_time = (alarm_hour * 100) + alarm_minute;
     ee0:	f0 91 5b 01 	lds	r31, 0x015B
     ee4:	80 91 5c 01 	lds	r24, 0x015C
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	a4 e6       	ldi	r26, 0x64	; 100
     eec:	fa 9f       	mul	r31, r26
     eee:	80 0d       	add	r24, r0
     ef0:	91 1d       	adc	r25, r1
     ef2:	11 24       	eor	r1, r1
     ef4:	90 93 45 01 	sts	0x0145, r25
     ef8:	80 93 44 01 	sts	0x0144, r24
	// if(minute_change){
	time = (hour * 100) + minute;
     efc:	c9 01       	movw	r24, r18
     efe:	84 0f       	add	r24, r20
     f00:	95 1f       	adc	r25, r21
     f02:	90 93 47 01 	sts	0x0147, r25
     f06:	80 93 46 01 	sts	0x0146, r24
	// minute_change = 0;

	if(show_ampm){
     f0a:	40 91 62 01 	lds	r20, 0x0162
     f0e:	44 23       	and	r20, r20
     f10:	39 f1       	breq	.+78     	; 0xf60 <update_time+0xb0>
		if(hour>=12){
     f12:	ec 30       	cpi	r30, 0x0C	; 12
     f14:	50 f1       	brcs	.+84     	; 0xf6a <update_time+0xba>
			if(hour == 12){
     f16:	ec 30       	cpi	r30, 0x0C	; 12
     f18:	d1 f1       	breq	.+116    	; 0xf8e <update_time+0xde>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour-12)*100 + minute;
     f1a:	6c 50       	subi	r22, 0x0C	; 12
     f1c:	71 09       	sbc	r23, r1
     f1e:	44 e6       	ldi	r20, 0x64	; 100
     f20:	46 9f       	mul	r20, r22
     f22:	c0 01       	movw	r24, r0
     f24:	47 9f       	mul	r20, r23
     f26:	90 0d       	add	r25, r0
     f28:	11 24       	eor	r1, r1
     f2a:	82 0f       	add	r24, r18
     f2c:	93 1f       	adc	r25, r19
     f2e:	90 93 43 01 	sts	0x0143, r25
     f32:	80 93 42 01 	sts	0x0142, r24
				am_pm = 1;
     f36:	81 e0       	ldi	r24, 0x01	; 1
     f38:	80 93 40 01 	sts	0x0140, r24
     f3c:	08 95       	ret
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
		hour++;
     f3e:	ef 5f       	subi	r30, 0xFF	; 255
     f40:	e0 93 5d 01 	sts	0x015D, r30
		minute = 0;
     f44:	10 92 5e 01 	sts	0x015E, r1
     f48:	20 e0       	ldi	r18, 0x00	; 0
     f4a:	30 e0       	ldi	r19, 0x00	; 0
	}
	if(hour >= 24){
     f4c:	e8 31       	cpi	r30, 0x18	; 24
     f4e:	10 f2       	brcs	.-124    	; 0xed4 <update_time+0x24>
		hour = 0;
     f50:	10 92 5d 01 	sts	0x015D, r1
     f54:	40 e0       	ldi	r20, 0x00	; 0
     f56:	50 e0       	ldi	r21, 0x00	; 0
     f58:	60 e0       	ldi	r22, 0x00	; 0
     f5a:	70 e0       	ldi	r23, 0x00	; 0
     f5c:	e0 e0       	ldi	r30, 0x00	; 0
     f5e:	c0 cf       	rjmp	.-128    	; 0xee0 <update_time+0x30>
			}
			am_pm = 0;
		}
	}
	else{
		show_time = (hour * 100) + minute;
     f60:	90 93 43 01 	sts	0x0143, r25
     f64:	80 93 42 01 	sts	0x0142, r24
     f68:	08 95       	ret
				show_time = (hour-12)*100 + minute;
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
     f6a:	ee 23       	and	r30, r30
     f6c:	39 f0       	breq	.+14     	; 0xf7c <update_time+0xcc>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour)*100 + minute;
     f6e:	90 93 43 01 	sts	0x0143, r25
     f72:	80 93 42 01 	sts	0x0142, r24
			}
			am_pm = 0;
     f76:	10 92 40 01 	sts	0x0140, r1
     f7a:	08 95       	ret
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
				show_time = 1200 + minute;
     f7c:	20 55       	subi	r18, 0x50	; 80
     f7e:	3b 4f       	sbci	r19, 0xFB	; 251
     f80:	30 93 43 01 	sts	0x0143, r19
     f84:	20 93 42 01 	sts	0x0142, r18
			}
			else{
				show_time = (hour)*100 + minute;
			}
			am_pm = 0;
     f88:	10 92 40 01 	sts	0x0140, r1
     f8c:	08 95       	ret
	// minute_change = 0;

	if(show_ampm){
		if(hour>=12){
			if(hour == 12){
				show_time = 1200 + minute;
     f8e:	20 55       	subi	r18, 0x50	; 80
     f90:	3b 4f       	sbci	r19, 0xFB	; 251
     f92:	30 93 43 01 	sts	0x0143, r19
     f96:	20 93 42 01 	sts	0x0142, r18
     f9a:	08 95       	ret

00000f9c <SPI_init>:
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
     f9c:	80 e5       	ldi	r24, 0x50	; 80
     f9e:	8d b9       	out	0x0d, r24	; 13
     fa0:	08 95       	ret

00000fa2 <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
     fa2:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
     fa4:	77 9b       	sbis	0x0e, 7	; 14
     fa6:	fe cf       	rjmp	.-4      	; 0xfa4 <SPI_Transmit+0x2>
}
     fa8:	08 95       	ret

00000faa <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
	PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
     faa:	83 b1       	in	r24, 0x03	; 3
     fac:	13 b8       	out	0x03, r1	; 3
	__asm__ __volatile__ ("nop");
     fae:	00 00       	nop
	__asm__ __volatile__ ("nop");
     fb0:	00 00       	nop
	// Wait until 8 clock cycles are done 
	SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
     fb2:	1f b8       	out	0x0f, r1	; 15
	PORTE |= (1 << PE6);  
     fb4:	1e 9a       	sbi	0x03, 6	; 3
	__asm__ __volatile__ ("nop");
     fb6:	00 00       	nop
	__asm__ __volatile__ ("nop");
     fb8:	00 00       	nop
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
     fba:	77 9b       	sbis	0x0e, 7	; 14
     fbc:	fe cf       	rjmp	.-4      	; 0xfba <SPI_Receive+0x10>
	// Return incoming data from SPDR
	return(SPDR);  
     fbe:	8f b1       	in	r24, 0x0f	; 15
}
     fc0:	08 95       	ret

00000fc2 <bar_graph>:
 *void bar_graph()
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
     fc2:	80 91 60 01 	lds	r24, 0x0160
     fc6:	88 23       	and	r24, r24
     fc8:	b9 f0       	breq	.+46     	; 0xff8 <bar_graph+0x36>
		write = 0x00;
	}
	else{
		write = 1<<(mode-1);
     fca:	9f ef       	ldi	r25, 0xFF	; 255
     fcc:	98 0f       	add	r25, r24
     fce:	81 e0       	ldi	r24, 0x01	; 1
     fd0:	01 c0       	rjmp	.+2      	; 0xfd4 <bar_graph+0x12>
     fd2:	88 0f       	add	r24, r24
     fd4:	9a 95       	dec	r25
     fd6:	ea f7       	brpl	.-6      	; 0xfd2 <bar_graph+0x10>
	}

	if(alarm_on != 0){
     fd8:	90 91 39 01 	lds	r25, 0x0139
     fdc:	91 11       	cpse	r25, r1
		write = 0xF0;
     fde:	80 ef       	ldi	r24, 0xF0	; 240

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
     fe0:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
     fe2:	77 9b       	sbis	0x0e, 7	; 14
     fe4:	fe cf       	rjmp	.-4      	; 0xfe2 <bar_graph+0x20>

	if(alarm_on != 0){
		write = 0xF0;
	}
	SPI_Transmit(write);
	PORTD = (1 << PD2);  //Push data out of SPI
     fe6:	84 e0       	ldi	r24, 0x04	; 4
     fe8:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop"); //Buffer
     fea:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
     fec:	00 00       	nop


	PORTD = (2 << PD2);  // Push data out of SPI
     fee:	88 e0       	ldi	r24, 0x08	; 8
     ff0:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop");  //Buffer
     ff2:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
     ff4:	00 00       	nop
     ff6:	08 95       	ret
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
		write = 0x00;
     ff8:	80 e0       	ldi	r24, 0x00	; 0
     ffa:	ee cf       	rjmp	.-36     	; 0xfd8 <bar_graph+0x16>

00000ffc <button_routine>:
		segment_data[1] = 0xFF;
		segment_data[0] = 0xFF;
	}
}//segment_sum
//***********************************************************************************
void button_routine(){
     ffc:	ff 92       	push	r15
     ffe:	0f 93       	push	r16
    1000:	1f 93       	push	r17
    1002:	cf 93       	push	r28
    1004:	df 93       	push	r29
	// L -> R
	// 3 2 1 0 7 6 5 4
	uint8_t button = 0;
	//static int previous_mode;   
	DDRA  = 0x00; // PORTA input mode
    1006:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0xFF; //Pull ups
    1008:	8f ef       	ldi	r24, 0xFF	; 255
    100a:	8b bb       	out	0x1b, r24	; 27
	__asm__ __volatile__ ("nop");
    100c:	00 00       	nop
	__asm__ __volatile__ ("nop");
    100e:	00 00       	nop
	//enable tristate buffer for pushbutton switches
	PORTB |= 0x70; //Set S2,S1,S0 to 111
    1010:	88 b3       	in	r24, 0x18	; 24
    1012:	80 67       	ori	r24, 0x70	; 112
    1014:	88 bb       	out	0x18, r24	; 24
	__asm__ __volatile__ ("nop");
    1016:	00 00       	nop
	__asm__ __volatile__ ("nop");
    1018:	00 00       	nop
    101a:	c0 e0       	ldi	r28, 0x00	; 0
    101c:	d0 e0       	ldi	r29, 0x00	; 0
				case 7:
					if(alarm_on && music_status){
						music_off();
						music_status = 0;
					}
					alarm_on = !alarm_on;
    101e:	11 e0       	ldi	r17, 0x01	; 1
				case 3:
					if(mode == 3){
						mode = 0;			
					}
					else{
						mode = 3;
    1020:	03 e0       	ldi	r16, 0x03	; 3
    1022:	f0 2e       	mov	r15, r16
				case 2:
					if(mode == 2){
						mode = 0;	
					}
					else{
						mode = 2;
    1024:	02 e0       	ldi	r16, 0x02	; 2
    1026:	0f c0       	rjmp	.+30     	; 0x1046 <button_routine+0x4a>
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
    1028:	41 e0       	ldi	r20, 0x01	; 1
    102a:	50 ee       	ldi	r21, 0xE0	; 224
    102c:	24 2b       	or	r18, r20
    102e:	35 2b       	or	r19, r21
    1030:	30 93 59 01 	sts	0x0159, r19
    1034:	20 93 58 01 	sts	0x0158, r18
	if (state == 0xF000){
    1038:	21 15       	cp	r18, r1
    103a:	30 4f       	sbci	r19, 0xF0	; 240
    103c:	c1 f0       	breq	.+48     	; 0x106e <button_routine+0x72>
    103e:	21 96       	adiw	r28, 0x01	; 1
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
    1040:	c8 30       	cpi	r28, 0x08	; 8
    1042:	d1 05       	cpc	r29, r1
    1044:	11 f1       	breq	.+68     	; 0x108a <button_routine+0x8e>
    1046:	8c 2f       	mov	r24, r28
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
    1048:	20 91 58 01 	lds	r18, 0x0158
    104c:	30 91 59 01 	lds	r19, 0x0159
    1050:	22 0f       	add	r18, r18
    1052:	33 1f       	adc	r19, r19
    1054:	49 b3       	in	r20, 0x19	; 25
    1056:	50 e0       	ldi	r21, 0x00	; 0
    1058:	0c 2e       	mov	r0, r28
    105a:	02 c0       	rjmp	.+4      	; 0x1060 <button_routine+0x64>
    105c:	55 95       	asr	r21
    105e:	47 95       	ror	r20
    1060:	0a 94       	dec	r0
    1062:	e2 f7       	brpl	.-8      	; 0x105c <button_routine+0x60>
    1064:	40 ff       	sbrs	r20, 0
    1066:	e0 cf       	rjmp	.-64     	; 0x1028 <button_routine+0x2c>
    1068:	40 e0       	ldi	r20, 0x00	; 0
    106a:	50 ee       	ldi	r21, 0xE0	; 224
    106c:	df cf       	rjmp	.-66     	; 0x102c <button_routine+0x30>
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	fc 01       	movw	r30, r24
    1072:	31 97       	sbiw	r30, 0x01	; 1
    1074:	e7 30       	cpi	r30, 0x07	; 7
    1076:	f1 05       	cpc	r31, r1
    1078:	90 f0       	brcs	.+36     	; 0x109e <button_routine+0xa2>
				case 0:  
					mode = 0;
					break;
				case 1:
					if(mode == 1){
						mode = 0;	
    107a:	10 92 60 01 	sts	0x0160, r1
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph();
    107e:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <bar_graph>
    1082:	21 96       	adiw	r28, 0x01	; 1
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
    1084:	c8 30       	cpi	r28, 0x08	; 8
    1086:	d1 05       	cpc	r29, r1
    1088:	f1 f6       	brne	.-68     	; 0x1046 <button_routine+0x4a>
			}
			bar_graph();
			
		}
	}
	DDRA = 0xFF;  //switch PORTA to output
    108a:	8f ef       	ldi	r24, 0xFF	; 255
    108c:	8a bb       	out	0x1a, r24	; 26
	__asm__ __volatile__ ("nop"); //Buffer
    108e:	00 00       	nop
	__asm__ __volatile__ ("nop"); //Buffer 
    1090:	00 00       	nop

}
    1092:	df 91       	pop	r29
    1094:	cf 91       	pop	r28
    1096:	1f 91       	pop	r17
    1098:	0f 91       	pop	r16
    109a:	ff 90       	pop	r15
    109c:	08 95       	ret
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
    109e:	ec 52       	subi	r30, 0x2C	; 44
    10a0:	ff 4f       	sbci	r31, 0xFF	; 255
    10a2:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
				case 4:
					show_temp = !show_temp;
					break;
				case 5:
					//show_ampm = !show_ampm;
					show_temp = !show_temp;
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	90 91 41 01 	lds	r25, 0x0141
    10ac:	91 11       	cpse	r25, r1
    10ae:	03 c0       	rjmp	.+6      	; 0x10b6 <button_routine+0xba>
    10b0:	80 93 41 01 	sts	0x0141, r24
					break;
    10b4:	e4 cf       	rjmp	.-56     	; 0x107e <button_routine+0x82>
				case 4:
					show_temp = !show_temp;
					break;
				case 5:
					//show_ampm = !show_ampm;
					show_temp = !show_temp;
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	80 93 41 01 	sts	0x0141, r24
    10bc:	e0 cf       	rjmp	.-64     	; 0x107e <button_routine+0x82>
					else{
						mode = 2;
					}
					break;
				case 3:
					if(mode == 3){
    10be:	80 91 60 01 	lds	r24, 0x0160
    10c2:	83 30       	cpi	r24, 0x03	; 3
    10c4:	d1 f2       	breq	.-76     	; 0x107a <button_routine+0x7e>
						mode = 0;			
					}
					else{
						mode = 3;
    10c6:	f0 92 60 01 	sts	0x0160, r15
    10ca:	d9 cf       	rjmp	.-78     	; 0x107e <button_routine+0x82>
					else{
						mode = 1;
					}
					break;
				case 2:
					if(mode == 2){
    10cc:	80 91 60 01 	lds	r24, 0x0160
    10d0:	82 30       	cpi	r24, 0x02	; 2
    10d2:	99 f2       	breq	.-90     	; 0x107a <button_routine+0x7e>
						mode = 0;	
					}
					else{
						mode = 2;
    10d4:	00 93 60 01 	sts	0x0160, r16
    10d8:	d2 cf       	rjmp	.-92     	; 0x107e <button_routine+0x82>
			switch(button){
				case 0:  
					mode = 0;
					break;
				case 1:
					if(mode == 1){
    10da:	80 91 60 01 	lds	r24, 0x0160
    10de:	81 30       	cpi	r24, 0x01	; 1
    10e0:	61 f2       	breq	.-104    	; 0x107a <button_routine+0x7e>
						mode = 0;	
					}
					else{
						mode = 1;
    10e2:	10 93 60 01 	sts	0x0160, r17
    10e6:	cb cf       	rjmp	.-106    	; 0x107e <button_routine+0x82>
				case 5:
					//show_ampm = !show_ampm;
					show_temp = !show_temp;
					break;
				case 6:
					if(music_status){
    10e8:	80 91 38 01 	lds	r24, 0x0138
    10ec:	88 23       	and	r24, r24
    10ee:	39 f2       	breq	.-114    	; 0x107e <button_routine+0x82>
						snooze_flag = 1;
    10f0:	10 93 3a 01 	sts	0x013A, r17
						music_status = 0;
    10f4:	10 92 38 01 	sts	0x0138, r1
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
    10f8:	10 92 63 01 	sts	0x0163, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
    10fc:	8e b5       	in	r24, 0x2e	; 46
    10fe:	8c 7f       	andi	r24, 0xFC	; 252
    1100:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
    1102:	92 9a       	sbi	0x12, 2	; 18
    1104:	bc cf       	rjmp	.-136    	; 0x107e <button_routine+0x82>
						music_off();
					}
					break;
				case 7:
					if(alarm_on && music_status){
    1106:	80 91 39 01 	lds	r24, 0x0139
    110a:	88 23       	and	r24, r24
    110c:	79 f0       	breq	.+30     	; 0x112c <__stack+0x2d>
    110e:	90 91 38 01 	lds	r25, 0x0138
    1112:	99 23       	and	r25, r25
    1114:	a1 f0       	breq	.+40     	; 0x113e <__stack+0x3f>
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
    1116:	10 92 63 01 	sts	0x0163, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
    111a:	8e b5       	in	r24, 0x2e	; 46
    111c:	8c 7f       	andi	r24, 0xFC	; 252
    111e:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
    1120:	92 9a       	sbi	0x12, 2	; 18
						music_off();
						music_status = 0;
    1122:	10 92 38 01 	sts	0x0138, r1
    1126:	90 91 39 01 	lds	r25, 0x0139
    112a:	01 c0       	rjmp	.+2      	; 0x112e <__stack+0x2f>
    112c:	90 e0       	ldi	r25, 0x00	; 0
					}
					alarm_on = !alarm_on;
    112e:	81 e0       	ldi	r24, 0x01	; 1
    1130:	91 11       	cpse	r25, r1
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	80 93 39 01 	sts	0x0139, r24
					update_LCD = 1;
    1138:	10 93 4a 01 	sts	0x014A, r17
					//alarm_change = 1; 
					break;
    113c:	a0 cf       	rjmp	.-192    	; 0x107e <button_routine+0x82>
    113e:	98 2f       	mov	r25, r24
    1140:	f6 cf       	rjmp	.-20     	; 0x112e <__stack+0x2f>

00001142 <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
	uint8_t display_segment = 0;
	//static uint8_t rotate_7seg = 0;
	switch(mode){
    1142:	80 91 60 01 	lds	r24, 0x0160
    1146:	83 30       	cpi	r24, 0x03	; 3
    1148:	41 f1       	breq	.+80     	; 0x119a <display_update+0x58>
    114a:	84 30       	cpi	r24, 0x04	; 4
    114c:	41 f0       	breq	.+16     	; 0x115e <display_update+0x1c>
    114e:	82 30       	cpi	r24, 0x02	; 2
    1150:	d9 f0       	breq	.+54     	; 0x1188 <display_update+0x46>
			segment_data[2] = 0xFF; //decimal
			break;
		case 4:
			break;
		default:
			segsum(show_time);
    1152:	80 91 42 01 	lds	r24, 0x0142
    1156:	90 91 43 01 	lds	r25, 0x0143
    115a:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
    115e:	ee e7       	ldi	r30, 0x7E	; 126
    1160:	f1 e0       	ldi	r31, 0x01	; 1
	__asm__ __volatile__ ("nop");  //Buffer
}
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    1162:	80 e0       	ldi	r24, 0x00	; 0

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
		PORTB = display_segment << 4;
		PORTA = segment_data[display_segment];
		_delay_us(80);
		PORTA = OFF;
    1164:	2f ef       	ldi	r18, 0xFF	; 255
			segsum(show_time);
			break;
	}

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
		PORTB = display_segment << 4;
    1166:	98 2f       	mov	r25, r24
    1168:	92 95       	swap	r25
    116a:	90 7f       	andi	r25, 0xF0	; 240
    116c:	98 bb       	out	0x18, r25	; 24
		PORTA = segment_data[display_segment];
    116e:	91 91       	ld	r25, Z+
    1170:	9b bb       	out	0x1b, r25	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1172:	af e3       	ldi	r26, 0x3F	; 63
    1174:	b1 e0       	ldi	r27, 0x01	; 1
    1176:	11 97       	sbiw	r26, 0x01	; 1
    1178:	f1 f7       	brne	.-4      	; 0x1176 <display_update+0x34>
    117a:	00 c0       	rjmp	.+0      	; 0x117c <display_update+0x3a>
    117c:	00 00       	nop
		_delay_us(80);
		PORTA = OFF;
    117e:	2b bb       	out	0x1b, r18	; 27
		default:
			segsum(show_time);
			break;
	}

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
    1180:	8f 5f       	subi	r24, 0xFF	; 255
    1182:	85 30       	cpi	r24, 0x05	; 5
    1184:	81 f7       	brne	.-32     	; 0x1166 <display_update+0x24>
		PORTB = display_segment << 4;
		PORTA = segment_data[display_segment];
		_delay_us(80);
		PORTA = OFF;
	}
}
    1186:	08 95       	ret
void display_update(){
	uint8_t display_segment = 0;
	//static uint8_t rotate_7seg = 0;
	switch(mode){
		case 2:
			segsum(alarm_time);
    1188:	80 91 44 01 	lds	r24, 0x0144
    118c:	90 91 45 01 	lds	r25, 0x0145
    1190:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0x00;
    1194:	10 92 80 01 	sts	0x0180, r1
			break;
    1198:	e2 cf       	rjmp	.-60     	; 0x115e <display_update+0x1c>
		case 3:
			segsum(OCR3A);
    119a:	80 91 86 00 	lds	r24, 0x0086
    119e:	90 91 87 00 	lds	r25, 0x0087
    11a2:	0e 94 cc 05 	call	0xb98	; 0xb98 <segsum>
			segment_data[2] = 0xFF; //decimal
    11a6:	8f ef       	ldi	r24, 0xFF	; 255
    11a8:	80 93 80 01 	sts	0x0180, r24
			break;
    11ac:	d8 cf       	rjmp	.-80     	; 0x115e <display_update+0x1c>

000011ae <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
	switch(mode){
    11ae:	80 91 60 01 	lds	r24, 0x0160
    11b2:	81 30       	cpi	r24, 0x01	; 1
    11b4:	59 f0       	breq	.+22     	; 0x11cc <right_inc+0x1e>
    11b6:	82 30       	cpi	r24, 0x02	; 2
    11b8:	41 f4       	brne	.+16     	; 0x11ca <right_inc+0x1c>
				minute = 0;	    
			}     
			second++;
			break;
		case 2: 
			alarm_minute++;
    11ba:	80 91 5c 01 	lds	r24, 0x015C
    11be:	8f 5f       	subi	r24, 0xFF	; 255
			if(alarm_minute >= 60){
    11c0:	8c 33       	cpi	r24, 0x3C	; 60
    11c2:	88 f0       	brcs	.+34     	; 0x11e6 <right_inc+0x38>
				alarm_minute = 0;	
    11c4:	10 92 5c 01 	sts	0x015C, r1
    11c8:	08 95       	ret
    11ca:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    11cc:	80 91 5e 01 	lds	r24, 0x015E
    11d0:	8f 5f       	subi	r24, 0xFF	; 255
			if(minute >= 60){
    11d2:	8c 33       	cpi	r24, 0x3C	; 60
    11d4:	58 f0       	brcs	.+22     	; 0x11ec <right_inc+0x3e>
				minute = 0;	    
    11d6:	10 92 5e 01 	sts	0x015E, r1
			}     
			second++;
    11da:	80 91 5f 01 	lds	r24, 0x015F
    11de:	8f 5f       	subi	r24, 0xFF	; 255
    11e0:	80 93 5f 01 	sts	0x015F, r24
			break;
    11e4:	08 95       	ret
		case 2: 
			alarm_minute++;
    11e6:	80 93 5c 01 	sts	0x015C, r24
    11ea:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    11ec:	80 93 5e 01 	sts	0x015E, r24
			if(minute >= 60){
				minute = 0;	    
			}     
			second++;
    11f0:	80 91 5f 01 	lds	r24, 0x015F
    11f4:	8f 5f       	subi	r24, 0xFF	; 255
    11f6:	80 93 5f 01 	sts	0x015F, r24
			break;
    11fa:	08 95       	ret

000011fc <right_dec>:
		default:
			break;             
	}
}
void right_dec(){
	switch(mode){
    11fc:	80 91 60 01 	lds	r24, 0x0160
    1200:	81 30       	cpi	r24, 0x01	; 1
    1202:	71 f0       	breq	.+28     	; 0x1220 <right_dec+0x24>
    1204:	82 30       	cpi	r24, 0x02	; 2
    1206:	59 f4       	brne	.+22     	; 0x121e <right_dec+0x22>
			if(minute >= 240){
				minute = 59;	    
			}   
			break;
		case 2: 
			alarm_minute--;
    1208:	80 91 5c 01 	lds	r24, 0x015C
    120c:	81 50       	subi	r24, 0x01	; 1
    120e:	80 93 5c 01 	sts	0x015C, r24
			if(alarm_minute >= 240){
    1212:	80 3f       	cpi	r24, 0xF0	; 240
    1214:	18 f0       	brcs	.+6      	; 0x121c <right_dec+0x20>
				alarm_minute = 59;	
    1216:	8b e3       	ldi	r24, 0x3B	; 59
    1218:	80 93 5c 01 	sts	0x015C, r24
    121c:	08 95       	ret
    121e:	08 95       	ret
void right_dec(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute--;
    1220:	80 91 5e 01 	lds	r24, 0x015E
    1224:	81 50       	subi	r24, 0x01	; 1
    1226:	80 93 5e 01 	sts	0x015E, r24
			if(minute >= 240){
    122a:	80 3f       	cpi	r24, 0xF0	; 240
    122c:	b8 f3       	brcs	.-18     	; 0x121c <right_dec+0x20>
				minute = 59;	    
    122e:	8b e3       	ldi	r24, 0x3B	; 59
    1230:	80 93 5e 01 	sts	0x015E, r24
    1234:	08 95       	ret

00001236 <decode_spi_right_knob>:
	previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
    1236:	cf 93       	push	r28
    1238:	df 93       	push	r29
    123a:	1f 92       	push	r1
    123c:	cd b7       	in	r28, 0x3d	; 61
    123e:	de b7       	in	r29, 0x3e	; 62
	uint8_t sw_index = 0;
	static uint8_t acount2 = 0;
	static uint8_t previous_encoder2 = 0;
	uint8_t direction = 0;
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    1240:	83 70       	andi	r24, 0x03	; 3
	sw_index = (previous_encoder2 << 2) | encoder2;
    1242:	e0 91 51 01 	lds	r30, 0x0151
    1246:	ee 0f       	add	r30, r30
    1248:	ee 0f       	add	r30, r30
    124a:	e8 2b       	or	r30, r24
	direction = sw_table[sw_index];
    124c:	f0 e0       	ldi	r31, 0x00	; 0
    124e:	ed 5f       	subi	r30, 0xFD	; 253
    1250:	fe 4f       	sbci	r31, 0xFE	; 254
    1252:	90 81       	ld	r25, Z
	//value = modeA;
	if(direction == CW){
    1254:	91 30       	cpi	r25, 0x01	; 1
    1256:	09 f1       	breq	.+66     	; 0x129a <decode_spi_right_knob+0x64>
		acount2++;
	}	
	if(direction == CCW){
    1258:	92 30       	cpi	r25, 0x02	; 2
    125a:	41 f0       	breq	.+16     	; 0x126c <decode_spi_right_knob+0x36>
		acount2--;
	}
	if(encoder2 == 3){
    125c:	83 30       	cpi	r24, 0x03	; 3
    125e:	69 f0       	breq	.+26     	; 0x127a <decode_spi_right_knob+0x44>
			right_dec();
		}
		//update_number();
		acount2 = 0;
	}
	previous_encoder2 = encoder2;
    1260:	80 93 51 01 	sts	0x0151, r24
}
    1264:	0f 90       	pop	r0
    1266:	df 91       	pop	r29
    1268:	cf 91       	pop	r28
    126a:	08 95       	ret
	//value = modeA;
	if(direction == CW){
		acount2++;
	}	
	if(direction == CCW){
		acount2--;
    126c:	90 91 50 01 	lds	r25, 0x0150
    1270:	91 50       	subi	r25, 0x01	; 1
    1272:	90 93 50 01 	sts	0x0150, r25
	}
	if(encoder2 == 3){
    1276:	83 30       	cpi	r24, 0x03	; 3
    1278:	99 f7       	brne	.-26     	; 0x1260 <decode_spi_right_knob+0x2a>
		if((acount2 > 1) && (acount2 < 10)){
    127a:	90 91 50 01 	lds	r25, 0x0150
    127e:	2e ef       	ldi	r18, 0xFE	; 254
    1280:	29 0f       	add	r18, r25
    1282:	28 30       	cpi	r18, 0x08	; 8
    1284:	b8 f0       	brcs	.+46     	; 0x12b4 <decode_spi_right_knob+0x7e>
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
    1286:	91 3f       	cpi	r25, 0xF1	; 241
    1288:	70 f4       	brcc	.+28     	; 0x12a6 <decode_spi_right_knob+0x70>
			right_dec();
		}
		//update_number();
		acount2 = 0;
    128a:	10 92 50 01 	sts	0x0150, r1
	}
	previous_encoder2 = encoder2;
    128e:	80 93 51 01 	sts	0x0151, r24
}
    1292:	0f 90       	pop	r0
    1294:	df 91       	pop	r29
    1296:	cf 91       	pop	r28
    1298:	08 95       	ret
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
	sw_index = (previous_encoder2 << 2) | encoder2;
	direction = sw_table[sw_index];
	//value = modeA;
	if(direction == CW){
		acount2++;
    129a:	90 91 50 01 	lds	r25, 0x0150
    129e:	9f 5f       	subi	r25, 0xFF	; 255
    12a0:	90 93 50 01 	sts	0x0150, r25
    12a4:	db cf       	rjmp	.-74     	; 0x125c <decode_spi_right_knob+0x26>
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
    12a6:	89 83       	std	Y+1, r24	; 0x01
    12a8:	0e 94 fe 08 	call	0x11fc	; 0x11fc <right_dec>
    12ac:	89 81       	ldd	r24, Y+1	; 0x01
		}
		//update_number();
		acount2 = 0;
    12ae:	10 92 50 01 	sts	0x0150, r1
    12b2:	ed cf       	rjmp	.-38     	; 0x128e <decode_spi_right_knob+0x58>
	if(direction == CCW){
		acount2--;
	}
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
    12b4:	89 83       	std	Y+1, r24	; 0x01
    12b6:	0e 94 d7 08 	call	0x11ae	; 0x11ae <right_inc>
    12ba:	89 81       	ldd	r24, Y+1	; 0x01
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
		}
		//update_number();
		acount2 = 0;
    12bc:	10 92 50 01 	sts	0x0150, r1
    12c0:	e6 cf       	rjmp	.-52     	; 0x128e <decode_spi_right_knob+0x58>

000012c2 <left_inc>:
			break;
	}

}
void left_inc(){
	switch(mode){
    12c2:	80 91 60 01 	lds	r24, 0x0160
    12c6:	82 30       	cpi	r24, 0x02	; 2
    12c8:	21 f1       	breq	.+72     	; 0x1312 <left_inc+0x50>
    12ca:	b8 f0       	brcs	.+46     	; 0x12fa <left_inc+0x38>
    12cc:	83 30       	cpi	r24, 0x03	; 3
    12ce:	51 f0       	breq	.+20     	; 0x12e4 <left_inc+0x22>
    12d0:	84 30       	cpi	r24, 0x04	; 4
    12d2:	71 f5       	brne	.+92     	; 0x1330 <left_inc+0x6e>
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	90 91 36 01 	lds	r25, 0x0136
    12da:	91 11       	cpse	r25, r1
    12dc:	24 c0       	rjmp	.+72     	; 0x1326 <left_inc+0x64>
    12de:	80 93 36 01 	sts	0x0136, r24
    12e2:	08 95       	ret
			if(alarm_hour >= 24){
				alarm_hour = 0;
			}
			break;
		case 3:
			volume++;
    12e4:	80 91 00 01 	lds	r24, 0x0100
    12e8:	8f 5f       	subi	r24, 0xFF	; 255
    12ea:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	90 93 87 00 	sts	0x0087, r25
    12f4:	80 93 86 00 	sts	0x0086, r24
			break;
    12f8:	08 95       	ret
			break;
	}

}
void left_inc(){
	switch(mode){
    12fa:	81 30       	cpi	r24, 0x01	; 1
    12fc:	c1 f4       	brne	.+48     	; 0x132e <left_inc+0x6c>
		case 0: 
			break;
		case 1:
			hour++;
    12fe:	80 91 5d 01 	lds	r24, 0x015D
    1302:	8f 5f       	subi	r24, 0xFF	; 255
    1304:	80 93 5d 01 	sts	0x015D, r24
			if(hour >= 24){
    1308:	88 31       	cpi	r24, 0x18	; 24
    130a:	58 f3       	brcs	.-42     	; 0x12e2 <left_inc+0x20>
				hour = 0;	    
    130c:	10 92 5d 01 	sts	0x015D, r1
    1310:	08 95       	ret
			}   
			break;
		case 2: 
			alarm_hour++;
    1312:	80 91 5b 01 	lds	r24, 0x015B
    1316:	8f 5f       	subi	r24, 0xFF	; 255
    1318:	80 93 5b 01 	sts	0x015B, r24
			if(alarm_hour >= 24){
    131c:	88 31       	cpi	r24, 0x18	; 24
    131e:	08 f3       	brcs	.-62     	; 0x12e2 <left_inc+0x20>
				alarm_hour = 0;
    1320:	10 92 5b 01 	sts	0x015B, r1
    1324:	08 95       	ret
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    1326:	80 e0       	ldi	r24, 0x00	; 0
    1328:	80 93 36 01 	sts	0x0136, r24
    132c:	da cf       	rjmp	.-76     	; 0x12e2 <left_inc+0x20>
    132e:	08 95       	ret
    1330:	08 95       	ret

00001332 <left_dec>:
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    1332:	80 91 60 01 	lds	r24, 0x0160
    1336:	82 30       	cpi	r24, 0x02	; 2
    1338:	29 f1       	breq	.+74     	; 0x1384 <left_dec+0x52>
    133a:	b8 f0       	brcs	.+46     	; 0x136a <left_dec+0x38>
    133c:	83 30       	cpi	r24, 0x03	; 3
    133e:	51 f0       	breq	.+20     	; 0x1354 <left_dec+0x22>
    1340:	84 30       	cpi	r24, 0x04	; 4
    1342:	81 f5       	brne	.+96     	; 0x13a4 <left_dec+0x72>
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    1344:	81 e0       	ldi	r24, 0x01	; 1
    1346:	90 91 36 01 	lds	r25, 0x0136
    134a:	91 11       	cpse	r25, r1
    134c:	26 c0       	rjmp	.+76     	; 0x139a <left_dec+0x68>
    134e:	80 93 36 01 	sts	0x0136, r24
    1352:	08 95       	ret
			if(alarm_hour >= 240){
				alarm_hour = 23;
			}
			break;
		case 3:
			volume--;
    1354:	80 91 00 01 	lds	r24, 0x0100
    1358:	81 50       	subi	r24, 0x01	; 1
    135a:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	90 93 87 00 	sts	0x0087, r25
    1364:	80 93 86 00 	sts	0x0086, r24
			break;
    1368:	08 95       	ret
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    136a:	81 30       	cpi	r24, 0x01	; 1
    136c:	d1 f4       	brne	.+52     	; 0x13a2 <left_dec+0x70>
		case 0: 
			break;
		case 1:
			hour--;    
    136e:	80 91 5d 01 	lds	r24, 0x015D
    1372:	81 50       	subi	r24, 0x01	; 1
    1374:	80 93 5d 01 	sts	0x015D, r24
			if(hour >= 240){
    1378:	80 3f       	cpi	r24, 0xF0	; 240
    137a:	58 f3       	brcs	.-42     	; 0x1352 <left_dec+0x20>
				hour = 23;	    
    137c:	87 e1       	ldi	r24, 0x17	; 23
    137e:	80 93 5d 01 	sts	0x015D, r24
    1382:	08 95       	ret
			}   
			break;
		case 2:
			alarm_hour--;
    1384:	80 91 5b 01 	lds	r24, 0x015B
    1388:	81 50       	subi	r24, 0x01	; 1
    138a:	80 93 5b 01 	sts	0x015B, r24
			if(alarm_hour >= 240){
    138e:	80 3f       	cpi	r24, 0xF0	; 240
    1390:	00 f3       	brcs	.-64     	; 0x1352 <left_dec+0x20>
				alarm_hour = 23;
    1392:	87 e1       	ldi	r24, 0x17	; 23
    1394:	80 93 5b 01 	sts	0x015B, r24
    1398:	08 95       	ret
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	80 93 36 01 	sts	0x0136, r24
    13a0:	d8 cf       	rjmp	.-80     	; 0x1352 <left_dec+0x20>
    13a2:	08 95       	ret
    13a4:	08 95       	ret

000013a6 <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
	uint8_t sw_index = 0;
	//Counter for preventing unneccessary reset    
	static uint8_t acount1 = 0;
	static uint8_t previous_encoder1 = 0; //Initialize previous    
	uint8_t direction = 0;                    //Direction variable
	encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
    13aa:	8c 70       	andi	r24, 0x0C	; 12
    13ac:	c8 2f       	mov	r28, r24
    13ae:	d0 e0       	ldi	r29, 0x00	; 0
    13b0:	d5 95       	asr	r29
    13b2:	c7 95       	ror	r28
    13b4:	d5 95       	asr	r29
    13b6:	c7 95       	ror	r28
    13b8:	9c 2f       	mov	r25, r28
	sw_index = (previous_encoder1 << 2) | encoder1; 
    13ba:	e0 91 53 01 	lds	r30, 0x0153
    13be:	ee 0f       	add	r30, r30
    13c0:	ee 0f       	add	r30, r30
    13c2:	ec 2b       	or	r30, r28
	/*shift previous to the left use it as an index Since
	  we know the pattern of the knob when it is turning
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
    13c4:	f0 e0       	ldi	r31, 0x00	; 0
    13c6:	ed 5f       	subi	r30, 0xFD	; 253
    13c8:	fe 4f       	sbci	r31, 0xFE	; 254
    13ca:	80 81       	ld	r24, Z
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
    13cc:	81 30       	cpi	r24, 0x01	; 1
    13ce:	f9 f0       	breq	.+62     	; 0x140e <decode_spi_left_knob+0x68>
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
    13d0:	82 30       	cpi	r24, 0x02	; 2
    13d2:	39 f0       	breq	.+14     	; 0x13e2 <decode_spi_left_knob+0x3c>
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    13d4:	93 30       	cpi	r25, 0x03	; 3
    13d6:	61 f0       	breq	.+24     	; 0x13f0 <decode_spi_left_knob+0x4a>
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
	}
	previous_encoder1 = encoder1;
    13d8:	c0 93 53 01 	sts	0x0153, r28
}
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	08 95       	ret
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
    13e2:	80 91 52 01 	lds	r24, 0x0152
    13e6:	81 50       	subi	r24, 0x01	; 1
    13e8:	80 93 52 01 	sts	0x0152, r24
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    13ec:	93 30       	cpi	r25, 0x03	; 3
    13ee:	a1 f7       	brne	.-24     	; 0x13d8 <decode_spi_left_knob+0x32>
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
    13f0:	80 91 52 01 	lds	r24, 0x0152
    13f4:	9e ef       	ldi	r25, 0xFE	; 254
    13f6:	98 0f       	add	r25, r24
    13f8:	98 30       	cpi	r25, 0x08	; 8
    13fa:	a0 f0       	brcs	.+40     	; 0x1424 <decode_spi_left_knob+0x7e>
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
    13fc:	81 3f       	cpi	r24, 0xF1	; 241
    13fe:	68 f4       	brcc	.+26     	; 0x141a <decode_spi_left_knob+0x74>
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    1400:	10 92 52 01 	sts	0x0152, r1
	}
	previous_encoder1 = encoder1;
    1404:	c0 93 53 01 	sts	0x0153, r28
}
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	08 95       	ret
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
    140e:	80 91 52 01 	lds	r24, 0x0152
    1412:	8f 5f       	subi	r24, 0xFF	; 255
    1414:	80 93 52 01 	sts	0x0152, r24
    1418:	dd cf       	rjmp	.-70     	; 0x13d4 <decode_spi_left_knob+0x2e>
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
    141a:	0e 94 99 09 	call	0x1332	; 0x1332 <left_dec>
		}
		acount1 = 0;                     //Reset counter
    141e:	10 92 52 01 	sts	0x0152, r1
    1422:	f0 cf       	rjmp	.-32     	; 0x1404 <decode_spi_left_knob+0x5e>
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
    1424:	0e 94 61 09 	call	0x12c2	; 0x12c2 <left_inc>
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    1428:	10 92 52 01 	sts	0x0152, r1
    142c:	eb cf       	rjmp	.-42     	; 0x1404 <decode_spi_left_knob+0x5e>

0000142e <check_knobs>:
	__asm__ __volatile__ ("nop");
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
	// Return incoming data from SPDR
	return(SPDR);  
}
void check_knobs(void){
    142e:	cf 93       	push	r28
	static uint8_t cnt = 0;
	static uint8_t encoder;
	cnt++;
    1430:	c0 91 55 01 	lds	r28, 0x0155
    1434:	cf 5f       	subi	r28, 0xFF	; 255
    1436:	c0 93 55 01 	sts	0x0155, r28
	encoder = SPI_Receive();
    143a:	0e 94 d5 07 	call	0xfaa	; 0xfaa <SPI_Receive>
    143e:	80 93 54 01 	sts	0x0154, r24
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
    1442:	c0 ff       	sbrs	r28, 0
    1444:	03 c0       	rjmp	.+6      	; 0x144c <check_knobs+0x1e>
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
	}
}
    1446:	cf 91       	pop	r28
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
    1448:	0c 94 1b 09 	jmp	0x1236	; 0x1236 <decode_spi_right_knob>
	}
}
    144c:	cf 91       	pop	r28
	static uint8_t encoder;
	cnt++;
	encoder = SPI_Receive();
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
    144e:	0c 94 d3 09 	jmp	0x13a6	; 0x13a6 <decode_spi_left_knob>

00001452 <__vector_10>:
		notes++;               //move on to the next note
		play_song(song, notes);//and play it
	}
}

ISR(TIMER2_OVF_vect){
    1452:	1f 92       	push	r1
    1454:	0f 92       	push	r0
    1456:	0f b6       	in	r0, 0x3f	; 63
    1458:	0f 92       	push	r0
    145a:	11 24       	eor	r1, r1
    145c:	0b b6       	in	r0, 0x3b	; 59
    145e:	0f 92       	push	r0
    1460:	2f 93       	push	r18
    1462:	3f 93       	push	r19
    1464:	4f 93       	push	r20
    1466:	5f 93       	push	r21
    1468:	6f 93       	push	r22
    146a:	7f 93       	push	r23
    146c:	8f 93       	push	r24
    146e:	9f 93       	push	r25
    1470:	af 93       	push	r26
    1472:	bf 93       	push	r27
    1474:	cf 93       	push	r28
    1476:	ef 93       	push	r30
    1478:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
    147a:	c0 91 56 01 	lds	r28, 0x0156
    147e:	cf 5f       	subi	r28, 0xFF	; 255
    1480:	c0 93 56 01 	sts	0x0156, r28
	//display_update();

	if(count%64 == 0){
    1484:	8c 2f       	mov	r24, r28
    1486:	8f 73       	andi	r24, 0x3F	; 63
    1488:	c1 f0       	breq	.+48     	; 0x14ba <__vector_10+0x68>
		button_routine();
	}

	switch(count%8){
    148a:	c7 70       	andi	r28, 0x07	; 7
    148c:	11 f4       	brne	.+4      	; 0x1492 <__vector_10+0x40>
		case 0:
			check_knobs();
    148e:	0e 94 17 0a 	call	0x142e	; 0x142e <check_knobs>
		case 1:
			break;
		default:
			break;
	}    
} 
    1492:	ff 91       	pop	r31
    1494:	ef 91       	pop	r30
    1496:	cf 91       	pop	r28
    1498:	bf 91       	pop	r27
    149a:	af 91       	pop	r26
    149c:	9f 91       	pop	r25
    149e:	8f 91       	pop	r24
    14a0:	7f 91       	pop	r23
    14a2:	6f 91       	pop	r22
    14a4:	5f 91       	pop	r21
    14a6:	4f 91       	pop	r20
    14a8:	3f 91       	pop	r19
    14aa:	2f 91       	pop	r18
    14ac:	0f 90       	pop	r0
    14ae:	0b be       	out	0x3b, r0	; 59
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
    14b4:	0f 90       	pop	r0
    14b6:	1f 90       	pop	r1
    14b8:	18 95       	reti
	static uint8_t count = 0;
	count++;
	//display_update();

	if(count%64 == 0){
		button_routine();
    14ba:	0e 94 fe 07 	call	0xffc	; 0xffc <button_routine>
    14be:	e5 cf       	rjmp	.-54     	; 0x148a <__vector_10+0x38>

000014c0 <get_remote_temp>:

//TOD
// Pull temp functions from temp directory
// Display temp

uint16_t get_remote_temp(){
    14c0:	cf 93       	push	r28
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(temp_mode){
    14c2:	80 91 36 01 	lds	r24, 0x0136
    14c6:	81 11       	cpse	r24, r1
    14c8:	0f c0       	rjmp	.+30     	; 0x14e8 <get_remote_temp+0x28>
		uart_putc(CELCIUS); //Ask atmega48 for celcius
	}
	else{
		uart_putc(FARENHEIT); //Ask for F
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	0e 94 04 0c 	call	0x1808	; 0x1808 <uart_putc>
	}

	lo = uart_getc(); //Get low byte
    14d0:	0e 94 38 0c 	call	0x1870	; 0x1870 <uart_getc>
    14d4:	c8 2f       	mov	r28, r24
	hi = uart_getc(); //Get high byte
    14d6:	0e 94 38 0c 	call	0x1870	; 0x1870 <uart_getc>

	tmp = (hi<<8) | lo; //Concatinate
    14da:	2c 2f       	mov	r18, r28
    14dc:	30 e0       	ldi	r19, 0x00	; 0
	return tmp;	   //return tempearture
}
    14de:	a9 01       	movw	r20, r18
    14e0:	58 2b       	or	r21, r24
    14e2:	ca 01       	movw	r24, r20
    14e4:	cf 91       	pop	r28
    14e6:	08 95       	ret
uint16_t get_remote_temp(){
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(temp_mode){
		uart_putc(CELCIUS); //Ask atmega48 for celcius
    14e8:	82 e0       	ldi	r24, 0x02	; 2
    14ea:	0e 94 04 0c 	call	0x1808	; 0x1808 <uart_putc>
    14ee:	f0 cf       	rjmp	.-32     	; 0x14d0 <get_remote_temp+0x10>

000014f0 <generate_temp_str>:
	tmp = (hi<<8) | lo; //Concatinate
	return tmp;	   //return tempearture
}


void generate_temp_str(){
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	00 d0       	rcall	.+0      	; 0x14f6 <generate_temp_str+0x6>
    14f6:	1f 92       	push	r1
    14f8:	cd b7       	in	r28, 0x3d	; 61
    14fa:	de b7       	in	r29, 0x3e	; 62
	static uint16_t remote_temp, local_temp;
	char local_buf[3];
	char remote_buf[3];
	if(!reset_temp){
    14fc:	80 91 49 01 	lds	r24, 0x0149
    1500:	81 11       	cpse	r24, r1
    1502:	06 c0       	rjmp	.+12     	; 0x1510 <generate_temp_str+0x20>

	itoa(local_temp,local_buf, 10);
	//loc_temp_str[10] = local_buf[2];
	loc_temp_str[11] = local_buf[1];
	loc_temp_str[12] = local_buf[0];
}
    1504:	0f 90       	pop	r0
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	df 91       	pop	r29
    150c:	cf 91       	pop	r28
    150e:	08 95       	ret
	if(!reset_temp){
		return;
	}
	//TODO
	//remote_temp = get_remote_temp();
	local_temp = get_local_temp(1);
    1510:	81 e0       	ldi	r24, 0x01	; 1
    1512:	0e 94 67 0c 	call	0x18ce	; 0x18ce <get_local_temp>
    1516:	90 93 4f 01 	sts	0x014F, r25
    151a:	80 93 4e 01 	sts	0x014E, r24
	reset_temp = 0;
    151e:	10 92 49 01 	sts	0x0149, r1
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1522:	4a e0       	ldi	r20, 0x0A	; 10
    1524:	be 01       	movw	r22, r28
    1526:	6f 5f       	subi	r22, 0xFF	; 255
    1528:	7f 4f       	sbci	r23, 0xFF	; 255
    152a:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <__itoa_ncheck>

	itoa(local_temp,local_buf, 10);
	//loc_temp_str[10] = local_buf[2];
	loc_temp_str[11] = local_buf[1];
    152e:	e0 91 70 01 	lds	r30, 0x0170
    1532:	f0 91 71 01 	lds	r31, 0x0171
    1536:	8a 81       	ldd	r24, Y+2	; 0x02
    1538:	83 87       	std	Z+11, r24	; 0x0b
	loc_temp_str[12] = local_buf[0];
    153a:	89 81       	ldd	r24, Y+1	; 0x01
    153c:	84 87       	std	Z+12, r24	; 0x0c
}
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0
    1542:	0f 90       	pop	r0
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	08 95       	ret

0000154a <update_temp>:
itoa(temperature, buff, 10);
LCD_PutStr("buff");
}
 */

void update_temp(){
    154a:	08 95       	ret

0000154c <show_temperature>:

}
void show_temperature(){
	static uint8_t counter = 0;
	//If temp string is not already displayed, diisplay it
	if(!temp_is_up){
    154c:	80 91 48 01 	lds	r24, 0x0148
    1550:	81 11       	cpse	r24, r1
    1552:	0b c0       	rjmp	.+22     	; 0x156a <show_temperature+0x1e>
		if(counter <= 15){
    1554:	80 91 4d 01 	lds	r24, 0x014D
    1558:	80 31       	cpi	r24, 0x10	; 16
    155a:	40 f0       	brcs	.+16     	; 0x156c <show_temperature+0x20>
				//_delay_ms(1);
			}
			counter++;
			//return;
		}
		else if (counter >=16 && counter <= 31){
    155c:	90 ef       	ldi	r25, 0xF0	; 240
    155e:	98 0f       	add	r25, r24
    1560:	90 31       	cpi	r25, 0x10	; 16
    1562:	b8 f0       	brcs	.+46     	; 0x1592 <show_temperature+0x46>
			counter++;
			//return;
		}
		
		if(counter >= 32){
			temp_is_up = 1;
    1564:	81 e0       	ldi	r24, 0x01	; 1
    1566:	80 93 48 01 	sts	0x0148, r24
    156a:	08 95       	ret
void show_temperature(){
	static uint8_t counter = 0;
	//If temp string is not already displayed, diisplay it
	if(!temp_is_up){
		if(counter <= 15){
			char2lcd(rem_temp_str[counter]);
    156c:	e0 91 77 01 	lds	r30, 0x0177
    1570:	f0 91 78 01 	lds	r31, 0x0178
    1574:	e8 0f       	add	r30, r24
    1576:	f1 1d       	adc	r31, r1
    1578:	80 81       	ld	r24, Z
    157a:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <char2lcd>
			if(counter == 15){
    157e:	80 91 4d 01 	lds	r24, 0x014D
    1582:	8f 30       	cpi	r24, 0x0F	; 15
    1584:	99 f0       	breq	.+38     	; 0x15ac <show_temperature+0x60>
			//return;
		}
		else if (counter >=16 && counter <= 31){
			//minute++;
			char2lcd(loc_temp_str[counter-16]);
			counter++;
    1586:	8f 5f       	subi	r24, 0xFF	; 255
    1588:	80 93 4d 01 	sts	0x014D, r24
			//return;
		}
		
		if(counter >= 32){
    158c:	80 32       	cpi	r24, 0x20	; 32
    158e:	50 f7       	brcc	.-44     	; 0x1564 <show_temperature+0x18>
    1590:	08 95       	ret
			counter++;
			//return;
		}
		else if (counter >=16 && counter <= 31){
			//minute++;
			char2lcd(loc_temp_str[counter-16]);
    1592:	e0 91 70 01 	lds	r30, 0x0170
    1596:	f0 91 71 01 	lds	r31, 0x0171
    159a:	e8 0f       	add	r30, r24
    159c:	f1 1d       	adc	r31, r1
    159e:	70 97       	sbiw	r30, 0x10	; 16
    15a0:	80 81       	ld	r24, Z
    15a2:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <char2lcd>
			counter++;
    15a6:	80 91 4d 01 	lds	r24, 0x014D
    15aa:	ed cf       	rjmp	.-38     	; 0x1586 <show_temperature+0x3a>
	//If temp string is not already displayed, diisplay it
	if(!temp_is_up){
		if(counter <= 15){
			char2lcd(rem_temp_str[counter]);
			if(counter == 15){
				home_line2();
    15ac:	0e 94 c8 0c 	call	0x1990	; 0x1990 <home_line2>
    15b0:	80 91 4d 01 	lds	r24, 0x014D
    15b4:	e8 cf       	rjmp	.-48     	; 0x1586 <show_temperature+0x3a>

000015b6 <LCD_Display>:
	}
}
void LCD_Display(){
	static uint8_t counter = 0;

	if(counter <= 15){
    15b6:	80 91 4c 01 	lds	r24, 0x014C
    15ba:	80 31       	cpi	r24, 0x10	; 16
    15bc:	50 f0       	brcs	.+20     	; 0x15d2 <LCD_Display+0x1c>
			//_delay_ms(1);
		}
		counter++;
		//	return;
	}
	else if (counter >=16 && counter <= 31){
    15be:	90 ef       	ldi	r25, 0xF0	; 240
    15c0:	98 0f       	add	r25, r24
    15c2:	90 31       	cpi	r25, 0x10	; 16
    15c4:	e8 f0       	brcs	.+58     	; 0x1600 <LCD_Display+0x4a>
		//minute++;
		char2lcd(loc_temp_str[counter-16]);
		counter++;
		//return;
	}
	else if(counter >= 75){ 
    15c6:	8b 34       	cpi	r24, 0x4B	; 75
    15c8:	b0 f4       	brcc	.+44     	; 0x15f6 <LCD_Display+0x40>
	}
	else if(counter >=100){
		counter = 0;
	}
	else{
		counter++;
    15ca:	8f 5f       	subi	r24, 0xFF	; 255
    15cc:	80 93 4c 01 	sts	0x014C, r24
    15d0:	08 95       	ret
}
void LCD_Display(){
	static uint8_t counter = 0;

	if(counter <= 15){
		char2lcd(rem_temp_str[counter]);
    15d2:	e0 91 77 01 	lds	r30, 0x0177
    15d6:	f0 91 78 01 	lds	r31, 0x0178
    15da:	e8 0f       	add	r30, r24
    15dc:	f1 1d       	adc	r31, r1
    15de:	80 81       	ld	r24, Z
    15e0:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <char2lcd>
		if(counter == 15){
    15e4:	80 91 4c 01 	lds	r24, 0x014C
    15e8:	8f 30       	cpi	r24, 0x0F	; 15
    15ea:	79 f7       	brne	.-34     	; 0x15ca <LCD_Display+0x14>
			home_line2();
    15ec:	0e 94 c8 0c 	call	0x1990	; 0x1990 <home_line2>
    15f0:	80 91 4c 01 	lds	r24, 0x014C
    15f4:	ea cf       	rjmp	.-44     	; 0x15ca <LCD_Display+0x14>
		//counter = 0;
		//loc_temp_str = "";
		//rem_temp_str = "";
		//loc_temp_str = "Local  temp:   C";
		//rem_temp_str = "Remote temp:   C";
		counter++;
    15f6:	8f 5f       	subi	r24, 0xFF	; 255
    15f8:	80 93 4c 01 	sts	0x014C, r24
		cursor_home();
    15fc:	0c 94 b6 0c 	jmp	0x196c	; 0x196c <cursor_home>
		counter++;
		//	return;
	}
	else if (counter >=16 && counter <= 31){
		//minute++;
		char2lcd(loc_temp_str[counter-16]);
    1600:	e0 91 70 01 	lds	r30, 0x0170
    1604:	f0 91 71 01 	lds	r31, 0x0171
    1608:	e8 0f       	add	r30, r24
    160a:	f1 1d       	adc	r31, r1
    160c:	70 97       	sbiw	r30, 0x10	; 16
    160e:	80 81       	ld	r24, Z
    1610:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <char2lcd>
		counter++;
    1614:	80 91 4c 01 	lds	r24, 0x014C
    1618:	8f 5f       	subi	r24, 0xFF	; 255
    161a:	80 93 4c 01 	sts	0x014C, r24
    161e:	08 95       	ret

00001620 <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1620:	83 b7       	in	r24, 0x33	; 51
    1622:	81 60       	ori	r24, 0x01	; 1
    1624:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    1626:	80 b7       	in	r24, 0x30	; 48
    1628:	88 60       	ori	r24, 0x08	; 8
    162a:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    162c:	85 b5       	in	r24, 0x25	; 37
    162e:	8a 67       	ori	r24, 0x7A	; 122
    1630:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1632:	87 b7       	in	r24, 0x37	; 55
    1634:	81 64       	ori	r24, 0x41	; 65
    1636:	87 bf       	out	0x37, r24	; 55
    1638:	08 95       	ret

0000163a <ADC_init>:
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    163a:	e1 e6       	ldi	r30, 0x61	; 97
    163c:	f0 e0       	ldi	r31, 0x00	; 0
    163e:	80 81       	ld	r24, Z
    1640:	80 83       	st	Z, r24
	PORTF = 0x00;
    1642:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1646:	87 b1       	in	r24, 0x07	; 7
    1648:	80 66       	ori	r24, 0x60	; 96
    164a:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    164c:	86 b1       	in	r24, 0x06	; 6
    164e:	8f 6e       	ori	r24, 0xEF	; 239
    1650:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    1652:	8f ef       	ldi	r24, 0xFF	; 255
    1654:	83 bd       	out	0x23, r24	; 35
    1656:	08 95       	ret

00001658 <volume_control_init>:
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1658:	81 e8       	ldi	r24, 0x81	; 129
    165a:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    165e:	89 e0       	ldi	r24, 0x09	; 9
    1660:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    1664:	80 91 00 01 	lds	r24, 0x0100
    1668:	90 e0       	ldi	r25, 0x00	; 0
    166a:	90 93 87 00 	sts	0x0087, r25
    166e:	80 93 86 00 	sts	0x0086, r24
    1672:	08 95       	ret

00001674 <initialize_string>:
}

void initialize_string(){
	loc_temp_str = 0;
	rem_temp_str = 0;
	loc_temp_str = "Local  temp:   C";
    1674:	83 e1       	ldi	r24, 0x13	; 19
    1676:	91 e0       	ldi	r25, 0x01	; 1
    1678:	90 93 71 01 	sts	0x0171, r25
    167c:	80 93 70 01 	sts	0x0170, r24
	rem_temp_str = "Remote temp:   C";
    1680:	84 e2       	ldi	r24, 0x24	; 36
    1682:	91 e0       	ldi	r25, 0x01	; 1
    1684:	90 93 78 01 	sts	0x0178, r25
    1688:	80 93 77 01 	sts	0x0177, r24
    168c:	08 95       	ret

0000168e <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    168e:	1f 92       	push	r1
    1690:	0f 92       	push	r0
    1692:	0f b6       	in	r0, 0x3f	; 63
    1694:	0f 92       	push	r0
    1696:	11 24       	eor	r1, r1
    1698:	0b b6       	in	r0, 0x3b	; 59
    169a:	0f 92       	push	r0
    169c:	2f 93       	push	r18
    169e:	3f 93       	push	r19
    16a0:	8f 93       	push	r24
    16a2:	9f 93       	push	r25
    16a4:	af 93       	push	r26
    16a6:	bf 93       	push	r27
    16a8:	ef 93       	push	r30
    16aa:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    16ac:	80 91 71 00 	lds	r24, 0x0071
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	fc 01       	movw	r30, r24
    16b4:	38 97       	sbiw	r30, 0x08	; 8
    16b6:	e1 35       	cpi	r30, 0x51	; 81
    16b8:	f1 05       	cpc	r31, r1
    16ba:	b0 f0       	brcs	.+44     	; 0x16e8 <__vector_33+0x5a>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    16bc:	80 91 71 00 	lds	r24, 0x0071
    16c0:	80 93 83 01 	sts	0x0183, r24
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    16c4:	84 e0       	ldi	r24, 0x04	; 4
    16c6:	80 93 74 00 	sts	0x0074, r24
  }//switch
}//TWI_isr
    16ca:	ff 91       	pop	r31
    16cc:	ef 91       	pop	r30
    16ce:	bf 91       	pop	r27
    16d0:	af 91       	pop	r26
    16d2:	9f 91       	pop	r25
    16d4:	8f 91       	pop	r24
    16d6:	3f 91       	pop	r19
    16d8:	2f 91       	pop	r18
    16da:	0f 90       	pop	r0
    16dc:	0b be       	out	0x3b, r0	; 59
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
    16e2:	0f 90       	pop	r0
    16e4:	1f 90       	pop	r1
    16e6:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    16e8:	e5 52       	subi	r30, 0x25	; 37
    16ea:	ff 4f       	sbci	r31, 0xFF	; 255
    16ec:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    16f0:	80 91 61 01 	lds	r24, 0x0161
    16f4:	e0 91 84 01 	lds	r30, 0x0184
    16f8:	f0 91 85 01 	lds	r31, 0x0185
    16fc:	e8 0f       	add	r30, r24
    16fe:	f1 1d       	adc	r31, r1
    1700:	80 91 73 00 	lds	r24, 0x0073
    1704:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    1706:	84 e9       	ldi	r24, 0x94	; 148
    1708:	80 93 74 00 	sts	0x0074, r24
      break;      
    170c:	de cf       	rjmp	.-68     	; 0x16ca <__vector_33+0x3c>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    170e:	80 91 86 01 	lds	r24, 0x0186
    1712:	80 93 73 00 	sts	0x0073, r24
      twi_buf_ptr = 0;      //initalize buffer pointer 
    1716:	10 92 61 01 	sts	0x0161, r1
      TWCR = TWCR_SEND;     //send SLA+RW
    171a:	85 e8       	ldi	r24, 0x85	; 133
    171c:	80 93 74 00 	sts	0x0074, r24
      break;
    1720:	d4 cf       	rjmp	.-88     	; 0x16ca <__vector_33+0x3c>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    1722:	80 91 61 01 	lds	r24, 0x0161
    1726:	90 91 87 01 	lds	r25, 0x0187
    172a:	89 17       	cp	r24, r25
    172c:	60 f7       	brcc	.-40     	; 0x1706 <__vector_33+0x78>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    172e:	e0 91 84 01 	lds	r30, 0x0184
    1732:	f0 91 85 01 	lds	r31, 0x0185
    1736:	91 e0       	ldi	r25, 0x01	; 1
    1738:	98 0f       	add	r25, r24
    173a:	90 93 61 01 	sts	0x0161, r25
    173e:	e8 0f       	add	r30, r24
    1740:	f1 1d       	adc	r31, r1
    1742:	80 81       	ld	r24, Z
    1744:	80 93 73 00 	sts	0x0073, r24
        TWCR = TWCR_SEND;               //send next byte 
    1748:	85 e8       	ldi	r24, 0x85	; 133
    174a:	80 93 74 00 	sts	0x0074, r24
    174e:	bd cf       	rjmp	.-134    	; 0x16ca <__vector_33+0x3c>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    1750:	85 ea       	ldi	r24, 0xA5	; 165
    1752:	80 93 74 00 	sts	0x0074, r24
      break;
    1756:	b9 cf       	rjmp	.-142    	; 0x16ca <__vector_33+0x3c>
    1758:	20 91 61 01 	lds	r18, 0x0161
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    175c:	80 91 87 01 	lds	r24, 0x0187
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	90 e0       	ldi	r25, 0x00	; 0
    1764:	01 97       	sbiw	r24, 0x01	; 1
    1766:	28 17       	cp	r18, r24
    1768:	39 07       	cpc	r19, r25
    176a:	dc f4       	brge	.+54     	; 0x17a2 <__vector_33+0x114>
    176c:	85 ec       	ldi	r24, 0xC5	; 197
    176e:	80 93 74 00 	sts	0x0074, r24
    1772:	ab cf       	rjmp	.-170    	; 0x16ca <__vector_33+0x3c>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    1774:	e0 91 84 01 	lds	r30, 0x0184
    1778:	f0 91 85 01 	lds	r31, 0x0185
    177c:	80 91 61 01 	lds	r24, 0x0161
    1780:	21 e0       	ldi	r18, 0x01	; 1
    1782:	28 0f       	add	r18, r24
    1784:	20 93 61 01 	sts	0x0161, r18
    1788:	e8 0f       	add	r30, r24
    178a:	f1 1d       	adc	r31, r1
    178c:	80 91 73 00 	lds	r24, 0x0073
    1790:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1792:	80 91 87 01 	lds	r24, 0x0187
    1796:	30 e0       	ldi	r19, 0x00	; 0
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	01 97       	sbiw	r24, 0x01	; 1
    179c:	28 17       	cp	r18, r24
    179e:	39 07       	cpc	r19, r25
    17a0:	2c f3       	brlt	.-54     	; 0x176c <__vector_33+0xde>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    17a2:	85 e8       	ldi	r24, 0x85	; 133
    17a4:	80 93 74 00 	sts	0x0074, r24
    17a8:	90 cf       	rjmp	.-224    	; 0x16ca <__vector_33+0x3c>

000017aa <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    17aa:	80 91 74 00 	lds	r24, 0x0074
}
    17ae:	81 70       	andi	r24, 0x01	; 1
    17b0:	08 95       	ret

000017b2 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    17b2:	90 91 74 00 	lds	r25, 0x0074
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    17b6:	90 fd       	sbrc	r25, 0
    17b8:	fc cf       	rjmp	.-8      	; 0x17b2 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    17ba:	8e 7f       	andi	r24, 0xFE	; 254
    17bc:	80 93 86 01 	sts	0x0186, r24
  twi_buf = twi_data;                   //load pointer to write buffer
    17c0:	70 93 85 01 	sts	0x0185, r23
    17c4:	60 93 84 01 	sts	0x0184, r22
  twi_msg_size = byte_cnt;              //load size of xfer 
    17c8:	40 93 87 01 	sts	0x0187, r20
  TWCR = TWCR_START;                    //initiate START
    17cc:	85 ea       	ldi	r24, 0xA5	; 165
    17ce:	80 93 74 00 	sts	0x0074, r24
    17d2:	08 95       	ret

000017d4 <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    17d4:	90 91 74 00 	lds	r25, 0x0074
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    17d8:	90 fd       	sbrc	r25, 0
    17da:	fc cf       	rjmp	.-8      	; 0x17d4 <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    17dc:	81 60       	ori	r24, 0x01	; 1
    17de:	80 93 86 01 	sts	0x0186, r24
  twi_buf = twi_data;                  //load pointer to write buffer
    17e2:	70 93 85 01 	sts	0x0185, r23
    17e6:	60 93 84 01 	sts	0x0184, r22
  twi_msg_size = byte_cnt;             //load size of xfer 
    17ea:	40 93 87 01 	sts	0x0187, r20
  TWCR = TWCR_START;                   //initiate START
    17ee:	85 ea       	ldi	r24, 0xA5	; 165
    17f0:	80 93 74 00 	sts	0x0074, r24
    17f4:	08 95       	ret

000017f6 <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    17f6:	8f ef       	ldi	r24, 0xFF	; 255
    17f8:	80 93 73 00 	sts	0x0073, r24
  TWSR = 0x00;     //prescaler value = 1
    17fc:	10 92 71 00 	sts	0x0071, r1
  TWBR = TWI_TWBR; //defined in twi_master.h 
    1800:	8c e0       	ldi	r24, 0x0C	; 12
    1802:	80 93 70 00 	sts	0x0070, r24
    1806:	08 95       	ret

00001808 <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1808:	5d 9b       	sbis	0x0b, 5	; 11
    180a:	fe cf       	rjmp	.-4      	; 0x1808 <uart_putc>
    UDR0 = data;    // Send data byte
    180c:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    180e:	5d 9b       	sbis	0x0b, 5	; 11
    1810:	fe cf       	rjmp	.-4      	; 0x180e <uart_putc+0x6>
}
    1812:	08 95       	ret

00001814 <uart_puts>:
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    1814:	fc 01       	movw	r30, r24
    1816:	20 81       	ld	r18, Z
    1818:	22 23       	and	r18, r18
    181a:	49 f0       	breq	.+18     	; 0x182e <uart_puts+0x1a>
    181c:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    181e:	5d 9b       	sbis	0x0b, 5	; 11
    1820:	fe cf       	rjmp	.-4      	; 0x181e <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    1822:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1824:	5d 9b       	sbis	0x0b, 5	; 11
    1826:	fe cf       	rjmp	.-4      	; 0x1824 <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    1828:	21 91       	ld	r18, Z+
    182a:	21 11       	cpse	r18, r1
    182c:	f8 cf       	rjmp	.-16     	; 0x181e <uart_puts+0xa>
    182e:	08 95       	ret

00001830 <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1830:	9c 01       	movw	r18, r24
    1832:	fc 01       	movw	r30, r24
    1834:	44 91       	lpm	r20, Z
    1836:	44 23       	and	r20, r20
    1838:	69 f0       	breq	.+26     	; 0x1854 <uart_puts_p+0x24>
	uart_putc(pgm_read_byte(str++));
    183a:	01 96       	adiw	r24, 0x01	; 1
    183c:	f9 01       	movw	r30, r18
    183e:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1840:	5d 9b       	sbis	0x0b, 5	; 11
    1842:	fe cf       	rjmp	.-4      	; 0x1840 <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    1844:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1846:	5d 9b       	sbis	0x0b, 5	; 11
    1848:	fe cf       	rjmp	.-4      	; 0x1846 <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    184a:	9c 01       	movw	r18, r24
    184c:	fc 01       	movw	r30, r24
    184e:	44 91       	lpm	r20, Z
    1850:	41 11       	cpse	r20, r1
    1852:	f3 cf       	rjmp	.-26     	; 0x183a <uart_puts_p+0xa>
	uart_putc(pgm_read_byte(str++));
    }
}
    1854:	08 95       	ret

00001856 <uart_init>:
//must be in place for the MAX232 chip to get data.

void uart_init(){
    //rx and tx enable, receive interrupt enabled, 8 bit characters
    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
    UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!
    1856:	8a b1       	in	r24, 0x0a	; 10
    1858:	88 61       	ori	r24, 0x18	; 24
    185a:	8a b9       	out	0x0a, r24	; 10

    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
    //async operation, no parity,  one stop bit, 8-bit characters
    UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    185c:	e5 e9       	ldi	r30, 0x95	; 149
    185e:	f0 e0       	ldi	r31, 0x00	; 0
    1860:	80 81       	ld	r24, Z
    1862:	86 60       	ori	r24, 0x06	; 6
    1864:	80 83       	st	Z, r24
    UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    1866:	10 92 90 00 	sts	0x0090, r1
    UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    186a:	87 e6       	ldi	r24, 0x67	; 103
    186c:	89 b9       	out	0x09, r24	; 9
    186e:	08 95       	ret

00001870 <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    1870:	80 e8       	ldi	r24, 0x80	; 128
    1872:	9e e3       	ldi	r25, 0x3E	; 62
    1874:	03 c0       	rjmp	.+6      	; 0x187c <uart_getc+0xc>
    1876:	01 97       	sbiw	r24, 0x01	; 1
	timer++;
	if(timer >= 16000){ return(0);}
    1878:	00 97       	sbiw	r24, 0x00	; 0
    187a:	21 f0       	breq	.+8      	; 0x1884 <uart_getc+0x14>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    187c:	5f 9b       	sbis	0x0b, 7	; 11
    187e:	fb cf       	rjmp	.-10     	; 0x1876 <uart_getc+0x6>
	//what should we return if nothing comes in?
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
    1880:	8c b1       	in	r24, 0x0c	; 12
    1882:	08 95       	ret
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
	timer++;
	if(timer >= 16000){ return(0);}
    1884:	80 e0       	ldi	r24, 0x00	; 0
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
}
    1886:	08 95       	ret

00001888 <lm73_temp_convert>:
//******************************************************************************
uint16_t lm73_temp_convert(uint16_t lm73_temp, uint8_t f_not_c){
    //given a temperature reading from an LM73, the address of a buffer
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    lm73_temp = (lm73_temp >> 7);
    1888:	88 0f       	add	r24, r24
    188a:	89 2f       	mov	r24, r25
    188c:	88 1f       	adc	r24, r24
    188e:	99 0b       	sbc	r25, r25
    1890:	91 95       	neg	r25
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 1){
    1892:	61 30       	cpi	r22, 0x01	; 1
    1894:	09 f0       	breq	.+2      	; 0x1898 <lm73_temp_convert+0x10>
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    1896:	08 95       	ret
    lm73_temp = (lm73_temp >> 7);
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 1){
	lm73_temp = (lm73_temp*5/9)+32;
    1898:	9c 01       	movw	r18, r24
    189a:	22 0f       	add	r18, r18
    189c:	33 1f       	adc	r19, r19
    189e:	22 0f       	add	r18, r18
    18a0:	33 1f       	adc	r19, r19
    18a2:	28 0f       	add	r18, r24
    18a4:	39 1f       	adc	r19, r25
    18a6:	af e8       	ldi	r26, 0x8F	; 143
    18a8:	b3 ee       	ldi	r27, 0xE3	; 227
    18aa:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
    18ae:	96 95       	lsr	r25
    18b0:	87 95       	ror	r24
    18b2:	96 95       	lsr	r25
    18b4:	87 95       	ror	r24
    18b6:	96 95       	lsr	r25
    18b8:	87 95       	ror	r24
    18ba:	80 96       	adiw	r24, 0x20	; 32
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    18bc:	08 95       	ret

000018be <lm73_init>:
//******************************************************************************
void lm73_init(){
	lm73_wr_buf[0] = LM73_PTR_TEMP;
    18be:	10 92 d8 01 	sts	0x01D8, r1
	twi_start_wr(LM73_ADDRESS, lm73_wr_buf, 2);
    18c2:	42 e0       	ldi	r20, 0x02	; 2
    18c4:	68 ed       	ldi	r22, 0xD8	; 216
    18c6:	71 e0       	ldi	r23, 0x01	; 1
    18c8:	80 e9       	ldi	r24, 0x90	; 144
    18ca:	0c 94 d9 0b 	jmp	0x17b2	; 0x17b2 <twi_start_wr>

000018ce <get_local_temp>:

}

uint16_t get_local_temp(uint8_t f_not_c){
    18ce:	cf 93       	push	r28
    18d0:	c8 2f       	mov	r28, r24
	uint16_t ret, lm73_temp;
	twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2);
    18d2:	42 e0       	ldi	r20, 0x02	; 2
    18d4:	6a ed       	ldi	r22, 0xDA	; 218
    18d6:	71 e0       	ldi	r23, 0x01	; 1
    18d8:	80 e9       	ldi	r24, 0x90	; 144
    18da:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    18de:	8f e3       	ldi	r24, 0x3F	; 63
    18e0:	9f e1       	ldi	r25, 0x1F	; 31
    18e2:	01 97       	sbiw	r24, 0x01	; 1
    18e4:	f1 f7       	brne	.-4      	; 0x18e2 <get_local_temp+0x14>
    18e6:	00 c0       	rjmp	.+0      	; 0x18e8 <get_local_temp+0x1a>
    18e8:	00 00       	nop
	_delay_ms(2);    //wait for it to finish
	//now assemble the two bytes read back into one 16-bit value
	//save high temperature byte into lm73_temp
	lm73_temp = lm73_rd_buf[0] << 8;
    18ea:	20 91 da 01 	lds	r18, 0x01DA
    18ee:	30 e0       	ldi	r19, 0x00	; 0
    18f0:	92 2f       	mov	r25, r18
    18f2:	88 27       	eor	r24, r24
//******************************************************************************
uint16_t lm73_temp_convert(uint16_t lm73_temp, uint8_t f_not_c){
    //given a temperature reading from an LM73, the address of a buffer
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    lm73_temp = (lm73_temp >> 7);
    18f4:	84 e0       	ldi	r24, 0x04	; 4
    18f6:	98 9f       	mul	r25, r24
    18f8:	81 2d       	mov	r24, r1
    18fa:	99 27       	eor	r25, r25
    18fc:	11 24       	eor	r1, r1
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 1){
    18fe:	c1 30       	cpi	r28, 0x01	; 1
    1900:	91 f4       	brne	.+36     	; 0x1926 <get_local_temp+0x58>
	lm73_temp = (lm73_temp*5/9)+32;
    1902:	9c 01       	movw	r18, r24
    1904:	22 0f       	add	r18, r18
    1906:	33 1f       	adc	r19, r19
    1908:	22 0f       	add	r18, r18
    190a:	33 1f       	adc	r19, r19
    190c:	28 0f       	add	r18, r24
    190e:	39 1f       	adc	r19, r25
    1910:	af e8       	ldi	r26, 0x8F	; 143
    1912:	b3 ee       	ldi	r27, 0xE3	; 227
    1914:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
    1918:	96 95       	lsr	r25
    191a:	87 95       	ror	r24
    191c:	96 95       	lsr	r25
    191e:	87 95       	ror	r24
    1920:	96 95       	lsr	r25
    1922:	87 95       	ror	r24
    1924:	80 96       	adiw	r24, 0x20	; 32
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
	ret = lm73_temp_convert(lm73_temp, f_not_c);

	return ret;
}
    1926:	cf 91       	pop	r28
    1928:	08 95       	ret

0000192a <strobe_lcd>:

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    192a:	e2 e6       	ldi	r30, 0x62	; 98
    192c:	f0 e0       	ldi	r31, 0x00	; 0
    192e:	80 81       	ld	r24, Z
    1930:	88 60       	ori	r24, 0x08	; 8
    1932:	80 83       	st	Z, r24
	PORTF &= ~0x08;
    1934:	80 81       	ld	r24, Z
    1936:	87 7f       	andi	r24, 0xF7	; 247
    1938:	80 83       	st	Z, r24
    193a:	08 95       	ret

0000193c <clear_display>:
}          
 
void clear_display(void){
	SPDR = 0x00;    //command, not data
    193c:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    193e:	77 9b       	sbis	0x0e, 7	; 14
    1940:	fe cf       	rjmp	.-4      	; 0x193e <clear_display+0x2>
	SPDR = 0x01;    //clear display command
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1946:	77 9b       	sbis	0x0e, 7	; 14
    1948:	fe cf       	rjmp	.-4      	; 0x1946 <clear_display+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    194a:	80 91 62 00 	lds	r24, 0x0062
    194e:	88 60       	ori	r24, 0x08	; 8
    1950:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1954:	80 91 62 00 	lds	r24, 0x0062
    1958:	87 7f       	andi	r24, 0xF7	; 247
    195a:	80 93 62 00 	sts	0x0062, r24
    195e:	8f e3       	ldi	r24, 0x3F	; 63
    1960:	9f e1       	ldi	r25, 0x1F	; 31
    1962:	01 97       	sbiw	r24, 0x01	; 1
    1964:	f1 f7       	brne	.-4      	; 0x1962 <clear_display+0x26>
    1966:	00 c0       	rjmp	.+0      	; 0x1968 <clear_display+0x2c>
    1968:	00 00       	nop
    196a:	08 95       	ret

0000196c <cursor_home>:
	strobe_lcd();   //strobe the LCD enable pin
	_delay_ms(2);   //obligatory waiting for slow LCD
}         

void cursor_home(void){
	SPDR = 0x00;    //command, not data
    196c:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    196e:	77 9b       	sbis	0x0e, 7	; 14
    1970:	fe cf       	rjmp	.-4      	; 0x196e <cursor_home+0x2>
	SPDR = 0x02;   // cursor go home position
    1972:	82 e0       	ldi	r24, 0x02	; 2
    1974:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1976:	77 9b       	sbis	0x0e, 7	; 14
    1978:	fe cf       	rjmp	.-4      	; 0x1976 <cursor_home+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    197a:	80 91 62 00 	lds	r24, 0x0062
    197e:	88 60       	ori	r24, 0x08	; 8
    1980:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1984:	80 91 62 00 	lds	r24, 0x0062
    1988:	87 7f       	andi	r24, 0xF7	; 247
    198a:	80 93 62 00 	sts	0x0062, r24
    198e:	08 95       	ret

00001990 <home_line2>:
	strobe_lcd();
//	_delay_ms(1);  //not necessary with alarm_clock.c code
}         
  
void home_line2(void){
	SPDR = 0x00;    //command, not data
    1990:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1992:	77 9b       	sbis	0x0e, 7	; 14
    1994:	fe cf       	rjmp	.-4      	; 0x1992 <home_line2+0x2>
	SPDR = 0xC0;   // cursor go home on line 2
    1996:	80 ec       	ldi	r24, 0xC0	; 192
    1998:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    199a:	77 9b       	sbis	0x0e, 7	; 14
    199c:	fe cf       	rjmp	.-4      	; 0x199a <home_line2+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    199e:	80 91 62 00 	lds	r24, 0x0062
    19a2:	88 60       	ori	r24, 0x08	; 8
    19a4:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    19a8:	80 91 62 00 	lds	r24, 0x0062
    19ac:	87 7f       	andi	r24, 0xF7	; 247
    19ae:	80 93 62 00 	sts	0x0062, r24
    19b2:	08 95       	ret

000019b4 <fill_spaces>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd(); 
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
    19b4:	80 e1       	ldi	r24, 0x10	; 16
    19b6:	90 e0       	ldi	r25, 0x00	; 0
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    19b8:	41 e0       	ldi	r20, 0x01	; 1
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		SPDR = 0x20; 
    19ba:	30 e2       	ldi	r19, 0x20	; 32
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    19bc:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19be:	77 9b       	sbis	0x0e, 7	; 14
    19c0:	fe cf       	rjmp	.-4      	; 0x19be <fill_spaces+0xa>
		SPDR = 0x20; 
    19c2:	3f b9       	out	0x0f, r19	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19c4:	77 9b       	sbis	0x0e, 7	; 14
    19c6:	fe cf       	rjmp	.-4      	; 0x19c4 <fill_spaces+0x10>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    19c8:	20 91 62 00 	lds	r18, 0x0062
    19cc:	28 60       	ori	r18, 0x08	; 8
    19ce:	20 93 62 00 	sts	0x0062, r18
	PORTF &= ~0x08;
    19d2:	20 91 62 00 	lds	r18, 0x0062
    19d6:	27 7f       	andi	r18, 0xF7	; 247
    19d8:	20 93 62 00 	sts	0x0062, r18
    19dc:	ef e9       	ldi	r30, 0x9F	; 159
    19de:	ff e0       	ldi	r31, 0x0F	; 15
    19e0:	31 97       	sbiw	r30, 0x01	; 1
    19e2:	f1 f7       	brne	.-4      	; 0x19e0 <fill_spaces+0x2c>
    19e4:	00 c0       	rjmp	.+0      	; 0x19e6 <fill_spaces+0x32>
    19e6:	00 00       	nop
    19e8:	01 97       	sbiw	r24, 0x01	; 1
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
    19ea:	00 97       	sbiw	r24, 0x00	; 0
    19ec:	39 f7       	brne	.-50     	; 0x19bc <fill_spaces+0x8>
		SPDR = 0x20; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_ms(1);
	}
}  
    19ee:	08 95       	ret

000019f0 <char2lcd>:
   
void char2lcd(char a_char){
	//sends a char to the LCD
	//usage: char2lcd('H');  // send an H to the LCD
	SPDR = 0x01;   //set SR for data xfer with LSB=1
    19f0:	91 e0       	ldi	r25, 0x01	; 1
    19f2:	9f b9       	out	0x0f, r25	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19f4:	77 9b       	sbis	0x0e, 7	; 14
    19f6:	fe cf       	rjmp	.-4      	; 0x19f4 <char2lcd+0x4>
	SPDR = a_char; //send the char to the SPI port
    19f8:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19fa:	77 9b       	sbis	0x0e, 7	; 14
    19fc:	fe cf       	rjmp	.-4      	; 0x19fa <char2lcd+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    19fe:	80 91 62 00 	lds	r24, 0x0062
    1a02:	88 60       	ori	r24, 0x08	; 8
    1a04:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a08:	80 91 62 00 	lds	r24, 0x0062
    1a0c:	87 7f       	andi	r24, 0xF7	; 247
    1a0e:	80 93 62 00 	sts	0x0062, r24
    1a12:	8f e9       	ldi	r24, 0x9F	; 159
    1a14:	9f e0       	ldi	r25, 0x0F	; 15
    1a16:	01 97       	sbiw	r24, 0x01	; 1
    1a18:	f1 f7       	brne	.-4      	; 0x1a16 <char2lcd+0x26>
    1a1a:	00 c0       	rjmp	.+0      	; 0x1a1c <char2lcd+0x2c>
    1a1c:	00 00       	nop
    1a1e:	08 95       	ret

00001a20 <cursor_off>:
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void cursor_off(void){
	//cuts cursor off 
	SPDR = 0x00;   //set SR for data xfer with LSB=1
    1a20:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a22:	77 9b       	sbis	0x0e, 7	; 14
    1a24:	fe cf       	rjmp	.-4      	; 0x1a22 <cursor_off+0x2>
	SPDR = 0x0C; //send the command to cut off cursor
    1a26:	8c e0       	ldi	r24, 0x0C	; 12
    1a28:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a2a:	77 9b       	sbis	0x0e, 7	; 14
    1a2c:	fe cf       	rjmp	.-4      	; 0x1a2a <cursor_off+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a2e:	80 91 62 00 	lds	r24, 0x0062
    1a32:	88 60       	ori	r24, 0x08	; 8
    1a34:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a38:	80 91 62 00 	lds	r24, 0x0062
    1a3c:	87 7f       	andi	r24, 0xF7	; 247
    1a3e:	80 93 62 00 	sts	0x0062, r24
    1a42:	8f e9       	ldi	r24, 0x9F	; 159
    1a44:	9f e0       	ldi	r25, 0x0F	; 15
    1a46:	01 97       	sbiw	r24, 0x01	; 1
    1a48:	f1 f7       	brne	.-4      	; 0x1a46 <cursor_off+0x26>
    1a4a:	00 c0       	rjmp	.+0      	; 0x1a4c <cursor_off+0x2c>
    1a4c:	00 00       	nop
    1a4e:	08 95       	ret

00001a50 <string2lcd>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();  //toggle the enable bit
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void string2lcd(char *lcd_str){
    1a50:	dc 01       	movw	r26, r24

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1a52:	80 e0       	ldi	r24, 0x00	; 0
    1a54:	90 e0       	ldi	r25, 0x00	; 0
    1a56:	20 e0       	ldi	r18, 0x00	; 0
    1a58:	30 e0       	ldi	r19, 0x00	; 0
		SPDR = 0x01; //set SR for data
    1a5a:	41 e0       	ldi	r20, 0x01	; 1
    1a5c:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a5e:	77 9b       	sbis	0x0e, 7	; 14
    1a60:	fe cf       	rjmp	.-4      	; 0x1a5e <string2lcd+0xe>
		SPDR = lcd_str[count]; 
    1a62:	fd 01       	movw	r30, r26
    1a64:	e8 0f       	add	r30, r24
    1a66:	f9 1f       	adc	r31, r25
    1a68:	80 81       	ld	r24, Z
    1a6a:	8f b9       	out	0x0f, r24	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a6c:	77 9b       	sbis	0x0e, 7	; 14
    1a6e:	fe cf       	rjmp	.-4      	; 0x1a6c <string2lcd+0x1c>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a70:	80 91 62 00 	lds	r24, 0x0062
    1a74:	88 60       	ori	r24, 0x08	; 8
    1a76:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a7a:	80 91 62 00 	lds	r24, 0x0062
    1a7e:	87 7f       	andi	r24, 0xF7	; 247
    1a80:	80 93 62 00 	sts	0x0062, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1a84:	8f e8       	ldi	r24, 0x8F	; 143
    1a86:	91 e0       	ldi	r25, 0x01	; 1
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	f1 f7       	brne	.-4      	; 0x1a88 <string2lcd+0x38>
    1a8c:	00 c0       	rjmp	.+0      	; 0x1a8e <string2lcd+0x3e>
    1a8e:	00 00       	nop
  
void string2lcd(char *lcd_str){

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1a90:	2f 5f       	subi	r18, 0xFF	; 255
    1a92:	3f 4f       	sbci	r19, 0xFF	; 255
    1a94:	c9 01       	movw	r24, r18
    1a96:	fd 01       	movw	r30, r26
    1a98:	01 90       	ld	r0, Z+
    1a9a:	00 20       	and	r0, r0
    1a9c:	e9 f7       	brne	.-6      	; 0x1a98 <string2lcd+0x48>
    1a9e:	ea 1b       	sub	r30, r26
    1aa0:	fb 0b       	sbc	r31, r27
    1aa2:	32 97       	sbiw	r30, 0x02	; 2
    1aa4:	e2 17       	cp	r30, r18
    1aa6:	f3 07       	cpc	r31, r19
    1aa8:	c8 f6       	brcc	.-78     	; 0x1a5c <string2lcd+0xc>
		SPDR = lcd_str[count]; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_us(100);
	}                  
} 
    1aaa:	08 95       	ret

00001aac <lcd_init>:
    1aac:	80 91 61 00 	lds	r24, 0x0061
    1ab0:	88 60       	ori	r24, 0x08	; 8
    1ab2:	80 93 61 00 	sts	0x0061, r24
    1ab6:	8f e5       	ldi	r24, 0x5F	; 95
    1ab8:	9a ee       	ldi	r25, 0xEA	; 234
    1aba:	01 97       	sbiw	r24, 0x01	; 1
    1abc:	f1 f7       	brne	.-4      	; 0x1aba <lcd_init+0xe>
    1abe:	00 c0       	rjmp	.+0      	; 0x1ac0 <lcd_init+0x14>
    1ac0:	00 00       	nop
    1ac2:	83 e0       	ldi	r24, 0x03	; 3
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	30 e3       	ldi	r19, 0x30	; 48
    1ac8:	1f b8       	out	0x0f, r1	; 15
    1aca:	77 9b       	sbis	0x0e, 7	; 14
    1acc:	fe cf       	rjmp	.-4      	; 0x1aca <lcd_init+0x1e>
    1ace:	3f b9       	out	0x0f, r19	; 15
    1ad0:	77 9b       	sbis	0x0e, 7	; 14
    1ad2:	fe cf       	rjmp	.-4      	; 0x1ad0 <lcd_init+0x24>
    1ad4:	20 91 62 00 	lds	r18, 0x0062
    1ad8:	28 60       	ori	r18, 0x08	; 8
    1ada:	20 93 62 00 	sts	0x0062, r18
    1ade:	20 91 62 00 	lds	r18, 0x0062
    1ae2:	27 7f       	andi	r18, 0xF7	; 247
    1ae4:	20 93 62 00 	sts	0x0062, r18
    1ae8:	ef e5       	ldi	r30, 0x5F	; 95
    1aea:	fd e6       	ldi	r31, 0x6D	; 109
    1aec:	31 97       	sbiw	r30, 0x01	; 1
    1aee:	f1 f7       	brne	.-4      	; 0x1aec <lcd_init+0x40>
    1af0:	00 c0       	rjmp	.+0      	; 0x1af2 <lcd_init+0x46>
    1af2:	00 00       	nop
    1af4:	01 97       	sbiw	r24, 0x01	; 1
    1af6:	00 97       	sbiw	r24, 0x00	; 0
    1af8:	39 f7       	brne	.-50     	; 0x1ac8 <lcd_init+0x1c>
    1afa:	1f b8       	out	0x0f, r1	; 15
    1afc:	77 9b       	sbis	0x0e, 7	; 14
    1afe:	fe cf       	rjmp	.-4      	; 0x1afc <lcd_init+0x50>
    1b00:	88 e3       	ldi	r24, 0x38	; 56
    1b02:	8f b9       	out	0x0f, r24	; 15
    1b04:	77 9b       	sbis	0x0e, 7	; 14
    1b06:	fe cf       	rjmp	.-4      	; 0x1b04 <lcd_init+0x58>
    1b08:	80 91 62 00 	lds	r24, 0x0062
    1b0c:	88 60       	ori	r24, 0x08	; 8
    1b0e:	80 93 62 00 	sts	0x0062, r24
    1b12:	80 91 62 00 	lds	r24, 0x0062
    1b16:	87 7f       	andi	r24, 0xF7	; 247
    1b18:	80 93 62 00 	sts	0x0062, r24
    1b1c:	8f e1       	ldi	r24, 0x1F	; 31
    1b1e:	9e e4       	ldi	r25, 0x4E	; 78
    1b20:	01 97       	sbiw	r24, 0x01	; 1
    1b22:	f1 f7       	brne	.-4      	; 0x1b20 <lcd_init+0x74>
    1b24:	00 c0       	rjmp	.+0      	; 0x1b26 <lcd_init+0x7a>
    1b26:	00 00       	nop
    1b28:	1f b8       	out	0x0f, r1	; 15
    1b2a:	77 9b       	sbis	0x0e, 7	; 14
    1b2c:	fe cf       	rjmp	.-4      	; 0x1b2a <lcd_init+0x7e>
    1b2e:	88 e0       	ldi	r24, 0x08	; 8
    1b30:	8f b9       	out	0x0f, r24	; 15
    1b32:	77 9b       	sbis	0x0e, 7	; 14
    1b34:	fe cf       	rjmp	.-4      	; 0x1b32 <lcd_init+0x86>
    1b36:	80 91 62 00 	lds	r24, 0x0062
    1b3a:	88 60       	ori	r24, 0x08	; 8
    1b3c:	80 93 62 00 	sts	0x0062, r24
    1b40:	80 91 62 00 	lds	r24, 0x0062
    1b44:	87 7f       	andi	r24, 0xF7	; 247
    1b46:	80 93 62 00 	sts	0x0062, r24
    1b4a:	ef e1       	ldi	r30, 0x1F	; 31
    1b4c:	fe e4       	ldi	r31, 0x4E	; 78
    1b4e:	31 97       	sbiw	r30, 0x01	; 1
    1b50:	f1 f7       	brne	.-4      	; 0x1b4e <lcd_init+0xa2>
    1b52:	00 c0       	rjmp	.+0      	; 0x1b54 <lcd_init+0xa8>
    1b54:	00 00       	nop
    1b56:	1f b8       	out	0x0f, r1	; 15
    1b58:	77 9b       	sbis	0x0e, 7	; 14
    1b5a:	fe cf       	rjmp	.-4      	; 0x1b58 <lcd_init+0xac>
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	8f b9       	out	0x0f, r24	; 15
    1b60:	77 9b       	sbis	0x0e, 7	; 14
    1b62:	fe cf       	rjmp	.-4      	; 0x1b60 <lcd_init+0xb4>
    1b64:	80 91 62 00 	lds	r24, 0x0062
    1b68:	88 60       	ori	r24, 0x08	; 8
    1b6a:	80 93 62 00 	sts	0x0062, r24
    1b6e:	80 91 62 00 	lds	r24, 0x0062
    1b72:	87 7f       	andi	r24, 0xF7	; 247
    1b74:	80 93 62 00 	sts	0x0062, r24
    1b78:	8f e1       	ldi	r24, 0x1F	; 31
    1b7a:	9e e4       	ldi	r25, 0x4E	; 78
    1b7c:	01 97       	sbiw	r24, 0x01	; 1
    1b7e:	f1 f7       	brne	.-4      	; 0x1b7c <lcd_init+0xd0>
    1b80:	00 c0       	rjmp	.+0      	; 0x1b82 <lcd_init+0xd6>
    1b82:	00 00       	nop
    1b84:	1f b8       	out	0x0f, r1	; 15
    1b86:	77 9b       	sbis	0x0e, 7	; 14
    1b88:	fe cf       	rjmp	.-4      	; 0x1b86 <lcd_init+0xda>
    1b8a:	86 e0       	ldi	r24, 0x06	; 6
    1b8c:	8f b9       	out	0x0f, r24	; 15
    1b8e:	77 9b       	sbis	0x0e, 7	; 14
    1b90:	fe cf       	rjmp	.-4      	; 0x1b8e <lcd_init+0xe2>
    1b92:	80 91 62 00 	lds	r24, 0x0062
    1b96:	88 60       	ori	r24, 0x08	; 8
    1b98:	80 93 62 00 	sts	0x0062, r24
    1b9c:	80 91 62 00 	lds	r24, 0x0062
    1ba0:	87 7f       	andi	r24, 0xF7	; 247
    1ba2:	80 93 62 00 	sts	0x0062, r24
    1ba6:	ef e1       	ldi	r30, 0x1F	; 31
    1ba8:	fe e4       	ldi	r31, 0x4E	; 78
    1baa:	31 97       	sbiw	r30, 0x01	; 1
    1bac:	f1 f7       	brne	.-4      	; 0x1baa <lcd_init+0xfe>
    1bae:	00 c0       	rjmp	.+0      	; 0x1bb0 <lcd_init+0x104>
    1bb0:	00 00       	nop
    1bb2:	1f b8       	out	0x0f, r1	; 15
    1bb4:	77 9b       	sbis	0x0e, 7	; 14
    1bb6:	fe cf       	rjmp	.-4      	; 0x1bb4 <lcd_init+0x108>
    1bb8:	8e e0       	ldi	r24, 0x0E	; 14
    1bba:	8f b9       	out	0x0f, r24	; 15
    1bbc:	77 9b       	sbis	0x0e, 7	; 14
    1bbe:	fe cf       	rjmp	.-4      	; 0x1bbc <lcd_init+0x110>
    1bc0:	80 91 62 00 	lds	r24, 0x0062
    1bc4:	88 60       	ori	r24, 0x08	; 8
    1bc6:	80 93 62 00 	sts	0x0062, r24
    1bca:	80 91 62 00 	lds	r24, 0x0062
    1bce:	87 7f       	andi	r24, 0xF7	; 247
    1bd0:	80 93 62 00 	sts	0x0062, r24
    1bd4:	8f e1       	ldi	r24, 0x1F	; 31
    1bd6:	9e e4       	ldi	r25, 0x4E	; 78
    1bd8:	01 97       	sbiw	r24, 0x01	; 1
    1bda:	f1 f7       	brne	.-4      	; 0x1bd8 <lcd_init+0x12c>
    1bdc:	00 c0       	rjmp	.+0      	; 0x1bde <lcd_init+0x132>
    1bde:	00 00       	nop
    1be0:	08 95       	ret

00001be2 <main>:

int main()
{
	//set port bits 4-7 B as outputs
	//uint8_t c = 0;
	DDRE = 0xFF;
    1be2:	9f ef       	ldi	r25, 0xFF	; 255
    1be4:	92 b9       	out	0x02, r25	; 2
	PORTE &= 0x7F;
    1be6:	1f 98       	cbi	0x03, 7	; 3
	DDRB = 0xF7;
    1be8:	87 ef       	ldi	r24, 0xF7	; 247
    1bea:	87 bb       	out	0x17, r24	; 23
	DDRD |= (1 << PB2);
    1bec:	8a 9a       	sbi	0x11, 2	; 17

	volume = 100;
    1bee:	84 e6       	ldi	r24, 0x64	; 100
    1bf0:	80 93 00 01 	sts	0x0100, r24
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1bf4:	83 b7       	in	r24, 0x33	; 51
    1bf6:	81 60       	ori	r24, 0x01	; 1
    1bf8:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    1bfa:	80 b7       	in	r24, 0x30	; 48
    1bfc:	88 60       	ori	r24, 0x08	; 8
    1bfe:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1c00:	85 b5       	in	r24, 0x25	; 37
    1c02:	8a 67       	ori	r24, 0x7A	; 122
    1c04:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1c06:	87 b7       	in	r24, 0x37	; 55
    1c08:	81 64       	ori	r24, 0x41	; 65
    1c0a:	87 bf       	out	0x37, r24	; 55
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    1c0c:	80 91 61 00 	lds	r24, 0x0061
    1c10:	80 93 61 00 	sts	0x0061, r24
	PORTF = 0x00;
    1c14:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1c18:	87 b1       	in	r24, 0x07	; 7
    1c1a:	80 66       	ori	r24, 0x60	; 96
    1c1c:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1c1e:	86 b1       	in	r24, 0x06	; 6
    1c20:	8f 6e       	ori	r24, 0xEF	; 239
    1c22:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    1c24:	93 bd       	out	0x23, r25	; 35
	DDRD |= (1 << PB2);

	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
    1c26:	0e 94 61 05 	call	0xac2	; 0xac2 <music_init>
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    1c2a:	80 e5       	ldi	r24, 0x50	; 80
    1c2c:	8d b9       	out	0x0d, r24	; 13
	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
	SPI_init();
	lcd_init();
    1c2e:	0e 94 56 0d 	call	0x1aac	; 0x1aac <lcd_init>
	init_twi();
    1c32:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <init_twi>
	uart_init();
    1c36:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uart_init>
	OCR2 = 0xFF;
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1c3a:	81 e8       	ldi	r24, 0x81	; 129
    1c3c:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    1c40:	89 e0       	ldi	r24, 0x09	; 9
    1c42:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    1c46:	80 91 00 01 	lds	r24, 0x0100
    1c4a:	90 e0       	ldi	r25, 0x00	; 0
    1c4c:	90 93 87 00 	sts	0x0087, r25
    1c50:	80 93 86 00 	sts	0x0086, r24
	SPI_init();
	lcd_init();
	init_twi();
	uart_init();
	volume_control_init();
	lm73_init();
    1c54:	0e 94 5f 0c 	call	0x18be	; 0x18be <lm73_init>
	cursor_off();
    1c58:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <cursor_off>
}

void initialize_string(){
	loc_temp_str = 0;
	rem_temp_str = 0;
	loc_temp_str = "Local  temp:   C";
    1c5c:	83 e1       	ldi	r24, 0x13	; 19
    1c5e:	91 e0       	ldi	r25, 0x01	; 1
    1c60:	90 93 71 01 	sts	0x0171, r25
    1c64:	80 93 70 01 	sts	0x0170, r24
	rem_temp_str = "Remote temp:   C";
    1c68:	84 e2       	ldi	r24, 0x24	; 36
    1c6a:	91 e0       	ldi	r25, 0x01	; 1
    1c6c:	90 93 78 01 	sts	0x0178, r25
    1c70:	80 93 77 01 	sts	0x0177, r24
	volume_control_init();
	lm73_init();
	cursor_off();
	initialize_string();
	//strcpy(loc_temp_str, "Local  temp:   C");
	sei();
    1c74:	78 94       	sei
    1c76:	02 c0       	rjmp	.+4      	; 0x1c7c <main+0x9a>
		//}
		if(reset_temp){
			generate_temp_str();
			reset_temp = 0;
		}
		show_temperature();
    1c78:	0e 94 a6 0a 	call	0x154c	; 0x154c <show_temperature>
	sei();
	//string2lcd("hello");
	while(1){
		//_delay_ms(100);
		//clear_display();
		display_update();
    1c7c:	0e 94 a1 08 	call	0x1142	; 0x1142 <display_update>
		update_time();
    1c80:	0e 94 58 07 	call	0xeb0	; 0xeb0 <update_time>
		//string2lcd(rem_temp_str);
		//if(update_LCD){
		//	update_LCD = 0;
		//	LCD_Display();
		//}
		if(reset_temp){
    1c84:	80 91 49 01 	lds	r24, 0x0149
    1c88:	88 23       	and	r24, r24
    1c8a:	b1 f3       	breq	.-20     	; 0x1c78 <main+0x96>
			generate_temp_str();
    1c8c:	0e 94 78 0a 	call	0x14f0	; 0x14f0 <generate_temp_str>
			reset_temp = 0;
    1c90:	10 92 49 01 	sts	0x0149, r1
    1c94:	f1 cf       	rjmp	.-30     	; 0x1c78 <main+0x96>

00001c96 <__tablejump2__>:
    1c96:	ee 0f       	add	r30, r30
    1c98:	ff 1f       	adc	r31, r31

00001c9a <__tablejump__>:
    1c9a:	05 90       	lpm	r0, Z+
    1c9c:	f4 91       	lpm	r31, Z
    1c9e:	e0 2d       	mov	r30, r0
    1ca0:	09 94       	ijmp

00001ca2 <__umulhisi3>:
    1ca2:	a2 9f       	mul	r26, r18
    1ca4:	b0 01       	movw	r22, r0
    1ca6:	b3 9f       	mul	r27, r19
    1ca8:	c0 01       	movw	r24, r0
    1caa:	a3 9f       	mul	r26, r19
    1cac:	70 0d       	add	r23, r0
    1cae:	81 1d       	adc	r24, r1
    1cb0:	11 24       	eor	r1, r1
    1cb2:	91 1d       	adc	r25, r1
    1cb4:	b2 9f       	mul	r27, r18
    1cb6:	70 0d       	add	r23, r0
    1cb8:	81 1d       	adc	r24, r1
    1cba:	11 24       	eor	r1, r1
    1cbc:	91 1d       	adc	r25, r1
    1cbe:	08 95       	ret

00001cc0 <__itoa_ncheck>:
    1cc0:	bb 27       	eor	r27, r27
    1cc2:	4a 30       	cpi	r20, 0x0A	; 10
    1cc4:	31 f4       	brne	.+12     	; 0x1cd2 <__itoa_ncheck+0x12>
    1cc6:	99 23       	and	r25, r25
    1cc8:	22 f4       	brpl	.+8      	; 0x1cd2 <__itoa_ncheck+0x12>
    1cca:	bd e2       	ldi	r27, 0x2D	; 45
    1ccc:	90 95       	com	r25
    1cce:	81 95       	neg	r24
    1cd0:	9f 4f       	sbci	r25, 0xFF	; 255
    1cd2:	0c 94 6c 0e 	jmp	0x1cd8	; 0x1cd8 <__utoa_common>

00001cd6 <__utoa_ncheck>:
    1cd6:	bb 27       	eor	r27, r27

00001cd8 <__utoa_common>:
    1cd8:	fb 01       	movw	r30, r22
    1cda:	55 27       	eor	r21, r21
    1cdc:	aa 27       	eor	r26, r26
    1cde:	88 0f       	add	r24, r24
    1ce0:	99 1f       	adc	r25, r25
    1ce2:	aa 1f       	adc	r26, r26
    1ce4:	a4 17       	cp	r26, r20
    1ce6:	10 f0       	brcs	.+4      	; 0x1cec <__utoa_common+0x14>
    1ce8:	a4 1b       	sub	r26, r20
    1cea:	83 95       	inc	r24
    1cec:	50 51       	subi	r21, 0x10	; 16
    1cee:	b9 f7       	brne	.-18     	; 0x1cde <__utoa_common+0x6>
    1cf0:	a0 5d       	subi	r26, 0xD0	; 208
    1cf2:	aa 33       	cpi	r26, 0x3A	; 58
    1cf4:	08 f0       	brcs	.+2      	; 0x1cf8 <__utoa_common+0x20>
    1cf6:	a9 5d       	subi	r26, 0xD9	; 217
    1cf8:	a1 93       	st	Z+, r26
    1cfa:	00 97       	sbiw	r24, 0x00	; 0
    1cfc:	79 f7       	brne	.-34     	; 0x1cdc <__utoa_common+0x4>
    1cfe:	b1 11       	cpse	r27, r1
    1d00:	b1 93       	st	Z+, r27
    1d02:	11 92       	st	Z+, r1
    1d04:	cb 01       	movw	r24, r22
    1d06:	0c 94 85 0e 	jmp	0x1d0a	; 0x1d0a <strrev>

00001d0a <strrev>:
    1d0a:	dc 01       	movw	r26, r24
    1d0c:	fc 01       	movw	r30, r24
    1d0e:	67 2f       	mov	r22, r23
    1d10:	71 91       	ld	r23, Z+
    1d12:	77 23       	and	r23, r23
    1d14:	e1 f7       	brne	.-8      	; 0x1d0e <strrev+0x4>
    1d16:	32 97       	sbiw	r30, 0x02	; 2
    1d18:	04 c0       	rjmp	.+8      	; 0x1d22 <strrev+0x18>
    1d1a:	7c 91       	ld	r23, X
    1d1c:	6d 93       	st	X+, r22
    1d1e:	70 83       	st	Z, r23
    1d20:	62 91       	ld	r22, -Z
    1d22:	ae 17       	cp	r26, r30
    1d24:	bf 07       	cpc	r27, r31
    1d26:	c8 f3       	brcs	.-14     	; 0x1d1a <strrev+0x10>
    1d28:	08 95       	ret

00001d2a <_exit>:
    1d2a:	f8 94       	cli

00001d2c <__stop_program>:
    1d2c:	ff cf       	rjmp	.-2      	; 0x1d2c <__stop_program>
