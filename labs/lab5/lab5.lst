
lab5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  00001d28  00001dbc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d28  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b6  00800136  00800136  00001df2  2**0
                  ALLOC
  3 .stab         00004cf8  00000000  00000000  00001df4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000193f  00000000  00000000  00006aec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000842b  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2d 01 	jmp	0x25a	; 0x25a <__ctors_end>
       4:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
       8:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
       c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      10:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      14:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      18:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      1c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      20:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      24:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      28:	0c 94 e6 07 	jmp	0xfcc	; 0xfcc <__vector_10>
      2c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      30:	0c 94 a5 07 	jmp	0xf4a	; 0xf4a <__vector_12>
      34:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      38:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      3c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      40:	0c 94 21 07 	jmp	0xe42	; 0xe42 <__vector_16>
      44:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      48:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      4c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      50:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      54:	0c 94 1e 08 	jmp	0x103c	; 0x103c <__vector_21>
      58:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      5c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      60:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      64:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      68:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      6c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      70:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      74:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      78:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      7c:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      80:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      84:	0c 94 42 0b 	jmp	0x1684	; 0x1684 <__vector_33>
      88:	0c 94 4c 01 	jmp	0x298	; 0x298 <__bad_interrupt>
      8c:	88 01       	movw	r16, r16
      8e:	90 01       	movw	r18, r0
      90:	98 01       	movw	r18, r16
      92:	a0 01       	movw	r20, r0
      94:	a8 01       	movw	r20, r16
      96:	b1 01       	movw	r22, r2
      98:	ba 01       	movw	r22, r20
      9a:	78 01       	movw	r14, r16
      9c:	80 01       	movw	r16, r0
      9e:	0e 03       	fmul	r16, r22
      a0:	06 03       	mulsu	r16, r22
      a2:	01 03       	mulsu	r16, r17
      a4:	2b 03       	fmul	r18, r19
      a6:	1e 03       	fmul	r17, r22
      a8:	26 03       	mulsu	r18, r22
      aa:	16 03       	mulsu	r17, r22
      ac:	df 02       	muls	r29, r31
      ae:	d7 02       	muls	r29, r23
      b0:	d2 02       	muls	r29, r18
      b2:	ca 02       	muls	r28, r26
      b4:	33 03       	mulsu	r19, r19
      b6:	e7 02       	muls	r30, r23
      b8:	bd 02       	muls	r27, r29
      ba:	a5 02       	muls	r26, r21
      bc:	53 03       	mulsu	r21, r19
      be:	fc 02       	muls	r31, r28
      c0:	f4 02       	muls	r31, r20
      c2:	ec 02       	muls	r30, r28
      c4:	73 03       	mulsu	r23, r19
      c6:	ad 02       	muls	r26, r29
      c8:	63 03       	mulsu	r22, r19
      ca:	b5 02       	muls	r27, r21
      cc:	80 03       	fmuls	r16, r16
      ce:	4b 03       	fmul	r20, r19
      d0:	6b 03       	fmul	r22, r19
      d2:	c5 02       	muls	r28, r21
      d4:	43 03       	mulsu	r20, r19
      d6:	3b 03       	fmul	r19, r19
      d8:	5b 03       	fmul	r21, r19
      da:	a0 02       	muls	r26, r16
      dc:	6e 02       	muls	r22, r30
      de:	66 02       	muls	r22, r22
      e0:	76 02       	muls	r23, r22
      e2:	78 03       	fmul	r23, r16
      e4:	59 02       	muls	r21, r25
      e6:	51 02       	muls	r21, r17
      e8:	7b 02       	muls	r23, r27
      ea:	34 02       	muls	r19, r20
      ec:	98 02       	muls	r25, r24
      ee:	61 02       	muls	r22, r17
      f0:	44 02       	muls	r20, r20
      f2:	3c 02       	muls	r19, r28
      f4:	88 02       	muls	r24, r24
      f6:	4c 02       	muls	r20, r28
      f8:	80 02       	muls	r24, r16
      fa:	2c 02       	muls	r18, r28
      fc:	12 02       	muls	r17, r18
      fe:	90 02       	muls	r25, r16
     100:	02 02       	muls	r16, r18
     102:	fa 01       	movw	r30, r20
     104:	1f 02       	muls	r17, r31
     106:	17 02       	muls	r17, r23
     108:	24 02       	muls	r18, r20
     10a:	f5 01       	movw	r30, r10
     10c:	0a 02       	muls	r16, r26
     10e:	dd 01       	movw	r26, r26
     110:	ed 01       	movw	r28, r26
     112:	d8 01       	movw	r26, r16
     114:	d0 01       	movw	r26, r0
     116:	c8 01       	movw	r24, r16
     118:	c3 01       	movw	r24, r6
     11a:	e5 01       	movw	r28, r10
     11c:	8a 04       	cpc	r8, r10
     11e:	a8 04       	cpc	r10, r8
     120:	84 04       	cpc	r8, r4
     122:	96 04       	cpc	r9, r6
     124:	78 04       	cpc	r7, r8
     126:	7e 04       	cpc	r7, r14
     128:	78 04       	cpc	r7, r8
     12a:	7e 04       	cpc	r7, r14
     12c:	ae 04       	cpc	r10, r14
     12e:	8a 04       	cpc	r8, r10
     130:	a8 04       	cpc	r10, r8
     132:	84 04       	cpc	r8, r4
     134:	96 04       	cpc	r9, r6
     136:	90 04       	cpc	r9, r0
     138:	72 04       	cpc	r7, r2
     13a:	90 04       	cpc	r9, r0
     13c:	72 04       	cpc	r7, r2
     13e:	d8 04       	cpc	r13, r8
     140:	14 05       	cpc	r17, r4
     142:	cc 04       	cpc	r12, r12
     144:	44 05       	cpc	r20, r4
     146:	cc 04       	cpc	r12, r12
     148:	08 05       	cpc	r16, r8
     14a:	02 05       	cpc	r16, r2
     14c:	72 04       	cpc	r7, r2
     14e:	de 04       	cpc	r13, r14
     150:	72 04       	cpc	r7, r2
     152:	f0 04       	cpc	r15, r0
     154:	9c 04       	cpc	r9, r12
     156:	32 05       	cpc	r19, r2
     158:	78 04       	cpc	r7, r8
     15a:	26 05       	cpc	r18, r6
     15c:	b4 04       	cpc	r11, r4
     15e:	2c 05       	cpc	r18, r12
     160:	ba 04       	cpc	r11, r10
     162:	38 05       	cpc	r19, r8
     164:	fc 04       	cpc	r15, r12
     166:	a2 04       	cpc	r10, r2
     168:	9c 04       	cpc	r9, r12
     16a:	e4 04       	cpc	r14, r4
     16c:	c0 04       	cpc	r12, r0
     16e:	8a 04       	cpc	r8, r10
     170:	a8 04       	cpc	r10, r8
     172:	84 04       	cpc	r8, r4
     174:	96 04       	cpc	r9, r6
     176:	78 04       	cpc	r7, r8
     178:	7e 04       	cpc	r7, r14
     17a:	78 04       	cpc	r7, r8
     17c:	7e 04       	cpc	r7, r14
     17e:	ae 04       	cpc	r10, r14
     180:	8a 04       	cpc	r8, r10
     182:	0e 05       	cpc	r16, r14
     184:	a2 04       	cpc	r10, r2
     186:	84 04       	cpc	r8, r4
     188:	90 04       	cpc	r9, r0
     18a:	72 04       	cpc	r7, r2
     18c:	90 04       	cpc	r9, r0
     18e:	72 04       	cpc	r7, r2
     190:	d8 04       	cpc	r13, r8
     192:	1a 05       	cpc	r17, r10
     194:	ea 04       	cpc	r14, r10
     196:	ae 04       	cpc	r10, r14
     198:	20 05       	cpc	r18, r0
     19a:	de 04       	cpc	r13, r14
     19c:	b4 04       	cpc	r11, r4
     19e:	ba 04       	cpc	r11, r10
     1a0:	9c 04       	cpc	r9, r12
     1a2:	a2 04       	cpc	r10, r2
     1a4:	3e 05       	cpc	r19, r14
     1a6:	c0 04       	cpc	r12, r0
     1a8:	d5 06       	cpc	r13, r21
     1aa:	d1 06       	cpc	r13, r17
     1ac:	da 06       	cpc	r13, r26
     1ae:	fe 06       	cpc	r15, r30
     1b0:	c2 06       	cpc	r12, r18
     1b2:	f4 06       	cpc	r15, r20
     1b4:	e3 06       	cpc	r14, r19
     1b6:	b8 06       	cpc	r11, r24
     1b8:	82 0b       	sbc	r24, r18
     1ba:	59 0b       	sbc	r21, r25
     1bc:	59 0b       	sbc	r21, r25
     1be:	59 0b       	sbc	r21, r25
     1c0:	59 0b       	sbc	r21, r25
     1c2:	59 0b       	sbc	r21, r25
     1c4:	59 0b       	sbc	r21, r25
     1c6:	59 0b       	sbc	r21, r25
     1c8:	82 0b       	sbc	r24, r18
     1ca:	59 0b       	sbc	r21, r25
     1cc:	59 0b       	sbc	r21, r25
     1ce:	59 0b       	sbc	r21, r25
     1d0:	59 0b       	sbc	r21, r25
     1d2:	59 0b       	sbc	r21, r25
     1d4:	59 0b       	sbc	r21, r25
     1d6:	59 0b       	sbc	r21, r25
     1d8:	8c 0b       	sbc	r24, r28
     1da:	59 0b       	sbc	r21, r25
     1dc:	59 0b       	sbc	r21, r25
     1de:	59 0b       	sbc	r21, r25
     1e0:	59 0b       	sbc	r21, r25
     1e2:	59 0b       	sbc	r21, r25
     1e4:	59 0b       	sbc	r21, r25
     1e6:	59 0b       	sbc	r21, r25
     1e8:	59 0b       	sbc	r21, r25
     1ea:	59 0b       	sbc	r21, r25
     1ec:	59 0b       	sbc	r21, r25
     1ee:	59 0b       	sbc	r21, r25
     1f0:	59 0b       	sbc	r21, r25
     1f2:	59 0b       	sbc	r21, r25
     1f4:	59 0b       	sbc	r21, r25
     1f6:	59 0b       	sbc	r21, r25
     1f8:	8c 0b       	sbc	r24, r28
     1fa:	59 0b       	sbc	r21, r25
     1fc:	59 0b       	sbc	r21, r25
     1fe:	59 0b       	sbc	r21, r25
     200:	59 0b       	sbc	r21, r25
     202:	59 0b       	sbc	r21, r25
     204:	59 0b       	sbc	r21, r25
     206:	59 0b       	sbc	r21, r25
     208:	59 0b       	sbc	r21, r25
     20a:	59 0b       	sbc	r21, r25
     20c:	59 0b       	sbc	r21, r25
     20e:	59 0b       	sbc	r21, r25
     210:	59 0b       	sbc	r21, r25
     212:	59 0b       	sbc	r21, r25
     214:	59 0b       	sbc	r21, r25
     216:	59 0b       	sbc	r21, r25
     218:	a3 0b       	sbc	r26, r19
     21a:	59 0b       	sbc	r21, r25
     21c:	59 0b       	sbc	r21, r25
     21e:	59 0b       	sbc	r21, r25
     220:	59 0b       	sbc	r21, r25
     222:	59 0b       	sbc	r21, r25
     224:	59 0b       	sbc	r21, r25
     226:	59 0b       	sbc	r21, r25
     228:	a7 0b       	sbc	r26, r23
     22a:	59 0b       	sbc	r21, r25
     22c:	59 0b       	sbc	r21, r25
     22e:	59 0b       	sbc	r21, r25
     230:	59 0b       	sbc	r21, r25
     232:	59 0b       	sbc	r21, r25
     234:	59 0b       	sbc	r21, r25
     236:	59 0b       	sbc	r21, r25
     238:	59 0b       	sbc	r21, r25
     23a:	59 0b       	sbc	r21, r25
     23c:	59 0b       	sbc	r21, r25
     23e:	59 0b       	sbc	r21, r25
     240:	59 0b       	sbc	r21, r25
     242:	59 0b       	sbc	r21, r25
     244:	59 0b       	sbc	r21, r25
     246:	59 0b       	sbc	r21, r25
     248:	b5 0b       	sbc	r27, r21
     24a:	59 0b       	sbc	r21, r25
     24c:	59 0b       	sbc	r21, r25
     24e:	59 0b       	sbc	r21, r25
     250:	59 0b       	sbc	r21, r25
     252:	59 0b       	sbc	r21, r25
     254:	59 0b       	sbc	r21, r25
     256:	59 0b       	sbc	r21, r25
     258:	73 0b       	sbc	r23, r19

0000025a <__ctors_end>:
     25a:	11 24       	eor	r1, r1
     25c:	1f be       	out	0x3f, r1	; 63
     25e:	cf ef       	ldi	r28, 0xFF	; 255
     260:	d0 e1       	ldi	r29, 0x10	; 16
     262:	de bf       	out	0x3e, r29	; 62
     264:	cd bf       	out	0x3d, r28	; 61

00000266 <__do_copy_data>:
     266:	11 e0       	ldi	r17, 0x01	; 1
     268:	a0 e0       	ldi	r26, 0x00	; 0
     26a:	b1 e0       	ldi	r27, 0x01	; 1
     26c:	e8 e2       	ldi	r30, 0x28	; 40
     26e:	fd e1       	ldi	r31, 0x1D	; 29
     270:	00 e0       	ldi	r16, 0x00	; 0
     272:	0b bf       	out	0x3b, r16	; 59
     274:	02 c0       	rjmp	.+4      	; 0x27a <__do_copy_data+0x14>
     276:	07 90       	elpm	r0, Z+
     278:	0d 92       	st	X+, r0
     27a:	a6 33       	cpi	r26, 0x36	; 54
     27c:	b1 07       	cpc	r27, r17
     27e:	d9 f7       	brne	.-10     	; 0x276 <__do_copy_data+0x10>

00000280 <__do_clear_bss>:
     280:	21 e0       	ldi	r18, 0x01	; 1
     282:	a6 e3       	ldi	r26, 0x36	; 54
     284:	b1 e0       	ldi	r27, 0x01	; 1
     286:	01 c0       	rjmp	.+2      	; 0x28a <.do_clear_bss_start>

00000288 <.do_clear_bss_loop>:
     288:	1d 92       	st	X+, r1

0000028a <.do_clear_bss_start>:
     28a:	ac 3e       	cpi	r26, 0xEC	; 236
     28c:	b2 07       	cpc	r27, r18
     28e:	e1 f7       	brne	.-8      	; 0x288 <.do_clear_bss_loop>
     290:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <main>
     294:	0c 94 92 0e 	jmp	0x1d24	; 0x1d24 <_exit>

00000298 <__bad_interrupt>:
     298:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029c <play_rest>:
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     29c:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     29e:	10 92 78 01 	sts	0x0178, r1
     2a2:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     2a6:	90 e0       	ldi	r25, 0x00	; 0
     2a8:	90 93 76 01 	sts	0x0176, r25
     2ac:	80 93 75 01 	sts	0x0175, r24
     2b0:	08 95       	ret

000002b2 <play_note>:
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
     2b2:	cf 93       	push	r28
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
     2b4:	92 98       	cbi	0x12, 2	; 18
  beat = 0;             //reset the beat counter
     2b6:	10 92 78 01 	sts	0x0178, r1
     2ba:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;  //set the max beat
     2be:	30 e0       	ldi	r19, 0x00	; 0
     2c0:	30 93 76 01 	sts	0x0176, r19
     2c4:	20 93 75 01 	sts	0x0175, r18
  switch (octave) {
     2c8:	50 e0       	ldi	r21, 0x00	; 0
     2ca:	49 30       	cpi	r20, 0x09	; 9
     2cc:	51 05       	cpc	r21, r1
     2ce:	20 f0       	brcs	.+8      	; 0x2d8 <play_note+0x26>
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
     2d0:	1b bc       	out	0x2b, r1	; 43
     2d2:	1a bc       	out	0x2a, r1	; 42
  }
}
     2d4:	cf 91       	pop	r28
     2d6:	08 95       	ret
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2d8:	4a 5b       	subi	r20, 0xBA	; 186
     2da:	5f 4f       	sbci	r21, 0xFF	; 255
     2dc:	fa 01       	movw	r30, r20
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     2de:	99 27       	eor	r25, r25
     2e0:	87 fd       	sbrc	r24, 7
     2e2:	90 95       	com	r25
     2e4:	a9 2f       	mov	r26, r25
     2e6:	b9 2f       	mov	r27, r25
     2e8:	81 54       	subi	r24, 0x41	; 65
     2ea:	91 09       	sbc	r25, r1
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
     2ec:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
     2f0:	87 30       	cpi	r24, 0x07	; 7
     2f2:	91 05       	cpc	r25, r1
     2f4:	78 f7       	brcc	.-34     	; 0x2d4 <play_note+0x22>
     2f6:	81 5b       	subi	r24, 0xB1	; 177
     2f8:	9f 4f       	sbci	r25, 0xFF	; 255
     2fa:	fc 01       	movw	r30, r24
     2fc:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
     300:	87 30       	cpi	r24, 0x07	; 7
     302:	91 05       	cpc	r25, r1
     304:	38 f7       	brcc	.-50     	; 0x2d4 <play_note+0x22>
     306:	8a 5a       	subi	r24, 0xAA	; 170
     308:	9f 4f       	sbci	r25, 0xFF	; 255
     30a:	fc 01       	movw	r30, r24
     30c:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
  //120 bpm (every 32ms inc beat)
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
     310:	87 30       	cpi	r24, 0x07	; 7
     312:	91 05       	cpc	r25, r1
     314:	f8 f6       	brcc	.-66     	; 0x2d4 <play_note+0x22>
     316:	83 5a       	subi	r24, 0xA3	; 163
     318:	9f 4f       	sbci	r25, 0xFF	; 255
     31a:	fc 01       	movw	r30, r24
     31c:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
     320:	87 30       	cpi	r24, 0x07	; 7
     322:	91 05       	cpc	r25, r1
     324:	b8 f6       	brcc	.-82     	; 0x2d4 <play_note+0x22>
     326:	8c 59       	subi	r24, 0x9C	; 156
     328:	9f 4f       	sbci	r25, 0xFF	; 255
     32a:	fc 01       	movw	r30, r24
     32c:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
     330:	87 30       	cpi	r24, 0x07	; 7
     332:	91 05       	cpc	r25, r1
     334:	78 f6       	brcc	.-98     	; 0x2d4 <play_note+0x22>
     336:	85 59       	subi	r24, 0x95	; 149
     338:	9f 4f       	sbci	r25, 0xFF	; 255
     33a:	fc 01       	movw	r30, r24
     33c:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
     340:	87 30       	cpi	r24, 0x07	; 7
     342:	91 05       	cpc	r25, r1
     344:	38 f6       	brcc	.-114    	; 0x2d4 <play_note+0x22>
     346:	8e 58       	subi	r24, 0x8E	; 142
     348:	9f 4f       	sbci	r25, 0xFF	; 255
     34a:	fc 01       	movw	r30, r24
     34c:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
     350:	87 30       	cpi	r24, 0x07	; 7
     352:	91 05       	cpc	r25, r1
     354:	08 f0       	brcs	.+2      	; 0x358 <play_note+0xa6>
     356:	be cf       	rjmp	.-132    	; 0x2d4 <play_note+0x22>
     358:	87 58       	subi	r24, 0x87	; 135
     35a:	9f 4f       	sbci	r25, 0xFF	; 255
     35c:	fc 01       	movw	r30, r24
     35e:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
     362:	87 30       	cpi	r24, 0x07	; 7
     364:	91 05       	cpc	r25, r1
     366:	08 f0       	brcs	.+2      	; 0x36a <play_note+0xb8>
     368:	b5 cf       	rjmp	.-150    	; 0x2d4 <play_note+0x22>
     36a:	80 58       	subi	r24, 0x80	; 128
     36c:	9f 4f       	sbci	r25, 0xFF	; 255
     36e:	fc 01       	movw	r30, r24
     370:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
     374:	87 30       	cpi	r24, 0x07	; 7
     376:	91 05       	cpc	r25, r1
     378:	08 f0       	brcs	.+2      	; 0x37c <play_note+0xca>
     37a:	ac cf       	rjmp	.-168    	; 0x2d4 <play_note+0x22>
     37c:	89 57       	subi	r24, 0x79	; 121
     37e:	9f 4f       	sbci	r25, 0xFF	; 255
     380:	fc 01       	movw	r30, r24
     382:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
     386:	88 e5       	ldi	r24, 0x58	; 88
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	9b bd       	out	0x2b, r25	; 43
     38c:	8a bd       	out	0x2a, r24	; 42
	break;
     38e:	a2 cf       	rjmp	.-188    	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
     390:	66 23       	and	r22, r22
     392:	09 f4       	brne	.+2      	; 0x396 <play_note+0xe4>
     394:	0f c2       	rjmp	.+1054   	; 0x7b4 <play_note+0x502>
     396:	83 e6       	ldi	r24, 0x63	; 99
     398:	90 e0       	ldi	r25, 0x00	; 0
     39a:	9b bd       	out	0x2b, r25	; 43
     39c:	8a bd       	out	0x2a, r24	; 42
     39e:	9a cf       	rjmp	.-204    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
     3a0:	66 23       	and	r22, r22
     3a2:	09 f4       	brne	.+2      	; 0x3a6 <play_note+0xf4>
     3a4:	11 c2       	rjmp	.+1058   	; 0x7c8 <play_note+0x516>
     3a6:	8f e6       	ldi	r24, 0x6F	; 111
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	9b bd       	out	0x2b, r25	; 43
     3ac:	8a bd       	out	0x2a, r24	; 42
     3ae:	92 cf       	rjmp	.-220    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
     3b0:	86 e7       	ldi	r24, 0x76	; 118
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	9b bd       	out	0x2b, r25	; 43
     3b6:	8a bd       	out	0x2a, r24	; 42
	break;
     3b8:	8d cf       	rjmp	.-230    	; 0x2d4 <play_note+0x22>
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
     3ba:	66 23       	and	r22, r22
     3bc:	09 f4       	brne	.+2      	; 0x3c0 <play_note+0x10e>
     3be:	ff c1       	rjmp	.+1022   	; 0x7be <play_note+0x50c>
     3c0:	8a e4       	ldi	r24, 0x4A	; 74
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	9b bd       	out	0x2b, r25	; 43
     3c6:	8a bd       	out	0x2a, r24	; 42
     3c8:	85 cf       	rjmp	.-246    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
     3ca:	66 23       	and	r22, r22
     3cc:	09 f4       	brne	.+2      	; 0x3d0 <play_note+0x11e>
     3ce:	01 c2       	rjmp	.+1026   	; 0x7d2 <play_note+0x520>
     3d0:	83 e5       	ldi	r24, 0x53	; 83
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	9b bd       	out	0x2b, r25	; 43
     3d6:	8a bd       	out	0x2a, r24	; 42
     3d8:	7d cf       	rjmp	.-262    	; 0x2d4 <play_note+0x22>
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
     3da:	66 23       	and	r22, r22
     3dc:	09 f4       	brne	.+2      	; 0x3e0 <play_note+0x12e>
     3de:	b8 c1       	rjmp	.+880    	; 0x750 <play_note+0x49e>
     3e0:	82 e4       	ldi	r24, 0x42	; 66
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	9b bd       	out	0x2b, r25	; 43
     3e6:	8a bd       	out	0x2a, r24	; 42
     3e8:	75 cf       	rjmp	.-278    	; 0x2d4 <play_note+0x22>
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
     3ea:	81 eb       	ldi	r24, 0xB1	; 177
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	9b bd       	out	0x2b, r25	; 43
     3f0:	8a bd       	out	0x2a, r24	; 42
	break;
     3f2:	70 cf       	rjmp	.-288    	; 0x2d4 <play_note+0x22>
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
     3f4:	66 23       	and	r22, r22
     3f6:	09 f4       	brne	.+2      	; 0x3fa <play_note+0x148>
     3f8:	d3 c1       	rjmp	.+934    	; 0x7a0 <play_note+0x4ee>
     3fa:	85 e8       	ldi	r24, 0x85	; 133
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	9b bd       	out	0x2b, r25	; 43
     400:	8a bd       	out	0x2a, r24	; 42
     402:	68 cf       	rjmp	.-304    	; 0x2d4 <play_note+0x22>
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
     404:	66 23       	and	r22, r22
     406:	09 f4       	brne	.+2      	; 0x40a <play_note+0x158>
     408:	c1 c1       	rjmp	.+898    	; 0x78c <play_note+0x4da>
     40a:	85 e9       	ldi	r24, 0x95	; 149
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	9b bd       	out	0x2b, r25	; 43
     410:	8a bd       	out	0x2a, r24	; 42
     412:	60 cf       	rjmp	.-320    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
     414:	66 23       	and	r22, r22
     416:	09 f4       	brne	.+2      	; 0x41a <play_note+0x168>
     418:	be c1       	rjmp	.+892    	; 0x796 <play_note+0x4e4>
     41a:	87 ea       	ldi	r24, 0xA7	; 167
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	9b bd       	out	0x2b, r25	; 43
     420:	8a bd       	out	0x2a, r24	; 42
     422:	58 cf       	rjmp	.-336    	; 0x2d4 <play_note+0x22>
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
     424:	84 e6       	ldi	r24, 0x64	; 100
     426:	91 e0       	ldi	r25, 0x01	; 1
     428:	9b bd       	out	0x2b, r25	; 43
     42a:	8a bd       	out	0x2a, r24	; 42
	break;
     42c:	53 cf       	rjmp	.-346    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
     42e:	66 23       	and	r22, r22
     430:	09 f4       	brne	.+2      	; 0x434 <play_note+0x182>
     432:	bb c1       	rjmp	.+886    	; 0x7aa <play_note+0x4f8>
     434:	80 ee       	ldi	r24, 0xE0	; 224
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	9b bd       	out	0x2b, r25	; 43
     43a:	8a bd       	out	0x2a, r24	; 42
     43c:	4b cf       	rjmp	.-362    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
     43e:	8d ee       	ldi	r24, 0xED	; 237
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	9b bd       	out	0x2b, r25	; 43
     444:	8a bd       	out	0x2a, r24	; 42
	break;
     446:	46 cf       	rjmp	.-372    	; 0x2d4 <play_note+0x22>
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
     448:	66 23       	and	r22, r22
     44a:	09 f4       	brne	.+2      	; 0x44e <play_note+0x19c>
     44c:	8b c1       	rjmp	.+790    	; 0x764 <play_note+0x4b2>
     44e:	87 ec       	ldi	r24, 0xC7	; 199
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	9b bd       	out	0x2b, r25	; 43
     454:	8a bd       	out	0x2a, r24	; 42
     456:	3e cf       	rjmp	.-388    	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
     458:	66 23       	and	r22, r22
     45a:	09 f4       	brne	.+2      	; 0x45e <play_note+0x1ac>
     45c:	74 c1       	rjmp	.+744    	; 0x746 <play_note+0x494>
     45e:	80 e9       	ldi	r24, 0x90	; 144
     460:	91 e0       	ldi	r25, 0x01	; 1
     462:	9b bd       	out	0x2b, r25	; 43
     464:	8a bd       	out	0x2a, r24	; 42
     466:	36 cf       	rjmp	.-404    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
     468:	66 23       	and	r22, r22
     46a:	09 f4       	brne	.+2      	; 0x46e <play_note+0x1bc>
     46c:	cb c1       	rjmp	.+918    	; 0x804 <play_note+0x552>
     46e:	84 e8       	ldi	r24, 0x84	; 132
     470:	93 e0       	ldi	r25, 0x03	; 3
     472:	9b bd       	out	0x2b, r25	; 43
     474:	8a bd       	out	0x2a, r24	; 42
     476:	2e cf       	rjmp	.-420    	; 0x2d4 <play_note+0x22>
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
     478:	66 23       	and	r22, r22
     47a:	09 f4       	brne	.+2      	; 0x47e <play_note+0x1cc>
     47c:	af c1       	rjmp	.+862    	; 0x7dc <play_note+0x52a>
     47e:	8b e2       	ldi	r24, 0x2B	; 43
     480:	91 e0       	ldi	r25, 0x01	; 1
     482:	9b bd       	out	0x2b, r25	; 43
     484:	8a bd       	out	0x2a, r24	; 42
     486:	26 cf       	rjmp	.-436    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
     488:	66 23       	and	r22, r22
     48a:	09 f4       	brne	.+2      	; 0x48e <play_note+0x1dc>
     48c:	b1 c1       	rjmp	.+866    	; 0x7f0 <play_note+0x53e>
     48e:	82 ea       	ldi	r24, 0xA2	; 162
     490:	92 e0       	ldi	r25, 0x02	; 2
     492:	9b bd       	out	0x2b, r25	; 43
     494:	8a bd       	out	0x2a, r24	; 42
     496:	1e cf       	rjmp	.-452    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
     498:	8c ed       	ldi	r24, 0xDC	; 220
     49a:	91 e0       	ldi	r25, 0x01	; 1
     49c:	9b bd       	out	0x2b, r25	; 43
     49e:	8a bd       	out	0x2a, r24	; 42
	break;
     4a0:	19 cf       	rjmp	.-462    	; 0x2d4 <play_note+0x22>
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
     4a2:	66 23       	and	r22, r22
     4a4:	09 f4       	brne	.+2      	; 0x4a8 <play_note+0x1f6>
     4a6:	59 c1       	rjmp	.+690    	; 0x75a <play_note+0x4a8>
     4a8:	87 e1       	ldi	r24, 0x17	; 23
     4aa:	92 e0       	ldi	r25, 0x02	; 2
     4ac:	9b bd       	out	0x2b, r25	; 43
     4ae:	8a bd       	out	0x2a, r24	; 42
     4b0:	11 cf       	rjmp	.-478    	; 0x2d4 <play_note+0x22>
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
     4b2:	66 23       	and	r22, r22
     4b4:	09 f4       	brne	.+2      	; 0x4b8 <play_note+0x206>
     4b6:	b0 c1       	rjmp	.+864    	; 0x818 <play_note+0x566>
     4b8:	88 e5       	ldi	r24, 0x58	; 88
     4ba:	92 e0       	ldi	r25, 0x02	; 2
     4bc:	9b bd       	out	0x2b, r25	; 43
     4be:	8a bd       	out	0x2a, r24	; 42
     4c0:	09 cf       	rjmp	.-494    	; 0x2d4 <play_note+0x22>
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
     4c2:	8a ec       	ldi	r24, 0xCA	; 202
     4c4:	92 e0       	ldi	r25, 0x02	; 2
     4c6:	9b bd       	out	0x2b, r25	; 43
     4c8:	8a bd       	out	0x2a, r24	; 42
	break;
     4ca:	04 cf       	rjmp	.-504    	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
     4cc:	66 23       	and	r22, r22
     4ce:	09 f4       	brne	.+2      	; 0x4d2 <play_note+0x220>
     4d0:	35 c1       	rjmp	.+618    	; 0x73c <play_note+0x48a>
     4d2:	86 e4       	ldi	r24, 0x46	; 70
     4d4:	96 e0       	ldi	r25, 0x06	; 6
     4d6:	9b bd       	out	0x2b, r25	; 43
     4d8:	8a bd       	out	0x2a, r24	; 42
     4da:	fc ce       	rjmp	.-520    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
     4dc:	66 23       	and	r22, r22
     4de:	09 f4       	brne	.+2      	; 0x4e2 <play_note+0x230>
     4e0:	82 c1       	rjmp	.+772    	; 0x7e6 <play_note+0x534>
     4e2:	8a e0       	ldi	r24, 0x0A	; 10
     4e4:	97 e0       	ldi	r25, 0x07	; 7
     4e6:	9b bd       	out	0x2b, r25	; 43
     4e8:	8a bd       	out	0x2a, r24	; 42
     4ea:	f4 ce       	rjmp	.-536    	; 0x2d4 <play_note+0x22>
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
     4ec:	86 e9       	ldi	r24, 0x96	; 150
     4ee:	95 e0       	ldi	r25, 0x05	; 5
     4f0:	9b bd       	out	0x2b, r25	; 43
     4f2:	8a bd       	out	0x2a, r24	; 42
	break;
     4f4:	ef ce       	rjmp	.-546    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
     4f6:	8a eb       	ldi	r24, 0xBA	; 186
     4f8:	93 e0       	ldi	r25, 0x03	; 3
     4fa:	9b bd       	out	0x2b, r25	; 43
     4fc:	8a bd       	out	0x2a, r24	; 42
	break;
     4fe:	ea ce       	rjmp	.-556    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
     500:	66 23       	and	r22, r22
     502:	09 f4       	brne	.+2      	; 0x506 <play_note+0x254>
     504:	7a c1       	rjmp	.+756    	; 0x7fa <play_note+0x548>
     506:	81 ec       	ldi	r24, 0xC1	; 193
     508:	91 e0       	ldi	r25, 0x01	; 1
     50a:	9b bd       	out	0x2b, r25	; 43
     50c:	8a bd       	out	0x2a, r24	; 42
     50e:	e2 ce       	rjmp	.-572    	; 0x2d4 <play_note+0x22>
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
     510:	66 23       	and	r22, r22
     512:	09 f4       	brne	.+2      	; 0x516 <play_note+0x264>
     514:	7c c1       	rjmp	.+760    	; 0x80e <play_note+0x55c>
     516:	8b e0       	ldi	r24, 0x0B	; 11
     518:	91 e0       	ldi	r25, 0x01	; 1
     51a:	9b bd       	out	0x2b, r25	; 43
     51c:	8a bd       	out	0x2a, r24	; 42
     51e:	da ce       	rjmp	.-588    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
     520:	66 23       	and	r22, r22
     522:	09 f4       	brne	.+2      	; 0x526 <play_note+0x274>
     524:	7e c1       	rjmp	.+764    	; 0x822 <play_note+0x570>
     526:	80 e5       	ldi	r24, 0x50	; 80
     528:	91 e0       	ldi	r25, 0x01	; 1
     52a:	9b bd       	out	0x2b, r25	; 43
     52c:	8a bd       	out	0x2a, r24	; 42
     52e:	d2 ce       	rjmp	.-604    	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
     530:	66 23       	and	r22, r22
     532:	09 f4       	brne	.+2      	; 0x536 <play_note+0x284>
     534:	ad c1       	rjmp	.+858    	; 0x890 <play_note+0x5de>
     536:	82 e2       	ldi	r24, 0x22	; 34
     538:	93 e0       	ldi	r25, 0x03	; 3
     53a:	9b bd       	out	0x2b, r25	; 43
     53c:	8a bd       	out	0x2a, r24	; 42
     53e:	ca ce       	rjmp	.-620    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
     540:	86 e7       	ldi	r24, 0x76	; 118
     542:	97 e0       	ldi	r25, 0x07	; 7
     544:	9b bd       	out	0x2b, r25	; 43
     546:	8a bd       	out	0x2a, r24	; 42
	break;
     548:	c5 ce       	rjmp	.-630    	; 0x2d4 <play_note+0x22>
  PORTD &= unmute;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
     54a:	66 23       	and	r22, r22
     54c:	09 f4       	brne	.+2      	; 0x550 <play_note+0x29e>
     54e:	0f c1       	rjmp	.+542    	; 0x76e <play_note+0x4bc>
     550:	8e ec       	ldi	r24, 0xCE	; 206
     552:	92 e1       	ldi	r25, 0x12	; 18
     554:	9b bd       	out	0x2b, r25	; 43
     556:	8a bd       	out	0x2a, r24	; 42
     558:	bd ce       	rjmp	.-646    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
     55a:	66 23       	and	r22, r22
     55c:	09 f4       	brne	.+2      	; 0x560 <play_note+0x2ae>
     55e:	7a c1       	rjmp	.+756    	; 0x854 <play_note+0x5a2>
     560:	8d e1       	ldi	r24, 0x1D	; 29
     562:	95 e1       	ldi	r25, 0x15	; 21
     564:	9b bd       	out	0x2b, r25	; 43
     566:	8a bd       	out	0x2a, r24	; 42
     568:	b5 ce       	rjmp	.-662    	; 0x2d4 <play_note+0x22>
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
     56a:	66 23       	and	r22, r22
     56c:	09 f4       	brne	.+2      	; 0x570 <play_note+0x2be>
     56e:	dc c0       	rjmp	.+440    	; 0x728 <play_note+0x476>
     570:	80 e6       	ldi	r24, 0x60	; 96
     572:	98 e0       	ldi	r25, 0x08	; 8
     574:	9b bd       	out	0x2b, r25	; 43
     576:	8a bd       	out	0x2a, r24	; 42
     578:	ad ce       	rjmp	.-678    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
     57a:	66 23       	and	r22, r22
     57c:	09 f4       	brne	.+2      	; 0x580 <play_note+0x2ce>
     57e:	92 c1       	rjmp	.+804    	; 0x8a4 <play_note+0x5f2>
     580:	80 e1       	ldi	r24, 0x10	; 16
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	9b bd       	out	0x2b, r25	; 43
     586:	8a bd       	out	0x2a, r24	; 42
     588:	a5 ce       	rjmp	.-694    	; 0x2d4 <play_note+0x22>
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
     58a:	8e e2       	ldi	r24, 0x2E	; 46
     58c:	9b e0       	ldi	r25, 0x0B	; 11
     58e:	9b bd       	out	0x2b, r25	; 43
     590:	8a bd       	out	0x2a, r24	; 42
	break;
     592:	a0 ce       	rjmp	.-704    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
     594:	66 23       	and	r22, r22
     596:	09 f4       	brne	.+2      	; 0x59a <play_note+0x2e8>
     598:	49 c1       	rjmp	.+658    	; 0x82c <play_note+0x57a>
     59a:	8b e1       	ldi	r24, 0x1B	; 27
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	9b bd       	out	0x2b, r25	; 43
     5a0:	8a bd       	out	0x2a, r24	; 42
     5a2:	98 ce       	rjmp	.-720    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
     5a4:	8c e1       	ldi	r24, 0x1C	; 28
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	9b bd       	out	0x2b, r25	; 43
     5aa:	8a bd       	out	0x2a, r24	; 42
	break;
     5ac:	93 ce       	rjmp	.-730    	; 0x2d4 <play_note+0x22>
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
     5ae:	66 23       	and	r22, r22
     5b0:	09 f4       	brne	.+2      	; 0x5b4 <play_note+0x302>
     5b2:	41 c1       	rjmp	.+642    	; 0x836 <play_note+0x584>
     5b4:	87 e0       	ldi	r24, 0x07	; 7
     5b6:	90 e0       	ldi	r25, 0x00	; 0
     5b8:	9b bd       	out	0x2b, r25	; 43
     5ba:	8a bd       	out	0x2a, r24	; 42
     5bc:	8b ce       	rjmp	.-746    	; 0x2d4 <play_note+0x22>
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
     5be:	66 23       	and	r22, r22
     5c0:	09 f4       	brne	.+2      	; 0x5c4 <play_note+0x312>
     5c2:	da c0       	rjmp	.+436    	; 0x778 <play_note+0x4c6>
     5c4:	8b e0       	ldi	r24, 0x0B	; 11
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	9b bd       	out	0x2b, r25	; 43
     5ca:	8a bd       	out	0x2a, r24	; 42
     5cc:	83 ce       	rjmp	.-762    	; 0x2d4 <play_note+0x22>
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
     5ce:	82 e1       	ldi	r24, 0x12	; 18
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	9b bd       	out	0x2b, r25	; 43
     5d4:	8a bd       	out	0x2a, r24	; 42
	break;
     5d6:	7e ce       	rjmp	.-772    	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
     5d8:	66 23       	and	r22, r22
     5da:	09 f4       	brne	.+2      	; 0x5de <play_note+0x32c>
     5dc:	9b c0       	rjmp	.+310    	; 0x714 <play_note+0x462>
     5de:	89 e1       	ldi	r24, 0x19	; 25
     5e0:	99 e1       	ldi	r25, 0x19	; 25
     5e2:	9b bd       	out	0x2b, r25	; 43
     5e4:	8a bd       	out	0x2a, r24	; 42
     5e6:	76 ce       	rjmp	.-788    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
     5e8:	66 23       	and	r22, r22
     5ea:	09 f4       	brne	.+2      	; 0x5ee <play_note+0x33c>
     5ec:	29 c1       	rjmp	.+594    	; 0x840 <play_note+0x58e>
     5ee:	80 e3       	ldi	r24, 0x30	; 48
     5f0:	9c e1       	ldi	r25, 0x1C	; 28
     5f2:	9b bd       	out	0x2b, r25	; 43
     5f4:	8a bd       	out	0x2a, r24	; 42
     5f6:	6e ce       	rjmp	.-804    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
     5f8:	8c ed       	ldi	r24, 0xDC	; 220
     5fa:	9d e1       	ldi	r25, 0x1D	; 29
     5fc:	9b bd       	out	0x2b, r25	; 43
     5fe:	8a bd       	out	0x2a, r24	; 42
	break;
     600:	69 ce       	rjmp	.-814    	; 0x2d4 <play_note+0x22>
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
     602:	8a e3       	ldi	r24, 0x3A	; 58
     604:	90 e0       	ldi	r25, 0x00	; 0
     606:	9b bd       	out	0x2b, r25	; 43
     608:	8a bd       	out	0x2a, r24	; 42
	break;
     60a:	64 ce       	rjmp	.-824    	; 0x2d4 <play_note+0x22>
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
     60c:	66 23       	and	r22, r22
     60e:	09 f4       	brne	.+2      	; 0x612 <play_note+0x360>
     610:	35 c1       	rjmp	.+618    	; 0x87c <play_note+0x5ca>
     612:	80 e2       	ldi	r24, 0x20	; 32
     614:	90 e0       	ldi	r25, 0x00	; 0
     616:	9b bd       	out	0x2b, r25	; 43
     618:	8a bd       	out	0x2a, r24	; 42
     61a:	5c ce       	rjmp	.-840    	; 0x2d4 <play_note+0x22>
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
     61c:	66 23       	and	r22, r22
     61e:	09 f4       	brne	.+2      	; 0x622 <play_note+0x370>
     620:	32 c1       	rjmp	.+612    	; 0x886 <play_note+0x5d4>
     622:	84 e2       	ldi	r24, 0x24	; 36
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	9b bd       	out	0x2b, r25	; 43
     628:	8a bd       	out	0x2a, r24	; 42
     62a:	54 ce       	rjmp	.-856    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
     62c:	66 23       	and	r22, r22
     62e:	09 f4       	brne	.+2      	; 0x632 <play_note+0x380>
     630:	76 c0       	rjmp	.+236    	; 0x71e <play_note+0x46c>
     632:	89 e2       	ldi	r24, 0x29	; 41
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	9b bd       	out	0x2b, r25	; 43
     638:	8a bd       	out	0x2a, r24	; 42
     63a:	4c ce       	rjmp	.-872    	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
     63c:	66 23       	and	r22, r22
     63e:	09 f4       	brne	.+2      	; 0x642 <play_note+0x390>
     640:	78 c0       	rjmp	.+240    	; 0x732 <play_note+0x480>
     642:	81 e3       	ldi	r24, 0x31	; 49
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	9b bd       	out	0x2b, r25	; 43
     648:	8a bd       	out	0x2a, r24	; 42
     64a:	44 ce       	rjmp	.-888    	; 0x2d4 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
     64c:	8b e2       	ldi	r24, 0x2B	; 43
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	9b bd       	out	0x2b, r25	; 43
     652:	8a bd       	out	0x2a, r24	; 42
	break;
     654:	3f ce       	rjmp	.-898    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
     656:	66 23       	and	r22, r22
     658:	09 f4       	brne	.+2      	; 0x65c <play_note+0x3aa>
     65a:	93 c0       	rjmp	.+294    	; 0x782 <play_note+0x4d0>
     65c:	87 e3       	ldi	r24, 0x37	; 55
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	9b bd       	out	0x2b, r25	; 43
     662:	8a bd       	out	0x2a, r24	; 42
     664:	37 ce       	rjmp	.-914    	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
     666:	66 23       	and	r22, r22
     668:	09 f4       	brne	.+2      	; 0x66c <play_note+0x3ba>
     66a:	4f c0       	rjmp	.+158    	; 0x70a <play_note+0x458>
     66c:	88 e1       	ldi	r24, 0x18	; 24
     66e:	90 e0       	ldi	r25, 0x00	; 0
     670:	9b bd       	out	0x2b, r25	; 43
     672:	8a bd       	out	0x2a, r24	; 42
     674:	2f ce       	rjmp	.-930    	; 0x2d4 <play_note+0x22>
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
     676:	66 23       	and	r22, r22
     678:	09 f4       	brne	.+2      	; 0x67c <play_note+0x3ca>
     67a:	f6 c0       	rjmp	.+492    	; 0x868 <play_note+0x5b6>
     67c:	82 eb       	ldi	r24, 0xB2	; 178
     67e:	94 e0       	ldi	r25, 0x04	; 4
     680:	9b bd       	out	0x2b, r25	; 43
     682:	8a bd       	out	0x2a, r24	; 42
     684:	27 ce       	rjmp	.-946    	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
     686:	66 23       	and	r22, r22
     688:	09 f4       	brne	.+2      	; 0x68c <play_note+0x3da>
     68a:	16 c1       	rjmp	.+556    	; 0x8b8 <play_note+0x606>
     68c:	8d e8       	ldi	r24, 0x8D	; 141
     68e:	9a e0       	ldi	r25, 0x0A	; 10
     690:	9b bd       	out	0x2b, r25	; 43
     692:	8a bd       	out	0x2a, r24	; 42
     694:	1f ce       	rjmp	.-962    	; 0x2d4 <play_note+0x22>
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
     696:	66 23       	and	r22, r22
     698:	09 f4       	brne	.+2      	; 0x69c <play_note+0x3ea>
     69a:	d7 c0       	rjmp	.+430    	; 0x84a <play_note+0x598>
     69c:	86 e1       	ldi	r24, 0x16	; 22
     69e:	9e e0       	ldi	r25, 0x0E	; 14
     6a0:	9b bd       	out	0x2b, r25	; 43
     6a2:	8a bd       	out	0x2a, r24	; 42
     6a4:	17 ce       	rjmp	.-978    	; 0x2d4 <play_note+0x22>
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
     6a6:	66 23       	and	r22, r22
     6a8:	09 f4       	brne	.+2      	; 0x6ac <play_note+0x3fa>
     6aa:	f7 c0       	rjmp	.+494    	; 0x89a <play_note+0x5e8>
     6ac:	80 ec       	ldi	r24, 0xC0	; 192
     6ae:	90 e1       	ldi	r25, 0x10	; 16
     6b0:	9b bd       	out	0x2b, r25	; 43
     6b2:	8a bd       	out	0x2a, r24	; 42
     6b4:	0f ce       	rjmp	.-994    	; 0x2d4 <play_note+0x22>
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
     6b6:	66 23       	and	r22, r22
     6b8:	09 f4       	brne	.+2      	; 0x6bc <play_note+0x40a>
     6ba:	d1 c0       	rjmp	.+418    	; 0x85e <play_note+0x5ac>
     6bc:	8f e2       	ldi	r24, 0x2F	; 47
     6be:	94 e0       	ldi	r25, 0x04	; 4
     6c0:	9b bd       	out	0x2b, r25	; 43
     6c2:	8a bd       	out	0x2a, r24	; 42
     6c4:	07 ce       	rjmp	.-1010   	; 0x2d4 <play_note+0x22>
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
     6c6:	66 23       	and	r22, r22
     6c8:	09 f4       	brne	.+2      	; 0x6cc <play_note+0x41a>
     6ca:	f1 c0       	rjmp	.+482    	; 0x8ae <play_note+0x5fc>
     6cc:	87 e6       	ldi	r24, 0x67	; 103
     6ce:	99 e0       	ldi	r25, 0x09	; 9
     6d0:	9b bd       	out	0x2b, r25	; 43
     6d2:	8a bd       	out	0x2a, r24	; 42
     6d4:	ff cd       	rjmp	.-1026   	; 0x2d4 <play_note+0x22>
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
     6d6:	66 23       	and	r22, r22
     6d8:	09 f4       	brne	.+2      	; 0x6dc <play_note+0x42a>
     6da:	cb c0       	rjmp	.+406    	; 0x872 <play_note+0x5c0>
     6dc:	8d e8       	ldi	r24, 0x8D	; 141
     6de:	9c e0       	ldi	r25, 0x0C	; 12
     6e0:	9b bd       	out	0x2b, r25	; 43
     6e2:	8a bd       	out	0x2a, r24	; 42
     6e4:	f7 cd       	rjmp	.-1042   	; 0x2d4 <play_note+0x22>
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
     6e6:	8d e5       	ldi	r24, 0x5D	; 93
     6e8:	96 e1       	ldi	r25, 0x16	; 22
     6ea:	9b bd       	out	0x2b, r25	; 43
     6ec:	8a bd       	out	0x2a, r24	; 42
	break;
     6ee:	f2 cd       	rjmp	.-1052   	; 0x2d4 <play_note+0x22>
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
     6f0:	66 23       	and	r22, r22
     6f2:	09 f4       	brne	.+2      	; 0x6f6 <play_note+0x444>
     6f4:	e6 c0       	rjmp	.+460    	; 0x8c2 <play_note+0x610>
     6f6:	86 e4       	ldi	r24, 0x46	; 70
     6f8:	95 e0       	ldi	r25, 0x05	; 5
     6fa:	9b bd       	out	0x2b, r25	; 43
     6fc:	8a bd       	out	0x2a, r24	; 42
     6fe:	ea cd       	rjmp	.-1068   	; 0x2d4 <play_note+0x22>
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
     700:	8d ee       	ldi	r24, 0xED	; 237
     702:	9e e0       	ldi	r25, 0x0E	; 14
     704:	9b bd       	out	0x2b, r25	; 43
     706:	8a bd       	out	0x2a, r24	; 42
	break;
     708:	e5 cd       	rjmp	.-1078   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
     70a:	85 e1       	ldi	r24, 0x15	; 21
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	9b bd       	out	0x2b, r25	; 43
     710:	8a bd       	out	0x2a, r24	; 42
     712:	e0 cd       	rjmp	.-1088   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
     714:	82 eb       	ldi	r24, 0xB2	; 178
     716:	97 e1       	ldi	r25, 0x17	; 23
     718:	9b bd       	out	0x2b, r25	; 43
     71a:	8a bd       	out	0x2a, r24	; 42
     71c:	db cd       	rjmp	.-1098   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
     71e:	86 e2       	ldi	r24, 0x26	; 38
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	9b bd       	out	0x2b, r25	; 43
     724:	8a bd       	out	0x2a, r24	; 42
     726:	d6 cd       	rjmp	.-1108   	; 0x2d4 <play_note+0x22>
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
     728:	87 ee       	ldi	r24, 0xE7	; 231
     72a:	97 e0       	ldi	r25, 0x07	; 7
     72c:	9b bd       	out	0x2b, r25	; 43
     72e:	8a bd       	out	0x2a, r24	; 42
     730:	d1 cd       	rjmp	.-1118   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
     732:	8e e2       	ldi	r24, 0x2E	; 46
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	9b bd       	out	0x2b, r25	; 43
     738:	8a bd       	out	0x2a, r24	; 42
     73a:	cc cd       	rjmp	.-1128   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
     73c:	8b ee       	ldi	r24, 0xEB	; 235
     73e:	95 e0       	ldi	r25, 0x05	; 5
     740:	9b bd       	out	0x2b, r25	; 43
     742:	8a bd       	out	0x2a, r24	; 42
     744:	c7 cd       	rjmp	.-1138   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
     746:	8a e7       	ldi	r24, 0x7A	; 122
     748:	91 e0       	ldi	r25, 0x01	; 1
     74a:	9b bd       	out	0x2b, r25	; 43
     74c:	8a bd       	out	0x2a, r24	; 42
     74e:	c2 cd       	rjmp	.-1148   	; 0x2d4 <play_note+0x22>
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
     750:	8e e3       	ldi	r24, 0x3E	; 62
     752:	90 e0       	ldi	r25, 0x00	; 0
     754:	9b bd       	out	0x2b, r25	; 43
     756:	8a bd       	out	0x2a, r24	; 42
     758:	bd cd       	rjmp	.-1158   	; 0x2d4 <play_note+0x22>
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
     75a:	89 ef       	ldi	r24, 0xF9	; 249
     75c:	91 e0       	ldi	r25, 0x01	; 1
     75e:	9b bd       	out	0x2b, r25	; 43
     760:	8a bd       	out	0x2a, r24	; 42
     762:	b8 cd       	rjmp	.-1168   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
     764:	8c eb       	ldi	r24, 0xBC	; 188
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	9b bd       	out	0x2b, r25	; 43
     76a:	8a bd       	out	0x2a, r24	; 42
     76c:	b3 cd       	rjmp	.-1178   	; 0x2d4 <play_note+0x22>
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
     76e:	80 ec       	ldi	r24, 0xC0	; 192
     770:	91 e1       	ldi	r25, 0x11	; 17
     772:	9b bd       	out	0x2b, r25	; 43
     774:	8a bd       	out	0x2a, r24	; 42
     776:	ae cd       	rjmp	.-1188   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
     778:	89 e0       	ldi	r24, 0x09	; 9
     77a:	90 e0       	ldi	r25, 0x00	; 0
     77c:	9b bd       	out	0x2b, r25	; 43
     77e:	8a bd       	out	0x2a, r24	; 42
     780:	a9 cd       	rjmp	.-1198   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
     782:	84 e3       	ldi	r24, 0x34	; 52
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	9b bd       	out	0x2b, r25	; 43
     788:	8a bd       	out	0x2a, r24	; 42
     78a:	a4 cd       	rjmp	.-1208   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
     78c:	8d e8       	ldi	r24, 0x8D	; 141
     78e:	90 e0       	ldi	r25, 0x00	; 0
     790:	9b bd       	out	0x2b, r25	; 43
     792:	8a bd       	out	0x2a, r24	; 42
     794:	9f cd       	rjmp	.-1218   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
     796:	8e e9       	ldi	r24, 0x9E	; 158
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	9b bd       	out	0x2b, r25	; 43
     79c:	8a bd       	out	0x2a, r24	; 42
     79e:	9a cd       	rjmp	.-1228   	; 0x2d4 <play_note+0x22>
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
     7a0:	8d e7       	ldi	r24, 0x7D	; 125
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	9b bd       	out	0x2b, r25	; 43
     7a6:	8a bd       	out	0x2a, r24	; 42
     7a8:	95 cd       	rjmp	.-1238   	; 0x2d4 <play_note+0x22>
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
     7aa:	83 ed       	ldi	r24, 0xD3	; 211
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	9b bd       	out	0x2b, r25	; 43
     7b0:	8a bd       	out	0x2a, r24	; 42
     7b2:	90 cd       	rjmp	.-1248   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
     7b4:	8d e5       	ldi	r24, 0x5D	; 93
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	9b bd       	out	0x2b, r25	; 43
     7ba:	8a bd       	out	0x2a, r24	; 42
     7bc:	8b cd       	rjmp	.-1258   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
     7be:	86 e4       	ldi	r24, 0x46	; 70
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	9b bd       	out	0x2b, r25	; 43
     7c4:	8a bd       	out	0x2a, r24	; 42
     7c6:	86 cd       	rjmp	.-1268   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
     7c8:	89 e6       	ldi	r24, 0x69	; 105
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	9b bd       	out	0x2b, r25	; 43
     7ce:	8a bd       	out	0x2a, r24	; 42
     7d0:	81 cd       	rjmp	.-1278   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
     7d2:	8e e4       	ldi	r24, 0x4E	; 78
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	9b bd       	out	0x2b, r25	; 43
     7d8:	8a bd       	out	0x2a, r24	; 42
     7da:	7c cd       	rjmp	.-1288   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
     7dc:	8b e1       	ldi	r24, 0x1B	; 27
     7de:	91 e0       	ldi	r25, 0x01	; 1
     7e0:	9b bd       	out	0x2b, r25	; 43
     7e2:	8a bd       	out	0x2a, r24	; 42
     7e4:	77 cd       	rjmp	.-1298   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
     7e6:	85 ea       	ldi	r24, 0xA5	; 165
     7e8:	96 e0       	ldi	r25, 0x06	; 6
     7ea:	9b bd       	out	0x2b, r25	; 43
     7ec:	8a bd       	out	0x2a, r24	; 42
     7ee:	72 cd       	rjmp	.-1308   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
     7f0:	8c e7       	ldi	r24, 0x7C	; 124
     7f2:	92 e0       	ldi	r25, 0x02	; 2
     7f4:	9b bd       	out	0x2b, r25	; 43
     7f6:	8a bd       	out	0x2a, r24	; 42
     7f8:	6d cd       	rjmp	.-1318   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
     7fa:	88 ea       	ldi	r24, 0xA8	; 168
     7fc:	91 e0       	ldi	r25, 0x01	; 1
     7fe:	9b bd       	out	0x2b, r25	; 43
     800:	8a bd       	out	0x2a, r24	; 42
     802:	68 cd       	rjmp	.-1328   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
     804:	82 e5       	ldi	r24, 0x52	; 82
     806:	93 e0       	ldi	r25, 0x03	; 3
     808:	9b bd       	out	0x2b, r25	; 43
     80a:	8a bd       	out	0x2a, r24	; 42
     80c:	63 cd       	rjmp	.-1338   	; 0x2d4 <play_note+0x22>
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
     80e:	8c ef       	ldi	r24, 0xFC	; 252
     810:	90 e0       	ldi	r25, 0x00	; 0
     812:	9b bd       	out	0x2b, r25	; 43
     814:	8a bd       	out	0x2a, r24	; 42
     816:	5e cd       	rjmp	.-1348   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
     818:	87 e3       	ldi	r24, 0x37	; 55
     81a:	92 e0       	ldi	r25, 0x02	; 2
     81c:	9b bd       	out	0x2b, r25	; 43
     81e:	8a bd       	out	0x2a, r24	; 42
     820:	59 cd       	rjmp	.-1358   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
     822:	8d e3       	ldi	r24, 0x3D	; 61
     824:	91 e0       	ldi	r25, 0x01	; 1
     826:	9b bd       	out	0x2b, r25	; 43
     828:	8a bd       	out	0x2a, r24	; 42
     82a:	54 cd       	rjmp	.-1368   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
     82c:	89 e1       	ldi	r24, 0x19	; 25
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	9b bd       	out	0x2b, r25	; 43
     832:	8a bd       	out	0x2a, r24	; 42
     834:	4f cd       	rjmp	.-1378   	; 0x2d4 <play_note+0x22>
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
     836:	85 e0       	ldi	r24, 0x05	; 5
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	9b bd       	out	0x2b, r25	; 43
     83c:	8a bd       	out	0x2a, r24	; 42
     83e:	4a cd       	rjmp	.-1388   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
     840:	8a e9       	ldi	r24, 0x9A	; 154
     842:	9a e1       	ldi	r25, 0x1A	; 26
     844:	9b bd       	out	0x2b, r25	; 43
     846:	8a bd       	out	0x2a, r24	; 42
     848:	45 cd       	rjmp	.-1398   	; 0x2d4 <play_note+0x22>
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
     84a:	8c e4       	ldi	r24, 0x4C	; 76
     84c:	9d e0       	ldi	r25, 0x0D	; 13
     84e:	9b bd       	out	0x2b, r25	; 43
     850:	8a bd       	out	0x2a, r24	; 42
     852:	40 cd       	rjmp	.-1408   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
     854:	8d ee       	ldi	r24, 0xED	; 237
     856:	93 e1       	ldi	r25, 0x13	; 19
     858:	9b bd       	out	0x2b, r25	; 43
     85a:	8a bd       	out	0x2a, r24	; 42
     85c:	3b cd       	rjmp	.-1418   	; 0x2d4 <play_note+0x22>
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
     85e:	83 ef       	ldi	r24, 0xF3	; 243
     860:	93 e0       	ldi	r25, 0x03	; 3
     862:	9b bd       	out	0x2b, r25	; 43
     864:	8a bd       	out	0x2a, r24	; 42
     866:	36 cd       	rjmp	.-1428   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
     868:	8f e6       	ldi	r24, 0x6F	; 111
     86a:	94 e0       	ldi	r25, 0x04	; 4
     86c:	9b bd       	out	0x2b, r25	; 43
     86e:	8a bd       	out	0x2a, r24	; 42
     870:	31 cd       	rjmp	.-1438   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
     872:	88 ed       	ldi	r24, 0xD8	; 216
     874:	9b e0       	ldi	r25, 0x0B	; 11
     876:	9b bd       	out	0x2b, r25	; 43
     878:	8a bd       	out	0x2a, r24	; 42
     87a:	2c cd       	rjmp	.-1448   	; 0x2d4 <play_note+0x22>
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
     87c:	8e e1       	ldi	r24, 0x1E	; 30
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	9b bd       	out	0x2b, r25	; 43
     882:	8a bd       	out	0x2a, r24	; 42
     884:	27 cd       	rjmp	.-1458   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
     886:	82 e2       	ldi	r24, 0x22	; 34
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	9b bd       	out	0x2b, r25	; 43
     88c:	8a bd       	out	0x2a, r24	; 42
     88e:	22 cd       	rjmp	.-1468   	; 0x2d4 <play_note+0x22>
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
     890:	85 ef       	ldi	r24, 0xF5	; 245
     892:	92 e0       	ldi	r25, 0x02	; 2
     894:	9b bd       	out	0x2b, r25	; 43
     896:	8a bd       	out	0x2a, r24	; 42
     898:	1d cd       	rjmp	.-1478   	; 0x2d4 <play_note+0x22>
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
     89a:	80 ed       	ldi	r24, 0xD0	; 208
     89c:	9f e0       	ldi	r25, 0x0F	; 15
     89e:	9b bd       	out	0x2b, r25	; 43
     8a0:	8a bd       	out	0x2a, r24	; 42
     8a2:	18 cd       	rjmp	.-1488   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
     8a4:	8d e0       	ldi	r24, 0x0D	; 13
     8a6:	90 e0       	ldi	r25, 0x00	; 0
     8a8:	9b bd       	out	0x2b, r25	; 43
     8aa:	8a bd       	out	0x2a, r24	; 42
     8ac:	13 cd       	rjmp	.-1498   	; 0x2d4 <play_note+0x22>
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
     8ae:	8f ed       	ldi	r24, 0xDF	; 223
     8b0:	98 e0       	ldi	r25, 0x08	; 8
     8b2:	9b bd       	out	0x2b, r25	; 43
     8b4:	8a bd       	out	0x2a, r24	; 42
     8b6:	0e cd       	rjmp	.-1508   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
     8b8:	86 ef       	ldi	r24, 0xF6	; 246
     8ba:	99 e0       	ldi	r25, 0x09	; 9
     8bc:	9b bd       	out	0x2b, r25	; 43
     8be:	8a bd       	out	0x2a, r24	; 42
     8c0:	09 cd       	rjmp	.-1518   	; 0x2d4 <play_note+0x22>
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
     8c2:	8a ef       	ldi	r24, 0xFA	; 250
     8c4:	94 e0       	ldi	r25, 0x04	; 4
     8c6:	9b bd       	out	0x2b, r25	; 43
     8c8:	8a bd       	out	0x2a, r24	; 42
     8ca:	04 cd       	rjmp	.-1528   	; 0x2d4 <play_note+0x22>

000008cc <song0>:
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8cc:	86 34       	cpi	r24, 0x46	; 70
     8ce:	91 05       	cpc	r25, r1
     8d0:	20 f0       	brcs	.+8      	; 0x8da <song0+0xe>
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
     8d2:	8f ef       	ldi	r24, 0xFF	; 255
     8d4:	80 93 67 01 	sts	0x0167, r24
     8d8:	08 95       	ret
volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
     8da:	fc 01       	movw	r30, r24
     8dc:	e2 57       	subi	r30, 0x72	; 114
     8de:	ff 4f       	sbci	r31, 0xFF	; 255
     8e0:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
     8e4:	22 e0       	ldi	r18, 0x02	; 2
     8e6:	44 e0       	ldi	r20, 0x04	; 4
     8e8:	60 e0       	ldi	r22, 0x00	; 0
     8ea:	81 e4       	ldi	r24, 0x41	; 65
     8ec:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
     8f0:	26 e0       	ldi	r18, 0x06	; 6
     8f2:	44 e0       	ldi	r20, 0x04	; 4
     8f4:	60 e0       	ldi	r22, 0x00	; 0
     8f6:	81 e4       	ldi	r24, 0x41	; 65
     8f8:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
     8fc:	22 e0       	ldi	r18, 0x02	; 2
     8fe:	44 e0       	ldi	r20, 0x04	; 4
     900:	61 e0       	ldi	r22, 0x01	; 1
     902:	81 e4       	ldi	r24, 0x41	; 65
     904:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
     908:	28 e0       	ldi	r18, 0x08	; 8
     90a:	44 e0       	ldi	r20, 0x04	; 4
     90c:	60 e0       	ldi	r22, 0x00	; 0
     90e:	84 e4       	ldi	r24, 0x44	; 68
     910:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
     914:	28 e0       	ldi	r18, 0x08	; 8
     916:	44 e0       	ldi	r20, 0x04	; 4
     918:	60 e0       	ldi	r22, 0x00	; 0
     91a:	86 e4       	ldi	r24, 0x46	; 70
     91c:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
     920:	26 e0       	ldi	r18, 0x06	; 6
     922:	44 e0       	ldi	r20, 0x04	; 4
     924:	61 e0       	ldi	r22, 0x01	; 1
     926:	82 e4       	ldi	r24, 0x42	; 66
     928:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
     92c:	28 e0       	ldi	r18, 0x08	; 8
     92e:	44 e0       	ldi	r20, 0x04	; 4
     930:	60 e0       	ldi	r22, 0x00	; 0
     932:	83 e4       	ldi	r24, 0x43	; 67
     934:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
     938:	28 e0       	ldi	r18, 0x08	; 8
     93a:	44 e0       	ldi	r20, 0x04	; 4
     93c:	60 e0       	ldi	r22, 0x00	; 0
     93e:	81 e4       	ldi	r24, 0x41	; 65
     940:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 67: play_note('G', 0, 4, 8);
     944:	28 e0       	ldi	r18, 0x08	; 8
     946:	44 e0       	ldi	r20, 0x04	; 4
     948:	60 e0       	ldi	r22, 0x00	; 0
     94a:	87 e4       	ldi	r24, 0x47	; 71
     94c:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
     950:	28 e0       	ldi	r18, 0x08	; 8
     952:	44 e0       	ldi	r20, 0x04	; 4
     954:	60 e0       	ldi	r22, 0x00	; 0
     956:	85 e4       	ldi	r24, 0x45	; 69
     958:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
     95c:	20 e1       	ldi	r18, 0x10	; 16
     95e:	44 e0       	ldi	r20, 0x04	; 4
     960:	60 e0       	ldi	r22, 0x00	; 0
     962:	81 e4       	ldi	r24, 0x41	; 65
     964:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
     968:	24 e0       	ldi	r18, 0x04	; 4
     96a:	45 e0       	ldi	r20, 0x05	; 5
     96c:	60 e0       	ldi	r22, 0x00	; 0
     96e:	83 e4       	ldi	r24, 0x43	; 67
     970:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 65: play_note('D', 0, 5, 4);
     974:	24 e0       	ldi	r18, 0x04	; 4
     976:	45 e0       	ldi	r20, 0x05	; 5
     978:	60 e0       	ldi	r22, 0x00	; 0
     97a:	84 e4       	ldi	r24, 0x44	; 68
     97c:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     980:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     982:	10 92 78 01 	sts	0x0178, r1
     986:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     98a:	88 e0       	ldi	r24, 0x08	; 8
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	90 93 76 01 	sts	0x0176, r25
     992:	80 93 75 01 	sts	0x0175, r24
     996:	08 95       	ret
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     998:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     99a:	10 92 78 01 	sts	0x0178, r1
     99e:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     9a2:	81 e0       	ldi	r24, 0x01	; 1
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	90 93 76 01 	sts	0x0176, r25
     9aa:	80 93 75 01 	sts	0x0175, r24
     9ae:	08 95       	ret
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
     9b0:	20 e1       	ldi	r18, 0x10	; 16
     9b2:	44 e0       	ldi	r20, 0x04	; 4
     9b4:	61 e0       	ldi	r22, 0x01	; 1
     9b6:	82 e4       	ldi	r24, 0x42	; 66
     9b8:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
     9bc:	28 e0       	ldi	r18, 0x08	; 8
     9be:	44 e0       	ldi	r20, 0x04	; 4
     9c0:	61 e0       	ldi	r22, 0x01	; 1
     9c2:	82 e4       	ldi	r24, 0x42	; 66
     9c4:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
     9c8:	28 e1       	ldi	r18, 0x18	; 24
     9ca:	44 e0       	ldi	r20, 0x04	; 4
     9cc:	60 e0       	ldi	r22, 0x00	; 0
     9ce:	87 e4       	ldi	r24, 0x47	; 71
     9d0:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
     9d4:	20 e1       	ldi	r18, 0x10	; 16
     9d6:	45 e0       	ldi	r20, 0x05	; 5
     9d8:	60 e0       	ldi	r22, 0x00	; 0
     9da:	84 e4       	ldi	r24, 0x44	; 68
     9dc:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= mute;
     9e0:	92 9a       	sbi	0x12, 2	; 18
  beat=0;
     9e2:	10 92 78 01 	sts	0x0178, r1
     9e6:	10 92 77 01 	sts	0x0177, r1
  max_beat = duration;
     9ea:	82 e0       	ldi	r24, 0x02	; 2
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	90 93 76 01 	sts	0x0176, r25
     9f2:	80 93 75 01 	sts	0x0175, r24
     9f6:	08 95       	ret
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
     9f8:	24 e0       	ldi	r18, 0x04	; 4
     9fa:	44 e0       	ldi	r20, 0x04	; 4
     9fc:	60 e0       	ldi	r22, 0x00	; 0
     9fe:	81 e4       	ldi	r24, 0x41	; 65
     a00:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
     a04:	26 e0       	ldi	r18, 0x06	; 6
     a06:	44 e0       	ldi	r20, 0x04	; 4
     a08:	60 e0       	ldi	r22, 0x00	; 0
     a0a:	87 e4       	ldi	r24, 0x47	; 71
     a0c:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
     a10:	24 e0       	ldi	r18, 0x04	; 4
     a12:	44 e0       	ldi	r20, 0x04	; 4
     a14:	61 e0       	ldi	r22, 0x01	; 1
     a16:	87 e4       	ldi	r24, 0x47	; 71
     a18:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
     a1c:	28 e0       	ldi	r18, 0x08	; 8
     a1e:	44 e0       	ldi	r20, 0x04	; 4
     a20:	61 e0       	ldi	r22, 0x01	; 1
     a22:	87 e4       	ldi	r24, 0x47	; 71
     a24:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
     a28:	23 e0       	ldi	r18, 0x03	; 3
     a2a:	44 e0       	ldi	r20, 0x04	; 4
     a2c:	60 e0       	ldi	r22, 0x00	; 0
     a2e:	87 e4       	ldi	r24, 0x47	; 71
     a30:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
     a34:	20 e1       	ldi	r18, 0x10	; 16
     a36:	44 e0       	ldi	r20, 0x04	; 4
     a38:	60 e0       	ldi	r22, 0x00	; 0
     a3a:	84 e4       	ldi	r24, 0x44	; 68
     a3c:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
     a40:	20 e1       	ldi	r18, 0x10	; 16
     a42:	45 e0       	ldi	r20, 0x05	; 5
     a44:	60 e0       	ldi	r22, 0x00	; 0
     a46:	83 e4       	ldi	r24, 0x43	; 67
     a48:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
     a4c:	22 e0       	ldi	r18, 0x02	; 2
     a4e:	44 e0       	ldi	r20, 0x04	; 4
     a50:	61 e0       	ldi	r22, 0x01	; 1
     a52:	82 e4       	ldi	r24, 0x42	; 66
     a54:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
     a58:	24 e0       	ldi	r18, 0x04	; 4
     a5a:	45 e0       	ldi	r20, 0x05	; 5
     a5c:	61 e0       	ldi	r22, 0x01	; 1
     a5e:	84 e4       	ldi	r24, 0x44	; 68
     a60:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
     a64:	24 e0       	ldi	r18, 0x04	; 4
     a66:	44 e0       	ldi	r20, 0x04	; 4
     a68:	61 e0       	ldi	r22, 0x01	; 1
     a6a:	81 e4       	ldi	r24, 0x41	; 65
     a6c:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
     a70:	28 e0       	ldi	r18, 0x08	; 8
     a72:	44 e0       	ldi	r20, 0x04	; 4
     a74:	60 e0       	ldi	r22, 0x00	; 0
     a76:	82 e4       	ldi	r24, 0x42	; 66
     a78:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
     a7c:	28 e1       	ldi	r18, 0x18	; 24
     a7e:	44 e0       	ldi	r20, 0x04	; 4
     a80:	60 e0       	ldi	r22, 0x00	; 0
     a82:	86 e4       	ldi	r24, 0x46	; 70
     a84:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
     a88:	27 e0       	ldi	r18, 0x07	; 7
     a8a:	44 e0       	ldi	r20, 0x04	; 4
     a8c:	60 e0       	ldi	r22, 0x00	; 0
     a8e:	87 e4       	ldi	r24, 0x47	; 71
     a90:	0c 94 59 01 	jmp	0x2b2	; 0x2b2 <play_note>

00000a94 <play_song>:
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     a94:	86 2f       	mov	r24, r22
     a96:	90 e0       	ldi	r25, 0x00	; 0
     a98:	0c 94 66 04 	jmp	0x8cc	; 0x8cc <song0>

00000a9c <music_off>:
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     a9c:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     aa0:	8e b5       	in	r24, 0x2e	; 46
     aa2:	8c 7f       	andi	r24, 0xFC	; 252
     aa4:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     aa6:	92 9a       	sbi	0x12, 2	; 18
     aa8:	08 95       	ret

00000aaa <music_on>:
}

void music_on(void) {
  //this starts the alarm timer running
  notes=0;
     aaa:	10 92 67 01 	sts	0x0167, r1
  TCCR1B |= (1<<CS11)|(1<<CS10);
     aae:	8e b5       	in	r24, 0x2e	; 46
     ab0:	83 60       	ori	r24, 0x03	; 3
     ab2:	8e bd       	out	0x2e, r24	; 46
  //unmutes the output
  PORTD &= unmute;
     ab4:	92 98       	cbi	0x12, 2	; 18
  //and starts the selected song
  play_song(song, notes);
     ab6:	80 91 67 01 	lds	r24, 0x0167
     aba:	90 91 74 01 	lds	r25, 0x0174
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	0c 94 66 04 	jmp	0x8cc	; 0x8cc <song0>

00000ac4 <music_init>:
  play_song(song, notes);
}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  DDRD |= (1<<PD7);
     ac4:	8f 9a       	sbi	0x11, 7	; 17
  TIMSK |= (1<<OCIE1A) | (1<<TOIE0);  //enable timer interrupt 1 on compare
     ac6:	87 b7       	in	r24, 0x37	; 55
     ac8:	81 61       	ori	r24, 0x11	; 17
     aca:	87 bf       	out	0x37, r24	; 55
  TCCR1A = 0x00;         //TCNT1, normal port operation
     acc:	1f bc       	out	0x2f, r1	; 47
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
     ace:	8e b5       	in	r24, 0x2e	; 46
     ad0:	88 60       	ori	r24, 0x08	; 8
     ad2:	8e bd       	out	0x2e, r24	; 46
  TCCR1C = 0x00;         //no forced compare
     ad4:	10 92 7a 00 	sts	0x007A, r1
  OCR1A = 0x0033;        //(use to vary alarm frequency)
     ad8:	83 e3       	ldi	r24, 0x33	; 51
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	9b bd       	out	0x2b, r25	; 43
     ade:	8a bd       	out	0x2a, r24	; 42
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     ae0:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     ae4:	8e b5       	in	r24, 0x2e	; 46
     ae6:	8c 7f       	andi	r24, 0xFC	; 252
     ae8:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     aea:	92 9a       	sbi	0x12, 2	; 18
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0033;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
     aec:	10 92 78 01 	sts	0x0178, r1
     af0:	10 92 77 01 	sts	0x0177, r1
  max_beat = 0;
     af4:	10 92 76 01 	sts	0x0176, r1
     af8:	10 92 75 01 	sts	0x0175, r1
  notes = 0;
     afc:	10 92 67 01 	sts	0x0167, r1
  song = 0;              //beaver fight song
     b00:	10 92 74 01 	sts	0x0174, r1
     b04:	08 95       	ret

00000b06 <chk_buttons>:
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b06:	20 91 58 01 	lds	r18, 0x0158
     b0a:	30 91 59 01 	lds	r19, 0x0159
     b0e:	22 0f       	add	r18, r18
     b10:	33 1f       	adc	r19, r19
     b12:	49 b3       	in	r20, 0x19	; 25
     b14:	50 e0       	ldi	r21, 0x00	; 0
     b16:	02 c0       	rjmp	.+4      	; 0xb1c <chk_buttons+0x16>
     b18:	55 95       	asr	r21
     b1a:	47 95       	ror	r20
     b1c:	8a 95       	dec	r24
     b1e:	e2 f7       	brpl	.-8      	; 0xb18 <chk_buttons+0x12>
     b20:	40 fd       	sbrc	r20, 0
     b22:	0e c0       	rjmp	.+28     	; 0xb40 <chk_buttons+0x3a>
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	90 ee       	ldi	r25, 0xE0	; 224
     b28:	28 2b       	or	r18, r24
     b2a:	39 2b       	or	r19, r25
     b2c:	30 93 59 01 	sts	0x0159, r19
     b30:	20 93 58 01 	sts	0x0158, r18
	if (state == 0xF000){
     b34:	81 e0       	ldi	r24, 0x01	; 1
     b36:	21 15       	cp	r18, r1
     b38:	30 4f       	sbci	r19, 0xF0	; 240
     b3a:	09 f0       	breq	.+2      	; 0xb3e <chk_buttons+0x38>
     b3c:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}
	return 0;
}
     b3e:	08 95       	ret
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	90 ee       	ldi	r25, 0xE0	; 224
     b44:	f1 cf       	rjmp	.-30     	; 0xb28 <chk_buttons+0x22>

00000b46 <int2seg>:
//***********************************************************************************
// int2seg
// return the 7-segment code for each digit
//***********************************************************************************
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
     b46:	81 11       	cpse	r24, r1
     b48:	02 c0       	rjmp	.+4      	; 0xb4e <int2seg+0x8>
		return ZERO;
     b4a:	80 ec       	ldi	r24, 0xC0	; 192
     b4c:	08 95       	ret
	}
	else if(number == 1 ){
     b4e:	81 30       	cpi	r24, 0x01	; 1
     b50:	91 f0       	breq	.+36     	; 0xb76 <int2seg+0x30>
		return ONE;
	}
	else if(number == 2 ){
     b52:	82 30       	cpi	r24, 0x02	; 2
     b54:	91 f0       	breq	.+36     	; 0xb7a <int2seg+0x34>
		return TWO;
	}
	else if(number == 3 ){
     b56:	83 30       	cpi	r24, 0x03	; 3
     b58:	a1 f0       	breq	.+40     	; 0xb82 <int2seg+0x3c>
		return THREE;
	}
	else if(number == 4 ){
     b5a:	84 30       	cpi	r24, 0x04	; 4
     b5c:	81 f0       	breq	.+32     	; 0xb7e <int2seg+0x38>
		return FOUR;
	}
	else if(number == 5 ){
     b5e:	85 30       	cpi	r24, 0x05	; 5
     b60:	91 f0       	breq	.+36     	; 0xb86 <int2seg+0x40>
		return FIVE;
	}
	else if(number == 6 ){
     b62:	86 30       	cpi	r24, 0x06	; 6
     b64:	91 f0       	breq	.+36     	; 0xb8a <int2seg+0x44>
		return  SIX;
	}
	else if(number == 7 ){
     b66:	87 30       	cpi	r24, 0x07	; 7
     b68:	91 f0       	breq	.+36     	; 0xb8e <int2seg+0x48>
		return SEVEN;
	}
	else if(number == 8 ){
     b6a:	88 30       	cpi	r24, 0x08	; 8
     b6c:	91 f0       	breq	.+36     	; 0xb92 <int2seg+0x4c>
		return EIGHT;
	}
	else if(number == 9 ){
     b6e:	89 30       	cpi	r24, 0x09	; 9
     b70:	91 f0       	breq	.+36     	; 0xb96 <int2seg+0x50>
		return NINE;
	}
	else{ 
		return 0;
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	08 95       	ret
uint8_t int2seg(uint8_t number){
	if(number == 0 ){
		return ZERO;
	}
	else if(number == 1 ){
		return ONE;
     b76:	89 ef       	ldi	r24, 0xF9	; 249
     b78:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
     b7a:	84 ea       	ldi	r24, 0xA4	; 164
     b7c:	08 95       	ret
	}
	else if(number == 3 ){
		return THREE;
	}
	else if(number == 4 ){
		return FOUR;
     b7e:	89 e9       	ldi	r24, 0x99	; 153
     b80:	08 95       	ret
	}
	else if(number == 2 ){
		return TWO;
	}
	else if(number == 3 ){
		return THREE;
     b82:	80 eb       	ldi	r24, 0xB0	; 176
     b84:	08 95       	ret
	}
	else if(number == 4 ){
		return FOUR;
	}
	else if(number == 5 ){
		return FIVE;
     b86:	82 e9       	ldi	r24, 0x92	; 146
     b88:	08 95       	ret
	}
	else if(number == 6 ){
		return  SIX;
     b8a:	82 e8       	ldi	r24, 0x82	; 130
     b8c:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
     b8e:	88 ef       	ldi	r24, 0xF8	; 248
		return NINE;
	}
	else{ 
		return 0;
	}
}
     b90:	08 95       	ret
	}
	else if(number == 7 ){
		return SEVEN;
	}
	else if(number == 8 ){
		return EIGHT;
     b92:	80 e8       	ldi	r24, 0x80	; 128
     b94:	08 95       	ret
	}
	else if(number == 9 ){
		return NINE;
     b96:	80 e9       	ldi	r24, 0x90	; 144
     b98:	08 95       	ret

00000b9a <segsum>:
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************

void segsum(uint16_t sum) {
     b9a:	ff 92       	push	r15
     b9c:	0f 93       	push	r16
     b9e:	1f 93       	push	r17
     ba0:	cf 93       	push	r28
     ba2:	df 93       	push	r29
     ba4:	ec 01       	movw	r28, r24
	//determine how many digits there are 
	//int digit;
	// Break down the digits

	if(ticker%2 == 1){
     ba6:	80 91 5a 01 	lds	r24, 0x015A
     baa:	80 ff       	sbrs	r24, 0
     bac:	82 c0       	rjmp	.+260    	; 0xcb2 <segsum+0x118>
		segment_data[2] = 0xFC;
     bae:	8c ef       	ldi	r24, 0xFC	; 252
     bb0:	80 93 80 01 	sts	0x0180, r24
		segment_data[2] = 0xFF;
	} 
	//When setting alarm is on)
	//break up decimal sum into 4 digit-segments

	segment_data[0] = int2seg(sum % 10); //ones
     bb4:	9e 01       	movw	r18, r28
     bb6:	ad ec       	ldi	r26, 0xCD	; 205
     bb8:	bc ec       	ldi	r27, 0xCC	; 204
     bba:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <__umulhisi3>
     bbe:	96 95       	lsr	r25
     bc0:	87 95       	ror	r24
     bc2:	96 95       	lsr	r25
     bc4:	87 95       	ror	r24
     bc6:	96 95       	lsr	r25
     bc8:	87 95       	ror	r24
     bca:	3c 2f       	mov	r19, r28
     bcc:	2a e0       	ldi	r18, 0x0A	; 10
     bce:	82 9f       	mul	r24, r18
     bd0:	30 19       	sub	r19, r0
     bd2:	11 24       	eor	r1, r1
     bd4:	83 2f       	mov	r24, r19
     bd6:	0e 94 a3 05 	call	0xb46	; 0xb46 <int2seg>
     bda:	f8 2e       	mov	r15, r24
	segment_data[1] = int2seg((sum % 100)/10); //tens
     bdc:	9e 01       	movw	r18, r28
     bde:	36 95       	lsr	r19
     be0:	27 95       	ror	r18
     be2:	36 95       	lsr	r19
     be4:	27 95       	ror	r18
     be6:	ab e7       	ldi	r26, 0x7B	; 123
     be8:	b4 e1       	ldi	r27, 0x14	; 20
     bea:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <__umulhisi3>
     bee:	96 95       	lsr	r25
     bf0:	87 95       	ror	r24
     bf2:	44 e6       	ldi	r20, 0x64	; 100
     bf4:	48 9f       	mul	r20, r24
     bf6:	90 01       	movw	r18, r0
     bf8:	49 9f       	mul	r20, r25
     bfa:	30 0d       	add	r19, r0
     bfc:	11 24       	eor	r1, r1
     bfe:	ce 01       	movw	r24, r28
     c00:	82 1b       	sub	r24, r18
     c02:	93 0b       	sbc	r25, r19
     c04:	9c 01       	movw	r18, r24
     c06:	ad ec       	ldi	r26, 0xCD	; 205
     c08:	bc ec       	ldi	r27, 0xCC	; 204
     c0a:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <__umulhisi3>
     c0e:	96 95       	lsr	r25
     c10:	87 95       	ror	r24
     c12:	96 95       	lsr	r25
     c14:	87 95       	ror	r24
     c16:	96 95       	lsr	r25
     c18:	87 95       	ror	r24
     c1a:	0e 94 a3 05 	call	0xb46	; 0xb46 <int2seg>
     c1e:	80 93 7f 01 	sts	0x017F, r24
	//segment_data[2] = 1; //decimal
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
     c22:	9e 01       	movw	r18, r28
     c24:	36 95       	lsr	r19
     c26:	27 95       	ror	r18
     c28:	36 95       	lsr	r19
     c2a:	27 95       	ror	r18
     c2c:	36 95       	lsr	r19
     c2e:	27 95       	ror	r18
     c30:	a5 ec       	ldi	r26, 0xC5	; 197
     c32:	b0 e2       	ldi	r27, 0x20	; 32
     c34:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <__umulhisi3>
     c38:	8c 01       	movw	r16, r24
     c3a:	12 95       	swap	r17
     c3c:	02 95       	swap	r16
     c3e:	0f 70       	andi	r16, 0x0F	; 15
     c40:	01 27       	eor	r16, r17
     c42:	1f 70       	andi	r17, 0x0F	; 15
     c44:	01 27       	eor	r16, r17
     c46:	48 ee       	ldi	r20, 0xE8	; 232
     c48:	53 e0       	ldi	r21, 0x03	; 3
     c4a:	04 9f       	mul	r16, r20
     c4c:	90 01       	movw	r18, r0
     c4e:	05 9f       	mul	r16, r21
     c50:	30 0d       	add	r19, r0
     c52:	14 9f       	mul	r17, r20
     c54:	30 0d       	add	r19, r0
     c56:	11 24       	eor	r1, r1
     c58:	ce 01       	movw	r24, r28
     c5a:	82 1b       	sub	r24, r18
     c5c:	93 0b       	sbc	r25, r19
     c5e:	9c 01       	movw	r18, r24
     c60:	36 95       	lsr	r19
     c62:	27 95       	ror	r18
     c64:	36 95       	lsr	r19
     c66:	27 95       	ror	r18
     c68:	ab e7       	ldi	r26, 0x7B	; 123
     c6a:	b4 e1       	ldi	r27, 0x14	; 20
     c6c:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <__umulhisi3>
     c70:	96 95       	lsr	r25
     c72:	87 95       	ror	r24
     c74:	0e 94 a3 05 	call	0xb46	; 0xb46 <int2seg>
     c78:	80 93 81 01 	sts	0x0181, r24
	segment_data[4] = int2seg(sum/1000); //thousands
     c7c:	80 2f       	mov	r24, r16
     c7e:	0e 94 a3 05 	call	0xb46	; 0xb46 <int2seg>
     c82:	80 93 82 01 	sts	0x0182, r24
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
     c86:	80 91 40 01 	lds	r24, 0x0140
     c8a:	88 23       	and	r24, r24
     c8c:	21 f0       	breq	.+8      	; 0xc96 <segsum+0xfc>
     c8e:	80 91 66 01 	lds	r24, 0x0166
     c92:	81 11       	cpse	r24, r1
     c94:	12 c0       	rjmp	.+36     	; 0xcba <segsum+0x120>
		segment_data[0] &= 0x7F;
	}
	else{
		segment_data[0] |= 0b10000000;
     c96:	8f 2d       	mov	r24, r15
     c98:	80 68       	ori	r24, 0x80	; 128
     c9a:	80 93 7e 01 	sts	0x017E, r24
	}
	if(mode == 1 && blink){
     c9e:	80 91 60 01 	lds	r24, 0x0160
     ca2:	81 30       	cpi	r24, 0x01	; 1
     ca4:	91 f0       	breq	.+36     	; 0xcca <segsum+0x130>
		segment_data[4] = 0xFF;
		segment_data[3] = 0xFF;
		segment_data[1] = 0xFF;
		segment_data[0] = 0xFF;
	}
}//segment_sum
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	1f 91       	pop	r17
     cac:	0f 91       	pop	r16
     cae:	ff 90       	pop	r15
     cb0:	08 95       	ret

	if(ticker%2 == 1){
		segment_data[2] = 0xFC;
	}
	else{
		segment_data[2] = 0xFF;
     cb2:	8f ef       	ldi	r24, 0xFF	; 255
     cb4:	80 93 80 01 	sts	0x0180, r24
     cb8:	7d cf       	rjmp	.-262    	; 0xbb4 <segsum+0x1a>
	segment_data[3] = int2seg((sum % 1000)/100); //hundreds
	segment_data[4] = int2seg(sum/1000); //thousands
	//blank out leading zero digits 
	//now move data to right place for misplaced colon position
	if(am_pm && show_ampm){
		segment_data[0] &= 0x7F;
     cba:	8f 2d       	mov	r24, r15
     cbc:	8f 77       	andi	r24, 0x7F	; 127
     cbe:	80 93 7e 01 	sts	0x017E, r24
	}
	else{
		segment_data[0] |= 0b10000000;
	}
	if(mode == 1 && blink){
     cc2:	80 91 60 01 	lds	r24, 0x0160
     cc6:	81 30       	cpi	r24, 0x01	; 1
     cc8:	71 f7       	brne	.-36     	; 0xca6 <segsum+0x10c>
     cca:	80 91 37 01 	lds	r24, 0x0137
     cce:	88 23       	and	r24, r24
     cd0:	51 f3       	breq	.-44     	; 0xca6 <segsum+0x10c>
		segment_data[4] = 0xFF;
     cd2:	8f ef       	ldi	r24, 0xFF	; 255
     cd4:	80 93 82 01 	sts	0x0182, r24
		segment_data[3] = 0xFF;
     cd8:	80 93 81 01 	sts	0x0181, r24
		segment_data[1] = 0xFF;
     cdc:	80 93 7f 01 	sts	0x017F, r24
		segment_data[0] = 0xFF;
     ce0:	80 93 7e 01 	sts	0x017E, r24
	}
}//segment_sum
     ce4:	df 91       	pop	r29
     ce6:	cf 91       	pop	r28
     ce8:	1f 91       	pop	r17
     cea:	0f 91       	pop	r16
     cec:	ff 90       	pop	r15
     cee:	08 95       	ret

00000cf0 <button_routine>:
//***********************************************************************************
void button_routine(){
     cf0:	1f 93       	push	r17
     cf2:	cf 93       	push	r28
     cf4:	df 93       	push	r29
	// L -> R
	// 3 2 1 0 7 6 5 4
	uint8_t button = 0;
	//static int previous_mode;   
	DDRA  = 0x00; // PORTA input mode
     cf6:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0xFF; //Pull ups
     cf8:	8f ef       	ldi	r24, 0xFF	; 255
     cfa:	8b bb       	out	0x1b, r24	; 27
	__asm__ __volatile__ ("nop");
     cfc:	00 00       	nop
	__asm__ __volatile__ ("nop");
     cfe:	00 00       	nop
	//enable tristate buffer for pushbutton switches
	PORTB |= 0x70; //Set S2,S1,S0 to 111
     d00:	88 b3       	in	r24, 0x18	; 24
     d02:	80 67       	ori	r24, 0x70	; 112
     d04:	88 bb       	out	0x18, r24	; 24
	__asm__ __volatile__ ("nop");
     d06:	00 00       	nop
	__asm__ __volatile__ ("nop");
     d08:	00 00       	nop
     d0a:	20 e0       	ldi	r18, 0x00	; 0
     d0c:	30 e0       	ldi	r19, 0x00	; 0
				case 7:
					if(alarm_on && music_status){
						music_off();
						music_status = 0;
					}
					alarm_on = !alarm_on;
     d0e:	d1 e0       	ldi	r29, 0x01	; 1
				case 3:
					if(mode == 3){
						mode = 0;			
					}
					else{
						mode = 3;
     d10:	c3 e0       	ldi	r28, 0x03	; 3
				case 2:
					if(mode == 2){
						mode = 0;	
					}
					else{
						mode = 2;
     d12:	12 e0       	ldi	r17, 0x02	; 2
     d14:	10 c0       	rjmp	.+32     	; 0xd36 <button_routine+0x46>
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d16:	61 e0       	ldi	r22, 0x01	; 1
     d18:	70 ee       	ldi	r23, 0xE0	; 224
     d1a:	46 2b       	or	r20, r22
     d1c:	57 2b       	or	r21, r23
     d1e:	50 93 59 01 	sts	0x0159, r21
     d22:	40 93 58 01 	sts	0x0158, r20
	if (state == 0xF000){
     d26:	41 15       	cp	r20, r1
     d28:	50 4f       	sbci	r21, 0xF0	; 240
     d2a:	c9 f0       	breq	.+50     	; 0xd5e <button_routine+0x6e>
     d2c:	2f 5f       	subi	r18, 0xFF	; 255
     d2e:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d30:	28 30       	cpi	r18, 0x08	; 8
     d32:	31 05       	cpc	r19, r1
     d34:	71 f1       	breq	.+92     	; 0xd92 <button_routine+0xa2>
     d36:	82 2f       	mov	r24, r18
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
int8_t chk_buttons(uint8_t button){
	static uint16_t state = 0;
	state = (state << 1) | (bit_is_clear(PINA, button) | 0xE000);
     d38:	40 91 58 01 	lds	r20, 0x0158
     d3c:	50 91 59 01 	lds	r21, 0x0159
     d40:	44 0f       	add	r20, r20
     d42:	55 1f       	adc	r21, r21
     d44:	69 b3       	in	r22, 0x19	; 25
     d46:	70 e0       	ldi	r23, 0x00	; 0
     d48:	02 2e       	mov	r0, r18
     d4a:	02 c0       	rjmp	.+4      	; 0xd50 <button_routine+0x60>
     d4c:	75 95       	asr	r23
     d4e:	67 95       	ror	r22
     d50:	0a 94       	dec	r0
     d52:	e2 f7       	brpl	.-8      	; 0xd4c <button_routine+0x5c>
     d54:	60 ff       	sbrs	r22, 0
     d56:	df cf       	rjmp	.-66     	; 0xd16 <button_routine+0x26>
     d58:	60 e0       	ldi	r22, 0x00	; 0
     d5a:	70 ee       	ldi	r23, 0xE0	; 224
     d5c:	de cf       	rjmp	.-68     	; 0xd1a <button_routine+0x2a>
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
		if (chk_buttons(button)){
			//Check the state of buttons
			switch(button){
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	88 30       	cpi	r24, 0x08	; 8
     d62:	91 05       	cpc	r25, r1
     d64:	78 f4       	brcc	.+30     	; 0xd84 <button_routine+0x94>
     d66:	8c 52       	subi	r24, 0x2C	; 44
     d68:	9f 4f       	sbci	r25, 0xFF	; 255
     d6a:	fc 01       	movw	r30, r24
     d6c:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
						music_status = 0;
						music_off();
					}
					break;
				case 7:
					if(alarm_on && music_status){
     d70:	80 91 39 01 	lds	r24, 0x0139
     d74:	81 11       	cpse	r24, r1
     d76:	54 c0       	rjmp	.+168    	; 0xe20 <button_routine+0x130>
     d78:	90 e0       	ldi	r25, 0x00	; 0
						music_off();
						music_status = 0;
					}
					alarm_on = !alarm_on;
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	91 11       	cpse	r25, r1
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	80 93 39 01 	sts	0x0139, r24
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     d84:	d0 93 49 01 	sts	0x0149, r29
     d88:	2f 5f       	subi	r18, 0xFF	; 255
     d8a:	3f 4f       	sbci	r19, 0xFF	; 255
	PORTB |= 0x70; //Set S2,S1,S0 to 111
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
	//now check each button and increment the count as needed

	for (button = 0 ; button < BUTTON_COUNT ; button++){
     d8c:	28 30       	cpi	r18, 0x08	; 8
     d8e:	31 05       	cpc	r19, r1
     d90:	91 f6       	brne	.-92     	; 0xd36 <button_routine+0x46>
					break;
			}
			bar_graph_flag = 1;	
		}
	}
	DDRA = 0xFF;  //switch PORTA to output
     d92:	8f ef       	ldi	r24, 0xFF	; 255
     d94:	8a bb       	out	0x1a, r24	; 26
	__asm__ __volatile__ ("nop"); //Buffer
     d96:	00 00       	nop
	__asm__ __volatile__ ("nop"); //Buffer 
     d98:	00 00       	nop

}
     d9a:	df 91       	pop	r29
     d9c:	cf 91       	pop	r28
     d9e:	1f 91       	pop	r17
     da0:	08 95       	ret
			switch(button){
				case 0:  
					mode = 0;
					break;
				case 1:
					if(mode == 1){
     da2:	80 91 60 01 	lds	r24, 0x0160
     da6:	81 30       	cpi	r24, 0x01	; 1
     da8:	91 f5       	brne	.+100    	; 0xe0e <button_routine+0x11e>
						mode = 0;	
     daa:	10 92 60 01 	sts	0x0160, r1
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     dae:	d0 93 49 01 	sts	0x0149, r29
     db2:	ea cf       	rjmp	.-44     	; 0xd88 <button_routine+0x98>
					else{
						mode = 1;
					}
					break;
				case 2:
					if(mode == 2){
     db4:	80 91 60 01 	lds	r24, 0x0160
     db8:	82 30       	cpi	r24, 0x02	; 2
     dba:	b9 f3       	breq	.-18     	; 0xdaa <button_routine+0xba>
						mode = 0;	
					}
					else{
						mode = 2;
     dbc:	10 93 60 01 	sts	0x0160, r17
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     dc0:	d0 93 49 01 	sts	0x0149, r29
     dc4:	e1 cf       	rjmp	.-62     	; 0xd88 <button_routine+0x98>
				case 5:
					show_ampm = !show_ampm;
					//show_temp = !show_temp;
					break;
				case 6:
					if(music_status){
     dc6:	80 91 38 01 	lds	r24, 0x0138
     dca:	88 23       	and	r24, r24
     dcc:	d9 f2       	breq	.-74     	; 0xd84 <button_routine+0x94>
						snooze_flag = 1;
     dce:	d0 93 3a 01 	sts	0x013A, r29
						music_status = 0;
     dd2:	10 92 38 01 	sts	0x0138, r1
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     dd6:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     dda:	8e b5       	in	r24, 0x2e	; 46
     ddc:	8c 7f       	andi	r24, 0xFC	; 252
     dde:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     de0:	92 9a       	sbi	0x12, 2	; 18
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     de2:	d0 93 49 01 	sts	0x0149, r29
     de6:	d0 cf       	rjmp	.-96     	; 0xd88 <button_routine+0x98>
					break;
				case 4:
					//show_temp = !show_temp;
					break;
				case 5:
					show_ampm = !show_ampm;
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	90 91 66 01 	lds	r25, 0x0166
     dee:	91 11       	cpse	r25, r1
     df0:	13 c0       	rjmp	.+38     	; 0xe18 <button_routine+0x128>
     df2:	80 93 66 01 	sts	0x0166, r24
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     df6:	d0 93 49 01 	sts	0x0149, r29
     dfa:	c6 cf       	rjmp	.-116    	; 0xd88 <button_routine+0x98>
					else{
						mode = 2;
					}
					break;
				case 3:
					if(mode == 3){
     dfc:	80 91 60 01 	lds	r24, 0x0160
     e00:	83 30       	cpi	r24, 0x03	; 3
     e02:	99 f2       	breq	.-90     	; 0xdaa <button_routine+0xba>
						mode = 0;			
					}
					else{
						mode = 3;
     e04:	c0 93 60 01 	sts	0x0160, r28
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     e08:	d0 93 49 01 	sts	0x0149, r29
     e0c:	bd cf       	rjmp	.-134    	; 0xd88 <button_routine+0x98>
				case 1:
					if(mode == 1){
						mode = 0;	
					}
					else{
						mode = 1;
     e0e:	d0 93 60 01 	sts	0x0160, r29
					//alarm_change = 1; 
					break;
				default:
					break;
			}
			bar_graph_flag = 1;	
     e12:	d0 93 49 01 	sts	0x0149, r29
     e16:	b8 cf       	rjmp	.-144    	; 0xd88 <button_routine+0x98>
					break;
				case 4:
					//show_temp = !show_temp;
					break;
				case 5:
					show_ampm = !show_ampm;
     e18:	80 e0       	ldi	r24, 0x00	; 0
     e1a:	80 93 66 01 	sts	0x0166, r24
     e1e:	eb cf       	rjmp	.-42     	; 0xdf6 <button_routine+0x106>
						music_status = 0;
						music_off();
					}
					break;
				case 7:
					if(alarm_on && music_status){
     e20:	90 91 38 01 	lds	r25, 0x0138
     e24:	99 23       	and	r25, r25
     e26:	59 f0       	breq	.+22     	; 0xe3e <button_routine+0x14e>
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
     e28:	10 92 67 01 	sts	0x0167, r1
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
     e2c:	8e b5       	in	r24, 0x2e	; 46
     e2e:	8c 7f       	andi	r24, 0xFC	; 252
     e30:	8e bd       	out	0x2e, r24	; 46
  //and mutes the output
  PORTD |= mute;
     e32:	92 9a       	sbi	0x12, 2	; 18
						music_off();
						music_status = 0;
     e34:	10 92 38 01 	sts	0x0138, r1
     e38:	90 91 39 01 	lds	r25, 0x0139
     e3c:	9e cf       	rjmp	.-196    	; 0xd7a <button_routine+0x8a>
     e3e:	98 2f       	mov	r25, r24
     e40:	9c cf       	rjmp	.-200    	; 0xd7a <button_routine+0x8a>

00000e42 <__vector_16>:
  Interrupt routine: set flag for checking button in main
  (Might cause an issue if button check takes too long to run, it will become
  polling instead of interrupt. Tried putting button routine in the ISR,
  LED dims
 ****************************************************************************/
ISR(TIMER0_OVF_vect){
     e42:	1f 92       	push	r1
     e44:	0f 92       	push	r0
     e46:	0f b6       	in	r0, 0x3f	; 63
     e48:	0f 92       	push	r0
     e4a:	11 24       	eor	r1, r1
     e4c:	0b b6       	in	r0, 0x3b	; 59
     e4e:	0f 92       	push	r0
     e50:	2f 93       	push	r18
     e52:	3f 93       	push	r19
     e54:	4f 93       	push	r20
     e56:	5f 93       	push	r21
     e58:	6f 93       	push	r22
     e5a:	7f 93       	push	r23
     e5c:	8f 93       	push	r24
     e5e:	9f 93       	push	r25
     e60:	af 93       	push	r26
     e62:	bf 93       	push	r27
     e64:	cf 93       	push	r28
     e66:	ef 93       	push	r30
     e68:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
     e6a:	20 91 57 01 	lds	r18, 0x0157
     e6e:	2f 5f       	subi	r18, 0xFF	; 255
     e70:	20 93 57 01 	sts	0x0157, r18
	//update_time();
	if(count%2 == 0){
     e74:	20 fd       	sbrc	r18, 0
     e76:	03 c0       	rjmp	.+6      	; 0xe7e <__vector_16+0x3c>
		update_LCD = 1;
     e78:	81 e0       	ldi	r24, 0x01	; 1
     e7a:	80 93 4b 01 	sts	0x014B, r24

	}
	if(count%8 == 0){
     e7e:	82 2f       	mov	r24, r18
     e80:	87 70       	andi	r24, 0x07	; 7
     e82:	81 f4       	brne	.+32     	; 0xea4 <__vector_16+0x62>
		//	update_LCD = 1;
		beat++;
     e84:	80 91 77 01 	lds	r24, 0x0177
     e88:	90 91 78 01 	lds	r25, 0x0178
     e8c:	01 96       	adiw	r24, 0x01	; 1
     e8e:	90 93 78 01 	sts	0x0178, r25
     e92:	80 93 77 01 	sts	0x0177, r24
		blink = !blink;
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	90 91 37 01 	lds	r25, 0x0137
     e9c:	91 11       	cpse	r25, r1
     e9e:	3f c0       	rjmp	.+126    	; 0xf1e <__vector_16+0xdc>
     ea0:	80 93 37 01 	sts	0x0137, r24
	}
	if((count%128)==0){
     ea4:	2f 77       	andi	r18, 0x7F	; 127
     ea6:	39 f5       	brne	.+78     	; 0xef6 <__vector_16+0xb4>
		ticker++;     
     ea8:	80 91 5a 01 	lds	r24, 0x015A
     eac:	8f 5f       	subi	r24, 0xFF	; 255
     eae:	80 93 5a 01 	sts	0x015A, r24
		second++; 
     eb2:	80 91 5f 01 	lds	r24, 0x015F
     eb6:	8f 5f       	subi	r24, 0xFF	; 255
     eb8:	80 93 5f 01 	sts	0x015F, r24
		reset_temp = 1;   
     ebc:	c1 e0       	ldi	r28, 0x01	; 1
     ebe:	c0 93 4a 01 	sts	0x014A, r28
		if(alarm_on){
     ec2:	80 91 39 01 	lds	r24, 0x0139
     ec6:	88 23       	and	r24, r24
     ec8:	b1 f0       	breq	.+44     	; 0xef6 <__vector_16+0xb4>
			if ((alarm_time == time) && !snooze_flag && !music_status){
     eca:	20 91 44 01 	lds	r18, 0x0144
     ece:	30 91 45 01 	lds	r19, 0x0145
     ed2:	80 91 46 01 	lds	r24, 0x0146
     ed6:	90 91 47 01 	lds	r25, 0x0147
     eda:	28 17       	cp	r18, r24
     edc:	39 07       	cpc	r19, r25
     ede:	41 f1       	breq	.+80     	; 0xf30 <__vector_16+0xee>
				//play music
				music_on();
				music_status = 1;
			}
			else if(snooze_flag){
     ee0:	80 91 3a 01 	lds	r24, 0x013A
     ee4:	88 23       	and	r24, r24
     ee6:	39 f0       	breq	.+14     	; 0xef6 <__vector_16+0xb4>
				snooze_second++;
     ee8:	80 91 3b 01 	lds	r24, 0x013B
     eec:	8f 5f       	subi	r24, 0xFF	; 255
     eee:	80 93 3b 01 	sts	0x013B, r24
				if(snooze_second >= 10){
     ef2:	8a 30       	cpi	r24, 0x0A	; 10
     ef4:	b0 f4       	brcc	.+44     	; 0xf22 <__vector_16+0xe0>
					snooze_second = 0;
				}	
			}
		}
	}
}
     ef6:	ff 91       	pop	r31
     ef8:	ef 91       	pop	r30
     efa:	cf 91       	pop	r28
     efc:	bf 91       	pop	r27
     efe:	af 91       	pop	r26
     f00:	9f 91       	pop	r25
     f02:	8f 91       	pop	r24
     f04:	7f 91       	pop	r23
     f06:	6f 91       	pop	r22
     f08:	5f 91       	pop	r21
     f0a:	4f 91       	pop	r20
     f0c:	3f 91       	pop	r19
     f0e:	2f 91       	pop	r18
     f10:	0f 90       	pop	r0
     f12:	0b be       	out	0x3b, r0	; 59
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	0f 90       	pop	r0
     f1a:	1f 90       	pop	r1
     f1c:	18 95       	reti

	}
	if(count%8 == 0){
		//	update_LCD = 1;
		beat++;
		blink = !blink;
     f1e:	80 e0       	ldi	r24, 0x00	; 0
     f20:	bf cf       	rjmp	.-130    	; 0xea0 <__vector_16+0x5e>
				music_status = 1;
			}
			else if(snooze_flag){
				snooze_second++;
				if(snooze_second >= 10){
					snooze_flag = 0;
     f22:	10 92 3a 01 	sts	0x013A, r1
					music_on();
     f26:	0e 94 55 05 	call	0xaaa	; 0xaaa <music_on>
					snooze_second = 0;
     f2a:	10 92 3b 01 	sts	0x013B, r1
     f2e:	e3 cf       	rjmp	.-58     	; 0xef6 <__vector_16+0xb4>
	if((count%128)==0){
		ticker++;     
		second++; 
		reset_temp = 1;   
		if(alarm_on){
			if ((alarm_time == time) && !snooze_flag && !music_status){
     f30:	80 91 3a 01 	lds	r24, 0x013A
     f34:	81 11       	cpse	r24, r1
     f36:	d8 cf       	rjmp	.-80     	; 0xee8 <__vector_16+0xa6>
     f38:	80 91 38 01 	lds	r24, 0x0138
     f3c:	81 11       	cpse	r24, r1
     f3e:	db cf       	rjmp	.-74     	; 0xef6 <__vector_16+0xb4>
				//play music
				music_on();
     f40:	0e 94 55 05 	call	0xaaa	; 0xaaa <music_on>
				music_status = 1;
     f44:	c0 93 38 01 	sts	0x0138, r28
     f48:	d6 cf       	rjmp	.-84     	; 0xef6 <__vector_16+0xb4>

00000f4a <__vector_12>:
			}
		}
	}
}

ISR(TIMER1_COMPA_vect){
     f4a:	1f 92       	push	r1
     f4c:	0f 92       	push	r0
     f4e:	0f b6       	in	r0, 0x3f	; 63
     f50:	0f 92       	push	r0
     f52:	11 24       	eor	r1, r1
     f54:	0b b6       	in	r0, 0x3b	; 59
     f56:	0f 92       	push	r0
     f58:	2f 93       	push	r18
     f5a:	3f 93       	push	r19
     f5c:	4f 93       	push	r20
     f5e:	5f 93       	push	r21
     f60:	6f 93       	push	r22
     f62:	7f 93       	push	r23
     f64:	8f 93       	push	r24
     f66:	9f 93       	push	r25
     f68:	af 93       	push	r26
     f6a:	bf 93       	push	r27
     f6c:	ef 93       	push	r30
     f6e:	ff 93       	push	r31
	PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
     f70:	82 b3       	in	r24, 0x12	; 18
     f72:	80 58       	subi	r24, 0x80	; 128
     f74:	82 bb       	out	0x12, r24	; 18
	PORTB |= (1<<PB0);
     f76:	c0 9a       	sbi	0x18, 0	; 24
	if(beat >= max_beat) {   //if we've played the note long enough
     f78:	20 91 77 01 	lds	r18, 0x0177
     f7c:	30 91 78 01 	lds	r19, 0x0178
     f80:	80 91 75 01 	lds	r24, 0x0175
     f84:	90 91 76 01 	lds	r25, 0x0176
     f88:	28 17       	cp	r18, r24
     f8a:	39 07       	cpc	r19, r25
     f8c:	60 f0       	brcs	.+24     	; 0xfa6 <__vector_12+0x5c>
		notes++;               //move on to the next note
     f8e:	80 91 67 01 	lds	r24, 0x0167
     f92:	8f 5f       	subi	r24, 0xFF	; 255
     f94:	80 93 67 01 	sts	0x0167, r24
		play_song(song, notes);//and play it
     f98:	80 91 67 01 	lds	r24, 0x0167
     f9c:	90 91 74 01 	lds	r25, 0x0174
    default: notes=-1;
  }
}//song0

void play_song(uint8_t song, uint8_t note) {
  song0(note); //beaver fight song
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	0e 94 66 04 	call	0x8cc	; 0x8cc <song0>
	}
}
     fa6:	ff 91       	pop	r31
     fa8:	ef 91       	pop	r30
     faa:	bf 91       	pop	r27
     fac:	af 91       	pop	r26
     fae:	9f 91       	pop	r25
     fb0:	8f 91       	pop	r24
     fb2:	7f 91       	pop	r23
     fb4:	6f 91       	pop	r22
     fb6:	5f 91       	pop	r21
     fb8:	4f 91       	pop	r20
     fba:	3f 91       	pop	r19
     fbc:	2f 91       	pop	r18
     fbe:	0f 90       	pop	r0
     fc0:	0b be       	out	0x3b, r0	; 59
     fc2:	0f 90       	pop	r0
     fc4:	0f be       	out	0x3f, r0	; 63
     fc6:	0f 90       	pop	r0
     fc8:	1f 90       	pop	r1
     fca:	18 95       	reti

00000fcc <__vector_10>:

ISR(TIMER2_OVF_vect){
     fcc:	1f 92       	push	r1
     fce:	0f 92       	push	r0
     fd0:	0f b6       	in	r0, 0x3f	; 63
     fd2:	0f 92       	push	r0
     fd4:	11 24       	eor	r1, r1
     fd6:	0b b6       	in	r0, 0x3b	; 59
     fd8:	0f 92       	push	r0
     fda:	2f 93       	push	r18
     fdc:	3f 93       	push	r19
     fde:	4f 93       	push	r20
     fe0:	5f 93       	push	r21
     fe2:	6f 93       	push	r22
     fe4:	7f 93       	push	r23
     fe6:	8f 93       	push	r24
     fe8:	9f 93       	push	r25
     fea:	af 93       	push	r26
     fec:	bf 93       	push	r27
     fee:	cf 93       	push	r28
     ff0:	ef 93       	push	r30
     ff2:	ff 93       	push	r31
	static uint8_t count = 0;
	count++;
     ff4:	c0 91 56 01 	lds	r28, 0x0156
     ff8:	cf 5f       	subi	r28, 0xFF	; 255
     ffa:	c0 93 56 01 	sts	0x0156, r28
	//display_update();

	if(count%64 == 0){
     ffe:	8c 2f       	mov	r24, r28
    1000:	8f 73       	andi	r24, 0x3F	; 63
    1002:	c9 f0       	breq	.+50     	; 0x1036 <__vector_10+0x6a>
		button_routine();
	}

	switch(count%8){
    1004:	c7 70       	andi	r28, 0x07	; 7
    1006:	19 f4       	brne	.+6      	; 0x100e <__vector_10+0x42>
		case 0:
			//TODO
			encode_flag = 1;
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	80 93 4d 01 	sts	0x014D, r24
		case 1:
			break;
		default:
			break;
	}    
} 
    100e:	ff 91       	pop	r31
    1010:	ef 91       	pop	r30
    1012:	cf 91       	pop	r28
    1014:	bf 91       	pop	r27
    1016:	af 91       	pop	r26
    1018:	9f 91       	pop	r25
    101a:	8f 91       	pop	r24
    101c:	7f 91       	pop	r23
    101e:	6f 91       	pop	r22
    1020:	5f 91       	pop	r21
    1022:	4f 91       	pop	r20
    1024:	3f 91       	pop	r19
    1026:	2f 91       	pop	r18
    1028:	0f 90       	pop	r0
    102a:	0b be       	out	0x3b, r0	; 59
    102c:	0f 90       	pop	r0
    102e:	0f be       	out	0x3f, r0	; 63
    1030:	0f 90       	pop	r0
    1032:	1f 90       	pop	r1
    1034:	18 95       	reti
	static uint8_t count = 0;
	count++;
	//display_update();

	if(count%64 == 0){
		button_routine();
    1036:	0e 94 78 06 	call	0xcf0	; 0xcf0 <button_routine>
    103a:	e4 cf       	rjmp	.-56     	; 0x1004 <__vector_10+0x38>

0000103c <__vector_21>:
		default:
			break;
	}    
} 

ISR(ADC_vect){
    103c:	1f 92       	push	r1
    103e:	0f 92       	push	r0
    1040:	0f b6       	in	r0, 0x3f	; 63
    1042:	0f 92       	push	r0
    1044:	11 24       	eor	r1, r1
    1046:	8f 93       	push	r24
    1048:	9f 93       	push	r25

	if(ADCH < 100){
    104a:	85 b1       	in	r24, 0x05	; 5
    104c:	84 36       	cpi	r24, 0x64	; 100
    104e:	48 f0       	brcs	.+18     	; 0x1062 <__vector_21+0x26>
		OCR2 = 100-ADCH;
	}  
	else{
		OCR2 = 1;// brightness_level;
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	83 bd       	out	0x23, r24	; 35
	}
}
    1054:	9f 91       	pop	r25
    1056:	8f 91       	pop	r24
    1058:	0f 90       	pop	r0
    105a:	0f be       	out	0x3f, r0	; 63
    105c:	0f 90       	pop	r0
    105e:	1f 90       	pop	r1
    1060:	18 95       	reti
} 

ISR(ADC_vect){

	if(ADCH < 100){
		OCR2 = 100-ADCH;
    1062:	95 b1       	in	r25, 0x05	; 5
    1064:	84 e6       	ldi	r24, 0x64	; 100
    1066:	89 1b       	sub	r24, r25
    1068:	83 bd       	out	0x23, r24	; 35
	}  
	else{
		OCR2 = 1;// brightness_level;
	}
}
    106a:	9f 91       	pop	r25
    106c:	8f 91       	pop	r24
    106e:	0f 90       	pop	r0
    1070:	0f be       	out	0x3f, r0	; 63
    1072:	0f 90       	pop	r0
    1074:	1f 90       	pop	r1
    1076:	18 95       	reti

00001078 <update_time>:
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
    1078:	80 91 5f 01 	lds	r24, 0x015F
		minute++;
    107c:	20 91 5e 01 	lds	r18, 0x015E
/***************************************************************************
  Initialize SPI 
 ****************************************************************************/
void update_time(void){
	// static int minute_change = 0;
	if (second >= 60){
    1080:	8c 33       	cpi	r24, 0x3C	; 60
    1082:	28 f0       	brcs	.+10     	; 0x108e <update_time+0x16>
		minute++;
    1084:	2f 5f       	subi	r18, 0xFF	; 255
    1086:	20 93 5e 01 	sts	0x015E, r18
		second = 0;
    108a:	10 92 5f 01 	sts	0x015F, r1
	}             
	if(minute >=60){
		hour++;
    108e:	e0 91 5d 01 	lds	r30, 0x015D
	// static int minute_change = 0;
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
    1092:	2c 33       	cpi	r18, 0x3C	; 60
    1094:	c0 f5       	brcc	.+112    	; 0x1106 <__stack+0x7>
    1096:	30 e0       	ldi	r19, 0x00	; 0
		hour++;
		minute = 0;
	}
	if(hour >= 24){
    1098:	e8 31       	cpi	r30, 0x18	; 24
    109a:	f0 f5       	brcc	.+124    	; 0x1118 <__stack+0x19>
    109c:	6e 2f       	mov	r22, r30
    109e:	70 e0       	ldi	r23, 0x00	; 0
    10a0:	84 e6       	ldi	r24, 0x64	; 100
    10a2:	e8 9f       	mul	r30, r24
    10a4:	a0 01       	movw	r20, r0
    10a6:	11 24       	eor	r1, r1
		hour = 0;
	} 

	alarm_time = (alarm_hour * 100) + alarm_minute;
    10a8:	f0 91 5b 01 	lds	r31, 0x015B
    10ac:	80 91 5c 01 	lds	r24, 0x015C
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	a4 e6       	ldi	r26, 0x64	; 100
    10b4:	fa 9f       	mul	r31, r26
    10b6:	80 0d       	add	r24, r0
    10b8:	91 1d       	adc	r25, r1
    10ba:	11 24       	eor	r1, r1
    10bc:	90 93 45 01 	sts	0x0145, r25
    10c0:	80 93 44 01 	sts	0x0144, r24
	// if(minute_change){
	time = (hour * 100) + minute;
    10c4:	c9 01       	movw	r24, r18
    10c6:	84 0f       	add	r24, r20
    10c8:	95 1f       	adc	r25, r21
    10ca:	90 93 47 01 	sts	0x0147, r25
    10ce:	80 93 46 01 	sts	0x0146, r24
	// minute_change = 0;

	if(show_ampm){
    10d2:	40 91 66 01 	lds	r20, 0x0166
    10d6:	44 23       	and	r20, r20
    10d8:	39 f1       	breq	.+78     	; 0x1128 <__stack+0x29>
		if(hour>=12){
    10da:	ec 30       	cpi	r30, 0x0C	; 12
    10dc:	50 f1       	brcs	.+84     	; 0x1132 <__stack+0x33>
			if(hour == 12){
    10de:	ec 30       	cpi	r30, 0x0C	; 12
    10e0:	d1 f1       	breq	.+116    	; 0x1156 <__stack+0x57>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour-12)*100 + minute;
    10e2:	6c 50       	subi	r22, 0x0C	; 12
    10e4:	71 09       	sbc	r23, r1
    10e6:	44 e6       	ldi	r20, 0x64	; 100
    10e8:	46 9f       	mul	r20, r22
    10ea:	c0 01       	movw	r24, r0
    10ec:	47 9f       	mul	r20, r23
    10ee:	90 0d       	add	r25, r0
    10f0:	11 24       	eor	r1, r1
    10f2:	82 0f       	add	r24, r18
    10f4:	93 1f       	adc	r25, r19
    10f6:	90 93 43 01 	sts	0x0143, r25
    10fa:	80 93 42 01 	sts	0x0142, r24
				am_pm = 1;
    10fe:	81 e0       	ldi	r24, 0x01	; 1
    1100:	80 93 40 01 	sts	0x0140, r24
    1104:	08 95       	ret
	if (second >= 60){
		minute++;
		second = 0;
	}             
	if(minute >=60){
		hour++;
    1106:	ef 5f       	subi	r30, 0xFF	; 255
    1108:	e0 93 5d 01 	sts	0x015D, r30
		minute = 0;
    110c:	10 92 5e 01 	sts	0x015E, r1
    1110:	20 e0       	ldi	r18, 0x00	; 0
    1112:	30 e0       	ldi	r19, 0x00	; 0
	}
	if(hour >= 24){
    1114:	e8 31       	cpi	r30, 0x18	; 24
    1116:	10 f2       	brcs	.-124    	; 0x109c <update_time+0x24>
		hour = 0;
    1118:	10 92 5d 01 	sts	0x015D, r1
    111c:	40 e0       	ldi	r20, 0x00	; 0
    111e:	50 e0       	ldi	r21, 0x00	; 0
    1120:	60 e0       	ldi	r22, 0x00	; 0
    1122:	70 e0       	ldi	r23, 0x00	; 0
    1124:	e0 e0       	ldi	r30, 0x00	; 0
    1126:	c0 cf       	rjmp	.-128    	; 0x10a8 <update_time+0x30>
			}
			am_pm = 0;
		}
	}
	else{
		show_time = (hour * 100) + minute;
    1128:	90 93 43 01 	sts	0x0143, r25
    112c:	80 93 42 01 	sts	0x0142, r24
    1130:	08 95       	ret
				show_time = (hour-12)*100 + minute;
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
    1132:	ee 23       	and	r30, r30
    1134:	39 f0       	breq	.+14     	; 0x1144 <__stack+0x45>
				show_time = 1200 + minute;
			}
			else{
				show_time = (hour)*100 + minute;
    1136:	90 93 43 01 	sts	0x0143, r25
    113a:	80 93 42 01 	sts	0x0142, r24
			}
			am_pm = 0;
    113e:	10 92 40 01 	sts	0x0140, r1
    1142:	08 95       	ret
				am_pm = 1;
			}
		}
		else{           
			if(hour == 0){
				show_time = 1200 + minute;
    1144:	20 55       	subi	r18, 0x50	; 80
    1146:	3b 4f       	sbci	r19, 0xFB	; 251
    1148:	30 93 43 01 	sts	0x0143, r19
    114c:	20 93 42 01 	sts	0x0142, r18
			}
			else{
				show_time = (hour)*100 + minute;
			}
			am_pm = 0;
    1150:	10 92 40 01 	sts	0x0140, r1
    1154:	08 95       	ret
	// minute_change = 0;

	if(show_ampm){
		if(hour>=12){
			if(hour == 12){
				show_time = 1200 + minute;
    1156:	20 55       	subi	r18, 0x50	; 80
    1158:	3b 4f       	sbci	r19, 0xFB	; 251
    115a:	30 93 43 01 	sts	0x0143, r19
    115e:	20 93 42 01 	sts	0x0142, r18
    1162:	08 95       	ret

00001164 <SPI_init>:
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    1164:	80 e5       	ldi	r24, 0x50	; 80
    1166:	8d b9       	out	0x0d, r24	; 13
    1168:	08 95       	ret

0000116a <SPI_Transmit>:

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    116a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    116c:	77 9b       	sbis	0x0e, 7	; 14
    116e:	fe cf       	rjmp	.-4      	; 0x116c <SPI_Transmit+0x2>
}
    1170:	08 95       	ret

00001172 <SPI_Receive>:

/***************************************************************************
  Read data from SPI input (SPDR)
 ****************************************************************************/
uint8_t SPI_Receive(void){
	PORTE &= 0;       //Write 0 to PE6 to trigger SPI on radio board
    1172:	83 b1       	in	r24, 0x03	; 3
    1174:	13 b8       	out	0x03, r1	; 3
	__asm__ __volatile__ ("nop");
    1176:	00 00       	nop
	__asm__ __volatile__ ("nop");
    1178:	00 00       	nop
	// Wait until 8 clock cycles are done 
	SPDR = 0x00;     //Write 1 to set the SPI slave input to one (wait for read)
    117a:	1f b8       	out	0x0f, r1	; 15
	PORTE |= (1 << PE6);  
    117c:	1e 9a       	sbi	0x03, 6	; 3
	__asm__ __volatile__ ("nop");
    117e:	00 00       	nop
	__asm__ __volatile__ ("nop");
    1180:	00 00       	nop
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
    1182:	77 9b       	sbis	0x0e, 7	; 14
    1184:	fe cf       	rjmp	.-4      	; 0x1182 <SPI_Receive+0x10>
	// Return incoming data from SPDR
	return(SPDR);  
    1186:	8f b1       	in	r24, 0x0f	; 15
}
    1188:	08 95       	ret

0000118a <bar_graph>:
 *void bar_graph()
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
    118a:	80 91 60 01 	lds	r24, 0x0160
    118e:	88 23       	and	r24, r24
    1190:	b9 f0       	breq	.+46     	; 0x11c0 <bar_graph+0x36>
		write = 0x00;
	}
	else{
		write = 1<<(mode-1);
    1192:	9f ef       	ldi	r25, 0xFF	; 255
    1194:	98 0f       	add	r25, r24
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	01 c0       	rjmp	.+2      	; 0x119c <bar_graph+0x12>
    119a:	88 0f       	add	r24, r24
    119c:	9a 95       	dec	r25
    119e:	ea f7       	brpl	.-6      	; 0x119a <bar_graph+0x10>
	}

	if(alarm_on != 0){
    11a0:	90 91 39 01 	lds	r25, 0x0139
    11a4:	91 11       	cpse	r25, r1
		write = 0xFF;
    11a6:	8f ef       	ldi	r24, 0xFF	; 255

/***************************************************************************
  Transmit data to SPI
 ****************************************************************************/
void SPI_Transmit(uint8_t data){
	SPDR = data;    //Write data to SPDR
    11a8:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))){} //SPIN write
    11aa:	77 9b       	sbis	0x0e, 7	; 14
    11ac:	fe cf       	rjmp	.-4      	; 0x11aa <bar_graph+0x20>

	if(alarm_on != 0){
		write = 0xFF;
	}
	SPI_Transmit(write);
	PORTD = (1 << PD2);  //Push data out of SPI
    11ae:	84 e0       	ldi	r24, 0x04	; 4
    11b0:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop"); //Buffer
    11b2:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    11b4:	00 00       	nop


	PORTD = (2 << PD2);  // Push data out of SPI
    11b6:	88 e0       	ldi	r24, 0x08	; 8
    11b8:	82 bb       	out	0x12, r24	; 18
	__asm__ __volatile__ ("nop");  //Buffer
    11ba:	00 00       	nop
	__asm__ __volatile__ ("nop");  //Buffer
    11bc:	00 00       	nop
    11be:	08 95       	ret
 *show selected modes on the bar graph
 **************************************************************************/
void bar_graph(){
	uint8_t write = 0;
	if(mode == 0){
		write = 0x00;
    11c0:	80 e0       	ldi	r24, 0x00	; 0
    11c2:	ee cf       	rjmp	.-36     	; 0x11a0 <bar_graph+0x16>

000011c4 <display_update>:
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
	uint8_t display_segment = 0;
	//static uint8_t rotate_7seg = 0;
	switch(mode){
    11c4:	80 91 60 01 	lds	r24, 0x0160
    11c8:	83 30       	cpi	r24, 0x03	; 3
    11ca:	41 f1       	breq	.+80     	; 0x121c <display_update+0x58>
    11cc:	84 30       	cpi	r24, 0x04	; 4
    11ce:	41 f0       	breq	.+16     	; 0x11e0 <display_update+0x1c>
    11d0:	82 30       	cpi	r24, 0x02	; 2
    11d2:	d9 f0       	breq	.+54     	; 0x120a <display_update+0x46>
			segment_data[2] = 0xFF; //decimal
			break;
		case 4:
			break;
		default:
			segsum(show_time);
    11d4:	80 91 42 01 	lds	r24, 0x0142
    11d8:	90 91 43 01 	lds	r25, 0x0143
    11dc:	0e 94 cd 05 	call	0xb9a	; 0xb9a <segsum>
    11e0:	ee e7       	ldi	r30, 0x7E	; 126
    11e2:	f1 e0       	ldi	r31, 0x01	; 1
	__asm__ __volatile__ ("nop");  //Buffer
}
/************************************************************************
 *Display the number (code from lab1)
 **************************************************************************/
void display_update(){
    11e4:	80 e0       	ldi	r24, 0x00	; 0

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
		PORTB = display_segment << 4;
		PORTA = segment_data[display_segment];
		_delay_us(80);
		PORTA = OFF;
    11e6:	2f ef       	ldi	r18, 0xFF	; 255
			segsum(show_time);
			break;
	}

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
		PORTB = display_segment << 4;
    11e8:	98 2f       	mov	r25, r24
    11ea:	92 95       	swap	r25
    11ec:	90 7f       	andi	r25, 0xF0	; 240
    11ee:	98 bb       	out	0x18, r25	; 24
		PORTA = segment_data[display_segment];
    11f0:	91 91       	ld	r25, Z+
    11f2:	9b bb       	out	0x1b, r25	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    11f4:	af e3       	ldi	r26, 0x3F	; 63
    11f6:	b1 e0       	ldi	r27, 0x01	; 1
    11f8:	11 97       	sbiw	r26, 0x01	; 1
    11fa:	f1 f7       	brne	.-4      	; 0x11f8 <display_update+0x34>
    11fc:	00 c0       	rjmp	.+0      	; 0x11fe <display_update+0x3a>
    11fe:	00 00       	nop
		_delay_us(80);
		PORTA = OFF;
    1200:	2b bb       	out	0x1b, r18	; 27
		default:
			segsum(show_time);
			break;
	}

	for(display_segment = 0 ; display_segment < 5 ; display_segment++){
    1202:	8f 5f       	subi	r24, 0xFF	; 255
    1204:	85 30       	cpi	r24, 0x05	; 5
    1206:	81 f7       	brne	.-32     	; 0x11e8 <display_update+0x24>
		PORTB = display_segment << 4;
		PORTA = segment_data[display_segment];
		_delay_us(80);
		PORTA = OFF;
	}
}
    1208:	08 95       	ret
void display_update(){
	uint8_t display_segment = 0;
	//static uint8_t rotate_7seg = 0;
	switch(mode){
		case 2:
			segsum(alarm_time);
    120a:	80 91 44 01 	lds	r24, 0x0144
    120e:	90 91 45 01 	lds	r25, 0x0145
    1212:	0e 94 cd 05 	call	0xb9a	; 0xb9a <segsum>
			segment_data[2] = 0x00;
    1216:	10 92 80 01 	sts	0x0180, r1
			break;
    121a:	e2 cf       	rjmp	.-60     	; 0x11e0 <display_update+0x1c>
		case 3:
			segsum(OCR3A);
    121c:	80 91 86 00 	lds	r24, 0x0086
    1220:	90 91 87 00 	lds	r25, 0x0087
    1224:	0e 94 cd 05 	call	0xb9a	; 0xb9a <segsum>
			segment_data[2] = 0xFF; //decimal
    1228:	8f ef       	ldi	r24, 0xFF	; 255
    122a:	80 93 80 01 	sts	0x0180, r24
			break;
    122e:	d8 cf       	rjmp	.-80     	; 0x11e0 <display_update+0x1c>

00001230 <right_inc>:
/***************************************************************************
 * Knob handle
 * increment/decrement timers depending on the selected mode
 ****************************************************************************/
void right_inc(){
	switch(mode){
    1230:	80 91 60 01 	lds	r24, 0x0160
    1234:	81 30       	cpi	r24, 0x01	; 1
    1236:	59 f0       	breq	.+22     	; 0x124e <right_inc+0x1e>
    1238:	82 30       	cpi	r24, 0x02	; 2
    123a:	41 f4       	brne	.+16     	; 0x124c <right_inc+0x1c>
				minute = 0;	    
			}     
			second++;
			break;
		case 2: 
			alarm_minute++;
    123c:	80 91 5c 01 	lds	r24, 0x015C
    1240:	8f 5f       	subi	r24, 0xFF	; 255
			if(alarm_minute >= 60){
    1242:	8c 33       	cpi	r24, 0x3C	; 60
    1244:	88 f0       	brcs	.+34     	; 0x1268 <right_inc+0x38>
				alarm_minute = 0;	
    1246:	10 92 5c 01 	sts	0x015C, r1
    124a:	08 95       	ret
    124c:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    124e:	80 91 5e 01 	lds	r24, 0x015E
    1252:	8f 5f       	subi	r24, 0xFF	; 255
			if(minute >= 60){
    1254:	8c 33       	cpi	r24, 0x3C	; 60
    1256:	58 f0       	brcs	.+22     	; 0x126e <right_inc+0x3e>
				minute = 0;	    
    1258:	10 92 5e 01 	sts	0x015E, r1
			}     
			second++;
    125c:	80 91 5f 01 	lds	r24, 0x015F
    1260:	8f 5f       	subi	r24, 0xFF	; 255
    1262:	80 93 5f 01 	sts	0x015F, r24
			break;
    1266:	08 95       	ret
		case 2: 
			alarm_minute++;
    1268:	80 93 5c 01 	sts	0x015C, r24
    126c:	08 95       	ret
void right_inc(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute++;
    126e:	80 93 5e 01 	sts	0x015E, r24
			if(minute >= 60){
				minute = 0;	    
			}     
			second++;
    1272:	80 91 5f 01 	lds	r24, 0x015F
    1276:	8f 5f       	subi	r24, 0xFF	; 255
    1278:	80 93 5f 01 	sts	0x015F, r24
			break;
    127c:	08 95       	ret

0000127e <right_dec>:
		default:
			break;             
	}
}
void right_dec(){
	switch(mode){
    127e:	80 91 60 01 	lds	r24, 0x0160
    1282:	81 30       	cpi	r24, 0x01	; 1
    1284:	71 f0       	breq	.+28     	; 0x12a2 <right_dec+0x24>
    1286:	82 30       	cpi	r24, 0x02	; 2
    1288:	59 f4       	brne	.+22     	; 0x12a0 <right_dec+0x22>
			if(minute >= 240){
				minute = 59;	    
			}   
			break;
		case 2: 
			alarm_minute--;
    128a:	80 91 5c 01 	lds	r24, 0x015C
    128e:	81 50       	subi	r24, 0x01	; 1
    1290:	80 93 5c 01 	sts	0x015C, r24
			if(alarm_minute >= 240){
    1294:	80 3f       	cpi	r24, 0xF0	; 240
    1296:	18 f0       	brcs	.+6      	; 0x129e <right_dec+0x20>
				alarm_minute = 59;	
    1298:	8b e3       	ldi	r24, 0x3B	; 59
    129a:	80 93 5c 01 	sts	0x015C, r24
    129e:	08 95       	ret
    12a0:	08 95       	ret
void right_dec(){
	switch(mode){
		case 0: 
			break;
		case 1:
			minute--;
    12a2:	80 91 5e 01 	lds	r24, 0x015E
    12a6:	81 50       	subi	r24, 0x01	; 1
    12a8:	80 93 5e 01 	sts	0x015E, r24
			if(minute >= 240){
    12ac:	80 3f       	cpi	r24, 0xF0	; 240
    12ae:	b8 f3       	brcs	.-18     	; 0x129e <right_dec+0x20>
				minute = 59;	    
    12b0:	8b e3       	ldi	r24, 0x3B	; 59
    12b2:	80 93 5e 01 	sts	0x015E, r24
    12b6:	08 95       	ret

000012b8 <decode_spi_right_knob>:
	previous_encoder1 = encoder1;
}
/*************************************************************************
  Exactly the same with decode_spi_left_knob(), only mask different bits 
 **************************************************************************/
void decode_spi_right_knob(uint8_t encoder2){
    12b8:	cf 93       	push	r28
    12ba:	df 93       	push	r29
    12bc:	1f 92       	push	r1
    12be:	cd b7       	in	r28, 0x3d	; 61
    12c0:	de b7       	in	r29, 0x3e	; 62
	uint8_t sw_index = 0;
	static uint8_t acount2 = 0;
	static uint8_t previous_encoder2 = 0;
	uint8_t direction = 0;
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
    12c2:	83 70       	andi	r24, 0x03	; 3
	sw_index = (previous_encoder2 << 2) | encoder2;
    12c4:	e0 91 51 01 	lds	r30, 0x0151
    12c8:	ee 0f       	add	r30, r30
    12ca:	ee 0f       	add	r30, r30
    12cc:	e8 2b       	or	r30, r24
	direction = sw_table[sw_index];
    12ce:	f0 e0       	ldi	r31, 0x00	; 0
    12d0:	ed 5f       	subi	r30, 0xFD	; 253
    12d2:	fe 4f       	sbci	r31, 0xFE	; 254
    12d4:	90 81       	ld	r25, Z
	//value = modeA;
	if(direction == CW){
    12d6:	91 30       	cpi	r25, 0x01	; 1
    12d8:	09 f1       	breq	.+66     	; 0x131c <decode_spi_right_knob+0x64>
		acount2++;
	}	
	if(direction == CCW){
    12da:	92 30       	cpi	r25, 0x02	; 2
    12dc:	41 f0       	breq	.+16     	; 0x12ee <decode_spi_right_knob+0x36>
		acount2--;
	}
	if(encoder2 == 3){
    12de:	83 30       	cpi	r24, 0x03	; 3
    12e0:	69 f0       	breq	.+26     	; 0x12fc <decode_spi_right_knob+0x44>
			right_dec();
		}
		//update_number();
		acount2 = 0;
	}
	previous_encoder2 = encoder2;
    12e2:	80 93 51 01 	sts	0x0151, r24
}
    12e6:	0f 90       	pop	r0
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	08 95       	ret
	//value = modeA;
	if(direction == CW){
		acount2++;
	}	
	if(direction == CCW){
		acount2--;
    12ee:	90 91 50 01 	lds	r25, 0x0150
    12f2:	91 50       	subi	r25, 0x01	; 1
    12f4:	90 93 50 01 	sts	0x0150, r25
	}
	if(encoder2 == 3){
    12f8:	83 30       	cpi	r24, 0x03	; 3
    12fa:	99 f7       	brne	.-26     	; 0x12e2 <decode_spi_right_knob+0x2a>
		if((acount2 > 1) && (acount2 < 10)){
    12fc:	90 91 50 01 	lds	r25, 0x0150
    1300:	2e ef       	ldi	r18, 0xFE	; 254
    1302:	29 0f       	add	r18, r25
    1304:	28 30       	cpi	r18, 0x08	; 8
    1306:	b8 f0       	brcs	.+46     	; 0x1336 <decode_spi_right_knob+0x7e>
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
    1308:	91 3f       	cpi	r25, 0xF1	; 241
    130a:	70 f4       	brcc	.+28     	; 0x1328 <decode_spi_right_knob+0x70>
			right_dec();
		}
		//update_number();
		acount2 = 0;
    130c:	10 92 50 01 	sts	0x0150, r1
	}
	previous_encoder2 = encoder2;
    1310:	80 93 51 01 	sts	0x0151, r24
}
    1314:	0f 90       	pop	r0
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	08 95       	ret
	encoder2 = ENCODE_RIGHT_KNOB(encoder2);
	sw_index = (previous_encoder2 << 2) | encoder2;
	direction = sw_table[sw_index];
	//value = modeA;
	if(direction == CW){
		acount2++;
    131c:	90 91 50 01 	lds	r25, 0x0150
    1320:	9f 5f       	subi	r25, 0xFF	; 255
    1322:	90 93 50 01 	sts	0x0150, r25
    1326:	db cf       	rjmp	.-74     	; 0x12de <decode_spi_right_knob+0x26>
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
    1328:	89 83       	std	Y+1, r24	; 0x01
    132a:	0e 94 3f 09 	call	0x127e	; 0x127e <right_dec>
    132e:	89 81       	ldd	r24, Y+1	; 0x01
		}
		//update_number();
		acount2 = 0;
    1330:	10 92 50 01 	sts	0x0150, r1
    1334:	ed cf       	rjmp	.-38     	; 0x1310 <decode_spi_right_knob+0x58>
	if(direction == CCW){
		acount2--;
	}
	if(encoder2 == 3){
		if((acount2 > 1) && (acount2 < 10)){
			right_inc();
    1336:	89 83       	std	Y+1, r24	; 0x01
    1338:	0e 94 18 09 	call	0x1230	; 0x1230 <right_inc>
    133c:	89 81       	ldd	r24, Y+1	; 0x01
		}
		if ((acount2 <= 0xFF) && (acount2 > 0xF0)){
			right_dec();
		}
		//update_number();
		acount2 = 0;
    133e:	10 92 50 01 	sts	0x0150, r1
    1342:	e6 cf       	rjmp	.-52     	; 0x1310 <decode_spi_right_knob+0x58>

00001344 <left_inc>:
			break;
	}

}
void left_inc(){
	switch(mode){
    1344:	80 91 60 01 	lds	r24, 0x0160
    1348:	82 30       	cpi	r24, 0x02	; 2
    134a:	21 f1       	breq	.+72     	; 0x1394 <left_inc+0x50>
    134c:	b8 f0       	brcs	.+46     	; 0x137c <left_inc+0x38>
    134e:	83 30       	cpi	r24, 0x03	; 3
    1350:	51 f0       	breq	.+20     	; 0x1366 <left_inc+0x22>
    1352:	84 30       	cpi	r24, 0x04	; 4
    1354:	71 f5       	brne	.+92     	; 0x13b2 <left_inc+0x6e>
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    1356:	81 e0       	ldi	r24, 0x01	; 1
    1358:	90 91 36 01 	lds	r25, 0x0136
    135c:	91 11       	cpse	r25, r1
    135e:	24 c0       	rjmp	.+72     	; 0x13a8 <left_inc+0x64>
    1360:	80 93 36 01 	sts	0x0136, r24
    1364:	08 95       	ret
			if(alarm_hour >= 24){
				alarm_hour = 0;
			}
			break;
		case 3:
			volume++;
    1366:	80 91 00 01 	lds	r24, 0x0100
    136a:	8f 5f       	subi	r24, 0xFF	; 255
    136c:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    1370:	90 e0       	ldi	r25, 0x00	; 0
    1372:	90 93 87 00 	sts	0x0087, r25
    1376:	80 93 86 00 	sts	0x0086, r24
			break;
    137a:	08 95       	ret
			break;
	}

}
void left_inc(){
	switch(mode){
    137c:	81 30       	cpi	r24, 0x01	; 1
    137e:	c1 f4       	brne	.+48     	; 0x13b0 <left_inc+0x6c>
		case 0: 
			break;
		case 1:
			hour++;
    1380:	80 91 5d 01 	lds	r24, 0x015D
    1384:	8f 5f       	subi	r24, 0xFF	; 255
    1386:	80 93 5d 01 	sts	0x015D, r24
			if(hour >= 24){
    138a:	88 31       	cpi	r24, 0x18	; 24
    138c:	58 f3       	brcs	.-42     	; 0x1364 <left_inc+0x20>
				hour = 0;	    
    138e:	10 92 5d 01 	sts	0x015D, r1
    1392:	08 95       	ret
			}   
			break;
		case 2: 
			alarm_hour++;
    1394:	80 91 5b 01 	lds	r24, 0x015B
    1398:	8f 5f       	subi	r24, 0xFF	; 255
    139a:	80 93 5b 01 	sts	0x015B, r24
			if(alarm_hour >= 24){
    139e:	88 31       	cpi	r24, 0x18	; 24
    13a0:	08 f3       	brcs	.-62     	; 0x1364 <left_inc+0x20>
				alarm_hour = 0;
    13a2:	10 92 5b 01 	sts	0x015B, r1
    13a6:	08 95       	ret
		case 3:
			volume++;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    13a8:	80 e0       	ldi	r24, 0x00	; 0
    13aa:	80 93 36 01 	sts	0x0136, r24
    13ae:	da cf       	rjmp	.-76     	; 0x1364 <left_inc+0x20>
    13b0:	08 95       	ret
    13b2:	08 95       	ret

000013b4 <left_dec>:
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    13b4:	80 91 60 01 	lds	r24, 0x0160
    13b8:	82 30       	cpi	r24, 0x02	; 2
    13ba:	29 f1       	breq	.+74     	; 0x1406 <left_dec+0x52>
    13bc:	b8 f0       	brcs	.+46     	; 0x13ec <left_dec+0x38>
    13be:	83 30       	cpi	r24, 0x03	; 3
    13c0:	51 f0       	breq	.+20     	; 0x13d6 <left_dec+0x22>
    13c2:	84 30       	cpi	r24, 0x04	; 4
    13c4:	81 f5       	brne	.+96     	; 0x1426 <left_dec+0x72>
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	90 91 36 01 	lds	r25, 0x0136
    13cc:	91 11       	cpse	r25, r1
    13ce:	26 c0       	rjmp	.+76     	; 0x141c <left_dec+0x68>
    13d0:	80 93 36 01 	sts	0x0136, r24
    13d4:	08 95       	ret
			if(alarm_hour >= 240){
				alarm_hour = 23;
			}
			break;
		case 3:
			volume--;
    13d6:	80 91 00 01 	lds	r24, 0x0100
    13da:	81 50       	subi	r24, 0x01	; 1
    13dc:	80 93 00 01 	sts	0x0100, r24
			OCR3A = volume;
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	90 93 87 00 	sts	0x0087, r25
    13e6:	80 93 86 00 	sts	0x0086, r24
			break;
    13ea:	08 95       	ret
		default:
			break;
	}
}
void left_dec(){
	switch(mode){
    13ec:	81 30       	cpi	r24, 0x01	; 1
    13ee:	d1 f4       	brne	.+52     	; 0x1424 <left_dec+0x70>
		case 0: 
			break;
		case 1:
			hour--;    
    13f0:	80 91 5d 01 	lds	r24, 0x015D
    13f4:	81 50       	subi	r24, 0x01	; 1
    13f6:	80 93 5d 01 	sts	0x015D, r24
			if(hour >= 240){
    13fa:	80 3f       	cpi	r24, 0xF0	; 240
    13fc:	58 f3       	brcs	.-42     	; 0x13d4 <left_dec+0x20>
				hour = 23;	    
    13fe:	87 e1       	ldi	r24, 0x17	; 23
    1400:	80 93 5d 01 	sts	0x015D, r24
    1404:	08 95       	ret
			}   
			break;
		case 2:
			alarm_hour--;
    1406:	80 91 5b 01 	lds	r24, 0x015B
    140a:	81 50       	subi	r24, 0x01	; 1
    140c:	80 93 5b 01 	sts	0x015B, r24
			if(alarm_hour >= 240){
    1410:	80 3f       	cpi	r24, 0xF0	; 240
    1412:	00 f3       	brcs	.-64     	; 0x13d4 <left_dec+0x20>
				alarm_hour = 23;
    1414:	87 e1       	ldi	r24, 0x17	; 23
    1416:	80 93 5b 01 	sts	0x015B, r24
    141a:	08 95       	ret
		case 3:
			volume--;
			OCR3A = volume;
			break;
		case 4: 
			temp_mode = !temp_mode;
    141c:	80 e0       	ldi	r24, 0x00	; 0
    141e:	80 93 36 01 	sts	0x0136, r24
    1422:	d8 cf       	rjmp	.-80     	; 0x13d4 <left_dec+0x20>
    1424:	08 95       	ret
    1426:	08 95       	ret

00001428 <decode_spi_left_knob>:
}
/**************************************************************************
 *Decode the knobs encoder using table method
 *Track the last phase and current phase
 **************************************************************************/
void decode_spi_left_knob(uint8_t encoder1){
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
	uint8_t sw_index = 0;
	//Counter for preventing unneccessary reset    
	static uint8_t acount1 = 0;
	static uint8_t previous_encoder1 = 0; //Initialize previous    
	uint8_t direction = 0;                    //Direction variable
	encoder1 = ENCODE_LEFT_KNOB(encoder1);  //Mask the bit for decoding left know
    142c:	8c 70       	andi	r24, 0x0C	; 12
    142e:	c8 2f       	mov	r28, r24
    1430:	d0 e0       	ldi	r29, 0x00	; 0
    1432:	d5 95       	asr	r29
    1434:	c7 95       	ror	r28
    1436:	d5 95       	asr	r29
    1438:	c7 95       	ror	r28
    143a:	9c 2f       	mov	r25, r28
	sw_index = (previous_encoder1 << 2) | encoder1; 
    143c:	e0 91 53 01 	lds	r30, 0x0153
    1440:	ee 0f       	add	r30, r30
    1442:	ee 0f       	add	r30, r30
    1444:	ec 2b       	or	r30, r28
	/*shift previous to the left use it as an index Since
	  we know the pattern of the knob when it is turning
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
    1446:	f0 e0       	ldi	r31, 0x00	; 0
    1448:	ed 5f       	subi	r30, 0xFD	; 253
    144a:	fe 4f       	sbci	r31, 0xFE	; 254
    144c:	80 81       	ld	r24, Z
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
    144e:	81 30       	cpi	r24, 0x01	; 1
    1450:	f9 f0       	breq	.+62     	; 0x1490 <decode_spi_left_knob+0x68>
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
    1452:	82 30       	cpi	r24, 0x02	; 2
    1454:	39 f0       	breq	.+14     	; 0x1464 <decode_spi_left_knob+0x3c>
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    1456:	93 30       	cpi	r25, 0x03	; 3
    1458:	61 f0       	breq	.+24     	; 0x1472 <decode_spi_left_knob+0x4a>
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
	}
	previous_encoder1 = encoder1;
    145a:	c0 93 53 01 	sts	0x0153, r28
}
    145e:	df 91       	pop	r29
    1460:	cf 91       	pop	r28
    1462:	08 95       	ret
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
	}	
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
    1464:	80 91 52 01 	lds	r24, 0x0152
    1468:	81 50       	subi	r24, 0x01	; 1
    146a:	80 93 52 01 	sts	0x0152, r24
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
    146e:	93 30       	cpi	r25, 0x03	; 3
    1470:	a1 f7       	brne	.-24     	; 0x145a <decode_spi_left_knob+0x32>
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
    1472:	80 91 52 01 	lds	r24, 0x0152
    1476:	9e ef       	ldi	r25, 0xFE	; 254
    1478:	98 0f       	add	r25, r24
    147a:	98 30       	cpi	r25, 0x08	; 8
    147c:	a0 f0       	brcs	.+40     	; 0x14a6 <decode_spi_left_knob+0x7e>
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
    147e:	81 3f       	cpi	r24, 0xF1	; 241
    1480:	68 f4       	brcc	.+26     	; 0x149c <decode_spi_left_knob+0x74>
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    1482:	10 92 52 01 	sts	0x0152, r1
	}
	previous_encoder1 = encoder1;
    1486:	c0 93 53 01 	sts	0x0153, r28
}
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	08 95       	ret
	  Use that data to compare with the table to determine
	  Which way it is turning*/
	direction = sw_table[sw_index];
	//Read out the direction from table
	if(direction == CW){  //If CW, add counter
		acount1++;
    1490:	80 91 52 01 	lds	r24, 0x0152
    1494:	8f 5f       	subi	r24, 0xFF	; 255
    1496:	80 93 52 01 	sts	0x0152, r24
    149a:	dd cf       	rjmp	.-70     	; 0x1456 <decode_spi_left_knob+0x2e>
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
    149c:	0e 94 da 09 	call	0x13b4	; 0x13b4 <left_dec>
		}
		acount1 = 0;                     //Reset counter
    14a0:	10 92 52 01 	sts	0x0152, r1
    14a4:	f0 cf       	rjmp	.-32     	; 0x1486 <decode_spi_left_knob+0x5e>
	if(direction == CCW){ //If CCW, decrement counter
		acount1--;
	}
	if(encoder1 == 3){    //encoder1 = 3 (stop spinning)
		if((acount1 > 1) && (acount1 < 10)){   //Check if the counter for CW
			left_inc();
    14a6:	0e 94 a2 09 	call	0x1344	; 0x1344 <left_inc>
		}
		if ((acount1 <= 0xFF) && (acount1 > 0xF0)){    //Check counter for CCW
			left_dec();
		}
		acount1 = 0;                     //Reset counter
    14aa:	10 92 52 01 	sts	0x0152, r1
    14ae:	eb cf       	rjmp	.-42     	; 0x1486 <decode_spi_left_knob+0x5e>

000014b0 <check_knobs>:
	__asm__ __volatile__ ("nop");
	while (bit_is_clear(SPSR,SPIF)){} //SPIN read 
	// Return incoming data from SPDR
	return(SPDR);  
}
void check_knobs(void){
    14b0:	cf 93       	push	r28
	static uint8_t cnt = 0;
	static uint8_t encoder;
	cnt++;
    14b2:	c0 91 55 01 	lds	r28, 0x0155
    14b6:	cf 5f       	subi	r28, 0xFF	; 255
    14b8:	c0 93 55 01 	sts	0x0155, r28
	encoder = SPI_Receive();
    14bc:	0e 94 b9 08 	call	0x1172	; 0x1172 <SPI_Receive>
    14c0:	80 93 54 01 	sts	0x0154, r24
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
    14c4:	c0 ff       	sbrs	r28, 0
    14c6:	03 c0       	rjmp	.+6      	; 0x14ce <check_knobs+0x1e>
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
	}
}
    14c8:	cf 91       	pop	r28
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
	}
	else{
		decode_spi_right_knob(encoder);
    14ca:	0c 94 5c 09 	jmp	0x12b8	; 0x12b8 <decode_spi_right_knob>
	}
}
    14ce:	cf 91       	pop	r28
	static uint8_t encoder;
	cnt++;
	encoder = SPI_Receive();
	//TIFR |= (1<<TOV2);
	if(cnt%2==0){
		decode_spi_left_knob(encoder);
    14d0:	0c 94 14 0a 	jmp	0x1428	; 0x1428 <decode_spi_left_knob>

000014d4 <get_remote_temp>:

//TOD
// Pull temp functions from temp directory
// Display temp

uint16_t get_remote_temp(){
    14d4:	cf 93       	push	r28
	uint8_t lo, hi; //Low and Hi byte of temperature
	uint16_t tmp; //Full temperature result
	//If temp_mode != 0 ---- want celcius
	if(1){
		uart_putc(CELCIUS); //Ask atmega48 for celcius
    14d6:	82 e0       	ldi	r24, 0x02	; 2
    14d8:	0e 94 ff 0b 	call	0x17fe	; 0x17fe <uart_putc>
	}
	else{
		uart_putc(FARENHEIT); //Ask for F
	}

	lo = uart_getc(); //Get low byte
    14dc:	0e 94 33 0c 	call	0x1866	; 0x1866 <uart_getc>
    14e0:	c8 2f       	mov	r28, r24
	hi = uart_getc(); //Get high byte
    14e2:	0e 94 33 0c 	call	0x1866	; 0x1866 <uart_getc>

	tmp = (hi<<8) | lo; //Concatinate
    14e6:	2c 2f       	mov	r18, r28
    14e8:	30 e0       	ldi	r19, 0x00	; 0
	return tmp;	   //return tempearture
}
    14ea:	a9 01       	movw	r20, r18
    14ec:	58 2b       	or	r21, r24
    14ee:	ca 01       	movw	r24, r20
    14f0:	cf 91       	pop	r28
    14f2:	08 95       	ret

000014f4 <generate_temp_str>:


void generate_temp_str(){
    14f4:	0f 93       	push	r16
    14f6:	1f 93       	push	r17
    14f8:	cf 93       	push	r28
    14fa:	df 93       	push	r29
    14fc:	00 d0       	rcall	.+0      	; 0x14fe <generate_temp_str+0xa>
    14fe:	00 d0       	rcall	.+0      	; 0x1500 <generate_temp_str+0xc>
    1500:	00 d0       	rcall	.+0      	; 0x1502 <generate_temp_str+0xe>
    1502:	cd b7       	in	r28, 0x3d	; 61
    1504:	de b7       	in	r29, 0x3e	; 62
	uint16_t remote_temp, local_temp;
	char local_buf[3];
	char remote_buf[3];
	if(reset_temp == 0){
    1506:	80 91 4a 01 	lds	r24, 0x014A
    150a:	81 11       	cpse	r24, r1
    150c:	0b c0       	rjmp	.+22     	; 0x1524 <generate_temp_str+0x30>
	//rem_temp_str[11] = remote_buf[2];
	rem_temp_str[12] = remote_buf[0];
	rem_temp_str[13] = remote_buf[1];
	//l_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
}
    150e:	26 96       	adiw	r28, 0x06	; 6
    1510:	0f b6       	in	r0, 0x3f	; 63
    1512:	f8 94       	cli
    1514:	de bf       	out	0x3e, r29	; 62
    1516:	0f be       	out	0x3f, r0	; 63
    1518:	cd bf       	out	0x3d, r28	; 61
    151a:	df 91       	pop	r29
    151c:	cf 91       	pop	r28
    151e:	1f 91       	pop	r17
    1520:	0f 91       	pop	r16
    1522:	08 95       	ret
	char remote_buf[3];
	if(reset_temp == 0){
		return;
	}
	//TODO
	remote_temp = get_remote_temp();
    1524:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <get_remote_temp>
    1528:	8c 01       	movw	r16, r24

	//initialize_string();
	local_temp = get_local_temp(1);
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <get_local_temp>
	reset_temp = 0;
    1530:	10 92 4a 01 	sts	0x014A, r1
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1534:	4a e0       	ldi	r20, 0x0A	; 10
    1536:	be 01       	movw	r22, r28
    1538:	6c 5f       	subi	r22, 0xFC	; 252
    153a:	7f 4f       	sbci	r23, 0xFF	; 255
    153c:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <__itoa_ncheck>
    1540:	4a e0       	ldi	r20, 0x0A	; 10
    1542:	be 01       	movw	r22, r28
    1544:	6f 5f       	subi	r22, 0xFF	; 255
    1546:	7f 4f       	sbci	r23, 0xFF	; 255
    1548:	c8 01       	movw	r24, r16
    154a:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <__itoa_ncheck>
	//local_temp_str[12] = local_buf[2];
	//local_temp_str[13] = local_buf[1];
	//local_temp_str[14] = local_buf[0];

	//loc_temp_str[11] = local_buf[2];
	loc_temp_str[12] = local_buf[0];
    154e:	e0 91 63 01 	lds	r30, 0x0163
    1552:	f0 91 64 01 	lds	r31, 0x0164
    1556:	8c 81       	ldd	r24, Y+4	; 0x04
    1558:	84 87       	std	Z+12, r24	; 0x0c
	loc_temp_str[13] = local_buf[1];
    155a:	8d 81       	ldd	r24, Y+5	; 0x05
    155c:	85 87       	std	Z+13, r24	; 0x0d
	
	
	//rem_temp_str[11] = remote_buf[2];
	rem_temp_str[12] = remote_buf[0];
    155e:	e0 91 61 01 	lds	r30, 0x0161
    1562:	f0 91 62 01 	lds	r31, 0x0162
    1566:	89 81       	ldd	r24, Y+1	; 0x01
    1568:	84 87       	std	Z+12, r24	; 0x0c
	rem_temp_str[13] = remote_buf[1];
    156a:	8a 81       	ldd	r24, Y+2	; 0x02
    156c:	85 87       	std	Z+13, r24	; 0x0d
    156e:	cf cf       	rjmp	.-98     	; 0x150e <generate_temp_str+0x1a>

00001570 <show_temperature>:
	static uint8_t counter = 0;
	//loc_temp_str = "Local  temp:   C";
	//rem_temp_str = "Remote temp:   C";
	//loc_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	generate_temp_str();
    1570:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <generate_temp_str>
	//If temp string is not already displayed, diisplay it
	if(counter <= 15){
    1574:	80 91 4f 01 	lds	r24, 0x014F
    1578:	80 31       	cpi	r24, 0x10	; 16
    157a:	50 f0       	brcs	.+20     	; 0x1590 <show_temperature+0x20>
			//_delay_ms(1);
		}
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
    157c:	90 ef       	ldi	r25, 0xF0	; 240
    157e:	98 0f       	add	r25, r24
    1580:	90 31       	cpi	r25, 0x10	; 16
    1582:	f8 f0       	brcs	.+62     	; 0x15c2 <show_temperature+0x52>
		//if(counter == 31){
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
    1584:	8b 34       	cpi	r24, 0x4B	; 75
    1586:	b0 f4       	brcc	.+44     	; 0x15b4 <show_temperature+0x44>
		temp_is_up = 1;
		counter = 0;
		cursor_home();
	}
	else{
		counter++;
    1588:	8f 5f       	subi	r24, 0xFF	; 255
    158a:	80 93 4f 01 	sts	0x014F, r24
    158e:	08 95       	ret
	//loc_temp_str[13] = '3';
	//loc_temp_str[12] = '2';
	generate_temp_str();
	//If temp string is not already displayed, diisplay it
	if(counter <= 15){
		char2lcd(loc_temp_str[counter]);
    1590:	e0 91 63 01 	lds	r30, 0x0163
    1594:	f0 91 64 01 	lds	r31, 0x0164
    1598:	e8 0f       	add	r30, r24
    159a:	f1 1d       	adc	r31, r1
    159c:	80 81       	ld	r24, Z
    159e:	0e 94 df 0c 	call	0x19be	; 0x19be <char2lcd>
		if(counter == 15){
    15a2:	80 91 4f 01 	lds	r24, 0x014F
    15a6:	8f 30       	cpi	r24, 0x0F	; 15
    15a8:	79 f7       	brne	.-34     	; 0x1588 <show_temperature+0x18>
			home_line2();
    15aa:	0e 94 af 0c 	call	0x195e	; 0x195e <home_line2>
    15ae:	80 91 4f 01 	lds	r24, 0x014F
    15b2:	ea cf       	rjmp	.-44     	; 0x1588 <show_temperature+0x18>
		//	cursor_home();
		//}
		//return;
	}
	else if(counter >= 75){
		temp_is_up = 1;
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	80 93 48 01 	sts	0x0148, r24
		counter = 0;
    15ba:	10 92 4f 01 	sts	0x014F, r1
		cursor_home();
    15be:	0c 94 9d 0c 	jmp	0x193a	; 0x193a <cursor_home>
		counter++;
		//return;
	}
	else if (counter >=16 && counter <= 31){
		//minute++;
		char2lcd(rem_temp_str[counter-16]);
    15c2:	e0 91 61 01 	lds	r30, 0x0161
    15c6:	f0 91 62 01 	lds	r31, 0x0162
    15ca:	e8 0f       	add	r30, r24
    15cc:	f1 1d       	adc	r31, r1
    15ce:	70 97       	sbiw	r30, 0x10	; 16
    15d0:	80 81       	ld	r24, Z
    15d2:	0e 94 df 0c 	call	0x19be	; 0x19be <char2lcd>
		counter++;
    15d6:	80 91 4f 01 	lds	r24, 0x014F
    15da:	8f 5f       	subi	r24, 0xFF	; 255
    15dc:	80 93 4f 01 	sts	0x014F, r24
    15e0:	08 95       	ret

000015e2 <LCD_Display>:


void LCD_Display(){
	static uint8_t counter = 0;

	if(counter <= 15){
    15e2:	80 91 4e 01 	lds	r24, 0x014E
    15e6:	80 31       	cpi	r24, 0x10	; 16
    15e8:	30 f4       	brcc	.+12     	; 0x15f6 <LCD_Display+0x14>
		//	char2lcd(rem_temp_str[counter]);
		if(counter == 15){
    15ea:	8f 30       	cpi	r24, 0x0F	; 15
    15ec:	79 f0       	breq	.+30     	; 0x160c <LCD_Display+0x2a>
	}
	else if(counter >=100){
		counter = 0;
	}
	else{
		counter++;
    15ee:	8f 5f       	subi	r24, 0xFF	; 255
    15f0:	80 93 4e 01 	sts	0x014E, r24
    15f4:	08 95       	ret
			//_delay_ms(1);
		}
		counter++;
		//	return;
	}
	else if (counter >=16 && counter <= 31){
    15f6:	90 ef       	ldi	r25, 0xF0	; 240
    15f8:	98 0f       	add	r25, r24
    15fa:	90 31       	cpi	r25, 0x10	; 16
    15fc:	c0 f3       	brcs	.-16     	; 0x15ee <LCD_Display+0xc>
		//	//minute++;
		//	char2lcd(loc_temp_str[counter-16]);
		counter++;
		//return;
	}
	else if(counter >= 75){ 
    15fe:	8b 34       	cpi	r24, 0x4B	; 75
    1600:	b0 f3       	brcs	.-20     	; 0x15ee <LCD_Display+0xc>
		//counter = 0;
		//loc_temp_str = "";
		//rem_temp_str = "";
		//loc_temp_str = "Local  temp:   C";
		//rem_temp_str = "Remote temp:   C";
		counter++;
    1602:	8f 5f       	subi	r24, 0xFF	; 255
    1604:	80 93 4e 01 	sts	0x014E, r24
		cursor_home();
    1608:	0c 94 9d 0c 	jmp	0x193a	; 0x193a <cursor_home>
	static uint8_t counter = 0;

	if(counter <= 15){
		//	char2lcd(rem_temp_str[counter]);
		if(counter == 15){
			home_line2();
    160c:	0e 94 af 0c 	call	0x195e	; 0x195e <home_line2>
    1610:	80 91 4e 01 	lds	r24, 0x014E
    1614:	ec cf       	rjmp	.-40     	; 0x15ee <LCD_Display+0xc>

00001616 <timer_init>:
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1616:	83 b7       	in	r24, 0x33	; 51
    1618:	81 60       	ori	r24, 0x01	; 1
    161a:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    161c:	80 b7       	in	r24, 0x30	; 48
    161e:	88 60       	ori	r24, 0x08	; 8
    1620:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1622:	85 b5       	in	r24, 0x25	; 37
    1624:	8a 67       	ori	r24, 0x7A	; 122
    1626:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1628:	87 b7       	in	r24, 0x37	; 55
    162a:	81 64       	ori	r24, 0x41	; 65
    162c:	87 bf       	out	0x37, r24	; 55
    162e:	08 95       	ret

00001630 <ADC_init>:
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    1630:	e1 e6       	ldi	r30, 0x61	; 97
    1632:	f0 e0       	ldi	r31, 0x00	; 0
    1634:	80 81       	ld	r24, Z
    1636:	80 83       	st	Z, r24
	PORTF = 0x00;
    1638:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    163c:	87 b1       	in	r24, 0x07	; 7
    163e:	80 66       	ori	r24, 0x60	; 96
    1640:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1642:	86 b1       	in	r24, 0x06	; 6
    1644:	8f 6e       	ori	r24, 0xEF	; 239
    1646:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    1648:	8f ef       	ldi	r24, 0xFF	; 255
    164a:	83 bd       	out	0x23, r24	; 35
    164c:	08 95       	ret

0000164e <volume_control_init>:
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    164e:	81 e8       	ldi	r24, 0x81	; 129
    1650:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    1654:	89 e0       	ldi	r24, 0x09	; 9
    1656:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    165a:	80 91 00 01 	lds	r24, 0x0100
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	90 93 87 00 	sts	0x0087, r25
    1664:	80 93 86 00 	sts	0x0086, r24
    1668:	08 95       	ret

0000166a <initialize_string>:
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    166a:	83 e1       	ldi	r24, 0x13	; 19
    166c:	91 e0       	ldi	r25, 0x01	; 1
    166e:	90 93 64 01 	sts	0x0164, r25
    1672:	80 93 63 01 	sts	0x0163, r24
	rem_temp_str = "Remote temp:   C";
    1676:	84 e2       	ldi	r24, 0x24	; 36
    1678:	91 e0       	ldi	r25, 0x01	; 1
    167a:	90 93 62 01 	sts	0x0162, r25
    167e:	80 93 61 01 	sts	0x0161, r24
    1682:	08 95       	ret

00001684 <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    1684:	1f 92       	push	r1
    1686:	0f 92       	push	r0
    1688:	0f b6       	in	r0, 0x3f	; 63
    168a:	0f 92       	push	r0
    168c:	11 24       	eor	r1, r1
    168e:	0b b6       	in	r0, 0x3b	; 59
    1690:	0f 92       	push	r0
    1692:	2f 93       	push	r18
    1694:	3f 93       	push	r19
    1696:	8f 93       	push	r24
    1698:	9f 93       	push	r25
    169a:	af 93       	push	r26
    169c:	bf 93       	push	r27
    169e:	ef 93       	push	r30
    16a0:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    16a2:	80 91 71 00 	lds	r24, 0x0071
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	fc 01       	movw	r30, r24
    16aa:	38 97       	sbiw	r30, 0x08	; 8
    16ac:	e1 35       	cpi	r30, 0x51	; 81
    16ae:	f1 05       	cpc	r31, r1
    16b0:	b0 f0       	brcs	.+44     	; 0x16de <__vector_33+0x5a>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    16b2:	80 91 71 00 	lds	r24, 0x0071
    16b6:	80 93 83 01 	sts	0x0183, r24
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    16ba:	84 e0       	ldi	r24, 0x04	; 4
    16bc:	80 93 74 00 	sts	0x0074, r24
  }//switch
}//TWI_isr
    16c0:	ff 91       	pop	r31
    16c2:	ef 91       	pop	r30
    16c4:	bf 91       	pop	r27
    16c6:	af 91       	pop	r26
    16c8:	9f 91       	pop	r25
    16ca:	8f 91       	pop	r24
    16cc:	3f 91       	pop	r19
    16ce:	2f 91       	pop	r18
    16d0:	0f 90       	pop	r0
    16d2:	0b be       	out	0x3b, r0	; 59
    16d4:	0f 90       	pop	r0
    16d6:	0f be       	out	0x3f, r0	; 63
    16d8:	0f 90       	pop	r0
    16da:	1f 90       	pop	r1
    16dc:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    16de:	e4 52       	subi	r30, 0x24	; 36
    16e0:	ff 4f       	sbci	r31, 0xFF	; 255
    16e2:	0c 94 48 0e 	jmp	0x1c90	; 0x1c90 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    16e6:	80 91 65 01 	lds	r24, 0x0165
    16ea:	e0 91 84 01 	lds	r30, 0x0184
    16ee:	f0 91 85 01 	lds	r31, 0x0185
    16f2:	e8 0f       	add	r30, r24
    16f4:	f1 1d       	adc	r31, r1
    16f6:	80 91 73 00 	lds	r24, 0x0073
    16fa:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    16fc:	84 e9       	ldi	r24, 0x94	; 148
    16fe:	80 93 74 00 	sts	0x0074, r24
      break;      
    1702:	de cf       	rjmp	.-68     	; 0x16c0 <__vector_33+0x3c>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    1704:	80 91 86 01 	lds	r24, 0x0186
    1708:	80 93 73 00 	sts	0x0073, r24
      twi_buf_ptr = 0;      //initalize buffer pointer 
    170c:	10 92 65 01 	sts	0x0165, r1
      TWCR = TWCR_SEND;     //send SLA+RW
    1710:	85 e8       	ldi	r24, 0x85	; 133
    1712:	80 93 74 00 	sts	0x0074, r24
      break;
    1716:	d4 cf       	rjmp	.-88     	; 0x16c0 <__vector_33+0x3c>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    1718:	80 91 65 01 	lds	r24, 0x0165
    171c:	90 91 87 01 	lds	r25, 0x0187
    1720:	89 17       	cp	r24, r25
    1722:	60 f7       	brcc	.-40     	; 0x16fc <__vector_33+0x78>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    1724:	e0 91 84 01 	lds	r30, 0x0184
    1728:	f0 91 85 01 	lds	r31, 0x0185
    172c:	91 e0       	ldi	r25, 0x01	; 1
    172e:	98 0f       	add	r25, r24
    1730:	90 93 65 01 	sts	0x0165, r25
    1734:	e8 0f       	add	r30, r24
    1736:	f1 1d       	adc	r31, r1
    1738:	80 81       	ld	r24, Z
    173a:	80 93 73 00 	sts	0x0073, r24
        TWCR = TWCR_SEND;               //send next byte 
    173e:	85 e8       	ldi	r24, 0x85	; 133
    1740:	80 93 74 00 	sts	0x0074, r24
    1744:	bd cf       	rjmp	.-134    	; 0x16c0 <__vector_33+0x3c>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    1746:	85 ea       	ldi	r24, 0xA5	; 165
    1748:	80 93 74 00 	sts	0x0074, r24
      break;
    174c:	b9 cf       	rjmp	.-142    	; 0x16c0 <__vector_33+0x3c>
    174e:	20 91 65 01 	lds	r18, 0x0165
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1752:	80 91 87 01 	lds	r24, 0x0187
    1756:	30 e0       	ldi	r19, 0x00	; 0
    1758:	90 e0       	ldi	r25, 0x00	; 0
    175a:	01 97       	sbiw	r24, 0x01	; 1
    175c:	28 17       	cp	r18, r24
    175e:	39 07       	cpc	r19, r25
    1760:	dc f4       	brge	.+54     	; 0x1798 <__vector_33+0x114>
    1762:	85 ec       	ldi	r24, 0xC5	; 197
    1764:	80 93 74 00 	sts	0x0074, r24
    1768:	ab cf       	rjmp	.-170    	; 0x16c0 <__vector_33+0x3c>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    176a:	e0 91 84 01 	lds	r30, 0x0184
    176e:	f0 91 85 01 	lds	r31, 0x0185
    1772:	80 91 65 01 	lds	r24, 0x0165
    1776:	21 e0       	ldi	r18, 0x01	; 1
    1778:	28 0f       	add	r18, r24
    177a:	20 93 65 01 	sts	0x0165, r18
    177e:	e8 0f       	add	r30, r24
    1780:	f1 1d       	adc	r31, r1
    1782:	80 91 73 00 	lds	r24, 0x0073
    1786:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1788:	80 91 87 01 	lds	r24, 0x0187
    178c:	30 e0       	ldi	r19, 0x00	; 0
    178e:	90 e0       	ldi	r25, 0x00	; 0
    1790:	01 97       	sbiw	r24, 0x01	; 1
    1792:	28 17       	cp	r18, r24
    1794:	39 07       	cpc	r19, r25
    1796:	2c f3       	brlt	.-54     	; 0x1762 <__vector_33+0xde>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    1798:	85 e8       	ldi	r24, 0x85	; 133
    179a:	80 93 74 00 	sts	0x0074, r24
    179e:	90 cf       	rjmp	.-224    	; 0x16c0 <__vector_33+0x3c>

000017a0 <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    17a0:	80 91 74 00 	lds	r24, 0x0074
}
    17a4:	81 70       	andi	r24, 0x01	; 1
    17a6:	08 95       	ret

000017a8 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    17a8:	90 91 74 00 	lds	r25, 0x0074
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    17ac:	90 fd       	sbrc	r25, 0
    17ae:	fc cf       	rjmp	.-8      	; 0x17a8 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    17b0:	8e 7f       	andi	r24, 0xFE	; 254
    17b2:	80 93 86 01 	sts	0x0186, r24
  twi_buf = twi_data;                   //load pointer to write buffer
    17b6:	70 93 85 01 	sts	0x0185, r23
    17ba:	60 93 84 01 	sts	0x0184, r22
  twi_msg_size = byte_cnt;              //load size of xfer 
    17be:	40 93 87 01 	sts	0x0187, r20
  TWCR = TWCR_START;                    //initiate START
    17c2:	85 ea       	ldi	r24, 0xA5	; 165
    17c4:	80 93 74 00 	sts	0x0074, r24
    17c8:	08 95       	ret

000017ca <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    17ca:	90 91 74 00 	lds	r25, 0x0074
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    17ce:	90 fd       	sbrc	r25, 0
    17d0:	fc cf       	rjmp	.-8      	; 0x17ca <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    17d2:	81 60       	ori	r24, 0x01	; 1
    17d4:	80 93 86 01 	sts	0x0186, r24
  twi_buf = twi_data;                  //load pointer to write buffer
    17d8:	70 93 85 01 	sts	0x0185, r23
    17dc:	60 93 84 01 	sts	0x0184, r22
  twi_msg_size = byte_cnt;             //load size of xfer 
    17e0:	40 93 87 01 	sts	0x0187, r20
  TWCR = TWCR_START;                   //initiate START
    17e4:	85 ea       	ldi	r24, 0xA5	; 165
    17e6:	80 93 74 00 	sts	0x0074, r24
    17ea:	08 95       	ret

000017ec <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    17ec:	8f ef       	ldi	r24, 0xFF	; 255
    17ee:	80 93 73 00 	sts	0x0073, r24
  TWSR = 0x00;     //prescaler value = 1
    17f2:	10 92 71 00 	sts	0x0071, r1
  TWBR = TWI_TWBR; //defined in twi_master.h 
    17f6:	8c e0       	ldi	r24, 0x0C	; 12
    17f8:	80 93 70 00 	sts	0x0070, r24
    17fc:	08 95       	ret

000017fe <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    17fe:	5d 9b       	sbis	0x0b, 5	; 11
    1800:	fe cf       	rjmp	.-4      	; 0x17fe <uart_putc>
    UDR0 = data;    // Send data byte
    1802:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1804:	5d 9b       	sbis	0x0b, 5	; 11
    1806:	fe cf       	rjmp	.-4      	; 0x1804 <uart_putc+0x6>
}
    1808:	08 95       	ret

0000180a <uart_puts>:
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    180a:	fc 01       	movw	r30, r24
    180c:	20 81       	ld	r18, Z
    180e:	22 23       	and	r18, r18
    1810:	49 f0       	breq	.+18     	; 0x1824 <uart_puts+0x1a>
    1812:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1814:	5d 9b       	sbis	0x0b, 5	; 11
    1816:	fe cf       	rjmp	.-4      	; 0x1814 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    1818:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    181a:	5d 9b       	sbis	0x0b, 5	; 11
    181c:	fe cf       	rjmp	.-4      	; 0x181a <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    181e:	21 91       	ld	r18, Z+
    1820:	21 11       	cpse	r18, r1
    1822:	f8 cf       	rjmp	.-16     	; 0x1814 <uart_puts+0xa>
    1824:	08 95       	ret

00001826 <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1826:	9c 01       	movw	r18, r24
    1828:	fc 01       	movw	r30, r24
    182a:	44 91       	lpm	r20, Z
    182c:	44 23       	and	r20, r20
    182e:	69 f0       	breq	.+26     	; 0x184a <uart_puts_p+0x24>
	uart_putc(pgm_read_byte(str++));
    1830:	01 96       	adiw	r24, 0x01	; 1
    1832:	f9 01       	movw	r30, r18
    1834:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1836:	5d 9b       	sbis	0x0b, 5	; 11
    1838:	fe cf       	rjmp	.-4      	; 0x1836 <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    183a:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    183c:	5d 9b       	sbis	0x0b, 5	; 11
    183e:	fe cf       	rjmp	.-4      	; 0x183c <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1840:	9c 01       	movw	r18, r24
    1842:	fc 01       	movw	r30, r24
    1844:	44 91       	lpm	r20, Z
    1846:	41 11       	cpse	r20, r1
    1848:	f3 cf       	rjmp	.-26     	; 0x1830 <uart_puts_p+0xa>
	uart_putc(pgm_read_byte(str++));
    }
}
    184a:	08 95       	ret

0000184c <uart_init>:
//must be in place for the MAX232 chip to get data.

void uart_init(){
    //rx and tx enable, receive interrupt enabled, 8 bit characters
    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
    UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!
    184c:	8a b1       	in	r24, 0x0a	; 10
    184e:	88 61       	ori	r24, 0x18	; 24
    1850:	8a b9       	out	0x0a, r24	; 10

    //  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
    //async operation, no parity,  one stop bit, 8-bit characters
    UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    1852:	e5 e9       	ldi	r30, 0x95	; 149
    1854:	f0 e0       	ldi	r31, 0x00	; 0
    1856:	80 81       	ld	r24, Z
    1858:	86 60       	ori	r24, 0x06	; 6
    185a:	80 83       	st	Z, r24
    UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    185c:	10 92 90 00 	sts	0x0090, r1
    UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    1860:	87 e6       	ldi	r24, 0x67	; 103
    1862:	89 b9       	out	0x09, r24	; 9
    1864:	08 95       	ret

00001866 <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    1866:	80 e8       	ldi	r24, 0x80	; 128
    1868:	9e e3       	ldi	r25, 0x3E	; 62
    186a:	03 c0       	rjmp	.+6      	; 0x1872 <uart_getc+0xc>
    186c:	01 97       	sbiw	r24, 0x01	; 1
	timer++;
	if(timer >= 16000){ return(0);}
    186e:	00 97       	sbiw	r24, 0x00	; 0
    1870:	21 f0       	breq	.+8      	; 0x187a <uart_getc+0x14>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
    1872:	5f 9b       	sbis	0x0b, 7	; 11
    1874:	fb cf       	rjmp	.-10     	; 0x186c <uart_getc+0x6>
	//what should we return if nothing comes in?
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
    1876:	8c b1       	in	r24, 0x0c	; 12
    1878:	08 95       	ret
char uart_getc(void) {
    uint16_t timer = 0;

    while (!(UCSR0A & (1<<RXC0))) {
	timer++;
	if(timer >= 16000){ return(0);}
    187a:	80 e0       	ldi	r24, 0x00	; 0
	//return the data into a global variable
	//give uart_getc the address of the variable
	//return a -1 if no data comes back.
    } // Wait for byte to arrive
    return(UDR0); //return the received data
}
    187c:	08 95       	ret

0000187e <lm73_temp_convert>:
//******************************************************************************
uint16_t lm73_temp_convert(uint16_t lm73_temp, uint8_t f_not_c){
    //given a temperature reading from an LM73, the address of a buffer
    //array, and a format (deg F or C) it formats the temperature into ascii in 
    //the buffer pointed to by the arguement.
    lm73_temp = (lm73_temp >> 7);
    187e:	88 0f       	add	r24, r24
    1880:	89 2f       	mov	r24, r25
    1882:	88 1f       	adc	r24, r24
    1884:	99 0b       	sbc	r25, r25
    1886:	91 95       	neg	r25
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 1){
    1888:	61 30       	cpi	r22, 0x01	; 1
    188a:	09 f0       	breq	.+2      	; 0x188e <lm73_temp_convert+0x10>
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    188c:	08 95       	ret
    lm73_temp = (lm73_temp >> 7);
    //temp_digits = 'C';
    //When f_not_c is 1 -> send F
    //when f_not_c is 2 -> send C
    if(f_not_c == 1){
	lm73_temp = (lm73_temp*5/9)+32;
    188e:	9c 01       	movw	r18, r24
    1890:	22 0f       	add	r18, r18
    1892:	33 1f       	adc	r19, r19
    1894:	22 0f       	add	r18, r18
    1896:	33 1f       	adc	r19, r19
    1898:	28 0f       	add	r18, r24
    189a:	39 1f       	adc	r19, r25
    189c:	af e8       	ldi	r26, 0x8F	; 143
    189e:	b3 ee       	ldi	r27, 0xE3	; 227
    18a0:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <__umulhisi3>
    18a4:	96 95       	lsr	r25
    18a6:	87 95       	ror	r24
    18a8:	96 95       	lsr	r25
    18aa:	87 95       	ror	r24
    18ac:	96 95       	lsr	r25
    18ae:	87 95       	ror	r24
    18b0:	80 96       	adiw	r24, 0x20	; 32
	//temp_digits = 'F';
    }
    return lm73_temp;
    //Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    18b2:	08 95       	ret

000018b4 <lm73_init>:
//******************************************************************************
void lm73_init(){
	lm73_wr_buf[0] = LM73_PTR_TEMP;
    18b4:	10 92 d8 01 	sts	0x01D8, r1
	twi_start_wr(LM73_ADDRESS, lm73_wr_buf, 2);
    18b8:	42 e0       	ldi	r20, 0x02	; 2
    18ba:	68 ed       	ldi	r22, 0xD8	; 216
    18bc:	71 e0       	ldi	r23, 0x01	; 1
    18be:	80 e9       	ldi	r24, 0x90	; 144
    18c0:	0c 94 d4 0b 	jmp	0x17a8	; 0x17a8 <twi_start_wr>

000018c4 <get_local_temp>:

}

uint16_t get_local_temp(uint8_t f_not_c){
	uint16_t ret, lm73_temp;
	twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2);
    18c4:	42 e0       	ldi	r20, 0x02	; 2
    18c6:	6a ed       	ldi	r22, 0xDA	; 218
    18c8:	71 e0       	ldi	r23, 0x01	; 1
    18ca:	80 e9       	ldi	r24, 0x90	; 144
    18cc:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    18d0:	8f e3       	ldi	r24, 0x3F	; 63
    18d2:	9f e1       	ldi	r25, 0x1F	; 31
    18d4:	01 97       	sbiw	r24, 0x01	; 1
    18d6:	f1 f7       	brne	.-4      	; 0x18d4 <get_local_temp+0x10>
    18d8:	00 c0       	rjmp	.+0      	; 0x18da <get_local_temp+0x16>
    18da:	00 00       	nop
	_delay_ms(2);    //wait for it to finish
	//now assemble the two bytes read back into one 16-bit value
	//save high temperature byte into lm73_temp
	lm73_temp = lm73_rd_buf[0] << 8;
    18dc:	80 91 da 01 	lds	r24, 0x01DA
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	98 2f       	mov	r25, r24
    18e4:	88 27       	eor	r24, r24
	//shift it into upper byte 
	//"OR" in the low temp byte to lm73_temp 
	lm73_temp |= lm73_rd_buf[1];
    18e6:	20 91 db 01 	lds	r18, 0x01DB
    18ea:	82 2b       	or	r24, r18
	//convert to string in array with itoa() from avr-libc                           
	lm73_temp = lm73_temp >> 7;
	//ret = lm73_temp_convert(lm73_temp, f_not_c);

	return lm73_temp;
}
    18ec:	88 0f       	add	r24, r24
    18ee:	89 2f       	mov	r24, r25
    18f0:	88 1f       	adc	r24, r24
    18f2:	99 0b       	sbc	r25, r25
    18f4:	91 95       	neg	r25
    18f6:	08 95       	ret

000018f8 <strobe_lcd>:

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    18f8:	e2 e6       	ldi	r30, 0x62	; 98
    18fa:	f0 e0       	ldi	r31, 0x00	; 0
    18fc:	80 81       	ld	r24, Z
    18fe:	88 60       	ori	r24, 0x08	; 8
    1900:	80 83       	st	Z, r24
	PORTF &= ~0x08;
    1902:	80 81       	ld	r24, Z
    1904:	87 7f       	andi	r24, 0xF7	; 247
    1906:	80 83       	st	Z, r24
    1908:	08 95       	ret

0000190a <clear_display>:
}          
 
void clear_display(void){
	SPDR = 0x00;    //command, not data
    190a:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    190c:	77 9b       	sbis	0x0e, 7	; 14
    190e:	fe cf       	rjmp	.-4      	; 0x190c <clear_display+0x2>
	SPDR = 0x01;    //clear display command
    1910:	81 e0       	ldi	r24, 0x01	; 1
    1912:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1914:	77 9b       	sbis	0x0e, 7	; 14
    1916:	fe cf       	rjmp	.-4      	; 0x1914 <clear_display+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1918:	80 91 62 00 	lds	r24, 0x0062
    191c:	88 60       	ori	r24, 0x08	; 8
    191e:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1922:	80 91 62 00 	lds	r24, 0x0062
    1926:	87 7f       	andi	r24, 0xF7	; 247
    1928:	80 93 62 00 	sts	0x0062, r24
    192c:	8f e3       	ldi	r24, 0x3F	; 63
    192e:	9f e1       	ldi	r25, 0x1F	; 31
    1930:	01 97       	sbiw	r24, 0x01	; 1
    1932:	f1 f7       	brne	.-4      	; 0x1930 <clear_display+0x26>
    1934:	00 c0       	rjmp	.+0      	; 0x1936 <clear_display+0x2c>
    1936:	00 00       	nop
    1938:	08 95       	ret

0000193a <cursor_home>:
	strobe_lcd();   //strobe the LCD enable pin
	_delay_ms(2);   //obligatory waiting for slow LCD
}         

void cursor_home(void){
	SPDR = 0x00;    //command, not data
    193a:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    193c:	77 9b       	sbis	0x0e, 7	; 14
    193e:	fe cf       	rjmp	.-4      	; 0x193c <cursor_home+0x2>
	SPDR = 0x02;   // cursor go home position
    1940:	82 e0       	ldi	r24, 0x02	; 2
    1942:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1944:	77 9b       	sbis	0x0e, 7	; 14
    1946:	fe cf       	rjmp	.-4      	; 0x1944 <cursor_home+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1948:	80 91 62 00 	lds	r24, 0x0062
    194c:	88 60       	ori	r24, 0x08	; 8
    194e:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1952:	80 91 62 00 	lds	r24, 0x0062
    1956:	87 7f       	andi	r24, 0xF7	; 247
    1958:	80 93 62 00 	sts	0x0062, r24
    195c:	08 95       	ret

0000195e <home_line2>:
	strobe_lcd();
//	_delay_ms(1);  //not necessary with alarm_clock.c code
}         
  
void home_line2(void){
	SPDR = 0x00;    //command, not data
    195e:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1960:	77 9b       	sbis	0x0e, 7	; 14
    1962:	fe cf       	rjmp	.-4      	; 0x1960 <home_line2+0x2>
	SPDR = 0xC0;   // cursor go home on line 2
    1964:	80 ec       	ldi	r24, 0xC0	; 192
    1966:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1968:	77 9b       	sbis	0x0e, 7	; 14
    196a:	fe cf       	rjmp	.-4      	; 0x1968 <home_line2+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    196c:	80 91 62 00 	lds	r24, 0x0062
    1970:	88 60       	ori	r24, 0x08	; 8
    1972:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1976:	80 91 62 00 	lds	r24, 0x0062
    197a:	87 7f       	andi	r24, 0xF7	; 247
    197c:	80 93 62 00 	sts	0x0062, r24
    1980:	08 95       	ret

00001982 <fill_spaces>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd(); 
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
    1982:	80 e1       	ldi	r24, 0x10	; 16
    1984:	90 e0       	ldi	r25, 0x00	; 0
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    1986:	41 e0       	ldi	r20, 0x01	; 1
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		SPDR = 0x20; 
    1988:	30 e2       	ldi	r19, 0x20	; 32
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
		SPDR = 0x01; //set SR for data
    198a:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    198c:	77 9b       	sbis	0x0e, 7	; 14
    198e:	fe cf       	rjmp	.-4      	; 0x198c <fill_spaces+0xa>
		SPDR = 0x20; 
    1990:	3f b9       	out	0x0f, r19	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1992:	77 9b       	sbis	0x0e, 7	; 14
    1994:	fe cf       	rjmp	.-4      	; 0x1992 <fill_spaces+0x10>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1996:	20 91 62 00 	lds	r18, 0x0062
    199a:	28 60       	ori	r18, 0x08	; 8
    199c:	20 93 62 00 	sts	0x0062, r18
	PORTF &= ~0x08;
    19a0:	20 91 62 00 	lds	r18, 0x0062
    19a4:	27 7f       	andi	r18, 0xF7	; 247
    19a6:	20 93 62 00 	sts	0x0062, r18
    19aa:	ef e9       	ldi	r30, 0x9F	; 159
    19ac:	ff e0       	ldi	r31, 0x0F	; 15
    19ae:	31 97       	sbiw	r30, 0x01	; 1
    19b0:	f1 f7       	brne	.-4      	; 0x19ae <fill_spaces+0x2c>
    19b2:	00 c0       	rjmp	.+0      	; 0x19b4 <fill_spaces+0x32>
    19b4:	00 00       	nop
    19b6:	01 97       	sbiw	r24, 0x01	; 1
//	_delay_ms(1);    //not necessary with alarm_clock.c code
}                           
 
void fill_spaces(void){
	int count;
	for (count=0; count<=15; count++){
    19b8:	00 97       	sbiw	r24, 0x00	; 0
    19ba:	39 f7       	brne	.-50     	; 0x198a <fill_spaces+0x8>
		SPDR = 0x20; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_ms(1);
	}
}  
    19bc:	08 95       	ret

000019be <char2lcd>:
   
void char2lcd(char a_char){
	//sends a char to the LCD
	//usage: char2lcd('H');  // send an H to the LCD
	SPDR = 0x01;   //set SR for data xfer with LSB=1
    19be:	91 e0       	ldi	r25, 0x01	; 1
    19c0:	9f b9       	out	0x0f, r25	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19c2:	77 9b       	sbis	0x0e, 7	; 14
    19c4:	fe cf       	rjmp	.-4      	; 0x19c2 <char2lcd+0x4>
	SPDR = a_char; //send the char to the SPI port
    19c6:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19c8:	77 9b       	sbis	0x0e, 7	; 14
    19ca:	fe cf       	rjmp	.-4      	; 0x19c8 <char2lcd+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    19cc:	80 91 62 00 	lds	r24, 0x0062
    19d0:	88 60       	ori	r24, 0x08	; 8
    19d2:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    19d6:	80 91 62 00 	lds	r24, 0x0062
    19da:	87 7f       	andi	r24, 0xF7	; 247
    19dc:	80 93 62 00 	sts	0x0062, r24
    19e0:	8f e9       	ldi	r24, 0x9F	; 159
    19e2:	9f e0       	ldi	r25, 0x0F	; 15
    19e4:	01 97       	sbiw	r24, 0x01	; 1
    19e6:	f1 f7       	brne	.-4      	; 0x19e4 <char2lcd+0x26>
    19e8:	00 c0       	rjmp	.+0      	; 0x19ea <char2lcd+0x2c>
    19ea:	00 00       	nop
    19ec:	08 95       	ret

000019ee <cursor_off>:
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void cursor_off(void){
	//cuts cursor off 
	SPDR = 0x00;   //set SR for data xfer with LSB=1
    19ee:	1f b8       	out	0x0f, r1	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19f0:	77 9b       	sbis	0x0e, 7	; 14
    19f2:	fe cf       	rjmp	.-4      	; 0x19f0 <cursor_off+0x2>
	SPDR = 0x0C; //send the command to cut off cursor
    19f4:	8c e0       	ldi	r24, 0x0C	; 12
    19f6:	8f b9       	out	0x0f, r24	; 15
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    19f8:	77 9b       	sbis	0x0e, 7	; 14
    19fa:	fe cf       	rjmp	.-4      	; 0x19f8 <cursor_off+0xa>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    19fc:	80 91 62 00 	lds	r24, 0x0062
    1a00:	88 60       	ori	r24, 0x08	; 8
    1a02:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a06:	80 91 62 00 	lds	r24, 0x0062
    1a0a:	87 7f       	andi	r24, 0xF7	; 247
    1a0c:	80 93 62 00 	sts	0x0062, r24
    1a10:	8f e9       	ldi	r24, 0x9F	; 159
    1a12:	9f e0       	ldi	r25, 0x0F	; 15
    1a14:	01 97       	sbiw	r24, 0x01	; 1
    1a16:	f1 f7       	brne	.-4      	; 0x1a14 <cursor_off+0x26>
    1a18:	00 c0       	rjmp	.+0      	; 0x1a1a <cursor_off+0x2c>
    1a1a:	00 00       	nop
    1a1c:	08 95       	ret

00001a1e <string2lcd>:
	while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
	strobe_lcd();  //toggle the enable bit
	_delay_ms(1); //wait the prescribed time for the LCD to process
}
  
void string2lcd(char *lcd_str){
    1a1e:	dc 01       	movw	r26, r24

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1a20:	80 e0       	ldi	r24, 0x00	; 0
    1a22:	90 e0       	ldi	r25, 0x00	; 0
    1a24:	20 e0       	ldi	r18, 0x00	; 0
    1a26:	30 e0       	ldi	r19, 0x00	; 0
		SPDR = 0x01; //set SR for data
    1a28:	41 e0       	ldi	r20, 0x01	; 1
    1a2a:	4f b9       	out	0x0f, r20	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a2c:	77 9b       	sbis	0x0e, 7	; 14
    1a2e:	fe cf       	rjmp	.-4      	; 0x1a2c <string2lcd+0xe>
		SPDR = lcd_str[count]; 
    1a30:	fd 01       	movw	r30, r26
    1a32:	e8 0f       	add	r30, r24
    1a34:	f9 1f       	adc	r31, r25
    1a36:	80 81       	ld	r24, Z
    1a38:	8f b9       	out	0x0f, r24	; 15
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
    1a3a:	77 9b       	sbis	0x0e, 7	; 14
    1a3c:	fe cf       	rjmp	.-4      	; 0x1a3a <string2lcd+0x1c>

char lcd_str[16];  //holds string to send to lcd  

void strobe_lcd(void){
	//twiddles bit 3, PORTF creating the enable signal for the LCD
	PORTF |= 0x08;
    1a3e:	80 91 62 00 	lds	r24, 0x0062
    1a42:	88 60       	ori	r24, 0x08	; 8
    1a44:	80 93 62 00 	sts	0x0062, r24
	PORTF &= ~0x08;
    1a48:	80 91 62 00 	lds	r24, 0x0062
    1a4c:	87 7f       	andi	r24, 0xF7	; 247
    1a4e:	80 93 62 00 	sts	0x0062, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1a52:	8f e8       	ldi	r24, 0x8F	; 143
    1a54:	91 e0       	ldi	r25, 0x01	; 1
    1a56:	01 97       	sbiw	r24, 0x01	; 1
    1a58:	f1 f7       	brne	.-4      	; 0x1a56 <string2lcd+0x38>
    1a5a:	00 c0       	rjmp	.+0      	; 0x1a5c <string2lcd+0x3e>
    1a5c:	00 00       	nop
  
void string2lcd(char *lcd_str){

	//sends a string to LCD
	int count;
	for (count=0; count<=(strlen(lcd_str)-1); count++){
    1a5e:	2f 5f       	subi	r18, 0xFF	; 255
    1a60:	3f 4f       	sbci	r19, 0xFF	; 255
    1a62:	c9 01       	movw	r24, r18
    1a64:	fd 01       	movw	r30, r26
    1a66:	01 90       	ld	r0, Z+
    1a68:	00 20       	and	r0, r0
    1a6a:	e9 f7       	brne	.-6      	; 0x1a66 <string2lcd+0x48>
    1a6c:	ea 1b       	sub	r30, r26
    1a6e:	fb 0b       	sbc	r31, r27
    1a70:	32 97       	sbiw	r30, 0x02	; 2
    1a72:	e2 17       	cp	r30, r18
    1a74:	f3 07       	cpc	r31, r19
    1a76:	c8 f6       	brcc	.-78     	; 0x1a2a <string2lcd+0xc>
		SPDR = lcd_str[count]; 
		while (!(SPSR & 0x80)) {}	// Wait for SPI transfer to complete
		strobe_lcd();
		_delay_us(100);
	}                  
} 
    1a78:	08 95       	ret

00001a7a <lcd_init>:
    1a7a:	80 91 61 00 	lds	r24, 0x0061
    1a7e:	88 60       	ori	r24, 0x08	; 8
    1a80:	80 93 61 00 	sts	0x0061, r24
    1a84:	8f e5       	ldi	r24, 0x5F	; 95
    1a86:	9a ee       	ldi	r25, 0xEA	; 234
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	f1 f7       	brne	.-4      	; 0x1a88 <lcd_init+0xe>
    1a8c:	00 c0       	rjmp	.+0      	; 0x1a8e <lcd_init+0x14>
    1a8e:	00 00       	nop
    1a90:	83 e0       	ldi	r24, 0x03	; 3
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	30 e3       	ldi	r19, 0x30	; 48
    1a96:	1f b8       	out	0x0f, r1	; 15
    1a98:	77 9b       	sbis	0x0e, 7	; 14
    1a9a:	fe cf       	rjmp	.-4      	; 0x1a98 <lcd_init+0x1e>
    1a9c:	3f b9       	out	0x0f, r19	; 15
    1a9e:	77 9b       	sbis	0x0e, 7	; 14
    1aa0:	fe cf       	rjmp	.-4      	; 0x1a9e <lcd_init+0x24>
    1aa2:	20 91 62 00 	lds	r18, 0x0062
    1aa6:	28 60       	ori	r18, 0x08	; 8
    1aa8:	20 93 62 00 	sts	0x0062, r18
    1aac:	20 91 62 00 	lds	r18, 0x0062
    1ab0:	27 7f       	andi	r18, 0xF7	; 247
    1ab2:	20 93 62 00 	sts	0x0062, r18
    1ab6:	ef e5       	ldi	r30, 0x5F	; 95
    1ab8:	fd e6       	ldi	r31, 0x6D	; 109
    1aba:	31 97       	sbiw	r30, 0x01	; 1
    1abc:	f1 f7       	brne	.-4      	; 0x1aba <lcd_init+0x40>
    1abe:	00 c0       	rjmp	.+0      	; 0x1ac0 <lcd_init+0x46>
    1ac0:	00 00       	nop
    1ac2:	01 97       	sbiw	r24, 0x01	; 1
    1ac4:	00 97       	sbiw	r24, 0x00	; 0
    1ac6:	39 f7       	brne	.-50     	; 0x1a96 <lcd_init+0x1c>
    1ac8:	1f b8       	out	0x0f, r1	; 15
    1aca:	77 9b       	sbis	0x0e, 7	; 14
    1acc:	fe cf       	rjmp	.-4      	; 0x1aca <lcd_init+0x50>
    1ace:	88 e3       	ldi	r24, 0x38	; 56
    1ad0:	8f b9       	out	0x0f, r24	; 15
    1ad2:	77 9b       	sbis	0x0e, 7	; 14
    1ad4:	fe cf       	rjmp	.-4      	; 0x1ad2 <lcd_init+0x58>
    1ad6:	80 91 62 00 	lds	r24, 0x0062
    1ada:	88 60       	ori	r24, 0x08	; 8
    1adc:	80 93 62 00 	sts	0x0062, r24
    1ae0:	80 91 62 00 	lds	r24, 0x0062
    1ae4:	87 7f       	andi	r24, 0xF7	; 247
    1ae6:	80 93 62 00 	sts	0x0062, r24
    1aea:	8f e1       	ldi	r24, 0x1F	; 31
    1aec:	9e e4       	ldi	r25, 0x4E	; 78
    1aee:	01 97       	sbiw	r24, 0x01	; 1
    1af0:	f1 f7       	brne	.-4      	; 0x1aee <lcd_init+0x74>
    1af2:	00 c0       	rjmp	.+0      	; 0x1af4 <lcd_init+0x7a>
    1af4:	00 00       	nop
    1af6:	1f b8       	out	0x0f, r1	; 15
    1af8:	77 9b       	sbis	0x0e, 7	; 14
    1afa:	fe cf       	rjmp	.-4      	; 0x1af8 <lcd_init+0x7e>
    1afc:	88 e0       	ldi	r24, 0x08	; 8
    1afe:	8f b9       	out	0x0f, r24	; 15
    1b00:	77 9b       	sbis	0x0e, 7	; 14
    1b02:	fe cf       	rjmp	.-4      	; 0x1b00 <lcd_init+0x86>
    1b04:	80 91 62 00 	lds	r24, 0x0062
    1b08:	88 60       	ori	r24, 0x08	; 8
    1b0a:	80 93 62 00 	sts	0x0062, r24
    1b0e:	80 91 62 00 	lds	r24, 0x0062
    1b12:	87 7f       	andi	r24, 0xF7	; 247
    1b14:	80 93 62 00 	sts	0x0062, r24
    1b18:	ef e1       	ldi	r30, 0x1F	; 31
    1b1a:	fe e4       	ldi	r31, 0x4E	; 78
    1b1c:	31 97       	sbiw	r30, 0x01	; 1
    1b1e:	f1 f7       	brne	.-4      	; 0x1b1c <lcd_init+0xa2>
    1b20:	00 c0       	rjmp	.+0      	; 0x1b22 <lcd_init+0xa8>
    1b22:	00 00       	nop
    1b24:	1f b8       	out	0x0f, r1	; 15
    1b26:	77 9b       	sbis	0x0e, 7	; 14
    1b28:	fe cf       	rjmp	.-4      	; 0x1b26 <lcd_init+0xac>
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	8f b9       	out	0x0f, r24	; 15
    1b2e:	77 9b       	sbis	0x0e, 7	; 14
    1b30:	fe cf       	rjmp	.-4      	; 0x1b2e <lcd_init+0xb4>
    1b32:	80 91 62 00 	lds	r24, 0x0062
    1b36:	88 60       	ori	r24, 0x08	; 8
    1b38:	80 93 62 00 	sts	0x0062, r24
    1b3c:	80 91 62 00 	lds	r24, 0x0062
    1b40:	87 7f       	andi	r24, 0xF7	; 247
    1b42:	80 93 62 00 	sts	0x0062, r24
    1b46:	8f e1       	ldi	r24, 0x1F	; 31
    1b48:	9e e4       	ldi	r25, 0x4E	; 78
    1b4a:	01 97       	sbiw	r24, 0x01	; 1
    1b4c:	f1 f7       	brne	.-4      	; 0x1b4a <lcd_init+0xd0>
    1b4e:	00 c0       	rjmp	.+0      	; 0x1b50 <lcd_init+0xd6>
    1b50:	00 00       	nop
    1b52:	1f b8       	out	0x0f, r1	; 15
    1b54:	77 9b       	sbis	0x0e, 7	; 14
    1b56:	fe cf       	rjmp	.-4      	; 0x1b54 <lcd_init+0xda>
    1b58:	86 e0       	ldi	r24, 0x06	; 6
    1b5a:	8f b9       	out	0x0f, r24	; 15
    1b5c:	77 9b       	sbis	0x0e, 7	; 14
    1b5e:	fe cf       	rjmp	.-4      	; 0x1b5c <lcd_init+0xe2>
    1b60:	80 91 62 00 	lds	r24, 0x0062
    1b64:	88 60       	ori	r24, 0x08	; 8
    1b66:	80 93 62 00 	sts	0x0062, r24
    1b6a:	80 91 62 00 	lds	r24, 0x0062
    1b6e:	87 7f       	andi	r24, 0xF7	; 247
    1b70:	80 93 62 00 	sts	0x0062, r24
    1b74:	ef e1       	ldi	r30, 0x1F	; 31
    1b76:	fe e4       	ldi	r31, 0x4E	; 78
    1b78:	31 97       	sbiw	r30, 0x01	; 1
    1b7a:	f1 f7       	brne	.-4      	; 0x1b78 <lcd_init+0xfe>
    1b7c:	00 c0       	rjmp	.+0      	; 0x1b7e <lcd_init+0x104>
    1b7e:	00 00       	nop
    1b80:	1f b8       	out	0x0f, r1	; 15
    1b82:	77 9b       	sbis	0x0e, 7	; 14
    1b84:	fe cf       	rjmp	.-4      	; 0x1b82 <lcd_init+0x108>
    1b86:	8e e0       	ldi	r24, 0x0E	; 14
    1b88:	8f b9       	out	0x0f, r24	; 15
    1b8a:	77 9b       	sbis	0x0e, 7	; 14
    1b8c:	fe cf       	rjmp	.-4      	; 0x1b8a <lcd_init+0x110>
    1b8e:	80 91 62 00 	lds	r24, 0x0062
    1b92:	88 60       	ori	r24, 0x08	; 8
    1b94:	80 93 62 00 	sts	0x0062, r24
    1b98:	80 91 62 00 	lds	r24, 0x0062
    1b9c:	87 7f       	andi	r24, 0xF7	; 247
    1b9e:	80 93 62 00 	sts	0x0062, r24
    1ba2:	8f e1       	ldi	r24, 0x1F	; 31
    1ba4:	9e e4       	ldi	r25, 0x4E	; 78
    1ba6:	01 97       	sbiw	r24, 0x01	; 1
    1ba8:	f1 f7       	brne	.-4      	; 0x1ba6 <lcd_init+0x12c>
    1baa:	00 c0       	rjmp	.+0      	; 0x1bac <lcd_init+0x132>
    1bac:	00 00       	nop
    1bae:	08 95       	ret

00001bb0 <main>:

int main()
{
	//set port bits 4-7 B as outputs
	//uint8_t c = 0;
	DDRE = 0xFF;
    1bb0:	9f ef       	ldi	r25, 0xFF	; 255
    1bb2:	92 b9       	out	0x02, r25	; 2
	PORTE &= 0x7F;
    1bb4:	1f 98       	cbi	0x03, 7	; 3
	DDRB = 0xF7;
    1bb6:	87 ef       	ldi	r24, 0xF7	; 247
    1bb8:	87 bb       	out	0x17, r24	; 23
	DDRD |= (1 << PB2);
    1bba:	8a 9a       	sbi	0x11, 2	; 17

	volume = 100;
    1bbc:	84 e6       	ldi	r24, 0x64	; 100
    1bbe:	80 93 00 01 	sts	0x0100, r24
 *Left knob  = PWM for 7-seg
 *Right knob = PWM for bar graph
 *****************************************************************/

void timer_init(void){
	TCCR0 |= (1<<CS00) ;  //normal mode, prescale by 32
    1bc2:	83 b7       	in	r24, 0x33	; 51
    1bc4:	81 60       	ori	r24, 0x01	; 1
    1bc6:	83 bf       	out	0x33, r24	; 51
	ASSR  |= (1<<AS0);
    1bc8:	80 b7       	in	r24, 0x30	; 48
    1bca:	88 60       	ori	r24, 0x08	; 8
    1bcc:	80 bf       	out	0x30, r24	; 48
	TCCR2 |= (1<<WGM21) | (1<<WGM20) | (1<<COM21) | (1<<COM20)|(0<<CS20)| (1<<CS21); //normal mode, prescale by 32
    1bce:	85 b5       	in	r24, 0x25	; 37
    1bd0:	8a 67       	ori	r24, 0x7A	; 122
    1bd2:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1<<TOIE0)| (1<<TOIE2);// | (1<<OCIE2);             //enable interrupts
    1bd4:	87 b7       	in	r24, 0x37	; 55
    1bd6:	81 64       	ori	r24, 0x41	; 65
    1bd8:	87 bf       	out	0x37, r24	; 55
}

void ADC_init(void){
	DDRF |= !(1<<PF0);
    1bda:	80 91 61 00 	lds	r24, 0x0061
    1bde:	80 93 61 00 	sts	0x0061, r24
	PORTF = 0x00;
    1be2:	10 92 62 00 	sts	0x0062, r1
	ADMUX  |= (1<<ADLAR) | (1<<REFS0);
    1be6:	87 b1       	in	r24, 0x07	; 7
    1be8:	80 66       	ori	r24, 0x60	; 96
    1bea:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADFR) | (1<<ADIE)\
    1bec:	86 b1       	in	r24, 0x06	; 6
    1bee:	8f 6e       	ori	r24, 0xEF	; 239
    1bf0:	86 b9       	out	0x06, r24	; 6
		  |(1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	OCR2 = 0xFF;
    1bf2:	93 bd       	out	0x23, r25	; 35
	DDRD |= (1 << PB2);

	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
    1bf4:	0e 94 62 05 	call	0xac4	; 0xac4 <music_init>
void SPI_init(){
	/* Set MOSI and SCK output, all others input */
	//DDRB = (1<<PB3)|(1<<PB1);

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR);
    1bf8:	80 e5       	ldi	r24, 0x50	; 80
    1bfa:	8d b9       	out	0x0d, r24	; 13
	volume = 100;
	timer_init();
	ADC_init();
	music_init();   
	SPI_init();
	lcd_init();
    1bfc:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <lcd_init>
	init_twi();
    1c00:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <init_twi>
	uart_init();
    1c04:	0e 94 26 0c 	call	0x184c	; 0x184c <uart_init>
	OCR2 = 0xFF;
}

void volume_control_init(void){
	//DDRE |= (1<<PE3);
	TCCR3A  = (1<<WGM30) | (1<<COM3A1);
    1c08:	81 e8       	ldi	r24, 0x81	; 129
    1c0a:	80 93 8b 00 	sts	0x008B, r24
	TCCR3B = (1<<WGM32) | (1<<CS30);
    1c0e:	89 e0       	ldi	r24, 0x09	; 9
    1c10:	80 93 8a 00 	sts	0x008A, r24
	OCR3A = volume;
    1c14:	80 91 00 01 	lds	r24, 0x0100
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	90 93 87 00 	sts	0x0087, r25
    1c1e:	80 93 86 00 	sts	0x0086, r24
	SPI_init();
	lcd_init();
	init_twi();
	uart_init();
	volume_control_init();
	lm73_init();
    1c22:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <lm73_init>
	cursor_off();
    1c26:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <cursor_off>
	TCCR3B = (1<<WGM32) | (1<<CS30);
	OCR3A = volume;
}

void initialize_string(){
	loc_temp_str = "Local  temp:   C";
    1c2a:	83 e1       	ldi	r24, 0x13	; 19
    1c2c:	91 e0       	ldi	r25, 0x01	; 1
    1c2e:	90 93 64 01 	sts	0x0164, r25
    1c32:	80 93 63 01 	sts	0x0163, r24
	rem_temp_str = "Remote temp:   C";
    1c36:	84 e2       	ldi	r24, 0x24	; 36
    1c38:	91 e0       	ldi	r25, 0x01	; 1
    1c3a:	90 93 62 01 	sts	0x0162, r25
    1c3e:	80 93 61 01 	sts	0x0161, r24
	volume_control_init();
	lm73_init();
	cursor_off();
	initialize_string();
	//strcpy(loc_temp_str, "Local  temp:   C");
	sei();
    1c42:	78 94       	sei
    1c44:	08 c0       	rjmp	.+16     	; 0x1c56 <main+0xa6>
		  }*/
		if(encode_flag){
			check_knobs();
			encode_flag = 0;
		}
		if(bar_graph_flag){
    1c46:	80 91 49 01 	lds	r24, 0x0149
    1c4a:	81 11       	cpse	r24, r1
    1c4c:	14 c0       	rjmp	.+40     	; 0x1c76 <main+0xc6>
			bar_graph();
			bar_graph_flag = 0;
		}
		if(update_LCD){
    1c4e:	80 91 4b 01 	lds	r24, 0x014B
    1c52:	81 11       	cpse	r24, r1
    1c54:	18 c0       	rjmp	.+48     	; 0x1c86 <main+0xd6>
	sei();
	//string2lcd("hello");
	while(1){
		//_delay_ms(100);
		//clear_display();
		display_update();
    1c56:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <display_update>
		update_time();
    1c5a:	0e 94 3c 08 	call	0x1078	; 0x1078 <update_time>
		//}
		/*if(reset_temp){
		  generate_temp_str();
		  reset_temp = 0;
		  }*/
		if(encode_flag){
    1c5e:	80 91 4d 01 	lds	r24, 0x014D
    1c62:	88 23       	and	r24, r24
    1c64:	81 f3       	breq	.-32     	; 0x1c46 <main+0x96>
			check_knobs();
    1c66:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <check_knobs>
			encode_flag = 0;
    1c6a:	10 92 4d 01 	sts	0x014D, r1
		}
		if(bar_graph_flag){
    1c6e:	80 91 49 01 	lds	r24, 0x0149
    1c72:	88 23       	and	r24, r24
    1c74:	61 f3       	breq	.-40     	; 0x1c4e <main+0x9e>
			bar_graph();
    1c76:	0e 94 c5 08 	call	0x118a	; 0x118a <bar_graph>
			bar_graph_flag = 0;
    1c7a:	10 92 49 01 	sts	0x0149, r1
		}
		if(update_LCD){
    1c7e:	80 91 4b 01 	lds	r24, 0x014B
    1c82:	88 23       	and	r24, r24
    1c84:	41 f3       	breq	.-48     	; 0x1c56 <main+0xa6>
			show_temperature();
    1c86:	0e 94 b8 0a 	call	0x1570	; 0x1570 <show_temperature>
			update_LCD = 0;
    1c8a:	10 92 4b 01 	sts	0x014B, r1
    1c8e:	e3 cf       	rjmp	.-58     	; 0x1c56 <main+0xa6>

00001c90 <__tablejump2__>:
    1c90:	ee 0f       	add	r30, r30
    1c92:	ff 1f       	adc	r31, r31

00001c94 <__tablejump__>:
    1c94:	05 90       	lpm	r0, Z+
    1c96:	f4 91       	lpm	r31, Z
    1c98:	e0 2d       	mov	r30, r0
    1c9a:	09 94       	ijmp

00001c9c <__umulhisi3>:
    1c9c:	a2 9f       	mul	r26, r18
    1c9e:	b0 01       	movw	r22, r0
    1ca0:	b3 9f       	mul	r27, r19
    1ca2:	c0 01       	movw	r24, r0
    1ca4:	a3 9f       	mul	r26, r19
    1ca6:	70 0d       	add	r23, r0
    1ca8:	81 1d       	adc	r24, r1
    1caa:	11 24       	eor	r1, r1
    1cac:	91 1d       	adc	r25, r1
    1cae:	b2 9f       	mul	r27, r18
    1cb0:	70 0d       	add	r23, r0
    1cb2:	81 1d       	adc	r24, r1
    1cb4:	11 24       	eor	r1, r1
    1cb6:	91 1d       	adc	r25, r1
    1cb8:	08 95       	ret

00001cba <__itoa_ncheck>:
    1cba:	bb 27       	eor	r27, r27
    1cbc:	4a 30       	cpi	r20, 0x0A	; 10
    1cbe:	31 f4       	brne	.+12     	; 0x1ccc <__itoa_ncheck+0x12>
    1cc0:	99 23       	and	r25, r25
    1cc2:	22 f4       	brpl	.+8      	; 0x1ccc <__itoa_ncheck+0x12>
    1cc4:	bd e2       	ldi	r27, 0x2D	; 45
    1cc6:	90 95       	com	r25
    1cc8:	81 95       	neg	r24
    1cca:	9f 4f       	sbci	r25, 0xFF	; 255
    1ccc:	0c 94 69 0e 	jmp	0x1cd2	; 0x1cd2 <__utoa_common>

00001cd0 <__utoa_ncheck>:
    1cd0:	bb 27       	eor	r27, r27

00001cd2 <__utoa_common>:
    1cd2:	fb 01       	movw	r30, r22
    1cd4:	55 27       	eor	r21, r21
    1cd6:	aa 27       	eor	r26, r26
    1cd8:	88 0f       	add	r24, r24
    1cda:	99 1f       	adc	r25, r25
    1cdc:	aa 1f       	adc	r26, r26
    1cde:	a4 17       	cp	r26, r20
    1ce0:	10 f0       	brcs	.+4      	; 0x1ce6 <__utoa_common+0x14>
    1ce2:	a4 1b       	sub	r26, r20
    1ce4:	83 95       	inc	r24
    1ce6:	50 51       	subi	r21, 0x10	; 16
    1ce8:	b9 f7       	brne	.-18     	; 0x1cd8 <__utoa_common+0x6>
    1cea:	a0 5d       	subi	r26, 0xD0	; 208
    1cec:	aa 33       	cpi	r26, 0x3A	; 58
    1cee:	08 f0       	brcs	.+2      	; 0x1cf2 <__utoa_common+0x20>
    1cf0:	a9 5d       	subi	r26, 0xD9	; 217
    1cf2:	a1 93       	st	Z+, r26
    1cf4:	00 97       	sbiw	r24, 0x00	; 0
    1cf6:	79 f7       	brne	.-34     	; 0x1cd6 <__utoa_common+0x4>
    1cf8:	b1 11       	cpse	r27, r1
    1cfa:	b1 93       	st	Z+, r27
    1cfc:	11 92       	st	Z+, r1
    1cfe:	cb 01       	movw	r24, r22
    1d00:	0c 94 82 0e 	jmp	0x1d04	; 0x1d04 <strrev>

00001d04 <strrev>:
    1d04:	dc 01       	movw	r26, r24
    1d06:	fc 01       	movw	r30, r24
    1d08:	67 2f       	mov	r22, r23
    1d0a:	71 91       	ld	r23, Z+
    1d0c:	77 23       	and	r23, r23
    1d0e:	e1 f7       	brne	.-8      	; 0x1d08 <strrev+0x4>
    1d10:	32 97       	sbiw	r30, 0x02	; 2
    1d12:	04 c0       	rjmp	.+8      	; 0x1d1c <strrev+0x18>
    1d14:	7c 91       	ld	r23, X
    1d16:	6d 93       	st	X+, r22
    1d18:	70 83       	st	Z, r23
    1d1a:	62 91       	ld	r22, -Z
    1d1c:	ae 17       	cp	r26, r30
    1d1e:	bf 07       	cpc	r27, r31
    1d20:	c8 f3       	brcs	.-14     	; 0x1d14 <strrev+0x10>
    1d22:	08 95       	ret

00001d24 <_exit>:
    1d24:	f8 94       	cli

00001d26 <__stop_program>:
    1d26:	ff cf       	rjmp	.-2      	; 0x1d26 <__stop_program>
